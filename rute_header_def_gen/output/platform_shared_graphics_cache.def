///     \class QPlatformSharedGraphicsCache
///     \since 5.0
///     \internal
///     \preliminary
///     \ingroup qpa
///     \brief The QPlatformSharedGraphicsCache is an abstraction of a cross-process graphics cache.
/// 
///     If supported, it is possible to retrieve a QPlatformSharedGraphicsCache object from the
///     platform integration. This is typically used to store graphical items which should be shared
///     between several processes.
/// 
///     Items are requested from the cache by calling requestItems(). If the cache contains the
///     requested items in the requested cache, the itemsAvailable() signal is emitted with the ID of
///     the graphical buffer and each item's coordinates inside the buffer. Before requesting items
///     from a cache, the user must call ensureCacheInitialized() to set the correct parameters for
///     the cache.
/// 
///     If the cache does not yet contain the requested items, it will emit a similar itemsMissing()
///     signal. The client can then call updateItems() with rasterizations of the items and they will be
///     entered into the shared cache. As the items are rendered into the cache, itemsAvailable() signals
///     will be emitted for each of the items which have previously been requested and which have not
///     yet been reported as ready.
/// 
///     Using beginRequestBatch() and endRequestBatch(), it's possible to batch glyph requests, which
///     could improve performance in cases where you have a sequence of requests pending, and you
///     do not need the results during this sequence.
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QPlatformSharedGraphicsCache)]
enum PixelFormat {
    Alpha8,
}

[org_name(QPlatformSharedGraphicsCache)]
enum BufferType {
    OpenGLTexture,
}

struct PlatformSharedGraphicsCache : Object {
    [event] begin_request_batch(),
    [event] ensure_cache_initialized(cache_id: &ByteArrayType, buffer_type: PlatformSharedGraphicsCache::BufferType, pixel_format: PlatformSharedGraphicsCache::PixelFormat),
    [event] request_items(cache_id: &ByteArrayType, item_ids: [u32]),
    [event] insert_items(cache_id: &ByteArrayType, item_ids: [u32], items: [ImageType]),
    [event] release_items(cache_id: &ByteArrayType, item_ids: [u32]),
    [event] end_request_batch(),
    [event] request_batch_started() -> bool,
    [event] texture_id_for_buffer(buffer_id: *void) -> uint,
    [event] reference_buffer(buffer_id: *void),
    [event] dereference_buffer(buffer_id: *void) -> bool,
    [event] size_of_buffer(buffer_id: *void) -> Size,
    [event] egl_image_for_buffer(buffer_id: *void),
    [signal] items_missing(cache_id: &ByteArrayType, item_ids: [u32]),
    [signal] items_available(cache_id: &ByteArrayType, buffer_id: *void, item_ids: [u32], positions_in_buffer: [PointType]),
    [signal] items_invalidated(cache_id: &ByteArrayType, item_ids: [u32]),
    [signal] items_updated(cache_id: &ByteArrayType, buffer_id: *void, item_ids: [u32], positions_in_buffer: [PointType]),
}

// vim: syntax=rust expandtab ts=4 sw=4
