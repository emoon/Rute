///     \class QStackedWidget
///     \brief The QStackedWidget class provides a stack of widgets where
///     only one widget is visible at a time.
/// 
///     \ingroup organizers
///     \ingroup geomanagement
///     \inmodule QtWidgets
/// 
///     QStackedWidget can be used to create a user interface similar to
///     the one provided by QTabWidget. It is a convenience layout widget
///     built on top of the QStackedLayout class.
/// 
///     Like QStackedLayout, QStackedWidget can be constructed and
///     populated with a number of child widgets ("pages"):
/// 
///     \snippet qstackedwidget/main.cpp 0
///     \snippet qstackedwidget/main.cpp 2
///     \snippet qstackedwidget/main.cpp 3
/// 
///     QStackedWidget provides no intrinsic means for the user to switch
///     page. This is typically done through a QComboBox or a QListWidget
///     that stores the titles of the QStackedWidget's pages. For
///     example:
/// 
///     \snippet qstackedwidget/main.cpp 1
/// 
///     When populating a stacked widget, the widgets are added to an
///     internal list. The indexOf() function returns the index of a
///     widget in that list. The widgets can either be added to the end of
///     the list using the addWidget() function, or inserted at a given
///     index using the insertWidget() function. The removeWidget()
///     function removes a widget from the stacked widget. The number of
///     widgets contained in the stacked widget can
///     be obtained using the count() function.
/// 
///     The widget() function returns the widget at a given index
///     position. The index of the widget that is shown on screen is given
///     by currentIndex() and can be changed using setCurrentIndex(). In a
///     similar manner, the currently shown widget can be retrieved using
///     the currentWidget() function, and altered using the
///     setCurrentWidget() function.
/// 
///     Whenever the current widget in the stacked widget changes or a
///     widget is removed from the stacked widget, the currentChanged()
///     and widgetRemoved() signals are emitted respectively.
/// 
///     \sa QStackedLayout, QTabWidget
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct StackedWidget : Frame {
    ///     Appends the given \a widget to the QStackedWidget and returns the
    ///     index position. Ownership of \a widget is passed on to the
    ///     QStackedWidget.
    /// 
    ///     If the QStackedWidget is empty before this function is called,
    ///     \a widget becomes the current widget.
    /// 
    ///     \sa insertWidget(), removeWidget(), setCurrentWidget()
    add_widget(w: *WidgetType) -> i32,
    ///     Inserts the given \a widget at the given \a index in the
    ///     QStackedWidget. Ownership of \a widget is passed on to the
    ///     QStackedWidget. If \a index is out of range, the \a widget is
    ///     appended (in which case it is the actual index of the \a widget
    ///     that is returned).
    /// 
    ///     If the QStackedWidget was empty before this function is called,
    ///     the given \a widget becomes the current widget.
    /// 
    ///     Inserting a new widget at an index less than or equal to the current index
    ///     will increment the current index, but keep the current widget.
    /// 
    ///     \sa addWidget(), removeWidget(), setCurrentWidget()
    insert_widget(index: i32, w: *WidgetType) -> i32,
    ///     Removes \a widget from the QStackedWidget. i.e., \a widget is \e
    ///     not deleted but simply removed from the stacked layout, causing it
    ///     to be hidden.
    /// 
    ///     \note Parent object and parent widget of \a widget will remain the
    ///     QStackedWidget. If the application wants to reuse the removed
    ///     \a widget, then it is recommended to re-parent it.
    /// 
    ///     \sa addWidget(), insertWidget(), currentWidget()
    remove_widget(w: *WidgetType),
    ///     Returns the current widget, or 0 if there are no child widgets.
    /// 
    ///     \sa currentIndex(), setCurrentWidget()
    current_widget() -> Widget?,
    current_index() -> i32,
    ///     Returns the index of the given \a widget, or -1 if the given \a
    ///     widget is not a child of the QStackedWidget.
    /// 
    ///     \sa currentIndex(), widget()
    index_of(arg0: *WidgetType) -> i32,
    ///     Returns the widget at the given \a index, or 0 if there is no such
    ///     widget.
    /// 
    ///     \sa currentWidget(), indexOf()
    widget(arg0: i32) -> Widget?,
    ///     \property QStackedWidget::count
    ///     \brief the number of widgets contained by this stacked widget
    /// 
    ///     By default, this property contains a value of 0.
    /// 
    ///     \sa currentIndex(), widget()
    count() -> i32,
    ///     \property QStackedWidget::currentIndex
    ///     \brief the index position of the widget that is visible
    /// 
    ///     The current index is -1 if there is no current widget.
    /// 
    ///     By default, this property contains a value of -1 because the stack
    ///     is initially empty.
    /// 
    ///     \sa currentWidget(), indexOf()
    set_current_index(index: i32),
    set_current_widget(w: *WidgetType),
    [signal] current_changed(arg0: i32),
    [signal] widget_removed(index: i32),
    [event] event(e: *EventType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
