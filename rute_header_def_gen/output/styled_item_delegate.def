///     \class QStyledItemDelegate
/// 
///     \brief The QStyledItemDelegate class provides display and editing facilities for
///     data items from a model.
/// 
///     \ingroup model-view
///     \inmodule QtWidgets
/// 
///     \since 4.4
/// 
///     When displaying data from models in Qt item views, e.g., a
///     QTableView, the individual items are drawn by a delegate. Also,
///     when an item is edited, it provides an editor widget, which is
///     placed on top of the item view while editing takes place.
///     QStyledItemDelegate is the default delegate for all Qt item
///     views, and is installed upon them when they are created.
/// 
///     The QStyledItemDelegate class is one of the \l{Model/View Classes}
///     and is part of Qt's \l{Model/View Programming}{model/view
///     framework}. The delegate allows the display and editing of items
///     to be developed independently from the model and view.
/// 
///     The data of items in models are assigned an
///     \l{Qt::}{ItemDataRole}; each item can store a QVariant for each
///     role. QStyledItemDelegate implements display and editing for the
///     most common datatypes expected by users, including booleans,
///     integers, and strings.
/// 
///     The data will be drawn differently depending on which role they
///     have in the model. The following table describes the roles and the
///     data types the delegate can handle for each of them. It is often
///     sufficient to ensure that the model returns appropriate data for
///     each of the roles to determine the appearance of items in views.
/// 
///     \table
///     \header \li Role \li Accepted Types
///     \omit
///     \row    \li \l Qt::AccessibleDescriptionRole \li QString
///     \row    \li \l Qt::AccessibleTextRole \li QString
///     \endomit
///     \row    \li \l Qt::BackgroundRole \li QBrush
///     \row    \li \l Qt::BackgroundColorRole \li QColor (obsolete; use Qt::BackgroundRole instead)
///     \row    \li \l Qt::CheckStateRole \li Qt::CheckState
///     \row    \li \l Qt::DecorationRole \li QIcon, QPixmap, QImage and QColor
///     \row    \li \l Qt::DisplayRole \li QString and types with a string representation
///     \row    \li \l Qt::EditRole \li See QItemEditorFactory for details
///     \row    \li \l Qt::FontRole \li QFont
///     \row    \li \l Qt::SizeHintRole \li QSize
///     \omit
///     \row    \li \l Qt::StatusTipRole \li
///     \endomit
///     \row    \li \l Qt::TextAlignmentRole \li Qt::Alignment
///     \row    \li \l Qt::ForegroundRole \li QBrush
///     \row    \li \l Qt::TextColorRole \li QColor (obsolete; use Qt::ForegroundRole instead)
///     \omit
///     \row    \li \l Qt::ToolTipRole
///     \row    \li \l Qt::WhatsThisRole
///     \endomit
///     \endtable
/// 
///     Editors are created with a QItemEditorFactory; a default static
///     instance provided by QItemEditorFactory is installed on all item
///     delegates. You can set a custom factory using
///     setItemEditorFactory() or set a new default factory with
///     QItemEditorFactory::setDefaultFactory(). It is the data stored in
///     the item model with the \l{Qt::}{EditRole} that is edited. See the
///     QItemEditorFactory class for a more high-level introduction to
///     item editor factories. The \l{Color Editor Factory Example}{Color
///     Editor Factory} example shows how to create custom editors with a
///     factory.
/// 
///     \section1 Subclassing QStyledItemDelegate
/// 
///     If the delegate does not support painting of the data types you
///     need or you want to customize the drawing of items, you need to
///     subclass QStyledItemDelegate, and reimplement paint() and possibly
///     sizeHint(). The paint() function is called individually for each
///     item, and with sizeHint(), you can specify the hint for each
///     of them.
/// 
///     When reimplementing paint(), one would typically handle the
///     datatypes one would like to draw and use the superclass
///     implementation for other types.
/// 
///     The painting of check box indicators are performed by the current
///     style. The style also specifies the size and the bounding
///     rectangles in which to draw the data for the different data roles.
///     The bounding rectangle of the item itself is also calculated by
///     the style. When drawing already supported datatypes, it is
///     therefore a good idea to ask the style for these bounding
///     rectangles. The QStyle class description describes this in
///     more detail.
/// 
///     If you wish to change any of the bounding rectangles calculated by
///     the style or the painting of check box indicators, you can
///     subclass QStyle. Note, however, that the size of the items can
///     also be affected by reimplementing sizeHint().
/// 
///     It is possible for a custom delegate to provide editors
///     without the use of an editor item factory. In this case, the
///     following virtual functions must be reimplemented:
/// 
///     \list
///         \li createEditor() returns the widget used to change data from the model
///            and can be reimplemented to customize editing behavior.
///         \li setEditorData() provides the widget with data to manipulate.
///         \li updateEditorGeometry() ensures that the editor is displayed correctly
///            with respect to the item view.
///         \li setModelData() returns updated data to the model.
///     \endlist
/// 
///     The \l{Star Delegate Example}{Star Delegate} example creates
///     editors by reimplementing these methods.
/// 
///     \section1 QStyledItemDelegate vs. QItemDelegate
/// 
///     Since Qt 4.4, there are two delegate classes: QItemDelegate and
///     QStyledItemDelegate. However, the default delegate is QStyledItemDelegate.
///     These two classes are independent alternatives to painting and providing
///     editors for items in views. The difference between them is that
///     QStyledItemDelegate uses the current style to paint its items. We therefore
///     recommend using QStyledItemDelegate as the base class when implementing
///     custom delegates or when working with Qt style sheets. The code required
///     for either class should be equal unless the custom delegate needs to use
///     the style for drawing.
/// 
///     If you wish to customize the painting of item views, you should
///     implement a custom style. Please see the QStyle class
///     documentation for details.
/// 
///     \sa {Delegate Classes}, QItemDelegate, QAbstractItemDelegate, QStyle,
///         {Spin Box Delegate Example}, {Star Delegate Example}, {Color
///          Editor Factory Example}
struct StyledItemDelegate : AbstractItemDelegate {
    [event] paint(painter: *PainterType, option: &StyleOptionViewItemType, index: &ModelIndexType),
    [event] size_hint(option: &StyleOptionViewItemType, index: &ModelIndexType) -> Size,
    [event] create_editor(parent: *WidgetType, option: &StyleOptionViewItemType, index: &ModelIndexType) -> Widget?,
    ///     Sets the data to be displayed and edited by the \a editor from the
    ///     data model item specified by the model \a index.
    /// 
    ///     The default implementation stores the data in the \a editor
    ///     widget's \l {Qt's Property System} {user property}.
    /// 
    ///     \sa QMetaProperty::isUser()
    [event] set_editor_data(editor: *WidgetType, index: &ModelIndexType),
    [event] set_model_data(editor: *WidgetType, model: *AbstractItemModelType, index: &ModelIndexType),
    ///   Returns the editor factory used by the item delegate.
    ///   If no editor factory is set, the function will return null.
    /// 
    ///   \sa setItemEditorFactory()
    item_editor_factory() -> ItemEditorFactory?,
    ///   Sets the editor factory to be used by the item delegate to be the \a factory
    ///   specified. If no editor factory is set, the item delegate will use the
    ///   default editor factory.
    /// 
    ///   \sa itemEditorFactory()
    set_item_editor_factory(factory: *ItemEditorFactoryType),
    ///     This function returns the string that the delegate will use to display the
    ///     Qt::DisplayRole of the model in \a locale. \a value is the value of the Qt::DisplayRole
    ///     provided by the model.
    /// 
    ///     The default implementation uses the QLocale::toString to convert \a value into
    ///     a QString.
    /// 
    ///     This function is not called for empty model indices, i.e., indices for which
    ///     the model returns an invalid QVariant.
    /// 
    ///     \sa QAbstractItemModel::data()
    [event] display_text(value: &VariantType, locale: &LocaleType) -> String,
    [event] init_style_option(option: *StyleOptionViewItemType, index: &ModelIndexType),
    ///     \fn bool QStyledItemDelegate::eventFilter(QObject *editor, QEvent *event)
    /// 
    ///     Returns \c true if the given \a editor is a valid QWidget and the
    ///     given \a event is handled; otherwise returns \c false. The following
    ///     key press events are handled by default:
    /// 
    ///     \list
    ///         \li \uicontrol Tab
    ///         \li \uicontrol Backtab
    ///         \li \uicontrol Enter
    ///         \li \uicontrol Return
    ///         \li \uicontrol Esc
    ///     \endlist
    /// 
    ///     If the \a editor's type is QTextEdit or QPlainTextEdit then \uicontrol Enter and
    ///     \uicontrol Return keys are \e not handled.
    /// 
    ///     In the case of \uicontrol Tab, \uicontrol Backtab, \uicontrol Enter and \uicontrol Return
    ///     key press events, the \a editor's data is committed to the model
    ///     and the editor is closed. If the \a event is a \uicontrol Tab key press
    ///     the view will open an editor on the next item in the
    ///     view. Likewise, if the \a event is a \uicontrol Backtab key press the
    ///     view will open an editor on the \e previous item in the view.
    /// 
    ///     If the event is a \uicontrol Esc key press event, the \a editor is
    ///     closed \e without committing its data.
    /// 
    ///     \sa commitData(), closeEditor()
    [event] event_filter(object: *ObjectType, event: *EventType) -> bool,
    [event] editor_event(event: *EventType, model: *AbstractItemModelType, option: &StyleOptionViewItemType, index: &ModelIndexType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
