[org_name(QByteArray)]
enum Base64Option {
    Base64Encoding,
    Base64UrlEncoding,
    KeepTrailingEquals,
    OmitTrailingEquals,
}


struct ByteArray {
    swap(other: &ByteArrayType),
    size() -> i32,
    is_empty() -> bool,
    resize(size: i32),
    fill(c: char, size: i32) -> ByteArray?,
    capacity() -> i32,
    reserve(size: i32),
    squeeze(),
    data() -> char?,
    data() -> char?,
    const_data() -> char?,
    detach(),
    is_detached() -> bool,
    is_shared_with(other: &ByteArrayType) -> bool,
    clear(),
    at(i: i32) -> char,
    front() -> char,
    front() -> ByteRef,
    back() -> char,
    back() -> ByteRef,
    index_of(c: char, from: i32) -> i32,
    index_of(c: *char, from: i32) -> i32,
    index_of(a: &ByteArrayType, from: i32) -> i32,
    last_index_of(c: char, from: i32) -> i32,
    last_index_of(c: *char, from: i32) -> i32,
    last_index_of(a: &ByteArrayType, from: i32) -> i32,
    contains(c: char) -> bool,
    contains(a: *char) -> bool,
    contains(a: &ByteArrayType) -> bool,
    count(c: char) -> i32,
    count(a: *char) -> i32,
    count(a: &ByteArrayType) -> i32,
    left(len: i32) -> ByteArray,
    right(len: i32) -> ByteArray,
    mid(index: i32, len: i32) -> ByteArray,
    chopped(len: i32) -> ByteArray,
    starts_with(a: &ByteArrayType) -> bool,
    starts_with(c: char) -> bool,
    starts_with(c: *char) -> bool,
    ends_with(a: &ByteArrayType) -> bool,
    ends_with(c: char) -> bool,
    ends_with(c: *char) -> bool,
    chop(n: i32),
    to_lower() -> ByteArray,
    to_lower() -> ByteArray,
    to_upper() -> ByteArray,
    to_upper() -> ByteArray,
    simplified() -> ByteArray,
    simplified() -> ByteArray,
    left_justified(width: i32, fill: char, truncate: bool) -> ByteArray,
    right_justified(width: i32, fill: char, truncate: bool) -> ByteArray,
    prepend(c: char) -> ByteArray?,
    prepend(count: i32, c: char) -> ByteArray?,
    prepend(s: *char) -> ByteArray?,
    prepend(s: *char, len: i32) -> ByteArray?,
    prepend(a: &ByteArrayType) -> ByteArray?,
    append(c: char) -> ByteArray?,
    append(count: i32, c: char) -> ByteArray?,
    append(s: *char) -> ByteArray?,
    append(s: *char, len: i32) -> ByteArray?,
    append(a: &ByteArrayType) -> ByteArray?,
    insert(i: i32, c: char) -> ByteArray?,
    insert(i: i32, count: i32, c: char) -> ByteArray?,
    insert(i: i32, s: *char) -> ByteArray?,
    insert(i: i32, s: *char, len: i32) -> ByteArray?,
    insert(i: i32, a: &ByteArrayType) -> ByteArray?,
    remove(index: i32, len: i32) -> ByteArray?,
    replace(index: i32, len: i32, s: *char) -> ByteArray?,
    replace(index: i32, len: i32, s: *char, alen: i32) -> ByteArray?,
    replace(index: i32, len: i32, s: &ByteArrayType) -> ByteArray?,
    replace(before: char, after: *char) -> ByteArray?,
    replace(before: char, after: &ByteArrayType) -> ByteArray?,
    replace(before: *char, after: *char) -> ByteArray?,
    replace(before: *char, bsize: i32, after: *char, asize: i32) -> ByteArray?,
    replace(before: &ByteArrayType, after: &ByteArrayType) -> ByteArray?,
    replace(before: &ByteArrayType, after: *char) -> ByteArray?,
    replace(before: *char, after: &ByteArrayType) -> ByteArray?,
    replace(before: char, after: char) -> ByteArray?,
    split(sep: char) -> [ByteArray],
    repeated(times: i32) -> ByteArray,
    append(s: String) -> ByteArray?,
    insert(i: i32, s: String) -> ByteArray?,
    replace(before: String, after: *char) -> ByteArray?,
    replace(c: char, after: String) -> ByteArray?,
    replace(before: String, after: &ByteArrayType) -> ByteArray?,
    index_of(s: String, from: i32) -> i32,
    last_index_of(s: String, from: i32) -> i32,
    to_short(ok: *bool, base: i32) -> short,
    to_u_short(ok: *bool, base: i32) -> ushort,
    to_int(ok: *bool, base: i32) -> i32,
    to_u_int(ok: *bool, base: i32) -> uint,
    to_long(ok: *bool, base: i32) -> long,
    to_u_long(ok: *bool, base: i32) -> ulong,
    to_long_long(ok: *bool, base: i32) -> i64,
    to_u_long_long(ok: *bool, base: i32) -> qulonglong,
    to_float(ok: *bool) -> f32,
    to_double(ok: *bool) -> double,
    to_base64(options: Base64Options) -> ByteArray,
    to_base64() -> ByteArray,
    to_hex() -> ByteArray,
    to_hex(separator: char) -> ByteArray,
    to_percent_encoding(exclude: &ByteArrayType, include: &ByteArrayType, percent: char) -> ByteArray,
    set_num(arg0: short, base: i32) -> ByteArray?,
    set_num(arg0: ushort, base: i32) -> ByteArray?,
    set_num(arg0: i32, base: i32) -> ByteArray?,
    set_num(arg0: uint, base: i32) -> ByteArray?,
    set_num(arg0: i64, base: i32) -> ByteArray?,
    set_num(arg0: qulonglong, base: i32) -> ByteArray?,
    set_num(arg0: f32, f: char, prec: i32) -> ByteArray?,
    set_num(arg0: double, f: char, prec: i32) -> ByteArray?,
    set_raw_data(a: *char, n: uint) -> ByteArray?,
    [static] number(arg0: i32, base: i32) -> ByteArray,
    [static] number(arg0: uint, base: i32) -> ByteArray,
    [static] number(arg0: i64, base: i32) -> ByteArray,
    [static] number(arg0: qulonglong, base: i32) -> ByteArray,
    [static] number(arg0: double, f: char, prec: i32) -> ByteArray,
    [static] from_raw_data(arg0: *char, size: i32) -> ByteArray,
    [static] from_base64(base64: &ByteArrayType, options: Base64Options) -> ByteArray,
    [static] from_base64(base64: &ByteArrayType) -> ByteArray,
    [static] from_hex(hex_encoded: &ByteArrayType) -> ByteArray,
    [static] from_percent_encoding(pct_encoded: &ByteArrayType, percent: char) -> ByteArray,
    begin() -> iterator,
    begin() -> const_iterator,
    cbegin() -> const_iterator,
    const_begin() -> const_iterator,
    end() -> iterator,
    end() -> const_iterator,
    cend() -> const_iterator,
    const_end() -> const_iterator,
    rbegin() -> i32,
    rend() -> i32,
    crbegin() -> i32,
    crend() -> i32,
    push_back(c: char),
    push_back(c: *char),
    push_back(a: &ByteArrayType),
    push_front(c: char),
    push_front(c: *char),
    push_front(a: &ByteArrayType),
    shrink_to_fit(),
    count() -> i32,
    length() -> i32,
    is_null() -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
