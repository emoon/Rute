/// 
/// QByteArray can be used to store both raw bytes (including '\\0's)
/// and traditional 8-bit '\\0'-terminated strings. Using QByteArray
/// is much more convenient than using `const char *` . Behind the
/// scenes, it always ensures that the data is followed by a '\\0'
/// terminator, and uses [implicit sharing](implicit%20sharing)
/// (copy-on-write) to
/// reduce memory usage and avoid needless copying of data.
/// 
/// In addition to QByteArray, Qt also provides the QString class to
/// store string data. For most purposes, QString is the class you
/// want to use. It stores 16-bit Unicode characters, making it easy
/// to store non-ASCII/non-Latin-1 characters in your application.
/// Furthermore, QString is used throughout in the Qt API. The two
/// main cases where QByteArray is appropriate are when you need to
/// store raw binary data, and when memory conservation is critical
/// (e.g., with Qt for Embedded Linux).
/// 
/// One way to initialize a QByteArray is simply to pass a `const
/// char *` to its constructor. For example, the following code
/// creates a byte array of size 5 containing the data :
/// 
/// Although the size() is 5, the byte array also maintains an extra
/// '\\0' character at the end so that if a function is used that
/// asks for a pointer to the underlying data (e.g. a call to
/// data()), the data pointed to is guaranteed to be
/// '\\0'-terminated.
/// 
/// QByteArray makes a deep copy of the `const char *` data, so you
/// can modify it later without experiencing side effects. (If for
/// performance reasons you don't want to take a deep copy of the
/// character data, use QByteArray::fromRawData() instead.)
/// 
/// Another approach is to set the size of the array using resize()
/// and to initialize the data byte per byte. QByteArray uses 0-based
/// indexes, just like C++ arrays. To access the byte at a particular
/// index position, you can use operator[](). On non-const byte
/// arrays, operator[]() returns a reference to a byte that can be
/// used on the left side of an assignment. For example:
/// 
/// For read-only access, an alternative syntax is to use at():
/// 
/// at() can be faster than operator[](), because it never causes a
/// [deep copy](deep%20copy)
/// to occur.
/// 
/// To extract many bytes at a time, use left(), right(), or mid().
/// 
/// A QByteArray can embed '\\0' bytes. The size() function always
/// returns the size of the whole array, including embedded '\\0'
/// bytes, but excluding the terminating '\\0' added by QByteArray.
/// For example:
/// 
/// If you want to obtain the length of the data up to and
/// excluding the first '\\0' character, call qstrlen() on the byte
/// array.
/// 
/// After a call to resize(), newly allocated bytes have undefined
/// values. To set all the bytes to a particular value, call fill().
/// 
/// To obtain a pointer to the actual character data, call data() or
/// constData(). These functions return a pointer to the beginning of the data.
/// The pointer is guaranteed to remain valid until a non-const function is
/// called on the QByteArray. It is also guaranteed that the data ends with a
/// '\\0' byte unless the QByteArray was created from a [raw
/// data](fromRawData())
/// . This '\\0' byte is automatically provided by QByteArray and is not
/// counted in size().
/// 
/// QByteArray provides the following basic functions for modifying
/// the byte data: append(), prepend(), insert(), replace(), and
/// remove(). For example:
/// 
/// The replace() and remove() functions' first two arguments are the
/// position from which to start erasing and the number of bytes that
/// should be erased.
/// 
/// When you append() data to a non-empty array, the array will be
/// reallocated and the new data copied to it. You can avoid this
/// behavior by calling reserve(), which preallocates a certain amount
/// of memory. You can also call capacity() to find out how much
/// memory QByteArray actually allocated. Data appended to an empty
/// array is not copied.
/// 
/// A frequent requirement is to remove whitespace characters from a
/// byte array ('\\n', '\\t', ' ', etc.). If you want to remove
/// whitespace from both ends of a QByteArray, use trimmed(). If you
/// want to remove whitespace from both ends and replace multiple
/// consecutive whitespaces with a single space character within the
/// byte array, use simplified().
/// 
/// If you want to find all occurrences of a particular character or
/// substring in a QByteArray, use indexOf() or lastIndexOf(). The
/// former searches forward starting from a given index position, the
/// latter searches backward. Both return the index position of the
/// character or substring if they find it; otherwise, they return -1.
/// For example, here's a typical loop that finds all occurrences of a
/// particular substring:
/// 
/// If you simply want to check whether a QByteArray contains a
/// particular character or substring, use contains(). If you want to
/// find out how many times a particular character or substring
/// occurs in the byte array, use count(). If you want to replace all
/// occurrences of a particular value with another, use one of the
/// two-parameter replace() overloads.
/// 
/// [QByteArray](QByteArray)
/// s can be compared using overloaded operators such as
/// operator<(), operator<=(), operator==(), operator>=(), and so on.
/// The comparison is based exclusively on the numeric values
/// of the characters and is very fast, but is not what a human would
/// expect. QString::localeAwareCompare() is a better choice for
/// sorting user-interface strings.
/// 
/// For historical reasons, QByteArray distinguishes between a null
/// byte array and an empty byte array. A *null* byte array is a
/// byte array that is initialized using QByteArray's default
/// constructor or by passing (const char *)0 to the constructor. An
/// *empty* byte array is any byte array with size 0. A null byte
/// array is always empty, but an empty byte array isn't necessarily
/// null:
/// 
/// All functions except isNull() treat null byte arrays the same as
/// empty byte arrays. For example, data() returns a pointer to a
/// '\\0' character for a null byte array ( *not* a null pointer),
/// and QByteArray() compares equal to QByteArray(""). We recommend
/// that you always use isEmpty() and avoid isNull().
/// 
/// # Notes on Locale
/// 
/// ## Number-String Conversions
/// 
/// Functions that perform conversions between numeric data types and
/// strings are performed in the C locale, irrespective of the user's
/// locale settings. Use QString to perform locale-aware conversions
/// between numbers and strings.
/// 
/// ## 8-bit Character Comparisons
/// 
/// In QByteArray, the notion of uppercase and lowercase and of which
/// character is greater than or less than another character is
/// locale dependent. This affects functions that support a case
/// insensitive option or that compare or lowercase or uppercase
/// their arguments. Case insensitive operations and comparisons will
/// be accurate if both strings contain only ASCII characters. (If `$LC_CTYPE` is set, most Unix systems do .)
/// Functions that this affects include contains(), indexOf(),
/// lastIndexOf(), operator<(), operator<=(), operator>(),
/// operator>=(), toLower() and toUpper().
/// 
/// This issue does not apply to [QString](QString)
/// s since they represent
/// characters using Unicode.
/// 
/// **See also:** QString
/// QBitArray
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QByteArray)]
enum Base64Option {
    Base64Encoding,
    Base64UrlEncoding,
    KeepTrailingEquals,
    OmitTrailingEquals,
}


struct ByteArray {
    /// 
    /// Swaps byte array *other* with this byte array. This operation is very
    /// fast and never fails.
    swap(other: &ByteArrayType),
    /// 
    /// Returns the number of bytes in this byte array.
    /// 
    /// The last byte in the byte array is at position size() - 1. In addition,
    /// QByteArray ensures that the byte at position size() is always '\\0', so
    /// that you can use the return value of data() and constData() as arguments to
    /// functions that expect '\\0'-terminated strings. If the QByteArray object
    /// was created from a [raw data](fromRawData())
    /// that didn't include the
    /// trailing null-termination character then QByteArray doesn't add it
    /// automaticall unless the [deep copy](deep%20copy)
    /// is created.
    /// 
    /// Example:
    /// 
    /// **See also:** isEmpty()
    /// resize()
    size() -> i32,
    /// 
    /// Returns `true` if the byte array has size 0; otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** size()
    is_empty() -> bool,
    /// 
    /// Sets the size of the byte array to *size* bytes.
    /// 
    /// If *size* is greater than the current size, the byte array is
    /// extended to make it *size* bytes with the extra bytes added to
    /// the end. The new bytes are uninitialized.
    /// 
    /// If *size* is less than the current size, bytes are removed from
    /// the end.
    /// 
    /// **See also:** size()
    /// truncate()
    resize(size: i32),
    /// 
    /// Sets every byte in the byte array to character *ch.* If *size*
    /// is different from -1 (the default), the byte array is resized to
    /// size *size* beforehand.
    /// 
    /// Example:
    /// 
    /// **See also:** resize()
    fill(c: char, size: i32) -> ByteArray?,
    /// 
    /// Returns the maximum number of bytes that can be stored in the
    /// byte array without forcing a reallocation.
    /// 
    /// The sole purpose of this function is to provide a means of fine
    /// tuning QByteArray's memory usage. In general, you will rarely
    /// ever need to call this function. If you want to know how many
    /// bytes are in the byte array, call size().
    /// 
    /// **See also:** reserve()
    /// squeeze()
    capacity() -> i32,
    /// 
    /// Attempts to allocate memory for at least *size* bytes. If you
    /// know in advance how large the byte array will be, you can call
    /// this function, and if you call resize() often you are likely to
    /// get better performance. If *size* is an underestimate, the worst
    /// that will happen is that the QByteArray will be a bit slower.
    /// 
    /// The sole purpose of this function is to provide a means of fine
    /// tuning QByteArray's memory usage. In general, you will rarely
    /// ever need to call this function. If you want to change the size
    /// of the byte array, call resize().
    /// 
    /// **See also:** squeeze()
    /// capacity()
    reserve(size: i32),
    /// 
    /// Releases any memory not required to store the array's data.
    /// 
    /// The sole purpose of this function is to provide a means of fine
    /// tuning QByteArray's memory usage. In general, you will rarely
    /// ever need to call this function.
    /// 
    /// **See also:** reserve()
    /// capacity()
    squeeze(),
    /// 
    /// Returns a pointer to the data stored in the byte array. The
    /// pointer can be used to access and modify the bytes that compose
    /// the array. The data is '\\0'-terminated, i.e. the number of
    /// bytes in the returned character string is size() + 1 for the
    /// '\\0' terminator.
    /// 
    /// Example:
    /// 
    /// The pointer remains valid as long as the byte array isn't
    /// reallocated or destroyed. For read-only access, constData() is
    /// faster because it never causes a [deep copy](deep%20copy)
    /// to occur.
    /// 
    /// This function is mostly useful to pass a byte array to a function
    /// that accepts a `const char *` .
    /// 
    /// The following example makes a copy of the char* returned by
    /// data(), but it will corrupt the heap and cause a crash because it
    /// does not allocate a byte for the '\\0' at the end:
    /// 
    /// This one allocates the correct amount of space:
    /// 
    /// Note: A QByteArray can store any byte values including '\\0's,
    /// but most functions that take `char *` arguments assume that the
    /// data ends at the first '\\0' they encounter.
    /// 
    /// **See also:** constData()
    /// operator[]()
    /// 
    /// **Overloads**
    data() -> char?,
    /// 
    /// Returns a pointer to the data stored in the byte array. The
    /// pointer can be used to access and modify the bytes that compose
    /// the array. The data is '\\0'-terminated, i.e. the number of
    /// bytes in the returned character string is size() + 1 for the
    /// '\\0' terminator.
    /// 
    /// Example:
    /// 
    /// The pointer remains valid as long as the byte array isn't
    /// reallocated or destroyed. For read-only access, constData() is
    /// faster because it never causes a [deep copy](deep%20copy)
    /// to occur.
    /// 
    /// This function is mostly useful to pass a byte array to a function
    /// that accepts a `const char *` .
    /// 
    /// The following example makes a copy of the char* returned by
    /// data(), but it will corrupt the heap and cause a crash because it
    /// does not allocate a byte for the '\\0' at the end:
    /// 
    /// This one allocates the correct amount of space:
    /// 
    /// Note: A QByteArray can store any byte values including '\\0's,
    /// but most functions that take `char *` arguments assume that the
    /// data ends at the first '\\0' they encounter.
    /// 
    /// **See also:** constData()
    /// operator[]()
    /// 
    /// **Overloads**
    data_2() -> char?,
    /// 
    /// Returns a pointer to the data stored in the byte array. The pointer can be
    /// used to access the bytes that compose the array. The data is
    /// '\\0'-terminated unless the QByteArray object was created from raw data.
    /// The pointer remains valid as long as the byte array isn't reallocated or
    /// destroyed.
    /// 
    /// This function is mostly useful to pass a byte array to a function
    /// that accepts a `const char *` .
    /// 
    /// Note: A QByteArray can store any byte values including '\\0's,
    /// but most functions that take `char *` arguments assume that the
    /// data ends at the first '\\0' they encounter.
    /// 
    /// **See also:** data()
    /// operator[]()
    /// fromRawData()
    const_data() -> char?,
    detach(),
    is_detached() -> bool,
    is_shared_with(other: &ByteArrayType) -> bool,
    /// 
    /// Clears the contents of the byte array and makes it null.
    /// 
    /// **See also:** resize()
    /// isNull()
    clear(),
    /// 
    /// Returns the character at index position *i* in the byte array.
    /// 
    /// *i* must be a valid index position in the byte array (i.e., 0 <=
    /// *i* < size()).
    /// 
    /// **See also:** operator[]()
    at(i: i32) -> char,
    /// 
    /// Returns the first character in the byte array.
    /// Same as `at(0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** back()
    /// at()
    /// operator[]()
    /// 
    /// Returns a reference to the first character in the byte array.
    /// Same as `operator[](0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** back()
    /// at()
    /// operator[]()
    front() -> char,
    /// 
    /// Returns the first character in the byte array.
    /// Same as `at(0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** back()
    /// at()
    /// operator[]()
    /// 
    /// Returns a reference to the first character in the byte array.
    /// Same as `operator[](0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** back()
    /// at()
    /// operator[]()
    front_2() -> ByteRef,
    /// 
    /// Returns the last character in the byte array.
    /// Same as `at(size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** front()
    /// at()
    /// operator[]()
    /// 
    /// Returns a reference to the last character in the byte array.
    /// Same as `operator[](size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** front()
    /// at()
    /// operator[]()
    back() -> char,
    /// 
    /// Returns the last character in the byte array.
    /// Same as `at(size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** front()
    /// at()
    /// operator[]()
    /// 
    /// Returns a reference to the last character in the byte array.
    /// Same as `operator[](size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty byte array constitutes
    /// undefined behavior.
    /// 
    /// **See also:** front()
    /// at()
    /// operator[]()
    back_2() -> ByteRef,
    /// 
    /// Returns the index position of the first occurrence of the byte
    /// array *ba* in this byte array, searching forward from index
    /// position *from.* Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position
    /// *from.* Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position *from.* Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the byte array, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    index_of(c: char, from: i32) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the byte
    /// array *ba* in this byte array, searching forward from index
    /// position *from.* Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position
    /// *from.* Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position *from.* Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the byte array, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    index_of_2(c: *char, from: i32) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the byte
    /// array *ba* in this byte array, searching forward from index
    /// position *from.* Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position
    /// *from.* Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position *from.* Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the byte array, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    index_of_3(a: &ByteArrayType, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the byte
    /// array *ba* in this byte array, searching backward from index
    /// position *from.* If *from* is -1 (the default), the search
    /// starts at the last byte. Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of character *ch* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    last_index_of(c: char, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the byte
    /// array *ba* in this byte array, searching backward from index
    /// position *from.* If *from* is -1 (the default), the search
    /// starts at the last byte. Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of character *ch* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    last_index_of_2(c: *char, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the byte
    /// array *ba* in this byte array, searching backward from index
    /// position *from.* If *from* is -1 (the default), the search
    /// starts at the last byte. Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of character *ch* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    last_index_of_3(a: &ByteArrayType, from: i32) -> i32,
    /// 
    /// Returns `true` if the byte array contains an occurrence of the byte
    /// array *ba;* otherwise returns `false.`
    /// 
    /// **See also:** indexOf()
    /// count()
    /// 
    /// **Overloads**
    /// Returns `true` if the byte array contains the string *str;*
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the byte array contains the character *ch;*
    /// otherwise returns `false.`
    contains(c: char) -> bool,
    /// 
    /// Returns `true` if the byte array contains an occurrence of the byte
    /// array *ba;* otherwise returns `false.`
    /// 
    /// **See also:** indexOf()
    /// count()
    /// 
    /// **Overloads**
    /// Returns `true` if the byte array contains the string *str;*
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the byte array contains the character *ch;*
    /// otherwise returns `false.`
    contains_2(a: *char) -> bool,
    /// 
    /// Returns `true` if the byte array contains an occurrence of the byte
    /// array *ba;* otherwise returns `false.`
    /// 
    /// **See also:** indexOf()
    /// count()
    /// 
    /// **Overloads**
    /// Returns `true` if the byte array contains the string *str;*
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the byte array contains the character *ch;*
    /// otherwise returns `false.`
    contains_3(a: &ByteArrayType) -> bool,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// byte array *ba* in this byte array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Returns the number of (potentially overlapping) occurrences of
    /// string *str* in the byte array.
    /// 
    /// **Overloads**
    /// Returns the number of occurrences of character *ch* in the byte
    /// array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Same as size().
    count(c: char) -> i32,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// byte array *ba* in this byte array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Returns the number of (potentially overlapping) occurrences of
    /// string *str* in the byte array.
    /// 
    /// **Overloads**
    /// Returns the number of occurrences of character *ch* in the byte
    /// array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Same as size().
    count_2(a: *char) -> i32,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// byte array *ba* in this byte array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Returns the number of (potentially overlapping) occurrences of
    /// string *str* in the byte array.
    /// 
    /// **Overloads**
    /// Returns the number of occurrences of character *ch* in the byte
    /// array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Same as size().
    count_3(a: &ByteArrayType) -> i32,
    /// 
    /// Returns a byte array that contains the leftmost *len* bytes of
    /// this byte array.
    /// 
    /// The entire byte array is returned if *len* is greater than
    /// size().
    /// 
    /// Example:
    /// 
    /// **See also:** startsWith()
    /// right()
    /// mid()
    /// chopped()
    /// chop()
    /// truncate()
    /// 
    /// Returns a byte array of size *width* that contains this byte
    /// array padded by the *fill* character.
    /// 
    /// If *truncate* is false and the size() of the byte array is more
    /// than *width,* then the returned byte array is a copy of this byte
    /// array.
    /// 
    /// If *truncate* is true and the size() of the byte array is more
    /// than *width,* then any bytes in a copy of the byte array
    /// after position *width* are removed, and the copy is returned.
    /// 
    /// Example:
    /// 
    /// **See also:** rightJustified()
    left(len: i32) -> ByteArray,
    /// 
    /// Returns a byte array that contains the rightmost *len* bytes of
    /// this byte array.
    /// 
    /// The entire byte array is returned if *len* is greater than
    /// size().
    /// 
    /// Example:
    /// 
    /// **See also:** endsWith()
    /// left()
    /// mid()
    /// chopped()
    /// chop()
    /// truncate()
    /// 
    /// Returns a byte array of size *width* that contains the *fill*
    /// character followed by this byte array.
    /// 
    /// If *truncate* is false and the size of the byte array is more
    /// than *width,* then the returned byte array is a copy of this byte
    /// array.
    /// 
    /// If *truncate* is true and the size of the byte array is more
    /// than *width,* then the resulting byte array is truncated at
    /// position *width.*
    /// 
    /// Example:
    /// 
    /// **See also:** leftJustified()
    right(len: i32) -> ByteArray,
    /// 
    /// Returns a byte array containing *len* bytes from this byte array,
    /// starting at position *pos.*
    /// 
    /// If *len* is -1 (the default), or *pos* + *len* >= size(),
    /// returns a byte array containing all bytes starting at position *pos* until the end of the byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** left()
    /// right()
    /// chopped()
    /// chop()
    /// truncate()
    mid(index: i32, len: i32) -> ByteArray,
    /// 
    /// Returns a byte array that contains the leftmost size() - *len* bytes of
    /// this byte array.
    /// 
    /// **Note**: The behavior is undefined if *len* is negative or greater than size().
    /// 
    /// **See also:** endsWith()
    /// left()
    /// right()
    /// mid()
    /// chop()
    /// truncate()
    chopped(len: i32) -> ByteArray,
    /// 
    /// Returns `true` if this byte array starts with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** endsWith()
    /// left()
    /// **Overloads**
    /// Returns `true` if this byte array starts with string *str;*
    /// otherwise returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array starts with character *ch;*
    /// otherwise returns `false.`
    starts_with(a: &ByteArrayType) -> bool,
    /// 
    /// Returns `true` if this byte array starts with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** endsWith()
    /// left()
    /// **Overloads**
    /// Returns `true` if this byte array starts with string *str;*
    /// otherwise returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array starts with character *ch;*
    /// otherwise returns `false.`
    starts_with_2(c: char) -> bool,
    /// 
    /// Returns `true` if this byte array starts with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** endsWith()
    /// left()
    /// **Overloads**
    /// Returns `true` if this byte array starts with string *str;*
    /// otherwise returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array starts with character *ch;*
    /// otherwise returns `false.`
    starts_with_3(c: *char) -> bool,
    /// 
    /// Returns `true` if this byte array ends with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** startsWith()
    /// right()
    /// **Overloads**
    /// Returns `true` if this byte array ends with string *str;* otherwise
    /// returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array ends with character *ch;*
    /// otherwise returns `false.`
    ends_with(a: &ByteArrayType) -> bool,
    /// 
    /// Returns `true` if this byte array ends with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** startsWith()
    /// right()
    /// **Overloads**
    /// Returns `true` if this byte array ends with string *str;* otherwise
    /// returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array ends with character *ch;*
    /// otherwise returns `false.`
    ends_with_2(c: char) -> bool,
    /// 
    /// Returns `true` if this byte array ends with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** startsWith()
    /// right()
    /// **Overloads**
    /// Returns `true` if this byte array ends with string *str;* otherwise
    /// returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array ends with character *ch;*
    /// otherwise returns `false.`
    ends_with_3(c: *char) -> bool,
    /// 
    /// Removes *n* bytes from the end of the byte array.
    /// 
    /// If *n* is greater than size(), the result is an empty byte
    /// array.
    /// 
    /// Example:
    /// 
    /// **See also:** truncate()
    /// resize()
    /// left()
    /// 
    /// Returns a byte array that contains the leftmost size() - *len* bytes of
    /// this byte array.
    /// 
    /// **Note**: The behavior is undefined if *len* is negative or greater than size().
    /// 
    /// **See also:** endsWith()
    /// left()
    /// right()
    /// mid()
    /// chop()
    /// truncate()
    chop(n: i32),
    /// 
    /// Returns a lowercase copy of the byte array. The bytearray is
    /// interpreted as a Latin-1 encoded string.
    /// 
    /// Example:
    /// 
    /// **See also:** toUpper()
    /// {8-bit Character Comparisons}
    to_lower() -> ByteArray,
    /// 
    /// Returns a lowercase copy of the byte array. The bytearray is
    /// interpreted as a Latin-1 encoded string.
    /// 
    /// Example:
    /// 
    /// **See also:** toUpper()
    /// {8-bit Character Comparisons}
    to_lower_2() -> ByteArray,
    /// 
    /// Returns an uppercase copy of the byte array. The bytearray is
    /// interpreted as a Latin-1 encoded string.
    /// 
    /// Example:
    /// 
    /// **See also:** toLower()
    /// {8-bit Character Comparisons}
    to_upper() -> ByteArray,
    /// 
    /// Returns an uppercase copy of the byte array. The bytearray is
    /// interpreted as a Latin-1 encoded string.
    /// 
    /// Example:
    /// 
    /// **See also:** toLower()
    /// {8-bit Character Comparisons}
    to_upper_2() -> ByteArray,
    /// 
    /// Returns a byte array that has whitespace removed from the start
    /// and the end, and which has each sequence of internal whitespace
    /// replaced with a single space.
    /// 
    /// Whitespace means any character for which the standard C++
    /// `isspace()` function returns `true` in the C locale. This includes the ASCII
    /// isspace() function returns `true` in the C locale. This includes the ASCII
    /// characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' '.
    /// 
    /// Example:
    /// 
    /// **See also:** trimmed()
    simplified() -> ByteArray,
    /// 
    /// Returns a byte array that has whitespace removed from the start
    /// and the end, and which has each sequence of internal whitespace
    /// replaced with a single space.
    /// 
    /// Whitespace means any character for which the standard C++
    /// `isspace()` function returns `true` in the C locale. This includes the ASCII
    /// isspace() function returns `true` in the C locale. This includes the ASCII
    /// characters '\\t', '\\n', '\\v', '\\f', '\\r', and ' '.
    /// 
    /// Example:
    /// 
    /// **See also:** trimmed()
    simplified_2() -> ByteArray,
    /// 
    /// Returns a byte array of size *width* that contains this byte
    /// array padded by the *fill* character.
    /// 
    /// If *truncate* is false and the size() of the byte array is more
    /// than *width,* then the returned byte array is a copy of this byte
    /// array.
    /// 
    /// If *truncate* is true and the size() of the byte array is more
    /// than *width,* then any bytes in a copy of the byte array
    /// after position *width* are removed, and the copy is returned.
    /// 
    /// Example:
    /// 
    /// **See also:** rightJustified()
    left_justified(width: i32, fill: char, truncate: bool) -> ByteArray,
    /// 
    /// Returns a byte array of size *width* that contains the *fill*
    /// character followed by this byte array.
    /// 
    /// If *truncate* is false and the size of the byte array is more
    /// than *width,* then the returned byte array is a copy of this byte
    /// array.
    /// 
    /// If *truncate* is true and the size of the byte array is more
    /// than *width,* then the resulting byte array is truncated at
    /// position *width.*
    /// 
    /// Example:
    /// 
    /// **See also:** leftJustified()
    right_justified(width: i32, fill: char, truncate: bool) -> ByteArray,
    /// 
    /// Prepends the byte array *ba* to this byte array and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(0, *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you prepend to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being prepended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// **See also:** append()
    /// insert()
    /// 
    /// **Overloads**
    /// Prepends the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *len* bytes of the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *count* copies of character *ch* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends the character *ch* to this byte array.
    prepend(c: char) -> ByteArray?,
    /// 
    /// Prepends the byte array *ba* to this byte array and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(0, *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you prepend to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being prepended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// **See also:** append()
    /// insert()
    /// 
    /// **Overloads**
    /// Prepends the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *len* bytes of the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *count* copies of character *ch* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends the character *ch* to this byte array.
    prepend_2(count: i32, c: char) -> ByteArray?,
    /// 
    /// Prepends the byte array *ba* to this byte array and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(0, *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you prepend to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being prepended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// **See also:** append()
    /// insert()
    /// 
    /// **Overloads**
    /// Prepends the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *len* bytes of the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *count* copies of character *ch* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends the character *ch* to this byte array.
    prepend_3(s: *char) -> ByteArray?,
    /// 
    /// Prepends the byte array *ba* to this byte array and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(0, *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you prepend to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being prepended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// **See also:** append()
    /// insert()
    /// 
    /// **Overloads**
    /// Prepends the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *len* bytes of the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *count* copies of character *ch* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends the character *ch* to this byte array.
    prepend_4(s: *char, len: i32) -> ByteArray?,
    /// 
    /// Prepends the byte array *ba* to this byte array and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(0, *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you prepend to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being prepended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// **See also:** append()
    /// insert()
    /// 
    /// **Overloads**
    /// Prepends the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *len* bytes of the string *str* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends *count* copies of character *ch* to this byte array.
    /// 
    /// **Overloads**
    /// Prepends the character *ch* to this byte array.
    prepend_5(a: &ByteArrayType) -> ByteArray?,
    /// 
    /// Appends the byte array *ba* onto the end of this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(size(), *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you append to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being appended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// This operation typically does not suffer from allocation overhead,
    /// because QByteArray preallocates extra space at the end of the data
    /// so that it may grow without reallocating for each append operation.
    /// 
    /// **See also:** operator+=()
    /// prepend()
    /// insert()
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array. The Unicode data is
    /// converted into 8-bit characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array.
    /// 
    /// **Overloads** append()
    /// Appends the first *len* characters of the string *str* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *len* is negative, the length of the string will be determined
    /// automatically using qstrlen(). If *len* is zero or *str* is
    /// null, nothing is appended to the byte array. Ensure that *len* is
    /// *not* longer than *str.*
    /// 
    /// **Overloads**
    /// Appends *count* copies of character *ch* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *count* is negative or zero nothing is appended to the byte array.
    /// 
    /// **Overloads**
    /// Appends the character *ch* to this byte array.
    append(c: char) -> ByteArray?,
    /// 
    /// Appends the byte array *ba* onto the end of this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(size(), *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you append to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being appended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// This operation typically does not suffer from allocation overhead,
    /// because QByteArray preallocates extra space at the end of the data
    /// so that it may grow without reallocating for each append operation.
    /// 
    /// **See also:** operator+=()
    /// prepend()
    /// insert()
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array. The Unicode data is
    /// converted into 8-bit characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array.
    /// 
    /// **Overloads** append()
    /// Appends the first *len* characters of the string *str* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *len* is negative, the length of the string will be determined
    /// automatically using qstrlen(). If *len* is zero or *str* is
    /// null, nothing is appended to the byte array. Ensure that *len* is
    /// *not* longer than *str.*
    /// 
    /// **Overloads**
    /// Appends *count* copies of character *ch* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *count* is negative or zero nothing is appended to the byte array.
    /// 
    /// **Overloads**
    /// Appends the character *ch* to this byte array.
    append_2(count: i32, c: char) -> ByteArray?,
    /// 
    /// Appends the byte array *ba* onto the end of this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(size(), *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you append to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being appended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// This operation typically does not suffer from allocation overhead,
    /// because QByteArray preallocates extra space at the end of the data
    /// so that it may grow without reallocating for each append operation.
    /// 
    /// **See also:** operator+=()
    /// prepend()
    /// insert()
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array. The Unicode data is
    /// converted into 8-bit characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array.
    /// 
    /// **Overloads** append()
    /// Appends the first *len* characters of the string *str* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *len* is negative, the length of the string will be determined
    /// automatically using qstrlen(). If *len* is zero or *str* is
    /// null, nothing is appended to the byte array. Ensure that *len* is
    /// *not* longer than *str.*
    /// 
    /// **Overloads**
    /// Appends *count* copies of character *ch* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *count* is negative or zero nothing is appended to the byte array.
    /// 
    /// **Overloads**
    /// Appends the character *ch* to this byte array.
    append_3(s: *char) -> ByteArray?,
    /// 
    /// Appends the byte array *ba* onto the end of this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(size(), *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you append to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being appended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// This operation typically does not suffer from allocation overhead,
    /// because QByteArray preallocates extra space at the end of the data
    /// so that it may grow without reallocating for each append operation.
    /// 
    /// **See also:** operator+=()
    /// prepend()
    /// insert()
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array. The Unicode data is
    /// converted into 8-bit characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array.
    /// 
    /// **Overloads** append()
    /// Appends the first *len* characters of the string *str* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *len* is negative, the length of the string will be determined
    /// automatically using qstrlen(). If *len* is zero or *str* is
    /// null, nothing is appended to the byte array. Ensure that *len* is
    /// *not* longer than *str.*
    /// 
    /// **Overloads**
    /// Appends *count* copies of character *ch* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *count* is negative or zero nothing is appended to the byte array.
    /// 
    /// **Overloads**
    /// Appends the character *ch* to this byte array.
    append_4(s: *char, len: i32) -> ByteArray?,
    /// 
    /// Appends the byte array *ba* onto the end of this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(size(), *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you append to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being appended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// This operation typically does not suffer from allocation overhead,
    /// because QByteArray preallocates extra space at the end of the data
    /// so that it may grow without reallocating for each append operation.
    /// 
    /// **See also:** operator+=()
    /// prepend()
    /// insert()
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array. The Unicode data is
    /// converted into 8-bit characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array.
    /// 
    /// **Overloads** append()
    /// Appends the first *len* characters of the string *str* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *len* is negative, the length of the string will be determined
    /// automatically using qstrlen(). If *len* is zero or *str* is
    /// null, nothing is appended to the byte array. Ensure that *len* is
    /// *not* longer than *str.*
    /// 
    /// **Overloads**
    /// Appends *count* copies of character *ch* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *count* is negative or zero nothing is appended to the byte array.
    /// 
    /// **Overloads**
    /// Appends the character *ch* to this byte array.
    append_5(a: &ByteArrayType) -> ByteArray?,
    /// 
    /// Inserts the byte array *ba* at index position *i* and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** append()
    /// prepend()
    /// replace()
    /// remove()
    /// 
    /// **Overloads**
    /// Inserts the string *str* at index position *i* in the byte
    /// array. The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Inserts the string *str* at position *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *len* bytes of the string *str* at position
    /// *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts character *ch* at index position *i* in the byte array.
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *count* copies of character *ch* at index position *i* in the
    /// byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using resize().
    insert(i: i32, c: char) -> ByteArray?,
    /// 
    /// Inserts the byte array *ba* at index position *i* and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** append()
    /// prepend()
    /// replace()
    /// remove()
    /// 
    /// **Overloads**
    /// Inserts the string *str* at index position *i* in the byte
    /// array. The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Inserts the string *str* at position *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *len* bytes of the string *str* at position
    /// *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts character *ch* at index position *i* in the byte array.
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *count* copies of character *ch* at index position *i* in the
    /// byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using resize().
    insert_2(i: i32, count: i32, c: char) -> ByteArray?,
    /// 
    /// Inserts the byte array *ba* at index position *i* and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** append()
    /// prepend()
    /// replace()
    /// remove()
    /// 
    /// **Overloads**
    /// Inserts the string *str* at index position *i* in the byte
    /// array. The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Inserts the string *str* at position *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *len* bytes of the string *str* at position
    /// *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts character *ch* at index position *i* in the byte array.
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *count* copies of character *ch* at index position *i* in the
    /// byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using resize().
    insert_3(i: i32, s: *char) -> ByteArray?,
    /// 
    /// Inserts the byte array *ba* at index position *i* and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** append()
    /// prepend()
    /// replace()
    /// remove()
    /// 
    /// **Overloads**
    /// Inserts the string *str* at index position *i* in the byte
    /// array. The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Inserts the string *str* at position *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *len* bytes of the string *str* at position
    /// *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts character *ch* at index position *i* in the byte array.
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *count* copies of character *ch* at index position *i* in the
    /// byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using resize().
    insert_4(i: i32, s: *char, len: i32) -> ByteArray?,
    /// 
    /// Inserts the byte array *ba* at index position *i* and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** append()
    /// prepend()
    /// replace()
    /// remove()
    /// 
    /// **Overloads**
    /// Inserts the string *str* at index position *i* in the byte
    /// array. The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Inserts the string *str* at position *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *len* bytes of the string *str* at position
    /// *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts character *ch* at index position *i* in the byte array.
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *count* copies of character *ch* at index position *i* in the
    /// byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using resize().
    insert_5(i: i32, a: &ByteArrayType) -> ByteArray?,
    /// 
    /// Removes *len* bytes from the array, starting at index position *pos,* and returns a reference to the array.
    /// 
    /// If *pos* is out of range, nothing happens. If *pos* is valid,
    /// but *pos* + *len* is larger than the size of the array, the
    /// array is truncated at position *pos.*
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// replace()
    remove(index: i32, len: i32) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace(index: i32, len: i32, s: *char) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_2(index: i32, len: i32, s: *char, alen: i32) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_3(index: i32, len: i32, s: &ByteArrayType) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_4(before: char, after: *char) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_5(before: char, after: &ByteArrayType) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_6(before: *char, after: *char) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_7(before: *char, bsize: i32, after: *char, asize: i32) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_8(before: &ByteArrayType, after: &ByteArrayType) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_9(before: &ByteArrayType, after: *char) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_10(before: *char, after: &ByteArrayType) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_11(before: char, after: char) -> ByteArray?,
    /// 
    /// Splits the byte array into subarrays wherever *sep* occurs, and
    /// returns the list of those arrays. If *sep* does not match
    /// anywhere in the byte array, split() returns a single-element list
    /// containing this byte array.
    split(sep: char) -> [ByteArray],
    /// 
    /// Returns a copy of this byte array repeated the specified number of *times.*
    /// 
    /// If *times* is less than 1, an empty byte array is returned.
    /// 
    /// Example:
    /// 
    /// ```
    /// QByteArray ba("ab");
    /// ba.repeated(4);             // returns "abababab"
    /// ```
    /// 
    repeated(times: i32) -> ByteArray,
    /// 
    /// Appends the byte array *ba* onto the end of this byte array.
    /// 
    /// Example:
    /// 
    /// This is the same as insert(size(), *ba).*
    /// 
    /// Note: QByteArray is an [implicitly shared](implicitly%20shared)
    /// class. Consequently,
    /// if you append to an empty byte array, then the byte array will just
    /// share the data held in *ba.* In this case, no copying of data is done,
    /// taking [constant time](constant%20time)
    /// . If a shared instance is modified, it will
    /// be copied (copy-on-write), taking [linear time](linear%20time)
    /// 
    /// 
    /// If the byte array being appended to is not empty, a deep copy of the
    /// data is performed, taking [linear time](linear%20time)
    /// 
    /// 
    /// This operation typically does not suffer from allocation overhead,
    /// because QByteArray preallocates extra space at the end of the data
    /// so that it may grow without reallocating for each append operation.
    /// 
    /// **See also:** operator+=()
    /// prepend()
    /// insert()
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array. The Unicode data is
    /// converted into 8-bit characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Appends the string *str* to this byte array.
    /// 
    /// **Overloads** append()
    /// Appends the first *len* characters of the string *str* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *len* is negative, the length of the string will be determined
    /// automatically using qstrlen(). If *len* is zero or *str* is
    /// null, nothing is appended to the byte array. Ensure that *len* is
    /// *not* longer than *str.*
    /// 
    /// **Overloads**
    /// Appends *count* copies of character *ch* to this byte
    /// array and returns a reference to this byte array.
    /// 
    /// If *count* is negative or zero nothing is appended to the byte array.
    /// 
    /// **Overloads**
    /// Appends the character *ch* to this byte array.
    append_6(s: String) -> ByteArray?,
    /// 
    /// Inserts the byte array *ba* at index position *i* and returns a
    /// reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** append()
    /// prepend()
    /// replace()
    /// remove()
    /// 
    /// **Overloads**
    /// Inserts the string *str* at index position *i* in the byte
    /// array. The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Inserts the string *str* at position *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *len* bytes of the string *str* at position
    /// *i* in the byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts character *ch* at index position *i* in the byte array.
    /// If *i* is greater than size(), the array is first extended using
    /// resize().
    /// 
    /// **Overloads**
    /// Inserts *count* copies of character *ch* at index position *i* in the
    /// byte array.
    /// 
    /// If *i* is greater than size(), the array is first extended using resize().
    insert_6(i: i32, s: String) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_12(before: String, after: *char) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_13(c: char, after: String) -> ByteArray?,
    /// 
    /// Replaces *len* bytes from index position *pos* with the byte
    /// array *after,* and returns a reference to this byte array.
    /// 
    /// Example:
    /// 
    /// **See also:** insert()
    /// remove()
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with the zero terminated
    /// string *after.*
    /// 
    /// Notice: this can change the length of the byte array.
    /// 
    /// **Overloads**
    /// Replaces *len* bytes from index position *pos* with *alen* bytes
    /// from the string *after.* *after* is allowed to have '\\0' characters.
    /// 
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// byte array *after.*
    /// 
    /// Example:
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string *after.*
    /// Since the sizes of the strings are given by *bsize* and *asize,* they
    /// may contain zero characters and do not need to be zero-terminated.
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the byte array *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the byte
    /// array *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the string *before* with the string
    /// *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// byte array *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.* The Unicode data is converted into 8-bit
    /// characters using QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// string *after.*
    /// 
    /// **Overloads**
    /// Replaces every occurrence of the character *before* with the
    /// character *after.*
    replace_14(before: String, after: &ByteArrayType) -> ByteArray?,
    /// 
    /// Returns the index position of the first occurrence of the byte
    /// array *ba* in this byte array, searching forward from index
    /// position *from.* Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position
    /// *from.* Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the string
    /// *str* in the byte array, searching forward from index position *from.* Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the byte array, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** lastIndexOf()
    /// contains()
    index_of_4(s: String, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the byte
    /// array *ba* in this byte array, searching backward from index
    /// position *from.* If *from* is -1 (the default), the search
    /// starts at the last byte. Returns -1 if *ba* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    /// count()
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// The Unicode data is converted into 8-bit characters using
    /// QString::toUtf8().
    /// 
    /// You can disable this function by defining `QT_NO_CAST_TO_ASCII` when you
    /// compile your applications. You then need to call QString::toUtf8() (or
    /// QString::toLatin1() or QString::toLocal8Bit()) explicitly if you want to
    /// convert the data to `const char *` .
    /// **Overloads**
    /// Returns the index position of the last occurrence of the string *str* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *str* could not be found.
    /// 
    /// **Overloads**
    /// Returns the index position of the last occurrence of character *ch* in the byte array, searching backward from index position *from.* If *from* is -1 (the default), the search starts at the
    /// last (size() - 1) byte. Returns -1 if *ch* could not be found.
    /// 
    /// Example:
    /// 
    /// **See also:** indexOf()
    /// contains()
    last_index_of_4(s: String, from: i32) -> i32,
    /// 
    /// Returns the byte array converted to a `short` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_short(ok: *bool, base: i32) -> short,
    /// 
    /// Returns the byte array converted to an `unsigned short` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_u_short(ok: *bool, base: i32) -> ushort,
    /// 
    /// Returns the byte array converted to an `int` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_int(ok: *bool, base: i32) -> i32,
    /// 
    /// Returns the byte array converted to an `unsigned int` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_u_int(ok: *bool, base: i32) -> uint,
    /// 
    /// Returns the byte array converted to a `long long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// 
    /// Returns the byte array converted to a `long` int using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_long(ok: *bool, base: i32) -> long,
    /// 
    /// Returns the byte array converted to an `unsigned long long`
    /// using base *base,* which is 10 by default and must be between 2
    /// and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// 
    /// Returns the byte array converted to an `unsigned long int` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_u_long(ok: *bool, base: i32) -> ulong,
    /// 
    /// Returns the byte array converted to a `long long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_long_long(ok: *bool, base: i32) -> i64,
    /// 
    /// Returns the byte array converted to an `unsigned long long`
    /// using base *base,* which is 10 by default and must be between 2
    /// and 36, or 0.
    /// 
    /// If *base* is 0, the base is determined automatically using the
    /// following rules: If the byte array begins with , it is assumed to
    /// be hexadecimal; if it begins with , it is assumed to be octal;
    /// otherwise it is assumed to be decimal.
    /// 
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_u_long_long(ok: *bool, base: i32) -> qulonglong,
    /// 
    /// Returns the byte array converted to a `float` value.
    /// 
    /// Returns 0.0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_float(ok: *bool) -> f32,
    /// 
    /// Returns the byte array converted to a `double` value.
    /// 
    /// Returns 0.0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Note**: The conversion of the number is performed in the default C locale,
    /// irrespective of the user's locale.
    /// 
    /// **See also:** number()
    to_double(ok: *bool) -> double,
    /// 
    /// Returns a copy of the byte array, encoded as Base64.
    /// 
    /// The algorithm used to encode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** fromBase64()
    /// 
    /// **Overloads**
    /// Returns a copy of the byte array, encoded using the options *options.*
    /// 
    /// The algorithm used to encode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** fromBase64()
    to_base64(options: ByteArray::Base64Options) -> ByteArray,
    /// 
    /// Returns a copy of the byte array, encoded as Base64.
    /// 
    /// The algorithm used to encode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** fromBase64()
    /// 
    /// **Overloads**
    /// Returns a copy of the byte array, encoded using the options *options.*
    /// 
    /// The algorithm used to encode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** fromBase64()
    to_base64_2() -> ByteArray,
    /// 
    /// Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and
    /// the letters a-f.
    /// 
    /// **See also:** fromHex()
    /// **Overloads**
    /// Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and
    /// the letters a-f.
    /// 
    /// If *separator* is not '\0', the separator character is inserted between the hex bytes.
    /// 
    /// Example:
    /// ```
    /// QByteArray macAddress = QByteArray::fromHex("123456abcdef");
    /// macAddress.toHex(':'); // returns "12:34:56:ab:cd:ef"
    /// macAddress.toHex(0);   // returns "123456abcdef"
    /// ```
    /// 
    /// **See also:** fromHex()
    to_hex() -> ByteArray,
    /// 
    /// Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and
    /// the letters a-f.
    /// 
    /// **See also:** fromHex()
    /// **Overloads**
    /// Returns a hex encoded copy of the byte array. The hex encoding uses the numbers 0-9 and
    /// the letters a-f.
    /// 
    /// If *separator* is not '\0', the separator character is inserted between the hex bytes.
    /// 
    /// Example:
    /// ```
    /// QByteArray macAddress = QByteArray::fromHex("123456abcdef");
    /// macAddress.toHex(':'); // returns "12:34:56:ab:cd:ef"
    /// macAddress.toHex(0);   // returns "123456abcdef"
    /// ```
    /// 
    /// **See also:** fromHex()
    to_hex_2(separator: char) -> ByteArray,
    /// 
    /// Returns a URI/URL-style percent-encoded copy of this byte array. The
    /// *percent* parameter allows you to override the default '%'
    /// character for another.
    /// 
    /// By default, this function will encode all characters that are not
    /// one of the following:
    /// 
    /// ALPHA ("a" to and to ) / DIGIT (0 to 9) / / / /
    /// 
    /// To prevent characters from being encoded pass them to *exclude.* To force characters to be encoded pass them to *include.* The *percent* character is always encoded.
    /// 
    /// Example:
    /// 
    /// ```
    /// QByteArray text = "{a fishy string?}";
    /// QByteArray ba = text.toPercentEncoding("{}", "s");
    /// qDebug(ba.constData());
    /// // prints "{a fi%73hy %73tring%3F}"
    /// ```
    /// 
    /// The hex encoding uses the numbers 0-9 and the uppercase letters A-F.
    /// 
    /// **See also:** fromPercentEncoding()
    /// QUrl::toPercentEncoding()
    to_percent_encoding(exclude: &ByteArrayType, include: &ByteArrayType, percent: char) -> ByteArray,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num(arg0: short, base: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_2(arg0: ushort, base: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_3(arg0: i32, base: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_4(arg0: uint, base: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_5(arg0: i64, base: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_6(arg0: qulonglong, base: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_7(arg0: f32, f: char, prec: i32) -> ByteArray?,
    /// 
    /// Sets the byte array to the printed value of *n* in base *base* (10
    /// by default) and returns a reference to the byte array. The *base* can
    /// be any value between 2 and 36. For bases other than 10, n is treated
    /// as an unsigned integer.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** number()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toShort()
    /// 
    /// **Overloads**
    /// **See also:** toUShort()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// The format *f* can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    /// 
    /// **Overloads**
    /// Sets the byte array to the printed value of *n,* formatted in format
    /// *f* with precision *prec,* and returns a reference to the
    /// byte array.
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toFloat()
    set_num_8(arg0: double, f: char, prec: i32) -> ByteArray?,
    /// 
    /// Resets the QByteArray to use the first *size* bytes of the
    /// *data* array. The bytes are *not* copied. The QByteArray will
    /// contain the *data* pointer. The caller guarantees that *data*
    /// will not be deleted or modified as long as this QByteArray and any
    /// copies of it exist that have not been modified.
    /// 
    /// This function can be used instead of fromRawData() to re-use
    /// existing QByteArray objects to save memory re-allocations.
    /// 
    /// **See also:** fromRawData()
    /// data()
    /// constData()
    set_raw_data(a: *char, n: uint) -> ByteArray?,
    /// 
    /// Returns a byte array containing the string equivalent of the
    /// number *n* to base *base* (10 by default). The *base* can be
    /// any value between 2 and 36.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** setNum()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Returns a byte array that contains the printed value of *n,*
    /// formatted in format *f* with precision *prec.*
    /// 
    /// Argument *n* is formatted according to the *f* format specified,
    /// which is `g` by default, and can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    [static] number(arg0: i32, base: i32) -> ByteArray,
    /// 
    /// Returns a byte array containing the string equivalent of the
    /// number *n* to base *base* (10 by default). The *base* can be
    /// any value between 2 and 36.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** setNum()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Returns a byte array that contains the printed value of *n,*
    /// formatted in format *f* with precision *prec.*
    /// 
    /// Argument *n* is formatted according to the *f* format specified,
    /// which is `g` by default, and can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    [static] number_2(arg0: uint, base: i32) -> ByteArray,
    /// 
    /// Returns a byte array containing the string equivalent of the
    /// number *n* to base *base* (10 by default). The *base* can be
    /// any value between 2 and 36.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** setNum()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Returns a byte array that contains the printed value of *n,*
    /// formatted in format *f* with precision *prec.*
    /// 
    /// Argument *n* is formatted according to the *f* format specified,
    /// which is `g` by default, and can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    [static] number_3(arg0: i64, base: i32) -> ByteArray,
    /// 
    /// Returns a byte array containing the string equivalent of the
    /// number *n* to base *base* (10 by default). The *base* can be
    /// any value between 2 and 36.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** setNum()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Returns a byte array that contains the printed value of *n,*
    /// formatted in format *f* with precision *prec.*
    /// 
    /// Argument *n* is formatted according to the *f* format specified,
    /// which is `g` by default, and can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    [static] number_4(arg0: qulonglong, base: i32) -> ByteArray,
    /// 
    /// Returns a byte array containing the string equivalent of the
    /// number *n* to base *base* (10 by default). The *base* can be
    /// any value between 2 and 36.
    /// 
    /// Example:
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** setNum()
    /// toInt()
    /// 
    /// **Overloads**
    /// **See also:** toUInt()
    /// 
    /// **Overloads**
    /// **See also:** toLongLong()
    /// 
    /// **Overloads**
    /// **See also:** toULongLong()
    /// 
    /// **Overloads**
    /// Returns a byte array that contains the printed value of *n,*
    /// formatted in format *f* with precision *prec.*
    /// 
    /// Argument *n* is formatted according to the *f* format specified,
    /// which is `g` by default, and can be any of the following:
    /// 
    /// * Format
    /// * Meaning
    /// * `e`
    /// * format as [-]9.9e[+|-]999
    /// * `E`
    /// * format as [-]9.9E[+|-]999
    /// * `f`
    /// * format as [-]9.9
    /// * `g`
    /// * use `e` or `f` format, whichever is the most concise
    /// * `G`
    /// * use `E` or `f` format, whichever is the most concise
    /// 
    /// With 'e', 'E', and 'f', *prec* is the number of digits after the
    /// decimal point. With 'g' and 'G', *prec* is the maximum number of
    /// significant digits (trailing zeroes are omitted).
    /// 
    /// **Note**: The format of the number is not localized; the default C locale
    /// is used irrespective of the user's locale.
    /// 
    /// **See also:** toDouble()
    [static] number_5(arg0: double, f: char, prec: i32) -> ByteArray,
    /// 
    /// Constructs a QByteArray that uses the first *size* bytes of the
    /// *data* array. The bytes are *not* copied. The QByteArray will
    /// contain the *data* pointer. The caller guarantees that *data*
    /// will not be deleted or modified as long as this QByteArray and any
    /// copies of it exist that have not been modified. In other words,
    /// because QByteArray is an [implicitly shared](implicitly%20shared)
    /// class and the
    /// instance returned by this function contains the *data* pointer,
    /// the caller must not delete *data* or modify it directly as long
    /// as the returned QByteArray and any copies exist. However,
    /// QByteArray does not take ownership of *data,* so the QByteArray
    /// destructor will never delete the raw *data,* even when the
    /// last QByteArray referring to *data* is destroyed.
    /// 
    /// A subsequent attempt to modify the contents of the returned
    /// QByteArray or any copy made from it will cause it to create a deep
    /// copy of the *data* array before doing the modification. This
    /// ensures that the raw *data* array itself will never be modified
    /// by QByteArray.
    /// 
    /// Here is an example of how to read data using a QDataStream on raw
    /// data in memory without copying the raw data into a QByteArray:
    /// 
    /// **Warning**: A byte array created with fromRawData() is *not*
    /// null-terminated, unless the raw data contains a 0 character at
    /// position *size.* While that does not matter for QDataStream or
    /// functions like indexOf(), passing the byte array to a function
    /// accepting a `const char *` expected to be '\\0'-terminated will
    /// fail.
    /// 
    /// **See also:** setRawData()
    /// data()
    /// constData()
    [static] from_raw_data(arg0: *char, size: i32) -> ByteArray,
    /// 
    /// Returns a decoded copy of the Base64 array *base64.* Input is not checked
    /// for validity; invalid characters in the input are skipped, enabling the
    /// decoding process to continue with subsequent characters.
    /// 
    /// For example:
    /// 
    /// The algorithm used to decode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** toBase64()
    /// 
    /// **Overloads**
    /// Returns a decoded copy of the Base64 array *base64,* using the alphabet
    /// defined by *options.* Input is not checked for validity; invalid
    /// characters in the input are skipped, enabling the decoding process to
    /// continue with subsequent characters.
    /// 
    /// For example:
    /// 
    /// The algorithm used to decode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** toBase64()
    [static] from_base64(base64: &ByteArrayType, options: ByteArray::Base64Options) -> ByteArray,
    /// 
    /// Returns a decoded copy of the Base64 array *base64.* Input is not checked
    /// for validity; invalid characters in the input are skipped, enabling the
    /// decoding process to continue with subsequent characters.
    /// 
    /// For example:
    /// 
    /// The algorithm used to decode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** toBase64()
    /// 
    /// **Overloads**
    /// Returns a decoded copy of the Base64 array *base64,* using the alphabet
    /// defined by *options.* Input is not checked for validity; invalid
    /// characters in the input are skipped, enabling the decoding process to
    /// continue with subsequent characters.
    /// 
    /// For example:
    /// 
    /// The algorithm used to decode Base64-encoded data is defined in [RFC 4648](RFC%204648)
    /// 
    /// 
    /// **See also:** toBase64()
    [static] from_base64_2(base64: &ByteArrayType) -> ByteArray,
    /// 
    /// Returns a decoded copy of the hex encoded array *hexEncoded.* Input is not checked
    /// for validity; invalid characters in the input are skipped, enabling the
    /// decoding process to continue with subsequent characters.
    /// 
    /// For example:
    /// 
    /// **See also:** toHex()
    [static] from_hex(hex_encoded: &ByteArrayType) -> ByteArray,
    /// 
    /// Returns a decoded copy of the URI/URL-style percent-encoded *input.*
    /// The *percent* parameter allows you to replace the '%' character for
    /// another (for instance, '_' or '=').
    /// 
    /// For example:
    /// ```
    /// QByteArray text = QByteArray::fromPercentEncoding("Qt%20is%20great%33");
    /// text.data();            // returns "Qt is great!"
    /// ```
    /// 
    /// **Note**: Given invalid input (such as a string containing the sequence ,
    /// which is not a valid hexadecimal number) the output will be invalid as
    /// well. As an example: the sequence could be decoded to 'W'.
    /// 
    /// **See also:** toPercentEncoding()
    /// QUrl::fromPercentEncoding()
    [static] from_percent_encoding(pct_encoded: &ByteArrayType, percent: char) -> ByteArray,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character in
    /// the byte-array.
    /// 
    /// **See also:** constBegin()
    /// end()
    /// 
    /// **Overloads** begin()
    begin() -> ByteArray::iterator,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character in
    /// the byte-array.
    /// 
    /// **See also:** constBegin()
    /// end()
    /// 
    /// **Overloads** begin()
    begin_2() -> ByteArray::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character
    /// in the byte-array.
    /// 
    /// **See also:** begin()
    /// cend()
    cbegin() -> ByteArray::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character
    /// in the byte-array.
    /// 
    /// **See also:** begin()
    /// constEnd()
    const_begin() -> ByteArray::const_iterator,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary character
    /// after the last character in the byte-array.
    /// 
    /// **See also:** begin()
    /// constEnd()
    /// 
    /// **Overloads** end()
    /// 
    /// Returns `true` if this byte array ends with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** startsWith()
    /// right()
    /// **Overloads**
    /// Returns `true` if this byte array ends with string *str;* otherwise
    /// returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array ends with character *ch;*
    /// otherwise returns `false.`
    end() -> ByteArray::iterator,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary character
    /// after the last character in the byte-array.
    /// 
    /// **See also:** begin()
    /// constEnd()
    /// 
    /// **Overloads** end()
    /// 
    /// Returns `true` if this byte array ends with byte array *ba;*
    /// otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** startsWith()
    /// right()
    /// **Overloads**
    /// Returns `true` if this byte array ends with string *str;* otherwise
    /// returns `false.`
    /// **Overloads**
    /// Returns `true` if this byte array ends with character *ch;*
    /// otherwise returns `false.`
    end_2() -> ByteArray::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary
    /// character after the last character in the list.
    /// 
    /// **See also:** cbegin()
    /// end()
    cend() -> ByteArray::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary
    /// character after the last character in the list.
    /// 
    /// **See also:** constBegin()
    /// end()
    const_end() -> ByteArray::const_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to the first
    /// character in the byte-array, in reverse order.
    /// 
    /// **See also:** begin()
    /// crbegin()
    /// rend()
    /// **Overloads**
    rbegin() -> ByteArray::reverse_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to one past
    /// the last character in the byte-array, in reverse order.
    /// 
    /// **See also:** end()
    /// crend()
    /// rbegin()
    /// **Overloads**
    rend() -> ByteArray::reverse_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to the first
    /// character in the byte-array, in reverse order.
    /// 
    /// **See also:** begin()
    /// crbegin()
    /// rend()
    /// **Overloads**
    rbegin_2() -> ByteArray::const_reverse_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to one past
    /// the last character in the byte-array, in reverse order.
    /// 
    /// **See also:** end()
    /// crend()
    /// rbegin()
    /// **Overloads**
    rend_2() -> ByteArray::const_reverse_iterator,
    /// 
    /// Returns a const [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to the first
    /// character in the byte-array, in reverse order.
    /// 
    /// **See also:** begin()
    /// rbegin()
    /// rend()
    crbegin() -> ByteArray::const_reverse_iterator,
    /// 
    /// Returns a const [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to one
    /// past the last character in the byte-array, in reverse order.
    /// 
    /// **See also:** end()
    /// rend()
    /// rbegin()
    crend() -> ByteArray::const_reverse_iterator,
    /// 
    /// This function is provided for STL compatibility. It is equivalent
    /// to append( *other).*
    /// 
    /// **Overloads**
    /// Same as append( *str).*
    /// 
    /// **Overloads**
    /// Same as append( *ch).*
    push_back(c: char),
    /// 
    /// This function is provided for STL compatibility. It is equivalent
    /// to append( *other).*
    /// 
    /// **Overloads**
    /// Same as append( *str).*
    /// 
    /// **Overloads**
    /// Same as append( *ch).*
    push_back_2(c: *char),
    /// 
    /// This function is provided for STL compatibility. It is equivalent
    /// to append( *other).*
    /// 
    /// **Overloads**
    /// Same as append( *str).*
    /// 
    /// **Overloads**
    /// Same as append( *ch).*
    push_back_3(a: &ByteArrayType),
    /// 
    /// This function is provided for STL compatibility. It is equivalent
    /// to prepend( *other).*
    /// 
    /// **Overloads**
    /// Same as prepend( *str).*
    /// 
    /// **Overloads**
    /// Same as prepend( *ch).*
    push_front(c: char),
    /// 
    /// This function is provided for STL compatibility. It is equivalent
    /// to prepend( *other).*
    /// 
    /// **Overloads**
    /// Same as prepend( *str).*
    /// 
    /// **Overloads**
    /// Same as prepend( *ch).*
    push_front_2(c: *char),
    /// 
    /// This function is provided for STL compatibility. It is equivalent
    /// to prepend( *other).*
    /// 
    /// **Overloads**
    /// Same as prepend( *str).*
    /// 
    /// **Overloads**
    /// Same as prepend( *ch).*
    push_front_3(a: &ByteArrayType),
    /// 
    /// This function is provided for STL compatibility. It is equivalent to
    /// squeeze().
    shrink_to_fit(),
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// byte array *ba* in this byte array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Returns the number of (potentially overlapping) occurrences of
    /// string *str* in the byte array.
    /// 
    /// **Overloads**
    /// Returns the number of occurrences of character *ch* in the byte
    /// array.
    /// 
    /// **See also:** contains()
    /// indexOf()
    /// 
    /// **Overloads**
    /// Same as size().
    count_4() -> i32,
    /// 
    /// Same as size().
    length() -> i32,
    /// 
    /// Returns `true` if this byte array is null; otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// Qt makes a distinction between null byte arrays and empty byte
    /// arrays for historical reasons. For most applications, what
    /// matters is whether or not a byte array contains any data,
    /// and this can be determined using isEmpty().
    /// 
    /// **See also:** isEmpty()
    is_null() -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
