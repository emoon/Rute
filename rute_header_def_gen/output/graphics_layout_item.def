///     \class QGraphicsLayoutItem
///     \brief The QGraphicsLayoutItem class can be inherited to allow your custom
///     items to be managed by layouts.
///     \since 4.4
///     \ingroup graphicsview-api
///     \inmodule QtWidgets
/// 
///     QGraphicsLayoutItem is an abstract class that defines a set of virtual
///     functions describing sizes, size policies, and size hints for any object
///     arranged by QGraphicsLayout. The API contains functions relevant
///     for both the item itself and for the user of the item as most of
///     QGraphicsLayoutItem's functions are also part of the subclass' public API.
/// 
///     In most cases, existing layout-aware classes such as QGraphicsWidget and
///     QGraphicsLayout already provide the functionality you require. However,
///     subclassing these classes will enable you to create both graphical
///     elements that work well with layouts (QGraphicsWidget) or custom layouts
///     (QGraphicsLayout).
/// 
///     \section1 Subclassing QGraphicsLayoutItem
/// 
///     If you create a subclass of QGraphicsLayoutItem and reimplement its
///     virtual functions, you will enable the layout to resize and position your
///     item along with other QGraphicsLayoutItems including QGraphicsWidget
///     and QGraphicsLayout.
/// 
///     You can start by reimplementing important functions: the protected
///     sizeHint() function, as well as the public setGeometry()
///     function. If you want your items to be aware of immediate geometry
///     changes, you can also reimplement updateGeometry().
/// 
///     The geometry, size hint, and size policy affect the item's size and
///     position. Calling setGeometry() will always resize and reposition the item
///     immediately. Normally, this function is called by QGraphicsLayout after
///     the layout has been activated, but it can also be called by the item's user
///     at any time.
/// 
///     The sizeHint() function returns the item' minimum, preferred and maximum
///     size hints. You can override these properties by calling setMinimumSize(),
///     setPreferredSize() or setMaximumSize(). You can also use functions such as
///     setMinimumWidth() or setMaximumHeight() to set only the width or height
///     component if desired.
/// 
///     The effectiveSizeHint() function, on the other hand, returns a size hint
///     for any given Qt::SizeHint, and guarantees that the returned size is bound
///     to the minimum and maximum sizes and size hints. You can set the item's
///     vertical and horizontal size policy by calling setSizePolicy(). The
///     sizePolicy property is used by the layout system to describe how this item
///     prefers to grow or shrink.
/// 
///     \section1 Nesting QGraphicsLayoutItems
/// 
///     QGraphicsLayoutItems can be nested within other QGraphicsLayoutItems,
///     similar to layouts that can contain sublayouts. This is done either by
///     passing a QGraphicsLayoutItem pointer to QGraphicsLayoutItem's
///     protected constructor, or by calling setParentLayoutItem(). The
///     parentLayoutItem() function returns a pointer to the item's layoutItem
///     parent. If the item's parent is 0 or if the parent does not inherit
///     from QGraphicsItem, the parentLayoutItem() function then returns 0.
///     isLayout() returns \c true if the QGraphicsLayoutItem subclass is itself a
///     layout, or false otherwise.
/// 
///     Qt uses QGraphicsLayoutItem to provide layout functionality in the
///     \l{Graphics View Framework}, but in the future its use may spread
///     throughout Qt itself.
/// 
///     \sa QGraphicsWidget, QGraphicsLayout, QGraphicsLinearLayout,
///     QGraphicsGridLayout
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.

struct GraphicsLayoutItem {
    ///     Sets the size policy to \a policy. The size policy describes how the item
    ///     should grow horizontally and vertically when arranged in a layout.
    /// 
    ///     QGraphicsLayoutItem's default size policy is (QSizePolicy::Fixed,
    ///     QSizePolicy::Fixed, QSizePolicy::DefaultType), but it is common for
    ///     subclasses to change the default. For example, QGraphicsWidget defaults
    ///     to (QSizePolicy::Preferred, QSizePolicy::Preferred,
    ///     QSizePolicy::DefaultType).
    /// 
    ///     \sa sizePolicy(), QWidget::sizePolicy()
    set_size_policy(policy: &SizePolicyType),
    ///     Sets the size policy to \a policy. The size policy describes how the item
    ///     should grow horizontally and vertically when arranged in a layout.
    /// 
    ///     QGraphicsLayoutItem's default size policy is (QSizePolicy::Fixed,
    ///     QSizePolicy::Fixed, QSizePolicy::DefaultType), but it is common for
    ///     subclasses to change the default. For example, QGraphicsWidget defaults
    ///     to (QSizePolicy::Preferred, QSizePolicy::Preferred,
    ///     QSizePolicy::DefaultType).
    /// 
    ///     \sa sizePolicy(), QWidget::sizePolicy()
    set_size_policy(h_policy: SizePolicy::Policy, v_policy: SizePolicy::Policy, control_type: SizePolicy::ControlType),
    ///     Returns the current size policy.
    /// 
    ///     \sa setSizePolicy(), QWidget::sizePolicy()
    size_policy() -> SizePolicy,
    ///     Sets the minimum size to \a size. This property overrides sizeHint() for
    ///     Qt::MinimumSize and ensures that effectiveSizeHint() will never return
    ///     a size smaller than \a size. In order to unset the minimum size, use an
    ///     invalid size.
    /// 
    ///     \sa minimumSize(), maximumSize(), preferredSize(), Qt::MinimumSize,
    ///     sizeHint(), setMinimumWidth(), setMinimumHeight()
    set_minimum_size(size: &SizeFType),
    ///     Sets the minimum size to \a size. This property overrides sizeHint() for
    ///     Qt::MinimumSize and ensures that effectiveSizeHint() will never return
    ///     a size smaller than \a size. In order to unset the minimum size, use an
    ///     invalid size.
    /// 
    ///     \sa minimumSize(), maximumSize(), preferredSize(), Qt::MinimumSize,
    ///     sizeHint(), setMinimumWidth(), setMinimumHeight()
    set_minimum_size(w: f32, h: f32),
    ///     Returns the minimum size.
    /// 
    ///     \sa setMinimumSize(), preferredSize(), maximumSize(), Qt::MinimumSize,
    ///     sizeHint()
    minimum_size() -> SizeF,
    ///     Sets the minimum width to \a width.
    /// 
    ///     \sa minimumWidth(), setMinimumSize(), minimumSize()
    set_minimum_width(width: f32),
    minimum_width() -> f32,
    ///     Sets the minimum height to \a height.
    /// 
    ///     \sa minimumHeight(), setMinimumSize(), minimumSize()
    set_minimum_height(height: f32),
    minimum_height() -> f32,
    ///     Sets the preferred size to \a size. This property overrides sizeHint() for
    ///     Qt::PreferredSize and provides the default value for effectiveSizeHint().
    ///     In order to unset the preferred size, use an invalid size.
    /// 
    ///     \sa preferredSize(), minimumSize(), maximumSize(), Qt::PreferredSize,
    ///     sizeHint()
    set_preferred_size(size: &SizeFType),
    ///     Sets the preferred size to \a size. This property overrides sizeHint() for
    ///     Qt::PreferredSize and provides the default value for effectiveSizeHint().
    ///     In order to unset the preferred size, use an invalid size.
    /// 
    ///     \sa preferredSize(), minimumSize(), maximumSize(), Qt::PreferredSize,
    ///     sizeHint()
    set_preferred_size(w: f32, h: f32),
    ///     Returns the preferred size.
    /// 
    ///     \sa setPreferredSize(), minimumSize(), maximumSize(), Qt::PreferredSize,
    ///     sizeHint()
    preferred_size() -> SizeF,
    ///     Sets the preferred width to \a width.
    /// 
    ///     \sa preferredHeight(), setPreferredSize(), preferredSize()
    set_preferred_width(width: f32),
    preferred_width() -> f32,
    ///     Sets the preferred height to \a height.
    /// 
    ///     \sa preferredWidth(), setPreferredSize(), preferredSize()
    set_preferred_height(height: f32),
    preferred_height() -> f32,
    ///     Sets the maximum size to \a size. This property overrides sizeHint() for
    ///     Qt::MaximumSize and ensures that effectiveSizeHint() will never return a
    ///     size larger than \a size. In order to unset the maximum size, use an
    ///     invalid size.
    /// 
    ///     \sa maximumSize(), minimumSize(), preferredSize(), Qt::MaximumSize,
    ///     sizeHint()
    set_maximum_size(size: &SizeFType),
    ///     Sets the maximum size to \a size. This property overrides sizeHint() for
    ///     Qt::MaximumSize and ensures that effectiveSizeHint() will never return a
    ///     size larger than \a size. In order to unset the maximum size, use an
    ///     invalid size.
    /// 
    ///     \sa maximumSize(), minimumSize(), preferredSize(), Qt::MaximumSize,
    ///     sizeHint()
    set_maximum_size(w: f32, h: f32),
    ///     Returns the maximum size.
    /// 
    ///     \sa setMaximumSize(), minimumSize(), preferredSize(), Qt::MaximumSize,
    ///     sizeHint()
    maximum_size() -> SizeF,
    ///     Sets the maximum width to \a width.
    /// 
    ///     \sa maximumWidth(), setMaximumSize(), maximumSize()
    set_maximum_width(width: f32),
    maximum_width() -> f32,
    ///     Sets the maximum height to \a height.
    /// 
    ///     \sa maximumHeight(), setMaximumSize(), maximumSize()
    set_maximum_height(height: f32),
    maximum_height() -> f32,
    ///     This virtual function provides the \a left, \a top, \a right and \a bottom
    ///     contents margins for this QGraphicsLayoutItem. The default implementation
    ///     assumes all contents margins are 0. The parameters point to values stored
    ///     in qreals. If any of the pointers is 0, that value will not be updated.
    /// 
    ///     \sa QGraphicsWidget::setContentsMargins()
    [event] get_contents_margins(left: *f32, top: *f32, right: *f32, bottom: *f32),
    ///     Returns the contents rect in local coordinates.
    /// 
    ///     The contents rect defines the subrectangle used by an associated layout
    ///     when arranging subitems. This function is a convenience function that
    ///     adjusts the item's geometry() by its contents margins. Note that
    ///     getContentsMargins() is a virtual function that you can reimplement to
    ///     return the item's contents margins.
    /// 
    ///     \sa getContentsMargins(), geometry()
    contents_rect() -> RectF,
    ///     Returns the effective size hint for this QGraphicsLayoutItem.
    /// 
    ///     \a which is the size hint in question.
    ///     \a constraint is an optional argument that defines a special constrain
    ///     when calculating the effective size hint. By default, \a constraint is
    ///     QSizeF(-1, -1), which means there is no constraint to the size hint.
    /// 
    ///     If you want to specify the widget's size hint for a given width or height,
    ///     you can provide the fixed dimension in \a constraint. This is useful for
    ///     widgets that can grow only either vertically or horizontally, and need to
    ///     set either their width or their height to a special value.
    /// 
    ///     For example, a text paragraph item fit into a column width of 200 may
    ///     grow vertically. You can pass QSizeF(200, -1) as a constraint to get a
    ///     suitable minimum, preferred and maximum height).
    /// 
    ///     You can adjust the effective size hint by reimplementing sizeHint()
    ///     in a QGraphicsLayoutItem subclass, or by calling one of the following
    ///     functions: setMinimumSize(), setPreferredSize, or setMaximumSize()
    ///     (or a combination of both).
    /// 
    ///     This function caches each of the size hints and guarantees that
    ///     sizeHint() will be called only once for each value of \a which - unless
    ///     \a constraint is not specified and updateGeometry() has been called.
    /// 
    ///     \sa sizeHint()
    effective_size_hint(which: Rute::SizeHint, constraint: &SizeFType) -> SizeF,
    ///     Returns the parent of this QGraphicsLayoutItem, or 0 if there is no parent,
    ///     or if the parent does not inherit from QGraphicsLayoutItem
    ///     (QGraphicsLayoutItem is often used through multiple inheritance with
    ///     QObject-derived classes).
    /// 
    ///     \sa setParentLayoutItem()
    parent_layout_item() -> GraphicsLayoutItem?,
    ///     Sets the parent of this QGraphicsLayoutItem to \a parent.
    /// 
    ///     \sa parentLayoutItem()
    set_parent_layout_item(parent: *GraphicsLayoutItemType),
    ///     Returns \c true if this QGraphicsLayoutItem is a layout (e.g., is inherited
    ///     by an object that arranges other QGraphicsLayoutItem objects); otherwise
    ///     returns \c false.
    /// 
    ///     \sa QGraphicsLayout
    is_layout() -> bool,
    graphics_item() -> GraphicsItem?,
    ///     \since 4.6
    /// 
    ///     Returns whether a layout should delete this item in its destructor.
    ///     If its true, then the layout will delete it. If its false, then it is
    ///     assumed that another object has the ownership of it, and the layout won't
    ///     delete this item.
    /// 
    ///     If the item inherits both QGraphicsItem and QGraphicsLayoutItem (such
    ///     as QGraphicsWidget does) the item is really part of two ownership
    ///     hierarchies. This property informs what the layout should do with its
    ///     child items when it is destructed. In the case of QGraphicsWidget, it
    ///     is preferred that when the layout is deleted it won't delete its children
    ///     (since they are also part of the graphics item hierarchy).
    /// 
    ///     By default this value is initialized to false in QGraphicsLayoutItem,
    ///     but it is overridden by QGraphicsLayout to return true. This is because
    ///     QGraphicsLayout is not normally part of the QGraphicsItem hierarchy, so the
    ///     parent layout should delete it.
    ///     Subclasses might override this default behaviour by calling
    ///     setOwnedByLayout(true).
    /// 
    ///     \sa setOwnedByLayout()
    owned_by_layout() -> bool,
    set_graphics_item(item: *GraphicsItemType),
    ///     \since 4.6
    /// 
    ///     Sets whether a layout should delete this item in its destructor or not.
    ///     \a ownership must be true to in order for the layout to delete it.
    ///     \sa ownedByLayout()
    set_owned_by_layout(owned_by_layout: bool),
    [event] size_hint(which: Rute::SizeHint, constraint: &SizeFType) -> SizeF,
}

// vim: syntax=rust expandtab ts=4 sw=4
