///     \class QLayout
///     \brief The QLayout class is the base class of geometry managers.
/// 
///     \ingroup geomanagement
///     \inmodule QtWidgets
/// 
///     This is an abstract base class inherited by the concrete classes
///     QBoxLayout, QGridLayout, QFormLayout, and QStackedLayout.
/// 
///     For users of QLayout subclasses or of QMainWindow there is seldom
///     any need to use the basic functions provided by QLayout, such as
///     setSizeConstraint() or setMenuBar(). See \l{Layout Management}
///     for more information.
/// 
///     To make your own layout manager, implement the functions
///     addItem(), sizeHint(), setGeometry(), itemAt() and takeAt(). You
///     should also implement minimumSize() to ensure your layout isn't
///     resized to zero size if there is too little space. To support
///     children whose heights depend on their widths, implement
///     hasHeightForWidth() and heightForWidth(). See the
///     \l{layouts/borderlayout}{Border Layout} and
///     \l{layouts/flowlayout}{Flow Layout} examples for
///     more information about implementing custom layout managers.
/// 
///     Geometry management stops when the layout manager is deleted.
/// 
///     \sa QLayoutItem, {Layout Management}, {Basic Layouts Example},
///         {Border Layout Example}, {Flow Layout Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QLayout)]
enum SizeConstraint {
    SetDefaultConstraint,
    SetNoConstraint,
    SetMinimumSize,
    SetFixedSize,
    SetMaximumSize,
    SetMinAndMaxSize,
}

struct Layout : Object, LayoutItem {
    ///     \obsolete
    margin() -> i32,
    ///     \property QLayout::spacing
    ///     \brief the spacing between widgets inside the layout
    /// 
    ///     If no value is explicitly set, the layout's spacing is inherited
    ///     from the parent layout, or from the style settings for the parent
    ///     widget.
    /// 
    ///     For QGridLayout and QFormLayout, it is possible to set different horizontal and
    ///     vertical spacings using \l{QGridLayout::}{setHorizontalSpacing()}
    ///     and \l{QGridLayout::}{setVerticalSpacing()}. In that case,
    ///     spacing() returns -1.
    /// 
    ///     \sa contentsRect(), getContentsMargins(), QStyle::layoutSpacing(),
    ///         QStyle::pixelMetric()
    spacing() -> i32,
    ///     \obsolete
    set_margin(arg0: i32),
    set_spacing(arg0: i32),
    ///     \since 4.6
    /// 
    ///     Sets the \a margins to use around the layout.
    /// 
    ///     By default, QLayout uses the values provided by the style. On
    ///     most platforms, the margin is 11 pixels in all directions.
    /// 
    ///     \sa contentsMargins()
    set_contents_margins(left: i32, top: i32, right: i32, bottom: i32),
    ///     \since 4.6
    /// 
    ///     Sets the \a margins to use around the layout.
    /// 
    ///     By default, QLayout uses the values provided by the style. On
    ///     most platforms, the margin is 11 pixels in all directions.
    /// 
    ///     \sa contentsMargins()
    set_contents_margins(margins: &MarginsType),
    ///     \since 4.3
    /// 
    ///     Extracts the left, top, right, and bottom margins used around the
    ///     layout, and assigns them to *\a left, *\a top, *\a right, and *\a
    ///     bottom (unless they are null pointers).
    /// 
    ///     By default, QLayout uses the values provided by the style. On
    ///     most platforms, the margin is 11 pixels in all directions.
    /// 
    ///     \sa setContentsMargins(), QStyle::pixelMetric(),
    ///         {QStyle::}{PM_LayoutLeftMargin},
    ///         {QStyle::}{PM_LayoutTopMargin},
    ///         {QStyle::}{PM_LayoutRightMargin},
    ///         {QStyle::}{PM_LayoutBottomMargin}
    get_contents_margins(left: *i32, top: *i32, right: *i32, bottom: *i32),
    ///     \since 4.6
    /// 
    ///     Returns the margins used around the layout.
    /// 
    ///     By default, QLayout uses the values provided by the style. On
    ///     most platforms, the margin is 11 pixels in all directions.
    /// 
    ///     \sa setContentsMargins()
    contents_margins() -> Margins,
    ///     \since 4.3
    /// 
    ///     Returns the layout's geometry() rectangle, but taking into account the
    ///     contents margins.
    /// 
    ///     \sa setContentsMargins(), getContentsMargins()
    contents_rect() -> Rect,
    ///   \overload
    /// 
    ///   Sets the alignment for the layout \a l to \a alignment and
    ///   returns \c true if \a l is found in this layout (not including child
    ///   layouts); otherwise returns \c false.
    set_alignment(w: *WidgetType, alignment: Rute::Alignment) -> bool,
    ///   \overload
    /// 
    ///   Sets the alignment for the layout \a l to \a alignment and
    ///   returns \c true if \a l is found in this layout (not including child
    ///   layouts); otherwise returns \c false.
    set_alignment(l: *LayoutType, alignment: Rute::Alignment) -> bool,
    ///     Tells the geometry manager to place the menu bar \a widget at the
    ///     top of parentWidget(), outside QWidget::contentsMargins(). All
    ///     child widgets are placed below the bottom edge of the menu bar.
    set_menu_bar(w: *WidgetType),
    ///     Returns the menu bar set for this layout, or 0 if no menu bar is
    ///     set.
    menu_bar() -> Widget?,
    ///     Returns the parent widget of this layout, or 0 if this layout is
    ///     not installed on any widget.
    /// 
    ///     If the layout is a sub-layout, this function returns the parent
    ///     widget of the parent layout.
    /// 
    ///     \sa parent()
    parent_widget() -> Widget?,
    ///     \reimp
    [event] invalidate(),
    ///     Redoes the layout for parentWidget() if necessary.
    /// 
    ///     You should generally not need to call this because it is
    ///     automatically called at the most appropriate times. It returns
    ///     true if the layout was redone.
    /// 
    ///     \sa update(), QWidget::updateGeometry()
    activate() -> bool,
    ///   Updates the layout for parentWidget().
    /// 
    ///   You should generally not need to call this because it is
    ///   automatically called at the most appropriate times.
    /// 
    ///   \sa activate(), invalidate()
    update(),
    ///     Adds widget \a w to this layout in a manner specific to the
    ///     layout. This function uses addItem().
    add_widget(w: *WidgetType),
    [event] add_item(arg0: *LayoutItemType),
    ///     Removes the widget \a widget from the layout. After this call, it
    ///     is the caller's responsibility to give the widget a reasonable
    ///     geometry or to put the widget back into a layout or to explicitly
    ///     hide it if necessary.
    /// 
    ///     \b{Note:} The ownership of \a widget remains the same as
    ///     when it was added.
    /// 
    ///     \sa removeItem(), QWidget::setGeometry(), addWidget()
    remove_widget(w: *WidgetType),
    ///     Removes the layout item \a item from the layout. It is the
    ///     caller's responsibility to delete the item.
    /// 
    ///     Notice that \a item can be a layout (since QLayout inherits
    ///     QLayoutItem).
    /// 
    ///     \sa removeWidget(), addItem()
    remove_item(arg0: *LayoutItemType),
    ///     Returns whether this layout can make use of more space than
    ///     sizeHint(). A value of Qt::Vertical or Qt::Horizontal means that
    ///     it wants to grow in only one dimension, whereas Qt::Vertical |
    ///     Qt::Horizontal means that it wants to grow in both dimensions.
    /// 
    ///     The default implementation returns Qt::Horizontal | Qt::Vertical.
    ///     Subclasses reimplement it to return a meaningful value based on
    ///     their child widgets's \l{QSizePolicy}{size policies}.
    /// 
    ///     \sa sizeHint()
    [event] expanding_directions() -> Rute::Orientations,
    ///     Returns the minimum size of this layout. This is the smallest
    ///     size that the layout can have while still respecting the
    ///     specifications.
    /// 
    ///     The returned value doesn't include the space required by
    ///     QWidget::setContentsMargins() or menuBar().
    /// 
    ///     The default implementation allows unlimited resizing.
    [event] minimum_size() -> Size,
    ///     Returns the maximum size of this layout. This is the largest size
    ///     that the layout can have while still respecting the
    ///     specifications.
    /// 
    ///     The returned value doesn't include the space required by
    ///     QWidget::setContentsMargins() or menuBar().
    /// 
    ///     The default implementation allows unlimited resizing.
    [event] maximum_size() -> Size,
    [event] item_at(index: i32) -> LayoutItem?,
    [event] take_at(index: i32) -> LayoutItem?,
    ///     Searches for widget \a widget in this layout (not including child
    ///     layouts).
    /// 
    ///     Returns the index of \a widget, or -1 if \a widget is not found.
    /// 
    ///     The default implementation iterates over all items using itemAt()
    [event] index_of(arg0: *WidgetType) -> i32,
    [event] count() -> i32,
    ///     \reimp
    [event] is_empty() -> bool,
    ///     \since 5.2
    /// 
    ///     Searches for widget \a from and replaces it with widget \a to if found.
    ///     Returns the layout item that contains the widget \a from on success.
    ///     Otherwise \c 0 is returned. If \a options contains \c Qt::FindChildrenRecursively
    ///     (the default), sub-layouts are searched for doing the replacement.
    ///     Any other flag in \a options is ignored.
    /// 
    ///     Notice that the returned item therefore might not belong to this layout,
    ///     but to a sub-layout.
    /// 
    ///     The returned layout item is no longer owned by the layout and should be
    ///     either deleted or inserted to another layout. The widget \a from is no
    ///     longer managed by the layout and may need to be deleted or hidden. The
    ///     parent of widget \a from is left unchanged.
    /// 
    ///     This function works for the built-in Qt layouts, but might not work for
    ///     custom layouts.
    /// 
    ///     \sa indexOf()
    replace_widget(from: *WidgetType, to: *WidgetType, options: Rute::FindChildOptions) -> LayoutItem?,
    ///   \internal
    ///   Also takes contentsMargins and menu bar into account.
    total_height_for_width(w: i32) -> i32,
    ///   \internal
    ///   Also takes contentsMargins and menu bar into account.
    total_minimum_size() -> Size,
    ///   \internal
    ///   Also takes contentsMargins and menu bar into account.
    total_maximum_size() -> Size,
    ///   \internal
    ///   Also takes contentsMargins and menu bar into account.
    total_size_hint() -> Size,
    ///     \reimp
    [event] layout() -> Layout?,
    ///     Enables this layout if \a enable is true, otherwise disables it.
    /// 
    ///     An enabled layout adjusts dynamically to changes; a disabled
    ///     layout acts as if it did not exist.
    /// 
    ///     By default all layouts are enabled.
    /// 
    ///     \sa isEnabled()
    set_enabled(arg0: bool),
    ///     Returns \c true if the layout is enabled; otherwise returns \c false.
    /// 
    ///     \sa setEnabled()
    is_enabled() -> bool,
    ///     Returns a size that satisfies all size constraints on \a widget,
    ///     including heightForWidth() and that is as close as possible to \a
    ///     size.
    [static] closest_acceptable_size(w: *WidgetType, s: &SizeType) -> Size,
    ///     \internal
    ///     Performs child widget layout when the parent widget is
    ///     resized.  Also handles removal of widgets. \a e is the
    ///     event
    widget_event(arg0: *EventType),
    ///     \reimp
    [event] child_event(e: *ChildEventType),
    ///     This function is called from \c addLayout() or \c insertLayout() functions in
    ///     subclasses to add layout \a l as a sub-layout.
    /// 
    ///     The only scenario in which you need to call it directly is if you
    ///     implement a custom layout that supports nested layouts.
    /// 
    ///     \sa QBoxLayout::addLayout(), QBoxLayout::insertLayout(), QGridLayout::addLayout()
    add_child_layout(l: *LayoutType),
    ///     This function is called from \c addWidget() functions in
    ///     subclasses to add \a w as a managed widget of a layout.
    /// 
    ///     If \a w is already managed by a layout, this function will give a warning
    ///     and remove \a w from that layout. This function must therefore be
    ///     called before adding \a w to the layout's data structure.
    add_child_widget(w: *WidgetType),
    adopt_layout(layout: *LayoutType) -> bool,
    ///     Returns the rectangle that should be covered when the geometry of
    ///     this layout is set to \a r, provided that this layout supports
    ///     setAlignment().
    /// 
    ///     The result is derived from sizeHint() and expanding(). It is never
    ///     larger than \a r.
    alignment_rect(arg0: &RectType) -> Rect,
}

// vim: syntax=rust expandtab ts=4 sw=4
