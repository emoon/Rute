///     \class QBrush
///     \ingroup painting
///     \ingroup shared
///     \inmodule QtGui
/// 
///     \brief The QBrush class defines the fill pattern of shapes drawn
///     by QPainter.
/// 
///     A brush has a style, a color, a gradient and a texture.
/// 
///     The brush style() defines the fill pattern using the
///     Qt::BrushStyle enum. The default brush style is Qt::NoBrush
///     (depending on how you construct a brush). This style tells the
///     painter to not fill shapes. The standard style for filling is
///     Qt::SolidPattern. The style can be set when the brush is created
///     using the appropriate constructor, and in addition the setStyle()
///     function provides means for altering the style once the brush is
///     constructed.
/// 
///     \image brush-styles.png Brush Styles
/// 
///     The brush color() defines the color of the fill pattern. The color
///     can either be one of Qt's predefined colors, Qt::GlobalColor, or
///     any other custom QColor. The currently set color can be retrieved
///     and altered using the color() and setColor() functions,
///     respectively.
/// 
///     The gradient() defines the gradient fill used when the current
///     style is either Qt::LinearGradientPattern,
///     Qt::RadialGradientPattern or Qt::ConicalGradientPattern. Gradient
///     brushes are created by giving a QGradient as a constructor
///     argument when creating the QBrush. Qt provides three different
///     gradients: QLinearGradient, QConicalGradient, and QRadialGradient
///     - all of which inherit QGradient.
/// 
///     \snippet brush/gradientcreationsnippet.cpp 0
/// 
///     The texture() defines the pixmap used when the current style is
///     Qt::TexturePattern.  You can create a brush with a texture by
///     providing the pixmap when the brush is created or by using
///     setTexture().
/// 
///     Note that applying setTexture() makes style() ==
///     Qt::TexturePattern, regardless of previous style
///     settings. Also, calling setColor() will not make a difference if
///     the style is a gradient. The same is the case if the style is
///     Qt::TexturePattern style unless the current texture is a QBitmap.
/// 
///     The isOpaque() function returns \c true if the brush is fully opaque
///     otherwise false. A brush is considered opaque if:
/// 
///     \list
///     \li The alpha component of the color() is 255.
///     \li Its texture() does not have an alpha channel and is not a QBitmap.
///     \li The colors in the gradient() all have an alpha component that is 255.
///     \endlist
/// 
///     \table 100%
///     \row
///     \li \inlineimage brush-outline.png Outlines
///     \li
/// 
///     To specify the style and color of lines and outlines, use the
///     QPainter's \l {QPen}{pen} combined with Qt::PenStyle and
///     Qt::GlobalColor:
/// 
///     \snippet code/src_gui_painting_qbrush.cpp 0
/// 
///     Note that, by default, QPainter renders the outline (using the
///     currently set pen) when drawing shapes. Use \l {Qt::NoPen}{\c
///     painter.setPen(Qt::NoPen)} to disable this behavior.
/// 
///     \endtable
/// 
///     For more information about painting in general, see the \l{Paint
///     System}.
/// 
///     \sa Qt::BrushStyle, QPainter, QColor
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.

struct Brush {
    swap(other: &BrushType),
    style() -> Rute::BrushStyle,
    ///     Sets the brush style to \a style.
    /// 
    ///     \sa style()
    set_style(arg0: Rute::BrushStyle),
    ///     \since 4.3
    /// 
    ///     Sets \a matrix as an explicit transformation matrix on the
    ///     current brush. The brush transformation matrix is merged with
    ///     QPainter transformation matrix to produce the final result.
    /// 
    ///     \sa transform()
    set_transform(arg0: &TransformType),
    ///     \fn QPixmap QBrush::texture() const
    /// 
    ///     Returns the custom brush pattern, or a null pixmap if no custom brush pattern
    ///     has been set.
    /// 
    ///     \sa setTexture()
    texture() -> Pixmap,
    ///     Sets the brush pixmap to \a pixmap. The style is set to
    ///     Qt::TexturePattern.
    /// 
    ///     The current brush color will only have an effect for monochrome
    ///     pixmaps, i.e. for QPixmap::depth() == 1 (\l {QBitmap}{QBitmaps}).
    /// 
    ///     \sa texture()
    set_texture(pixmap: &PixmapType),
    ///     \since 4.2
    /// 
    ///     Returns the custom brush pattern, or a null image if no custom
    ///     brush pattern has been set.
    /// 
    ///     If the texture was set as a QPixmap it will be converted to a
    ///     QImage.
    /// 
    ///     \sa setTextureImage()
    texture_image() -> Image,
    ///     \since 4.2
    /// 
    ///     Sets the brush image to \a image. The style is set to
    ///     Qt::TexturePattern.
    /// 
    ///     Note the current brush color will \e not have any affect on
    ///     monochrome images, as opposed to calling setTexture() with a
    ///     QBitmap. If you want to change the color of monochrome image
    ///     brushes, either convert the image to QBitmap with \c
    ///     QBitmap::fromImage() and set the resulting QBitmap as a texture,
    ///     or change the entries in the color table for the image.
    /// 
    ///     \sa textureImage(), setTexture()
    set_texture_image(image: &ImageType),
    color() -> Color?,
    ///     \fn void QBrush::setColor(const QColor &color)
    /// 
    ///     Sets the brush color to the given \a color.
    /// 
    ///     Note that calling setColor() will not make a difference if the
    ///     style is a gradient. The same is the case if the style is
    ///     Qt::TexturePattern style unless the current texture is a QBitmap.
    /// 
    ///     \sa color()
    set_color(color: &ColorType),
    ///     \fn void QBrush::setColor(const QColor &color)
    /// 
    ///     Sets the brush color to the given \a color.
    /// 
    ///     Note that calling setColor() will not make a difference if the
    ///     style is a gradient. The same is the case if the style is
    ///     Qt::TexturePattern style unless the current texture is a QBitmap.
    /// 
    ///     \sa color()
    set_color(color: Rute::GlobalColor),
    ///     Returns the gradient describing this brush.
    gradient() -> Gradient?,
    ///     Returns \c true if the brush is fully opaque otherwise false. A brush
    ///     is considered opaque if:
    /// 
    ///     \list
    ///     \li The alpha component of the color() is 255.
    ///     \li Its texture() does not have an alpha channel and is not a QBitmap.
    ///     \li The colors in the gradient() all have an alpha component that is 255.
    ///     \li It is an extended radial gradient.
    ///     \endlist
    is_opaque() -> bool,
    is_detached() -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
