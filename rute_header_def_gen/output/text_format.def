/// 
/// A QTextFormat is a generic class used for describing the format of
/// parts of a QTextDocument. The derived classes QTextCharFormat,
/// QTextBlockFormat, QTextListFormat, and QTextTableFormat are usually
/// more useful, and describe the formatting that is applied to
/// specific parts of the document.
/// 
/// A format has a `FormatType` which specifies the kinds of text item it
/// can format; e.g. a block of text, a list, a table, etc. A format
/// also has various properties (some specific to particular format
/// types), as described by the Property enum. Every property has a
/// corresponding Property.
/// 
/// The format type is given by type(), and the format can be tested
/// with isCharFormat(), isBlockFormat(), isListFormat(),
/// isTableFormat(), isFrameFormat(), and isImageFormat(). If the
/// type is determined, it can be retrieved with toCharFormat(),
/// toBlockFormat(), toListFormat(), toTableFormat(), toFrameFormat(),
/// and toImageFormat().
/// 
/// A format's properties can be set with the setProperty() functions,
/// and retrieved with boolProperty(), intProperty(), doubleProperty(),
/// and stringProperty() as appropriate. All the property IDs used in
/// the format can be retrieved with allPropertyIds(). One format can
/// be merged into another using merge().
/// 
/// A format's object index can be set with setObjectIndex(), and
/// retrieved with objectIndex(). These methods can be used to
/// associate the format with a QTextObject. It is used to represent
/// lists, frames, and tables inside the document.
/// 
/// **See also:** {Rich Text Processing}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct TextFormat {
    qt_check_for_qgadget_macro(),
    /// 
    /// Swaps this text format with *other.* This function is very fast
    /// and never fails.
    swap(other: &TextFormatType),
    /// 
    /// Merges the *other* format with this format; where there are
    /// conflicts the *other* format takes precedence.
    merge(other: &TextFormatType),
    /// 
    /// Returns `true` if the format is valid (i.e. is not
    /// InvalidFormat); otherwise returns `false.`
    is_valid() -> bool,
    /// 
    /// Returns true if the format does not store any properties; false otherwise.
    /// 
    /// **See also:** [`property_count()`]
    /// [`properties()`]
    is_empty() -> bool,
    /// 
    /// Returns the type of this format.
    /// 
    /// **See also:** FormatType
    type() -> i32,
    /// 
    /// Returns the index of the format object, or -1 if the format object is invalid.
    /// 
    /// **See also:** [`set_object_index()`]
    object_index() -> i32,
    /// 
    /// Sets the format object's object *index.*
    /// 
    /// **See also:** [`object_index()`]
    set_object_index(object: i32),
    /// 
    /// Returns the property specified by the given *propertyId.*
    /// 
    /// **See also:** Property
    /// 
    /// Returns the number of properties stored in the format.
    property(property_id: i32) -> Variant,
    /// 
    /// Sets the property specified by the *propertyId* to the given *value.*
    /// 
    /// **See also:** Property
    /// 
    /// Sets the value of the property given by *propertyId* to *value.*
    /// 
    /// **See also:** [`length_vector_property()`]
    /// Property
    set_property(property_id: i32, value: &VariantType),
    /// 
    /// Clears the value of the property given by *propertyId*
    /// 
    /// **See also:** Property
    clear_property(property_id: i32),
    /// 
    /// Returns `true` if the text format has a property with the given *propertyId;* otherwise returns `false.`
    /// 
    /// **See also:** [`properties()`]
    /// Property
    has_property(property_id: i32) -> bool,
    /// 
    /// Returns the value of the property specified by *propertyId.* If the
    /// property isn't of QTextFormat::Bool type, false is returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`int_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`color_property()`]
    /// [`length_property()`]
    /// [`length_vector_property()`]
    /// Property
    bool_property(property_id: i32) -> bool,
    /// 
    /// Returns the value of the property specified by *propertyId.* If the
    /// property is not of QTextFormat::Integer type, 0 is returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`color_property()`]
    /// [`length_property()`]
    /// [`length_vector_property()`]
    /// Property
    int_property(property_id: i32) -> i32,
    /// 
    /// Returns the value of the property specified by *propertyId.* If the
    /// property isn't of QVariant::Double or QMetaType::Float type, 0 is
    /// returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`int_property()`]
    /// [`string_property()`]
    /// [`color_property()`]
    /// [`length_property()`]
    /// [`length_vector_property()`]
    /// Property
    double_property(property_id: i32) -> f32,
    /// 
    /// Returns the value of the property given by *propertyId;* if the
    /// property isn't of QVariant::Color type, an invalid color is
    /// returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`int_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`length_property()`]
    /// [`length_vector_property()`]
    /// Property
    color_property(property_id: i32) -> Color,
    /// 
    /// Returns the value of the property given by *propertyId;* if the
    /// property isn't of QVariant::Pen type, Qt::NoPen is
    /// returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`int_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`length_property()`]
    /// [`length_vector_property()`]
    /// Property
    pen_property(property_id: i32) -> Pen,
    /// 
    /// Returns the value of the property given by *propertyId;* if the
    /// property isn't of QVariant::Brush type, Qt::NoBrush is
    /// returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`int_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`length_property()`]
    /// [`length_vector_property()`]
    /// Property
    brush_property(property_id: i32) -> Brush,
    /// 
    /// Returns the value of the property given by *propertyId.*
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`int_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`color_property()`]
    /// [`length_vector_property()`]
    /// Property
    length_property(property_id: i32) -> TextLength,
    /// 
    /// Returns the value of the property given by *propertyId.* If the
    /// property isn't of QTextFormat::LengthVector type, an empty length
    /// vector is returned instead.
    /// 
    /// **See also:** [`set_property()`]
    /// [`bool_property()`]
    /// [`int_property()`]
    /// [`double_property()`]
    /// [`string_property()`]
    /// [`color_property()`]
    /// [`length_property()`]
    /// Property
    length_vector_property(property_id: i32) -> [TextLength],
    /// 
    /// Sets the property specified by the *propertyId* to the given *value.*
    /// 
    /// **See also:** Property
    /// 
    /// Sets the value of the property given by *propertyId* to *value.*
    /// 
    /// **See also:** [`length_vector_property()`]
    /// Property
    [org_name(setProperty)]
    set_property_2(property_id: i32, lengths: [TextLengthType]),
    /// 
    /// Returns a map with all properties of this text format.
    properties() -> Map<int,,
    /// 
    /// Returns the number of properties stored in the format.
    property_count() -> i32,
    /// 
    /// Sets the text format's object type to *type.*
    /// 
    /// **See also:** ObjectTypes
    /// [`object_type()`]
    set_object_type(type: i32),
    /// 
    /// Returns the text format's object type.
    /// 
    /// **See also:** ObjectTypes
    /// [`set_object_type()`]
    object_type() -> i32,
    /// 
    /// Returns `true` if this text format is a `CharFormat;` otherwise
    /// returns `false.`
    is_char_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `BlockFormat;` otherwise
    /// returns `false.`
    is_block_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `ListFormat;` otherwise
    /// returns `false.`
    is_list_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `FrameFormat;` otherwise
    /// returns `false.`
    is_frame_format() -> bool,
    /// 
    /// Returns `true` if this text format is an image format; otherwise
    /// returns `false.`
    is_image_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `TableFormat;` otherwise
    /// returns `false.`
    is_table_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `TableCellFormat;` otherwise
    /// returns `false.`
    is_table_cell_format() -> bool,
    /// 
    /// Returns this format as a block format.
    to_block_format() -> TextBlockFormat,
    /// 
    /// Returns this format as a character format.
    to_char_format() -> TextCharFormat,
    /// 
    /// Returns this format as a list format.
    to_list_format() -> TextListFormat,
    /// 
    /// Returns this format as a table format.
    to_table_format() -> TextTableFormat,
    /// 
    /// Returns this format as a frame format.
    to_frame_format() -> TextFrameFormat,
    /// 
    /// Returns this format as an image format.
    to_image_format() -> TextImageFormat,
    /// 
    /// Returns this format as a table cell format.
    to_table_cell_format() -> TextTableCellFormat,
    /// 
    /// Sets the document's layout direction to the specified *direction.*
    /// 
    /// **See also:** [`layout_direction()`]
    set_layout_direction(direction: Rute::LayoutDirection),
    /// 
    /// Returns the document's layout direction.
    /// 
    /// **See also:** [`set_layout_direction()`]
    layout_direction() -> Rute::LayoutDirection,
    /// 
    /// Sets the brush use to paint the document's background to the
    /// *brush* specified.
    /// 
    /// **See also:** [`background()`]
    /// [`clear_background()`]
    /// [`set_foreground()`]
    set_background(brush: &BrushType),
    /// 
    /// Returns the brush used to paint the document's background.
    /// 
    /// **See also:** [`set_background()`]
    /// [`clear_background()`]
    /// [`foreground()`]
    background() -> Brush,
    /// 
    /// Clears the brush used to paint the document's background. The default
    /// brush will be used.
    /// 
    /// **See also:** [`background()`]
    /// [`set_background()`]
    /// [`clear_foreground()`]
    clear_background(),
    /// 
    /// Sets the foreground brush to the specified *brush.* The foreground
    /// brush is mostly used to render text.
    /// 
    /// **See also:** [`foreground()`]
    /// [`clear_foreground()`]
    /// [`set_background()`]
    set_foreground(brush: &BrushType),
    /// 
    /// Returns the brush used to render foreground details, such as text,
    /// frame outlines, and table borders.
    /// 
    /// **See also:** [`set_foreground()`]
    /// [`clear_foreground()`]
    /// [`background()`]
    foreground() -> Brush,
    /// 
    /// Clears the brush used to paint the document's foreground. The default
    /// brush will be used.
    /// 
    /// **See also:** [`foreground()`]
    /// [`set_foreground()`]
    /// [`clear_background()`]
    clear_foreground(),
}

[org_name(QTextFormat)]
enum FormatType {
    /// An invalid format as created by the default
    InvalidFormat,
    /// The object formats a text block
    BlockFormat,
    /// The object formats a single character
    CharFormat,
    /// The object formats a list
    ListFormat,
    TableFormat,
    /// The object formats a frame
    FrameFormat,
    /// 
    UserFormat,
}

[org_name(QTextFormat)]
enum Property {
    /// The index of the formatted object. See objectIndex().
    ObjectIndex,
    /// How a frame is located relative to the surrounding text
    CssFloat,
    /// The layout direction of the text in the document
    LayoutDirection,
    /// 
    OutlinePen,
    /// 
    BackgroundBrush,
    /// 
    ForegroundBrush,
    /// 
    BackgroundImageUrl,
    /// 
    BlockAlignment,
    /// 
    BlockTopMargin,
    /// 
    BlockBottomMargin,
    /// 
    BlockLeftMargin,
    /// 
    BlockRightMargin,
    /// 
    TextIndent,
    /// Specifies the tab positions.  The tab positions are structs of QTextOption::Tab which are stored in
    TabPositions,
    /// 
    BlockIndent,
    /// 
    LineHeight,
    /// 
    LineHeightType,
    /// 
    BlockNonBreakableLines,
    /// The width of a horizontal ruler element.
    BlockTrailingHorizontalRulerWidth,
    FirstFontProperty,
    /// Specifies the capitalization type that is to be applied to the text.
    FontCapitalization,
    /// Specifies the meaning of the FontLetterSpacing property. The default
    FontLetterSpacingType,
    /// Changes the default spacing between individual letters in the font. The value is
    FontLetterSpacing,
    /// Changes the default spacing between individual words. A positive value increases the word spacing
    FontWordSpacing,
    /// Corresponds to the QFont::Stretch property
    FontStretch,
    /// Corresponds to the QFont::StyleHint property
    FontStyleHint,
    /// Corresponds to the QFont::StyleStrategy property
    FontStyleStrategy,
    /// Specifies whether the font has kerning turned on.
    FontKerning,
    /// Controls the use of hinting according to values
    FontHintingPreference,
    /// 
    FontFamily,
    /// 
    FontPointSize,
    /// Specifies the change in size given to the fontsize already set using
    FontSizeAdjustment,
    FontSizeIncrement,
    /// 
    FontWeight,
    /// 
    FontItalic,
    /// 
    FontUnderline,
    /// 
    FontOverline,
    /// 
    FontStrikeOut,
    /// 
    FontFixedPitch,
    /// 
    FontPixelSize,
    LastFontProperty,
    /// 
    TextUnderlineColor,
    /// 
    TextVerticalAlignment,
    /// 
    TextOutline,
    /// 
    TextUnderlineStyle,
    /// Specifies the (optional) tool tip to be displayed for a fragment of text.
    TextToolTip,
    /// 
    IsAnchor,
    /// 
    AnchorHref,
    /// 
    AnchorName,
    /// 
    ObjectType,
    /// Specifies the style used for the items in a list,
    ListStyle,
    /// Specifies the amount of indentation used for a list.
    ListIndent,
    /// Defines the text which is prepended to item numbers in
    ListNumberPrefix,
    /// Defines the text which is appended to item numbers in
    ListNumberSuffix,
    /// 
    FrameBorder,
    /// 
    FrameMargin,
    /// 
    FramePadding,
    /// 
    FrameWidth,
    /// 
    FrameHeight,
    /// 
    FrameTopMargin,
    /// 
    FrameBottomMargin,
    /// 
    FrameLeftMargin,
    /// 
    FrameRightMargin,
    /// 
    FrameBorderBrush,
    /// See the
    FrameBorderStyle,
    /// 
    TableColumns,
    /// 
    TableColumnWidthConstraints,
    /// 
    TableCellSpacing,
    /// 
    TableCellPadding,
    /// 
    TableHeaderRowCount,
    /// 
    TableCellRowSpan,
    /// 
    TableCellColumnSpan,
    /// 
    TableCellTopPadding,
    /// 
    TableCellBottomPadding,
    /// 
    TableCellLeftPadding,
    /// 
    TableCellRightPadding,
    /// 
    ImageName,
    /// 
    ImageWidth,
    /// 
    ImageHeight,
    /// When set on the characterFormat of a selection,
    FullWidthSelection,
    /// Specifies how pages are broken. See the PageBreakFlag enum.
    PageBreakPolicy,
    /// 
    UserProperty,
}

[org_name(QTextFormat)]
enum ObjectTypes {
    /// 
    NoObject,
    /// 
    ImageObject,
    /// 
    TableObject,
    /// 
    TableCellObject,
    /// The first object that can be used for application-specific purposes.
    UserObject,
}

[org_name(QTextFormat)]
enum PageBreakFlag {
    /// The page break is determined automatically depending on the
    PageBreak_Auto,
    /// The page is always broken before the paragraph/table
    PageBreak_AlwaysBefore,
    /// A new page is always started after the paragraph/table
    PageBreak_AlwaysAfter,
}

// vim: syntax=rust expandtab ts=4 sw=4
