/// 
/// A QTextFormat is a generic class used for describing the format of
/// parts of a QTextDocument. The derived classes QTextCharFormat,
/// QTextBlockFormat, QTextListFormat, and QTextTableFormat are usually
/// more useful, and describe the formatting that is applied to
/// specific parts of the document.
/// 
/// A format has a `FormatType` which specifies the kinds of text item it
/// can format; e.g. a block of text, a list, a table, etc. A format
/// also has various properties (some specific to particular format
/// types), as described by the Property enum. Every property has a
/// corresponding Property.
/// 
/// The format type is given by type(), and the format can be tested
/// with isCharFormat(), isBlockFormat(), isListFormat(),
/// isTableFormat(), isFrameFormat(), and isImageFormat(). If the
/// type is determined, it can be retrieved with toCharFormat(),
/// toBlockFormat(), toListFormat(), toTableFormat(), toFrameFormat(),
/// and toImageFormat().
/// 
/// A format's properties can be set with the setProperty() functions,
/// and retrieved with boolProperty(), intProperty(), doubleProperty(),
/// and stringProperty() as appropriate. All the property IDs used in
/// the format can be retrieved with allPropertyIds(). One format can
/// be merged into another using merge().
/// 
/// A format's object index can be set with setObjectIndex(), and
/// retrieved with objectIndex(). These methods can be used to
/// associate the format with a QTextObject. It is used to represent
/// lists, frames, and tables inside the document.
/// 
/// **See also:** {Rich Text Processing}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QTextFormat)]
enum FormatType {
    InvalidFormat,
    BlockFormat,
    CharFormat,
    ListFormat,
    TableFormat,
    FrameFormat,
    UserFormat,
}

[org_name(QTextFormat)]
enum Property {
    ObjectIndex,
    CssFloat,
    LayoutDirection,
    OutlinePen,
    BackgroundBrush,
    ForegroundBrush,
    BackgroundImageUrl,
    BlockAlignment,
    BlockTopMargin,
    BlockBottomMargin,
    BlockLeftMargin,
    BlockRightMargin,
    TextIndent,
    TabPositions,
    BlockIndent,
    LineHeight,
    LineHeightType,
    BlockNonBreakableLines,
    BlockTrailingHorizontalRulerWidth,
    FirstFontProperty,
    FontCapitalization,
    FontLetterSpacingType,
    FontLetterSpacing,
    FontWordSpacing,
    FontStretch,
    FontStyleHint,
    FontStyleStrategy,
    FontKerning,
    FontHintingPreference,
    FontFamily,
    FontPointSize,
    FontSizeAdjustment,
    FontSizeIncrement,
    FontWeight,
    FontItalic,
    FontUnderline,
    FontOverline,
    FontStrikeOut,
    FontFixedPitch,
    FontPixelSize,
    LastFontProperty,
    TextUnderlineColor,
    TextVerticalAlignment,
    TextOutline,
    TextUnderlineStyle,
    TextToolTip,
    IsAnchor,
    AnchorHref,
    AnchorName,
    ObjectType,
    ListStyle,
    ListIndent,
    ListNumberPrefix,
    ListNumberSuffix,
    FrameBorder,
    FrameMargin,
    FramePadding,
    FrameWidth,
    FrameHeight,
    FrameTopMargin,
    FrameBottomMargin,
    FrameLeftMargin,
    FrameRightMargin,
    FrameBorderBrush,
    FrameBorderStyle,
    TableColumns,
    TableColumnWidthConstraints,
    TableCellSpacing,
    TableCellPadding,
    TableHeaderRowCount,
    TableCellRowSpan,
    TableCellColumnSpan,
    TableCellTopPadding,
    TableCellBottomPadding,
    TableCellLeftPadding,
    TableCellRightPadding,
    ImageName,
    ImageWidth,
    ImageHeight,
    FullWidthSelection,
    PageBreakPolicy,
    UserProperty,
}

[org_name(QTextFormat)]
enum ObjectTypes {
    NoObject,
    ImageObject,
    TableObject,
    TableCellObject,
    UserObject,
}

[org_name(QTextFormat)]
enum PageBreakFlag {
    PageBreak_Auto,
    PageBreak_AlwaysBefore,
    PageBreak_AlwaysAfter,
}


struct TextFormat {
    qt_check_for_qgadget_macro(),
    /// 
    /// Swaps this text format with *other.* This function is very fast
    /// and never fails.
    swap(other: &TextFormatType),
    /// 
    /// Merges the *other* format with this format; where there are
    /// conflicts the *other* format takes precedence.
    merge(other: &TextFormatType),
    /// 
    /// Returns `true` if the format is valid (i.e. is not
    /// InvalidFormat); otherwise returns `false.`
    is_valid() -> bool,
    /// 
    /// Returns true if the format does not store any properties; false otherwise.
    /// 
    /// **See also:** propertyCount()
    /// properties()
    is_empty() -> bool,
    /// 
    /// Returns the type of this format.
    /// 
    /// **See also:** FormatType
    type() -> i32,
    /// 
    /// Returns the index of the format object, or -1 if the format object is invalid.
    /// 
    /// **See also:** setObjectIndex()
    object_index() -> i32,
    /// 
    /// Sets the format object's object *index.*
    /// 
    /// **See also:** objectIndex()
    set_object_index(object: i32),
    /// 
    /// Returns the property specified by the given *propertyId.*
    /// 
    /// **See also:** Property
    /// 
    /// Returns the number of properties stored in the format.
    property(property_id: i32) -> Variant,
    /// 
    /// Sets the property specified by the *propertyId* to the given *value.*
    /// 
    /// **See also:** Property
    /// 
    /// Sets the value of the property given by *propertyId* to *value.*
    /// 
    /// **See also:** lengthVectorProperty()
    /// Property
    set_property(property_id: i32, value: &VariantType),
    /// 
    /// Clears the value of the property given by *propertyId*
    /// 
    /// **See also:** Property
    clear_property(property_id: i32),
    /// 
    /// Returns `true` if the text format has a property with the given *propertyId;* otherwise returns `false.`
    /// 
    /// **See also:** properties()
    /// Property
    has_property(property_id: i32) -> bool,
    /// 
    /// Returns the value of the property specified by *propertyId.* If the
    /// property isn't of QTextFormat::Bool type, false is returned instead.
    /// 
    /// **See also:** setProperty()
    /// intProperty()
    /// doubleProperty()
    /// stringProperty()
    /// colorProperty()
    /// lengthProperty()
    /// lengthVectorProperty()
    /// Property
    bool_property(property_id: i32) -> bool,
    /// 
    /// Returns the value of the property specified by *propertyId.* If the
    /// property is not of QTextFormat::Integer type, 0 is returned instead.
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// doubleProperty()
    /// stringProperty()
    /// colorProperty()
    /// lengthProperty()
    /// lengthVectorProperty()
    /// Property
    int_property(property_id: i32) -> i32,
    /// 
    /// Returns the value of the property specified by *propertyId.* If the
    /// property isn't of QVariant::Double or QMetaType::Float type, 0 is
    /// returned instead.
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// intProperty()
    /// stringProperty()
    /// colorProperty()
    /// lengthProperty()
    /// lengthVectorProperty()
    /// Property
    double_property(property_id: i32) -> f32,
    /// 
    /// Returns the value of the property given by *propertyId;* if the
    /// property isn't of QVariant::Color type, an invalid color is
    /// returned instead.
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// intProperty()
    /// doubleProperty()
    /// stringProperty()
    /// lengthProperty()
    /// lengthVectorProperty()
    /// Property
    color_property(property_id: i32) -> Color,
    /// 
    /// Returns the value of the property given by *propertyId;* if the
    /// property isn't of QVariant::Pen type, Qt::NoPen is
    /// returned instead.
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// intProperty()
    /// doubleProperty()
    /// stringProperty()
    /// lengthProperty()
    /// lengthVectorProperty()
    /// Property
    pen_property(property_id: i32) -> Pen,
    /// 
    /// Returns the value of the property given by *propertyId;* if the
    /// property isn't of QVariant::Brush type, Qt::NoBrush is
    /// returned instead.
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// intProperty()
    /// doubleProperty()
    /// stringProperty()
    /// lengthProperty()
    /// lengthVectorProperty()
    /// Property
    brush_property(property_id: i32) -> Brush,
    /// 
    /// Returns the value of the property given by *propertyId.*
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// intProperty()
    /// doubleProperty()
    /// stringProperty()
    /// colorProperty()
    /// lengthVectorProperty()
    /// Property
    length_property(property_id: i32) -> TextLength,
    /// 
    /// Returns the value of the property given by *propertyId.* If the
    /// property isn't of QTextFormat::LengthVector type, an empty length
    /// vector is returned instead.
    /// 
    /// **See also:** setProperty()
    /// boolProperty()
    /// intProperty()
    /// doubleProperty()
    /// stringProperty()
    /// colorProperty()
    /// lengthProperty()
    /// Property
    length_vector_property(property_id: i32) -> [TextLength],
    /// 
    /// Sets the property specified by the *propertyId* to the given *value.*
    /// 
    /// **See also:** Property
    /// 
    /// Sets the value of the property given by *propertyId* to *value.*
    /// 
    /// **See also:** lengthVectorProperty()
    /// Property
    set_property(property_id: i32, lengths: [TextLengthType]),
    /// 
    /// Returns a map with all properties of this text format.
    properties() -> Map<int,,
    /// 
    /// Returns the number of properties stored in the format.
    property_count() -> i32,
    /// 
    /// Sets the text format's object type to *type.*
    /// 
    /// **See also:** ObjectTypes
    /// objectType()
    set_object_type(type: i32),
    /// 
    /// Returns the text format's object type.
    /// 
    /// **See also:** ObjectTypes
    /// setObjectType()
    object_type() -> i32,
    /// 
    /// Returns `true` if this text format is a `CharFormat;` otherwise
    /// returns `false.`
    is_char_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `BlockFormat;` otherwise
    /// returns `false.`
    is_block_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `ListFormat;` otherwise
    /// returns `false.`
    is_list_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `FrameFormat;` otherwise
    /// returns `false.`
    is_frame_format() -> bool,
    /// 
    /// Returns `true` if this text format is an image format; otherwise
    /// returns `false.`
    is_image_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `TableFormat;` otherwise
    /// returns `false.`
    is_table_format() -> bool,
    /// 
    /// Returns `true` if this text format is a `TableCellFormat;` otherwise
    /// returns `false.`
    is_table_cell_format() -> bool,
    /// 
    /// Returns this format as a block format.
    to_block_format() -> TextBlockFormat,
    /// 
    /// Returns this format as a character format.
    to_char_format() -> TextCharFormat,
    /// 
    /// Returns this format as a list format.
    to_list_format() -> TextListFormat,
    /// 
    /// Returns this format as a table format.
    to_table_format() -> TextTableFormat,
    /// 
    /// Returns this format as a frame format.
    to_frame_format() -> TextFrameFormat,
    /// 
    /// Returns this format as an image format.
    to_image_format() -> TextImageFormat,
    /// 
    /// Returns this format as a table cell format.
    to_table_cell_format() -> TextTableCellFormat,
    /// 
    /// Sets the document's layout direction to the specified *direction.*
    /// 
    /// **See also:** layoutDirection()
    set_layout_direction(direction: Rute::LayoutDirection),
    /// 
    /// Returns the document's layout direction.
    /// 
    /// **See also:** setLayoutDirection()
    layout_direction() -> Rute::LayoutDirection,
    /// 
    /// Sets the brush use to paint the document's background to the
    /// *brush* specified.
    /// 
    /// **See also:** background()
    /// clearBackground()
    /// setForeground()
    set_background(brush: &BrushType),
    /// 
    /// Returns the brush used to paint the document's background.
    /// 
    /// **See also:** setBackground()
    /// clearBackground()
    /// foreground()
    background() -> Brush,
    /// 
    /// Clears the brush used to paint the document's background. The default
    /// brush will be used.
    /// 
    /// **See also:** background()
    /// setBackground()
    /// clearForeground()
    clear_background(),
    /// 
    /// Sets the foreground brush to the specified *brush.* The foreground
    /// brush is mostly used to render text.
    /// 
    /// **See also:** foreground()
    /// clearForeground()
    /// setBackground()
    set_foreground(brush: &BrushType),
    /// 
    /// Returns the brush used to render foreground details, such as text,
    /// frame outlines, and table borders.
    /// 
    /// **See also:** setForeground()
    /// clearForeground()
    /// background()
    foreground() -> Brush,
    /// 
    /// Clears the brush used to paint the document's foreground. The default
    /// brush will be used.
    /// 
    /// **See also:** foreground()
    /// setForeground()
    /// clearBackground()
    clear_foreground(),
}

// vim: syntax=rust expandtab ts=4 sw=4
