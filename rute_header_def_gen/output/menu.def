///     \class QMenu
///     \brief The QMenu class provides a menu widget for use in menu
///     bars, context menus, and other popup menus.
/// 
///     \ingroup mainwindow-classes
///     \ingroup basicwidgets
///     \inmodule QtWidgets
/// 
///     \image fusion-menu.png
/// 
///     A menu widget is a selection menu. It can be either a pull-down
///     menu in a menu bar or a standalone context menu. Pull-down menus
///     are shown by the menu bar when the user clicks on the respective
///     item or presses the specified shortcut key. Use
///     QMenuBar::addMenu() to insert a menu into a menu bar. Context
///     menus are usually invoked by some special keyboard key or by
///     right-clicking. They can be executed either asynchronously with
///     popup() or synchronously with exec(). Menus can also be invoked in
///     response to button presses; these are just like context menus
///     except for how they are invoked.
/// 
///     \section1 Actions
/// 
///     A menu consists of a list of action items. Actions are added with
///     the addAction(), addActions() and insertAction() functions. An action
///     is represented vertically and rendered by QStyle. In addition, actions
///     can have a text label, an optional icon drawn on the very left side,
///     and shortcut key sequence such as "Ctrl+X".
/// 
///     The existing actions held by a menu can be found with actions().
/// 
///     There are four kinds of action items: separators, actions that
///     show a submenu, widgets, and actions that perform an action.
///     Separators are inserted with addSeparator(), submenus with addMenu(),
///     and all other items are considered action items.
/// 
///     When inserting action items you usually specify a receiver and a
///     slot. The receiver will be notifed whenever the item is
///     \l{QAction::triggered()}{triggered()}. In addition, QMenu provides
///     two signals, triggered() and hovered(), which signal the
///     QAction that was triggered from the menu.
/// 
///     You clear a menu with clear() and remove individual action items
///     with removeAction().
/// 
///     A QMenu can also provide a tear-off menu. A tear-off menu is a
///     top-level window that contains a copy of the menu. This makes it
///     possible for the user to "tear off" frequently used menus and
///     position them in a convenient place on the screen. If you want
///     this functionality for a particular menu, insert a tear-off handle
///     with setTearOffEnabled(). When using tear-off menus, bear in mind
///     that the concept isn't typically used on Microsoft Windows so
///     some users may not be familiar with it. Consider using a QToolBar
///     instead.
/// 
///     Widgets can be inserted into menus with the QWidgetAction class.
///     Instances of this class are used to hold widgets, and are inserted
///     into menus with the addAction() overload that takes a QAction.
/// 
///     Conversely, actions can be added to widgets with the addAction(),
///     addActions() and insertAction() functions.
/// 
///     \warning To make QMenu visible on the screen, exec() or popup() should be
///     used instead of show().
/// 
///     \section1 QMenu on \macos with Qt Build Against Cocoa
/// 
///     QMenu can be inserted only once in a menu/menubar. Subsequent insertions will
///     have no effect or will result in a disabled menu item.
/// 
///     See the \l{mainwindows/menus}{Menus} example for an example of how
///     to use QMenuBar and QMenu in your application.
/// 
///     \b{Important inherited functions:} addAction(), removeAction(), clear(),
///     addSeparator(), and addMenu().
/// 
///     \sa QMenuBar, {fowler}{GUI Design Handbook: Menu, Drop-Down and Pop-Up},
///         {Application Example}, {Menus Example}
struct Menu : Widget {
    add_action(text: String) -> Action?,
    add_action(icon: &IconType, text: String) -> Action?,
    add_action(text: String, receiver: *ObjectType, member: *char, shortcut: &KeySequenceType) -> Action?,
    add_action(icon: &IconType, text: String, receiver: *ObjectType, member: *char, shortcut: &KeySequenceType) -> Action?,
    add_menu(title: String) -> Menu?,
    add_menu(icon: &IconType, title: String) -> Menu?,
    add_separator() -> Action?,
    add_section(text: String) -> Action?,
    add_section(icon: &IconType, text: String) -> Action?,
    insert_menu(before: *ActionType, menu: *MenuType) -> Action?,
    insert_separator(before: *ActionType) -> Action?,
    insert_section(before: *ActionType, text: String) -> Action?,
    insert_section(before: *ActionType, icon: &IconType, text: String) -> Action?,
    is_empty() -> bool,
    clear(),
    set_tear_off_enabled(arg0: bool),
    is_tear_off_enabled() -> bool,
    is_tear_off_menu_visible() -> bool,
    show_tear_off_menu(),
    show_tear_off_menu(pos: &PointType),
    hide_tear_off_menu(),
    set_default_action(arg0: *ActionType),
    default_action() -> Action?,
    set_active_action(act: *ActionType),
    active_action() -> Action?,
    popup(pos: &PointType, at: *ActionType),
    exec() -> Action?,
    exec(pos: &PointType, at: *ActionType) -> Action?,
    [static] exec(actions: [*ActionType], pos: &PointType, at: *ActionType, parent: *WidgetType) -> Action?,
    [event] size_hint() -> Size,
    action_at(arg0: &PointType) -> Action?,
    menu_action() -> Action?,
    title() -> String,
    set_title(title: String),
    icon() -> Icon,
    set_icon(icon: &IconType),
    set_no_replay_for(widget: *WidgetType),
    platform_menu() -> PlatformMenu?,
    set_platform_menu(platform_menu: *PlatformMenuType),
    separators_collapsible() -> bool,
    set_separators_collapsible(collapse: bool),
    tool_tips_visible() -> bool,
    set_tool_tips_visible(visible: bool),
    [signal] about_to_show(),
    [signal] about_to_hide(),
    [signal] hovered(action: *ActionType),
    column_count() -> i32,
    [event] change_event(arg0: *EventType),
    [event] key_press_event(arg0: *KeyEventType),
    [event] mouse_release_event(arg0: *MouseEventType),
    [event] mouse_press_event(arg0: *MouseEventType),
    [event] mouse_move_event(arg0: *MouseEventType),
    [event] wheel_event(arg0: *WheelEventType),
    [event] enter_event(arg0: *EventType),
    [event] leave_event(arg0: *EventType),
    [event] hide_event(arg0: *HideEventType),
    [event] paint_event(arg0: *PaintEventType),
    [event] action_event(arg0: *ActionEventType),
    [event] timer_event(arg0: *TimerEventType),
    [event] event(arg0: *EventType) -> bool,
    [event] focus_next_prev_child(next: bool) -> bool,
    init_style_option(option: *StyleOptionMenuItemType, action: *ActionType),
}

// vim: syntax=rust expandtab ts=4 sw=4
