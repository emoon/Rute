///     \class QUrl
///     \inmodule QtCore
/// 
///     \brief The QUrl class provides a convenient interface for working
///     with URLs.
/// 
///     \reentrant
///     \ingroup io
///     \ingroup network
///     \ingroup shared
/// 
/// 
///     It can parse and construct URLs in both encoded and unencoded
///     form. QUrl also has support for internationalized domain names
///     (IDNs).
/// 
///     The most common way to use QUrl is to initialize it via the
///     constructor by passing a QString. Otherwise, setUrl() can also
///     be used.
/// 
///     URLs can be represented in two forms: encoded or unencoded. The
///     unencoded representation is suitable for showing to users, but
///     the encoded representation is typically what you would send to
///     a web server. For example, the unencoded URL
///     "http://b√ºhler.example.com/List of applicants.xml"
///     would be sent to the server as
///     "http://xn--bhler-kva.example.com/List%20of%20applicants.xml".
/// 
///     A URL can also be constructed piece by piece by calling
///     setScheme(), setUserName(), setPassword(), setHost(), setPort(),
///     setPath(), setQuery() and setFragment(). Some convenience
///     functions are also available: setAuthority() sets the user name,
///     password, host and port. setUserInfo() sets the user name and
///     password at once.
/// 
///     Call isValid() to check if the URL is valid. This can be done at any point
///     during the constructing of a URL. If isValid() returns \c false, you should
///     clear() the URL before proceeding, or start over by parsing a new URL with
///     setUrl().
/// 
///     Constructing a query is particularly convenient through the use of the \l
///     QUrlQuery class and its methods QUrlQuery::setQueryItems(),
///     QUrlQuery::addQueryItem() and QUrlQuery::removeQueryItem(). Use
///     QUrlQuery::setQueryDelimiters() to customize the delimiters used for
///     generating the query string.
/// 
///     For the convenience of generating encoded URL strings or query
///     strings, there are two static functions called
///     fromPercentEncoding() and toPercentEncoding() which deal with
///     percent encoding and decoding of QString objects.
/// 
///     fromLocalFile() constructs a QUrl by parsing a local
///     file path. toLocalFile() converts a URL to a local file path.
/// 
///     The human readable representation of the URL is fetched with
///     toString(). This representation is appropriate for displaying a
///     URL to a user in unencoded form. The encoded form however, as
///     returned by toEncoded(), is for internal use, passing to web
///     servers, mail clients and so on. Both forms are technically correct
///     and represent the same URL unambiguously -- in fact, passing either
///     form to QUrl's constructor or to setUrl() will yield the same QUrl
///     object.
/// 
///     QUrl conforms to the URI specification from
///     \l{RFC 3986} (Uniform Resource Identifier: Generic Syntax), and includes
///     scheme extensions from \l{RFC 1738} (Uniform Resource Locators). Case
///     folding rules in QUrl conform to \l{RFC 3491} (Nameprep: A Stringprep
///     Profile for Internationalized Domain Names (IDN)). It is also compatible with the
///     \l{http://freedesktop.org/wiki/Specifications/file-uri-spec/}{file URI specification}
///     from freedesktop.org, provided that the locale encodes file names using
///     UTF-8 (required by IDN).
/// 
///     \section2 Relative URLs vs Relative Paths
/// 
///     Calling isRelative() will return whether or not the URL is relative.
///     A relative URL has no \l {scheme}. For example:
/// 
///     \code
///     qDebug() << QUrl("main.qml").isRelative();          // true: no scheme
///     qDebug() << QUrl("qml/main.qml").isRelative();      // true: no scheme
///     qDebug() << QUrl("file:main.qml").isRelative();     // false: has "file" scheme
///     qDebug() << QUrl("file:qml/main.qml").isRelative(); // false: has "file" scheme
///     \endcode
/// 
///     Notice that a URL can be absolute while containing a relative path, and
///     vice versa:
/// 
///     \code
///     // Absolute URL, relative path
///     QUrl url("file:file.txt");
///     qDebug() << url.isRelative();                 // false: has "file" scheme
///     qDebug() << QDir::isAbsolutePath(url.path()); // false: relative path
/// 
///     // Relative URL, absolute path
///     url = QUrl("/home/user/file.txt");
///     qDebug() << url.isRelative();                 // true: has no scheme
///     qDebug() << QDir::isAbsolutePath(url.path()); // true: absolute path
///     \endcode
/// 
///     A relative URL can be resolved by passing it as an argument to resolved(),
///     which returns an absolute URL. isParentOf() is used for determining whether
///     one URL is a parent of another.
/// 
///     \section2 Error checking
/// 
///     QUrl is capable of detecting many errors in URLs while parsing it or when
///     components of the URL are set with individual setter methods (like
///     setScheme(), setHost() or setPath()). If the parsing or setter function is
///     successful, any previously recorded error conditions will be discarded.
/// 
///     By default, QUrl setter methods operate in QUrl::TolerantMode, which means
///     they accept some common mistakes and mis-representation of data. An
///     alternate method of parsing is QUrl::StrictMode, which applies further
///     checks. See QUrl::ParsingMode for a description of the difference of the
///     parsing modes.
/// 
///     QUrl only checks for conformance with the URL specification. It does not
///     try to verify that high-level protocol URLs are in the format they are
///     expected to be by handlers elsewhere. For example, the following URIs are
///     all considered valid by QUrl, even if they do not make sense when used:
/// 
///     \list
///       \li "http:/filename.html"
///       \li "mailto://example.com"
///     \endlist
/// 
///     When the parser encounters an error, it signals the event by making
///     isValid() return false and toString() / toEncoded() return an empty string.
///     If it is necessary to show the user the reason why the URL failed to parse,
///     the error condition can be obtained from QUrl by calling errorString().
///     Note that this message is highly technical and may not make sense to
///     end-users.
/// 
///     QUrl is capable of recording only one error condition. If more than one
///     error is found, it is undefined which error is reported.
/// 
///     \section2 Character Conversions
/// 
///     Follow these rules to avoid erroneous character conversion when
///     dealing with URLs and strings:
/// 
///     \list
///     \li When creating a QString to contain a URL from a QByteArray or a
///        char*, always use QString::fromUtf8().
///     \endlist
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QUrl)]
enum ParsingMode {
    TolerantMode,
    StrictMode,
    DecodedMode,
}

[org_name(QUrl)]
enum UrlFormattingOption {
    None,
    RemoveScheme,
    RemovePassword,
    RemoveUserInfo,
    RemovePort,
    RemoveAuthority,
    RemovePath,
    RemoveQuery,
    RemoveFragment,
    PreferLocalFile,
    StripTrailingSlash,
    RemoveFilename,
    NormalizePathSegments,
}

[org_name(QUrl)]
enum ComponentFormattingOption {
    PrettyDecoded,
    EncodeSpaces,
    EncodeUnicode,
    EncodeDelimiters,
    EncodeReserved,
    DecodeReserved,
    FullyEncoded,
    FullyDecoded,
}

[org_name(QUrl)]
enum UserInputResolutionOption {
    DefaultResolution,
    AssumeLocalFile,
}


struct Url {
    swap(other: &UrlType),
    ///     Parses \a url and sets this object to that value. QUrl will automatically
    ///     percent encode all characters that are not allowed in a URL and decode the
    ///     percent-encoded sequences that represent an unreserved character (letters,
    ///     digits, hyphens, undercores, dots and tildes). All other characters are
    ///     left in their original forms.
    /// 
    ///     Parses the \a url using the parser mode \a parsingMode. In TolerantMode
    ///     (the default), QUrl will correct certain mistakes, notably the presence of
    ///     a percent character ('%') not followed by two hexadecimal digits, and it
    ///     will accept any character in any position. In StrictMode, encoding mistakes
    ///     will not be tolerated and QUrl will also check that certain forbidden
    ///     characters are not present in unencoded form. If an error is detected in
    ///     StrictMode, isValid() will return false. The parsing mode DecodedMode is
    ///     not permitted in this context and will produce a run-time warning.
    /// 
    ///     \sa url(), toString()
    set_url(url: String, mode: Url::ParsingMode),
    ///     Returns a string representation of the URL. The output can be customized by
    ///     passing flags with \a options. The option QUrl::FullyDecoded is not
    ///     permitted in this function since it would generate ambiguous data.
    /// 
    ///     The resulting QString can be passed back to a QUrl later on.
    /// 
    ///     Synonym for toString(options).
    /// 
    ///     \sa FormattingOptions, toEncoded(), toString()
    url(options: Url::FormattingOptions) -> String,
    ///     \since 5.2
    /// 
    ///     Returns an adjusted version of the URL.
    ///     The output can be customized by passing flags with \a options.
    /// 
    ///     The encoding options from QUrl::ComponentFormattingOption don't make
    ///     much sense for this method, nor does QUrl::PreferLocalFile.
    /// 
    ///     This is always equivalent to QUrl(url.toString(options)).
    /// 
    ///     \sa FormattingOptions, toEncoded(), toString()
    adjusted(options: Url::FormattingOptions) -> Url,
    ///     Returns the encoded representation of the URL if it's valid;
    ///     otherwise an empty QByteArray is returned. The output can be
    ///     customized by passing flags with \a options.
    /// 
    ///     The user info, path and fragment are all converted to UTF-8, and
    ///     all non-ASCII characters are then percent encoded. The host name
    ///     is encoded using Punycode.
    to_encoded(options: Url::FormattingOptions) -> ByteArray,
    ///     \fn QUrl QUrl::fromEncoded(const QByteArray &input, ParsingMode parsingMode)
    /// 
    ///     Parses \a input and returns the corresponding QUrl. \a input is
    ///     assumed to be in encoded form, containing only ASCII characters.
    /// 
    ///     Parses the URL using \a parsingMode. See setUrl() for more information on
    ///     this parameter. QUrl::DecodedMode is not permitted in this context.
    /// 
    ///     \sa toEncoded(), setUrl()
    [static] from_encoded(url: &ByteArrayType, mode: Url::ParsingMode) -> Url,
    ///     Returns a valid URL from a user supplied \a userInput string if one can be
    ///     deducted. In the case that is not possible, an invalid QUrl() is returned.
    /// 
    ///     \since 4.6
    /// 
    ///     Most applications that can browse the web, allow the user to input a URL
    ///     in the form of a plain string. This string can be manually typed into
    ///     a location bar, obtained from the clipboard, or passed in via command
    ///     line arguments.
    /// 
    ///     When the string is not already a valid URL, a best guess is performed,
    ///     making various web related assumptions.
    /// 
    ///     In the case the string corresponds to a valid file path on the system,
    ///     a file:// URL is constructed, using QUrl::fromLocalFile().
    /// 
    ///     If that is not the case, an attempt is made to turn the string into a
    ///     http:// or ftp:// URL. The latter in the case the string starts with
    ///     'ftp'. The result is then passed through QUrl's tolerant parser, and
    ///     in the case or success, a valid QUrl is returned, or else a QUrl().
    /// 
    ///     \section1 Examples:
    /// 
    ///     \list
    ///     \li qt-project.org becomes http://qt-project.org
    ///     \li ftp.qt-project.org becomes ftp://ftp.qt-project.org
    ///     \li hostname becomes http://hostname
    ///     \li /home/user/test.html becomes file:///home/user/test.html
    ///     \endlist
    [static] from_user_input(user_input: String) -> Url,
    ///     Returns a valid URL from a user supplied \a userInput string if one can be
    ///     deducted. In the case that is not possible, an invalid QUrl() is returned.
    /// 
    ///     \since 4.6
    /// 
    ///     Most applications that can browse the web, allow the user to input a URL
    ///     in the form of a plain string. This string can be manually typed into
    ///     a location bar, obtained from the clipboard, or passed in via command
    ///     line arguments.
    /// 
    ///     When the string is not already a valid URL, a best guess is performed,
    ///     making various web related assumptions.
    /// 
    ///     In the case the string corresponds to a valid file path on the system,
    ///     a file:// URL is constructed, using QUrl::fromLocalFile().
    /// 
    ///     If that is not the case, an attempt is made to turn the string into a
    ///     http:// or ftp:// URL. The latter in the case the string starts with
    ///     'ftp'. The result is then passed through QUrl's tolerant parser, and
    ///     in the case or success, a valid QUrl is returned, or else a QUrl().
    /// 
    ///     \section1 Examples:
    /// 
    ///     \list
    ///     \li qt-project.org becomes http://qt-project.org
    ///     \li ftp.qt-project.org becomes ftp://ftp.qt-project.org
    ///     \li hostname becomes http://hostname
    ///     \li /home/user/test.html becomes file:///home/user/test.html
    ///     \endlist
    [static] from_user_input(user_input: String, working_directory: String, options: Url::UserInputResolutionOptions) -> Url,
    ///     Returns \c true if the URL is non-empty and valid; otherwise returns \c false.
    /// 
    ///     The URL is run through a conformance test. Every part of the URL
    ///     must conform to the standard encoding rules of the URI standard
    ///     for the URL to be reported as valid.
    /// 
    ///     \snippet code/src_corelib_io_qurl.cpp 2
    is_valid() -> bool,
    ///     Returns \c true if the URL has no data; otherwise returns \c false.
    /// 
    ///     \sa clear()
    is_empty() -> bool,
    ///     Resets the content of the QUrl. After calling this function, the
    ///     QUrl is equal to one that has been constructed with the default
    ///     empty constructor.
    /// 
    ///     \sa isEmpty()
    clear(),
    ///     Sets the scheme of the URL to \a scheme. As a scheme can only
    ///     contain ASCII characters, no conversion or decoding is done on the
    ///     input. It must also start with an ASCII letter.
    /// 
    ///     The scheme describes the type (or protocol) of the URL. It's
    ///     represented by one or more ASCII characters at the start the URL.
    /// 
    ///     A scheme is strictly \l {http://www.ietf.org/rfc/rfc3986.txt} {RFC 3986}-compliant:
    ///         \tt {scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )}
    /// 
    ///     The following example shows a URL where the scheme is "ftp":
    /// 
    ///     \image qurl-authority2.png
    /// 
    ///     To set the scheme, the following call is used:
    ///     \code
    ///         QUrl url;
    ///         url.setScheme("ftp");
    ///     \endcode
    /// 
    ///     The scheme can also be empty, in which case the URL is interpreted
    ///     as relative.
    /// 
    ///     \sa scheme(), isRelative()
    set_scheme(scheme: String),
    ///     Returns the scheme of the URL. If an empty string is returned,
    ///     this means the scheme is undefined and the URL is then relative.
    /// 
    ///     The scheme can only contain US-ASCII letters or digits, which means it
    ///     cannot contain any character that would otherwise require encoding.
    ///     Additionally, schemes are always returned in lowercase form.
    /// 
    ///     \sa setScheme(), isRelative()
    scheme() -> String,
    ///     Sets the authority of the URL to \a authority.
    /// 
    ///     The authority of a URL is the combination of user info, a host
    ///     name and a port. All of these elements are optional; an empty
    ///     authority is therefore valid.
    /// 
    ///     The user info and host are separated by a '@', and the host and
    ///     port are separated by a ':'. If the user info is empty, the '@'
    ///     must be omitted; although a stray ':' is permitted if the port is
    ///     empty.
    /// 
    ///     The following example shows a valid authority string:
    /// 
    ///     \image qurl-authority.png
    /// 
    ///     The \a authority data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode (the default), all characters are accepted in undecoded form
    ///     and the tolerant parser will correct stray '%' not followed by two hex
    ///     characters.
    /// 
    ///     This function does not allow \a mode to be QUrl::DecodedMode. To set fully
    ///     decoded data, call setUserName(), setPassword(), setHost() and setPort()
    ///     individually.
    /// 
    ///     \sa setUserInfo(), setHost(), setPort()
    set_authority(authority: String, mode: Url::ParsingMode),
    ///     Returns the authority of the URL if it is defined; otherwise
    ///     an empty string is returned.
    /// 
    ///     This function returns an unambiguous value, which may contain that
    ///     characters still percent-encoded, plus some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     The \a options argument controls how to format the user info component. The
    ///     value of QUrl::FullyDecoded is not permitted in this function. If you need
    ///     to obtain fully decoded data, call userName(), password(), host() and
    ///     port() individually.
    /// 
    ///     \sa setAuthority(), userInfo(), userName(), password(), host(), port()
    authority(options: Url::ComponentFormattingOptions) -> String,
    ///     Sets the user info of the URL to \a userInfo. The user info is an
    ///     optional part of the authority of the URL, as described in
    ///     setAuthority().
    /// 
    ///     The user info consists of a user name and optionally a password,
    ///     separated by a ':'. If the password is empty, the colon must be
    ///     omitted. The following example shows a valid user info string:
    /// 
    ///     \image qurl-authority3.png
    /// 
    ///     The \a userInfo data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode (the default), all characters are accepted in undecoded form
    ///     and the tolerant parser will correct stray '%' not followed by two hex
    ///     characters.
    /// 
    ///     This function does not allow \a mode to be QUrl::DecodedMode. To set fully
    ///     decoded data, call setUserName() and setPassword() individually.
    /// 
    ///     \sa userInfo(), setUserName(), setPassword(), setAuthority()
    set_user_info(user_info: String, mode: Url::ParsingMode),
    ///     Returns the user info of the URL, or an empty string if the user
    ///     info is undefined.
    /// 
    ///     This function returns an unambiguous value, which may contain that
    ///     characters still percent-encoded, plus some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     The \a options argument controls how to format the user info component. The
    ///     value of QUrl::FullyDecoded is not permitted in this function. If you need
    ///     to obtain fully decoded data, call userName() and password() individually.
    /// 
    ///     \sa setUserInfo(), userName(), password(), authority()
    user_info(options: Url::ComponentFormattingOptions) -> String,
    ///     Sets the URL's user name to \a userName. The \a userName is part
    ///     of the user info element in the authority of the URL, as described
    ///     in setUserInfo().
    /// 
    ///     The \a userName data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode (the default), all characters are accepted in undecoded form
    ///     and the tolerant parser will correct stray '%' not followed by two hex
    ///     characters. In DecodedMode, '%' stand for themselves and encoded characters
    ///     are not possible.
    /// 
    ///     QUrl::DecodedMode should be used when setting the user name from a data
    ///     source which is not a URL, such as a password dialog shown to the user or
    ///     with a user name obtained by calling userName() with the QUrl::FullyDecoded
    ///     formatting option.
    /// 
    ///     \sa userName(), setUserInfo()
    set_user_name(user_name: String, mode: Url::ParsingMode),
    ///     Returns the user name of the URL if it is defined; otherwise
    ///     an empty string is returned.
    /// 
    ///     The \a options argument controls how to format the user name component. All
    ///     values produce an unambiguous result. With QUrl::FullyDecoded, all
    ///     percent-encoded sequences are decoded; otherwise, the returned value may
    ///     contain some percent-encoded sequences for some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     Note that QUrl::FullyDecoded may cause data loss if those non-representable
    ///     sequences are present. It is recommended to use that value when the result
    ///     will be used in a non-URL context, such as setting in QAuthenticator or
    ///     negotiating a login.
    /// 
    ///     \sa setUserName(), userInfo()
    user_name(options: Url::ComponentFormattingOptions) -> String,
    ///     Sets the URL's password to \a password. The \a password is part of
    ///     the user info element in the authority of the URL, as described in
    ///     setUserInfo().
    /// 
    ///     The \a password data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode, all characters are accepted in undecoded form and the
    ///     tolerant parser will correct stray '%' not followed by two hex characters.
    ///     In DecodedMode, '%' stand for themselves and encoded characters are not
    ///     possible.
    /// 
    ///     QUrl::DecodedMode should be used when setting the password from a data
    ///     source which is not a URL, such as a password dialog shown to the user or
    ///     with a password obtained by calling password() with the QUrl::FullyDecoded
    ///     formatting option.
    /// 
    ///     \sa password(), setUserInfo()
    set_password(password: String, mode: Url::ParsingMode),
    ///     Returns the password of the URL if it is defined; otherwise
    ///     an empty string is returned.
    /// 
    ///     The \a options argument controls how to format the user name component. All
    ///     values produce an unambiguous result. With QUrl::FullyDecoded, all
    ///     percent-encoded sequences are decoded; otherwise, the returned value may
    ///     contain some percent-encoded sequences for some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     Note that QUrl::FullyDecoded may cause data loss if those non-representable
    ///     sequences are present. It is recommended to use that value when the result
    ///     will be used in a non-URL context, such as setting in QAuthenticator or
    ///     negotiating a login.
    /// 
    ///     \sa setPassword()
    password(arg0: Url::ComponentFormattingOptions) -> String,
    ///     Sets the host of the URL to \a host. The host is part of the
    ///     authority.
    /// 
    ///     The \a host data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode, all characters are accepted in undecoded form and the
    ///     tolerant parser will correct stray '%' not followed by two hex characters.
    ///     In DecodedMode, '%' stand for themselves and encoded characters are not
    ///     possible.
    /// 
    ///     Note that, in all cases, the result of the parsing must be a valid hostname
    ///     according to STD 3 rules, as modified by the Internationalized Resource
    ///     Identifiers specification (RFC 3987). Invalid hostnames are not permitted
    ///     and will cause isValid() to become false.
    /// 
    ///     \sa host(), setAuthority()
    set_host(host: String, mode: Url::ParsingMode),
    ///     Returns the host of the URL if it is defined; otherwise
    ///     an empty string is returned.
    /// 
    ///     The \a options argument controls how the hostname will be formatted. The
    ///     QUrl::EncodeUnicode option will cause this function to return the hostname
    ///     in the ASCII-Compatible Encoding (ACE) form, which is suitable for use in
    ///     channels that are not 8-bit clean or that require the legacy hostname (such
    ///     as DNS requests or in HTTP request headers). If that flag is not present,
    ///     this function returns the International Domain Name (IDN) in Unicode form,
    ///     according to the list of permissible top-level domains (see
    ///     idnWhitelist()).
    /// 
    ///     All other flags are ignored. Host names cannot contain control or percent
    ///     characters, so the returned value can be considered fully decoded.
    /// 
    ///     \sa setHost(), idnWhitelist(), setIdnWhitelist(), authority()
    host(arg0: Url::ComponentFormattingOptions) -> String,
    ///     \since 4.8
    /// 
    ///     Returns the TLD (Top-Level Domain) of the URL, (e.g. .co.uk, .net).
    ///     Note that the return value is prefixed with a '.' unless the
    ///     URL does not contain a valid TLD, in which case the function returns
    ///     an empty string.
    /// 
    ///     Note that this function considers a TLD to be any domain that allows users
    ///     to register subdomains under, including many home, dynamic DNS websites and
    ///     blogging providers. This is useful for determining whether two websites
    ///     belong to the same infrastructure and communication should be allowed, such
    ///     as browser cookies: two domains should be considered part of the same
    ///     website if they share at least one label in addition to the value
    ///     returned by this function.
    /// 
    ///     \list
    ///       \li \c{foo.co.uk} and \c{foo.com} do not share a top-level domain
    ///       \li \c{foo.co.uk} and \c{bar.co.uk} share the \c{.co.uk} domain, but the next label is different
    ///       \li \c{www.foo.co.uk} and \c{ftp.foo.co.uk} share the same top-level domain and one more label,
    ///           so they are considered part of the same site
    ///     \endlist
    /// 
    ///     If \a options includes EncodeUnicode, the returned string will be in
    ///     ASCII Compatible Encoding.
    top_level_domain(options: Url::ComponentFormattingOptions) -> String,
    ///     Sets the port of the URL to \a port. The port is part of the
    ///     authority of the URL, as described in setAuthority().
    /// 
    ///     \a port must be between 0 and 65535 inclusive. Setting the
    ///     port to -1 indicates that the port is unspecified.
    set_port(port: i32),
    ///     \since 4.1
    /// 
    ///     Returns the port of the URL, or \a defaultPort if the port is
    ///     unspecified.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_io_qurl.cpp 3
    port(default_port: i32) -> i32,
    ///     Sets the path of the URL to \a path. The path is the part of the
    ///     URL that comes after the authority but before the query string.
    /// 
    ///     \image qurl-ftppath.png
    /// 
    ///     For non-hierarchical schemes, the path will be everything
    ///     following the scheme declaration, as in the following example:
    /// 
    ///     \image qurl-mailtopath.png
    /// 
    ///     The \a path data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode, all characters are accepted in undecoded form and the
    ///     tolerant parser will correct stray '%' not followed by two hex characters.
    ///     In DecodedMode, '%' stand for themselves and encoded characters are not
    ///     possible.
    /// 
    ///     QUrl::DecodedMode should be used when setting the path from a data source
    ///     which is not a URL, such as a dialog shown to the user or with a path
    ///     obtained by calling path() with the QUrl::FullyDecoded formatting option.
    /// 
    ///     \sa path()
    set_path(path: String, mode: Url::ParsingMode),
    ///     Returns the path of the URL.
    /// 
    ///     \code
    ///     qDebug() << QUrl("file:file.txt").path();                   // "file.txt"
    ///     qDebug() << QUrl("/home/user/file.txt").path();             // "/home/user/file.txt"
    ///     qDebug() << QUrl("http://www.example.com/test/123").path(); // "/test/123"
    ///     \endcode
    /// 
    ///     The \a options argument controls how to format the path component. All
    ///     values produce an unambiguous result. With QUrl::FullyDecoded, all
    ///     percent-encoded sequences are decoded; otherwise, the returned value may
    ///     contain some percent-encoded sequences for some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     Note that QUrl::FullyDecoded may cause data loss if those non-representable
    ///     sequences are present. It is recommended to use that value when the result
    ///     will be used in a non-URL context, such as sending to an FTP server.
    /// 
    ///     An example of data loss is when you have non-Unicode percent-encoded sequences
    ///     and use FullyDecoded (the default):
    /// 
    ///     \code
    ///     qDebug() << QUrl("/foo%FFbar").path();
    ///     \endcode
    /// 
    ///     In this example, there will be some level of data loss because the \c %FF cannot
    ///     be converted.
    /// 
    ///     Data loss can also occur when the path contains sub-delimiters (such as \c +):
    /// 
    ///     \code
    ///     qDebug() << QUrl("/foo+bar%2B").path(); // "/foo+bar+"
    ///     \endcode
    /// 
    ///     Other decoding examples:
    /// 
    ///     \code
    ///     const QUrl url("/tmp/Mambo %235%3F.mp3");
    ///     qDebug() << url.path(QUrl::FullyDecoded);  // "/tmp/Mambo #5?.mp3"
    ///     qDebug() << url.path(QUrl::PrettyDecoded); // "/tmp/Mambo #5?.mp3"
    ///     qDebug() << url.path(QUrl::FullyEncoded);  // "/tmp/Mambo%20%235%3F.mp3"
    ///     \endcode
    /// 
    ///     \sa setPath()
    path(options: Url::ComponentFormattingOptions) -> String,
    ///     \since 5.2
    /// 
    ///     Returns the name of the file, excluding the directory path.
    /// 
    ///     Note that, if this QUrl object is given a path ending in a slash, the name of the file is considered empty.
    /// 
    ///     If the path doesn't contain any slash, it is fully returned as the fileName.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_io_qurl.cpp 7
    /// 
    ///     The \a options argument controls how to format the file name component. All
    ///     values produce an unambiguous result. With QUrl::FullyDecoded, all
    ///     percent-encoded sequences are decoded; otherwise, the returned value may
    ///     contain some percent-encoded sequences for some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     \sa path()
    file_name(options: Url::ComponentFormattingOptions) -> String,
    ///     \since 4.2
    /// 
    ///     Returns \c true if this URL contains a Query (i.e., if ? was seen on it).
    /// 
    ///     \sa setQuery(), query(), hasFragment()
    has_query() -> bool,
    ///     \overload
    ///     \since 5.0
    ///     Sets the query string of the URL to \a query.
    /// 
    ///     This function reconstructs the query string from the QUrlQuery object and
    ///     sets on this QUrl object. This function does not have parsing parameters
    ///     because the QUrlQuery contains data that is already parsed.
    /// 
    ///     \sa query(), hasQuery()
    set_query(query: String, mode: Url::ParsingMode),
    ///     \overload
    ///     \since 5.0
    ///     Sets the query string of the URL to \a query.
    /// 
    ///     This function reconstructs the query string from the QUrlQuery object and
    ///     sets on this QUrl object. This function does not have parsing parameters
    ///     because the QUrlQuery contains data that is already parsed.
    /// 
    ///     \sa query(), hasQuery()
    set_query(query: &UrlQueryType),
    ///     Returns the query string of the URL if there's a query string, or an empty
    ///     result if not. To determine if the parsed URL contained a query string, use
    ///     hasQuery().
    /// 
    ///     The \a options argument controls how to format the query component. All
    ///     values produce an unambiguous result. With QUrl::FullyDecoded, all
    ///     percent-encoded sequences are decoded; otherwise, the returned value may
    ///     contain some percent-encoded sequences for some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     Note that use of QUrl::FullyDecoded in queries is discouraged, as queries
    ///     often contain data that is supposed to remain percent-encoded, including
    ///     the use of the "%2B" sequence to represent a plus character ('+').
    /// 
    ///     \sa setQuery(), hasQuery()
    query(arg0: Url::ComponentFormattingOptions) -> String,
    ///     \since 4.2
    /// 
    ///     Returns \c true if this URL contains a fragment (i.e., if # was seen on it).
    /// 
    ///     \sa fragment(), setFragment()
    has_fragment() -> bool,
    ///     Returns the fragment of the URL. To determine if the parsed URL contained a
    ///     fragment, use hasFragment().
    /// 
    ///     The \a options argument controls how to format the fragment component. All
    ///     values produce an unambiguous result. With QUrl::FullyDecoded, all
    ///     percent-encoded sequences are decoded; otherwise, the returned value may
    ///     contain some percent-encoded sequences for some control sequences not
    ///     representable in decoded form in QString.
    /// 
    ///     Note that QUrl::FullyDecoded may cause data loss if those non-representable
    ///     sequences are present. It is recommended to use that value when the result
    ///     will be used in a non-URL context.
    /// 
    ///     \sa setFragment(), hasFragment()
    fragment(options: Url::ComponentFormattingOptions) -> String,
    ///     Sets the fragment of the URL to \a fragment. The fragment is the
    ///     last part of the URL, represented by a '#' followed by a string of
    ///     characters. It is typically used in HTTP for referring to a
    ///     certain link or point on a page:
    /// 
    ///     \image qurl-fragment.png
    /// 
    ///     The fragment is sometimes also referred to as the URL "reference".
    /// 
    ///     Passing an argument of QString() (a null QString) will unset the fragment.
    ///     Passing an argument of QString("") (an empty but not null QString) will set the
    ///     fragment to an empty string (as if the original URL had a lone "#").
    /// 
    ///     The \a fragment data is interpreted according to \a mode: in StrictMode,
    ///     any '%' characters must be followed by exactly two hexadecimal characters
    ///     and some characters (including space) are not allowed in undecoded form. In
    ///     TolerantMode, all characters are accepted in undecoded form and the
    ///     tolerant parser will correct stray '%' not followed by two hex characters.
    ///     In DecodedMode, '%' stand for themselves and encoded characters are not
    ///     possible.
    /// 
    ///     QUrl::DecodedMode should be used when setting the fragment from a data
    ///     source which is not a URL or with a fragment obtained by calling
    ///     fragment() with the QUrl::FullyDecoded formatting option.
    /// 
    ///     \sa fragment(), hasFragment()
    set_fragment(fragment: String, mode: Url::ParsingMode),
    ///     Returns the result of the merge of this URL with \a relative. This
    ///     URL is used as a base to convert \a relative to an absolute URL.
    /// 
    ///     If \a relative is not a relative URL, this function will return \a
    ///     relative directly. Otherwise, the paths of the two URLs are
    ///     merged, and the new URL returned has the scheme and authority of
    ///     the base URL, but with the merged path, as in the following
    ///     example:
    /// 
    ///     \snippet code/src_corelib_io_qurl.cpp 5
    /// 
    ///     Calling resolved() with ".." returns a QUrl whose directory is
    ///     one level higher than the original. Similarly, calling resolved()
    ///     with "../.." removes two levels from the path. If \a relative is
    ///     "/", the path becomes "/".
    /// 
    ///     \sa isRelative()
    resolved(relative: &UrlType) -> Url,
    ///     Returns \c true if the URL is relative; otherwise returns \c false. A URL is
    ///     relative reference if its scheme is undefined; this function is therefore
    ///     equivalent to calling scheme().isEmpty().
    /// 
    ///     Relative references are defined in RFC 3986 section 4.2.
    /// 
    ///     \sa {Relative URLs vs Relative Paths}
    is_relative() -> bool,
    ///     Returns \c true if this URL is a parent of \a childUrl. \a childUrl is a child
    ///     of this URL if the two URLs share the same scheme and authority,
    ///     and this URL's path is a parent of the path of \a childUrl.
    is_parent_of(url: &UrlType) -> bool,
    ///     \since 4.8
    ///     Returns \c true if this URL is pointing to a local file path. A URL is a
    ///     local file path if the scheme is "file".
    /// 
    ///     Note that this function considers URLs with hostnames to be local file
    ///     paths, even if the eventual file path cannot be opened with
    ///     QFile::open().
    /// 
    ///     \sa fromLocalFile(), toLocalFile()
    is_local_file() -> bool,
    ///     Returns a QUrl representation of \a localFile, interpreted as a local
    ///     file. This function accepts paths separated by slashes as well as the
    ///     native separator for this platform.
    /// 
    ///     This function also accepts paths with a doubled leading slash (or
    ///     backslash) to indicate a remote file, as in
    ///     "//servername/path/to/file.txt". Note that only certain platforms can
    ///     actually open this file using QFile::open().
    /// 
    ///     An empty \a localFile leads to an empty URL (since Qt 5.4).
    /// 
    ///     \code
    ///     qDebug() << QUrl::fromLocalFile("file.txt");            // QUrl("file:file.txt")
    ///     qDebug() << QUrl::fromLocalFile("/home/user/file.txt"); // QUrl("file:///home/user/file.txt")
    ///     qDebug() << QUrl::fromLocalFile("file:file.txt");       // doesn't make sense; expects path, not url with scheme
    ///     \endcode
    /// 
    ///     In the first line in snippet above, a file URL is constructed from a
    ///     local, relative path. A file URL with a relative path only makes sense
    ///     if there is a base URL to resolve it against. For example:
    /// 
    ///     \code
    ///     QUrl url = QUrl::fromLocalFile("file.txt");
    ///     QUrl baseUrl = QUrl("file:/home/user/");
    ///     // wrong: prints QUrl("file:file.txt"), as url already has a scheme
    ///     qDebug() << baseUrl.resolved(url);
    ///     \endcode
    /// 
    ///     To resolve such a URL, it's necessary to remove the scheme beforehand:
    /// 
    ///     \code
    ///     // correct: prints QUrl("file:///home/user/file.txt")
    ///     url.setScheme(QString());
    ///     qDebug() << baseUrl.resolved(url);
    ///     \endcode
    /// 
    ///     For this reason, it is better to use a relative URL (that is, no scheme)
    ///     for relative file paths:
    /// 
    ///     \code
    ///     QUrl url = QUrl("file.txt");
    ///     QUrl baseUrl = QUrl("file:/home/user/");
    ///     // prints QUrl("file:///home/user/file.txt")
    ///     qDebug() << baseUrl.resolved(url);
    ///     \endcode
    /// 
    ///     \sa toLocalFile(), isLocalFile(), QDir::toNativeSeparators()
    [static] from_local_file(localfile: String) -> Url,
    ///     Returns the path of this URL formatted as a local file path. The path
    ///     returned will use forward slashes, even if it was originally created
    ///     from one with backslashes.
    /// 
    ///     If this URL contains a non-empty hostname, it will be encoded in the
    ///     returned value in the form found on SMB networks (for example,
    ///     "//servername/path/to/file.txt").
    /// 
    ///     \code
    ///     qDebug() << QUrl("file:file.txt").toLocalFile();            // "file:file.txt"
    ///     qDebug() << QUrl("file:/home/user/file.txt").toLocalFile(); // "file:///home/user/file.txt"
    ///     qDebug() << QUrl("file.txt").toLocalFile();                 // ""; wasn't a local file as it had no scheme
    ///     \endcode
    /// 
    ///     Note: if the path component of this URL contains a non-UTF-8 binary
    ///     sequence (such as %80), the behaviour of this function is undefined.
    /// 
    ///     \sa fromLocalFile(), isLocalFile()
    to_local_file() -> String,
    ///     \internal
    /// 
    ///     Forces a detach.
    detach(),
    ///     \internal
    is_detached() -> bool,
    ///     \since 5.2
    /// 
    ///     Returns \c true if this URL and the given \a url are equal after
    ///     applying \a options to both; otherwise returns \c false.
    /// 
    ///     This is equivalent to calling adjusted(options) on both URLs
    ///     and comparing the resulting urls, but faster.
    /// 
    matches(url: &UrlType, options: Url::FormattingOptions) -> bool,
    ///     Returns a decoded copy of \a input. \a input is first decoded from
    ///     percent encoding, then converted from UTF-8 to unicode.
    /// 
    ///     \note Given invalid input (such as a string containing the sequence "%G5",
    ///     which is not a valid hexadecimal number) the output will be invalid as
    ///     well. As an example: the sequence "%G5" could be decoded to 'W'.
    [static] from_percent_encoding(arg0: &ByteArrayType) -> String,
    ///     Returns an encoded copy of \a input. \a input is first converted
    ///     to UTF-8, and all ASCII-characters that are not in the unreserved group
    ///     are percent encoded. To prevent characters from being percent encoded
    ///     pass them to \a exclude. To force characters to be percent encoded pass
    ///     them to \a include.
    /// 
    ///     Unreserved is defined as:
    ///        \tt {ALPHA / DIGIT / "-" / "." / "_" / "~"}
    /// 
    ///     \snippet code/src_corelib_io_qurl.cpp 6
    [static] to_percent_encoding(arg0: String, exclude: &ByteArrayType, include: &ByteArrayType) -> ByteArray,
    ///     \since 4.2
    /// 
    ///     Returns the Unicode form of the given domain name
    ///     \a domain, which is encoded in the ASCII Compatible Encoding (ACE).
    ///     The result of this function is considered equivalent to \a domain.
    /// 
    ///     If the value in \a domain cannot be encoded, it will be converted
    ///     to QString and returned.
    /// 
    ///     The ASCII Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491
    ///     and RFC 3492. It is part of the Internationalizing Domain Names in
    ///     Applications (IDNA) specification, which allows for domain names
    ///     (like \c "example.com") to be written using international
    ///     characters.
    [static] from_ace(arg0: &ByteArrayType) -> String,
    ///     \since 4.2
    /// 
    ///     Returns the ASCII Compatible Encoding of the given domain name \a domain.
    ///     The result of this function is considered equivalent to \a domain.
    /// 
    ///     The ASCII-Compatible Encoding (ACE) is defined by RFC 3490, RFC 3491
    ///     and RFC 3492. It is part of the Internationalizing Domain Names in
    ///     Applications (IDNA) specification, which allows for domain names
    ///     (like \c "example.com") to be written using international
    ///     characters.
    /// 
    ///     This function returns an empty QByteArray if \a domain is not a valid
    ///     hostname. Note, in particular, that IPv6 literals are not valid domain
    ///     names.
    [static] to_ace(arg0: String) -> ByteArray,
    ///     \since 4.2
    /// 
    ///     Returns the current whitelist of top-level domains that are allowed
    ///     to have non-ASCII characters in their compositions.
    /// 
    ///     See setIdnWhitelist() for the rationale of this list.
    [static] idn_whitelist() -> [String],
    ///     \since 4.2
    /// 
    ///     Sets the whitelist of Top-Level Domains (TLDs) that are allowed to have
    ///     non-ASCII characters in domains to the value of \a list.
    /// 
    ///     Note that if you call this function, you need to do so \e before
    ///     you start any threads that might access idnWhitelist().
    /// 
    ///     Qt comes with a default list that contains the Internet top-level domains
    ///     that have published support for Internationalized Domain Names (IDNs)
    ///     and rules to guarantee that no deception can happen between similarly-looking
    ///     characters (such as the Latin lowercase letter \c 'a' and the Cyrillic
    ///     equivalent, which in most fonts are visually identical).
    /// 
    ///     This list is periodically maintained, as registrars publish new rules.
    /// 
    ///     This function is provided for those who need to manipulate the list, in
    ///     order to add or remove a TLD. It is not recommended to change its value
    ///     for purposes other than testing, as it may expose users to security risks.
    [static] set_idn_whitelist(arg0: &[String]),
}

// vim: syntax=rust expandtab ts=4 sw=4
