/// 
/// A color is normally specified in terms of RGB (red, green, and
/// blue) components, but it is also possible to specify it in terms
/// of HSV (hue, saturation, and value) and CMYK (cyan, magenta,
/// yellow and black) components. In addition a color can be specified
/// using a color name. The color name can be any of the SVG 1.0 color
/// names.
/// 
/// * RGB
/// * HSV
/// * CMYK
/// 
/// * ![qcolor-rgb.png](qcolor-rgb.png)
/// 
/// * ![qcolor-hsv.png](qcolor-hsv.png)
/// 
/// * ![qcolor-cmyk.png](qcolor-cmyk.png)
/// 
/// The QColor constructor creates the color based on RGB values. To
/// create a QColor based on either HSV or CMYK values, use the
/// toHsv() and toCmyk() functions respectively. These functions
/// return a copy of the color using the desired format. In addition
/// the static fromRgb(), fromHsv() and fromCmyk() functions create
/// colors from the specified values. Alternatively, a color can be
/// converted to any of the three formats using the convertTo()
/// function (returning a copy of the color in the desired format), or
/// any of the setRgb(), setHsv() and setCmyk() functions altering *this* color's format. The spec() function tells how the color was
/// specified.
/// 
/// A color can be set by passing an RGB string (such as ),
/// or an ARGB string (such as ) or a color name (such as ),
/// to the setNamedColor() function.
/// The color names are taken from the SVG 1.0 color names. The name()
/// function returns the name of the color in the format
/// . Colors can also be set using setRgb(), setHsv() and
/// setCmyk(). To get a lighter or darker color use the lighter() and
/// darker() functions respectively.
/// 
/// The isValid() function indicates whether a QColor is legal at
/// all. For example, a RGB color with RGB values out of range is
/// illegal. For performance reasons, QColor mostly disregards illegal
/// colors, and for that reason, the result of using an invalid color
/// is undefined.
/// 
/// The color components can be retrieved individually, e.g with
/// red(), hue() and cyan(). The values of the color components can
/// also be retrieved in one go using the getRgb(), getHsv() and
/// getCmyk() functions. Using the RGB color model, the color
/// components can in addition be accessed with rgb().
/// 
/// There are several related non-members: QRgb is a typdef for an
/// unsigned int representing the RGB value triplet (r, g, b). Note
/// that it also can hold a value for the alpha-channel (for more
/// information, see the [Alpha-Blended Drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
/// section). The qRed(), qBlue() and
/// qGreen() functions return the respective component of the given
/// QRgb value, while the qRgb() and qRgba() functions create and
/// return the QRgb triplet based on the given component
/// values. Finally, the qAlpha() function returns the alpha component
/// of the provided QRgb, and the qGray() function calculates and
/// return a gray value based on the given value.
/// 
/// QColor is platform and device independent. The QColormap class
/// maps the color to the hardware.
/// 
/// For more information about painting in general, see the [Paint
/// System](Paint%0A%20%20%20%20System)
/// documentation.
/// 
/// # Integer vs. Floating Point Precision
/// 
/// QColor supports floating point precision and provides floating
/// point versions of all the color components functions,
/// e.g. getRgbF(), hueF() and fromCmykF(). Note that since the
/// components are stored using 16-bit integers, there might be minor
/// deviations between the values set using, for example, setRgbF()
/// and the values returned by the getRgbF() function due to rounding.
/// 
/// While the integer based functions take values in the range 0-255
/// (except hue() which must have values within the range 0-359),
/// the floating point functions accept values in the range 0.0 - 1.0.
/// 
/// # Alpha-Blended Drawing
/// 
/// QColor also support alpha-blended outlining and filling. The
/// alpha channel of a color specifies the transparency effect, 0
/// represents a fully transparent color, while 255 represents a fully
/// opaque color. For example:
/// 
/// The code above produces the following output:
/// 
/// ![alphafill.png](alphafill.png)
/// 
/// The alpha channel of a color can be retrieved and set using the
/// alpha() and setAlpha() functions if its value is an integer, and
/// alphaF() and setAlphaF() if its value is qreal (double). By
/// default, the alpha-channel is set to 255 (opaque). To retrieve and
/// set *all* the RGB color components (including the alpha-channel)
/// in one go, use the rgba() and setRgba() functions.
/// 
/// # Predefined Colors
/// 
/// There are 20 predefined QColors described by the Qt::GlobalColor enum,
/// including black, white, primary and secondary colors, darker versions
/// of these colors and three shades of gray. QColor also recognizes a
/// variety of color names; the static colorNames() function returns a
/// QStringList color names that QColor knows about.
/// 
/// ![Qt Colors](qt-colors.png)
/// 
/// Additionally, the Qt::color0, Qt::color1 and Qt::transparent colors
/// are used for special purposes.
/// 
/// Qt::color0 (zero pixel value) and Qt::color1 (non-zero pixel value)
/// are special colors for drawing in QBitmaps. Painting with Qt::color0
/// sets the bitmap bits to 0 (transparent; i.e., background), and painting
/// with Qt::color1 sets the bits to 1 (opaque; i.e., foreground).
/// 
/// Qt::transparent is used to indicate a transparent pixel. When painting
/// with this value, a pixel value will be used that is appropriate for the
/// underlying pixel format in use.
/// 
/// # The HSV Color Model
/// 
/// The RGB model is hardware-oriented. Its representation is close to
/// what most monitors show. In contrast, HSV represents color in a way
/// more suited to the human perception of color. For example, the
/// relationships , , and
/// are easily expressed in HSV but are much harder to express in RGB.
/// 
/// HSV, like RGB, has three components:
/// 
/// * H, for hue, is in the range 0 to 359 if the color is chromatic (not gray), or meaningless if it is gray. It represents degrees on the color wheel familiar to most people. Red is 0 (degrees), green is 120, and blue is 240. ![qcolor-hue.png](qcolor-hue.png)
/// 
/// * S, for saturation, is in the range 0 to 255, and the bigger it is, the stronger the color is. Grayish colors have saturation near 0; very strong colors have saturation near 255. ![qcolor-saturation.png](qcolor-saturation.png)
/// 
/// * V, for value, is in the range 0 to 255 and represents lightness or brightness of the color. 0 is black; 255 is as far from black as possible. ![qcolor-value.png](qcolor-value.png)
/// 
/// Here are some examples: pure red is H=0, S=255, V=255; a dark red,
/// moving slightly towards the magenta, could be H=350 (equivalent to
/// -10), S=255, V=180; a grayish light red could have H about 0 (say
/// 350-359 or 0-10), S about 50-100, and S=255.
/// 
/// Qt returns a hue value of -1 for achromatic colors. If you pass a
/// hue value that is too large, Qt forces it into range. Hue 360 or 720 is
/// treated as 0; hue 540 is treated as 180.
/// 
/// In addition to the standard HSV model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
/// 
/// 
/// # The HSL Color Model
/// 
/// HSL is similar to HSV, however instead of the Value parameter, HSL
/// specifies a Lightness parameter.
/// 
/// # The CMYK Color Model
/// 
/// While the RGB and HSV color models are used for display on
/// computer monitors, the CMYK model is used in the four-color
/// printing process of printing presses and some hard-copy
/// devices.
/// 
/// CMYK has four components, all in the range 0-255: cyan (C),
/// magenta (M), yellow (Y) and black (K). Cyan, magenta and yellow
/// are called subtractive colors; the CMYK color model creates color
/// by starting with a white surface and then subtracting color by
/// applying the appropriate components. While combining cyan, magenta
/// and yellow gives the color black, subtracting one or more will
/// yield any other color. When combined in various percentages, these
/// three colors can create the entire spectrum of colors.
/// 
/// Mixing 100 percent of cyan, magenta and yellow *does* produce
/// black, but the result is unsatisfactory since it wastes ink,
/// increases drying time, and gives a muddy colour when printing. For
/// that reason, black is added in professional printing to provide a
/// solid black tone; hence the term 'four color process'.
/// 
/// In addition to the standard CMYK model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
/// 
/// 
/// **See also:** QPalette
/// QBrush
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QColor)]
enum Spec {
    Invalid,
    Rgb,
    Hsv,
    Cmyk,
    Hsl,
}

[org_name(QColor)]
enum NameFormat {
    HexRgb,
    HexArgb,
}


struct Color {
    /// 
    /// Returns `true` if the color is valid; otherwise returns `false.`
    /// 
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    /// 
    /// It uses the same algorithm used in setNamedColor().
    /// 
    /// **See also:** setNamedColor()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    is_valid() -> bool,
    /// 
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    /// 
    /// **See also:** setNamedColor()
    /// 
    /// Returns the name of the color in the specified *format.*
    /// 
    /// **See also:** setNamedColor()
    /// NameFormat
    name() -> String,
    /// 
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    /// 
    /// **See also:** setNamedColor()
    /// 
    /// Returns the name of the color in the specified *format.*
    /// 
    /// **See also:** setNamedColor()
    /// NameFormat
    name(format: Color::NameFormat) -> String,
    /// 
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    /// 
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    /// 
    /// The color is invalid if *name* cannot be parsed.
    /// 
    /// **See also:** QColor()
    /// name()
    /// isValid()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_named_color(name: String),
    /// 
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    /// 
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    /// 
    /// The color is invalid if *name* cannot be parsed.
    /// 
    /// **See also:** QColor()
    /// name()
    /// isValid()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_named_color(name: StringViewType),
    /// 
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    /// 
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    /// 
    /// The color is invalid if *name* cannot be parsed.
    /// 
    /// **See also:** QColor()
    /// name()
    /// isValid()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_named_color(name: Latin1StringType),
    /// 
    /// Returns a QStringList containing the color names Qt knows about.
    /// 
    /// **See also:** {QColor#Predefined Colors}{Predefined Colors}
    [static] color_names() -> [String],
    /// 
    /// Returns how the color was specified.
    /// 
    /// **See also:** Spec
    /// convertTo()
    spec() -> Color::Spec,
    /// 
    /// Returns the alpha color component of this color.
    /// 
    /// **See also:** setAlpha()
    /// alphaF()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    /// 
    /// Returns the alpha color component of this color.
    /// 
    /// **See also:** setAlphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    alpha() -> i32,
    /// 
    /// Sets the alpha of this color to *alpha.* Integer alpha is specified in the
    /// range 0-255.
    /// 
    /// **See also:** alpha()
    /// alphaF()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    /// 
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    /// 
    /// **See also:** alphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    /// 
    set_alpha(alpha: i32),
    /// 
    /// Returns the alpha color component of this color.
    /// 
    /// **See also:** setAlphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    alpha_f() -> f32,
    /// 
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    /// 
    /// **See also:** alphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    /// 
    set_alpha_f(alpha: f32),
    /// 
    /// Returns the red color component of this color.
    /// 
    /// **See also:** setRed()
    /// redF()
    /// getRgb()
    /// 
    /// Returns the red color component of this color.
    /// 
    /// **See also:** setRedF()
    /// red()
    /// getRgbF()
    red() -> i32,
    /// 
    /// Returns the green color component of this color.
    /// 
    /// **See also:** setGreen()
    /// greenF()
    /// getRgb()
    /// 
    /// Returns the green color component of this color.
    /// 
    /// **See also:** setGreenF()
    /// green()
    /// getRgbF()
    green() -> i32,
    /// 
    /// Returns the blue color component of this color.
    /// 
    /// **See also:** setBlue()
    /// blueF()
    /// getRgb()
    /// 
    /// Returns the blue color component of this color.
    /// 
    /// **See also:** setBlueF()
    /// blue()
    /// getRgbF()
    blue() -> i32,
    /// 
    /// Sets the red color component of this color to *red.* Integer components
    /// are specified in the range 0-255.
    /// 
    /// **See also:** red()
    /// redF()
    /// setRgb()
    /// 
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    /// 
    /// **See also:** redF()
    /// red()
    /// setRgbF()
    set_red(red: i32),
    /// 
    /// Sets the green color component of this color to *green.* Integer
    /// components are specified in the range 0-255.
    /// 
    /// **See also:** green()
    /// greenF()
    /// setRgb()
    /// 
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    /// 
    /// **See also:** greenF()
    /// green()
    /// setRgbF()
    set_green(green: i32),
    /// 
    /// Sets the blue color component of this color to *blue.* Integer components
    /// are specified in the range 0-255.
    /// 
    /// **See also:** blue()
    /// blueF()
    /// setRgb()
    /// 
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    /// 
    /// **See also:** blueF()
    /// blue()
    /// setRgbF()
    set_blue(blue: i32),
    /// 
    /// Returns the red color component of this color.
    /// 
    /// **See also:** setRedF()
    /// red()
    /// getRgbF()
    red_f() -> f32,
    /// 
    /// Returns the green color component of this color.
    /// 
    /// **See also:** setGreenF()
    /// green()
    /// getRgbF()
    green_f() -> f32,
    /// 
    /// Returns the blue color component of this color.
    /// 
    /// **See also:** setBlueF()
    /// blue()
    /// getRgbF()
    blue_f() -> f32,
    /// 
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    /// 
    /// **See also:** redF()
    /// red()
    /// setRgbF()
    set_red_f(red: f32),
    /// 
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    /// 
    /// **See also:** greenF()
    /// green()
    /// setRgbF()
    set_green_f(green: f32),
    /// 
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    /// 
    /// **See also:** blueF()
    /// blue()
    /// setRgbF()
    set_blue_f(blue: f32),
    /// 
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    /// 
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    /// 
    /// **See also:** rgb()
    /// setRgb()
    /// 
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    /// 
    /// These components can be retrieved individually using the red(), green(),
    /// blue() and alpha() functions.
    /// 
    /// **See also:** rgb()
    /// setRgb()
    get_rgb(r: *i32, g: *i32, b: *i32, a: *i32),
    /// 
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    /// 
    /// All values must be in the range 0.0-1.0.
    /// 
    /// **See also:** rgb()
    /// getRgbF()
    /// setRgb()
    /// 
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    /// 
    /// All the values must be in the range 0-255.
    /// 
    /// **See also:** rgb()
    /// getRgb()
    /// setRgbF()
    /// 
    /// Sets the RGB value to *rgba,* including its alpha.
    /// 
    /// **See also:** rgba()
    /// rgb()
    /// setRgba64()
    /// 
    /// Sets the RGB64 value to *rgba,* including its alpha.
    /// 
    /// **See also:** \setRgba()
    /// rgba64()
    /// 
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    set_rgb(r: i32, g: i32, b: i32, a: i32),
    /// 
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    /// 
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    /// 
    /// **See also:** rgb()
    /// setRgb()
    get_rgb_f(r: *f32, g: *f32, b: *f32, a: *f32),
    /// 
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    /// 
    /// All values must be in the range 0.0-1.0.
    /// 
    /// **See also:** rgb()
    /// getRgbF()
    /// setRgb()
    set_rgb_f(r: f32, g: f32, b: f32, a: f32),
    /// 
    /// Returns the RGB64 value of the color, including its alpha.
    /// 
    /// For an invalid color, the alpha value of the returned color is unspecified.
    /// 
    /// **See also:** setRgba64()
    /// rgba()
    /// rgb()
    rgba64() -> Rgba64,
    /// 
    /// Sets the RGB64 value to *rgba,* including its alpha.
    /// 
    /// **See also:** \setRgba()
    /// rgba64()
    set_rgba64(rgba: Rgba64Type),
    /// 
    /// Returns the RGB value of the color, including its alpha.
    /// 
    /// For an invalid color, the alpha value of the returned color is unspecified.
    /// 
    /// **See also:** setRgba()
    /// rgb()
    /// rgba64()
    /// 
    /// Returns the RGB64 value of the color, including its alpha.
    /// 
    /// For an invalid color, the alpha value of the returned color is unspecified.
    /// 
    /// **See also:** setRgba64()
    /// rgba()
    /// rgb()
    rgba() -> Rgb,
    /// 
    /// Sets the RGB value to *rgba,* including its alpha.
    /// 
    /// **See also:** rgba()
    /// rgb()
    /// setRgba64()
    /// 
    /// Sets the RGB64 value to *rgba,* including its alpha.
    /// 
    /// **See also:** \setRgba()
    /// rgba64()
    set_rgba(rgba: RgbType),
    /// 
    /// Returns the RGB value of the color, including its alpha.
    /// 
    /// For an invalid color, the alpha value of the returned color is unspecified.
    /// 
    /// **See also:** setRgba()
    /// rgb()
    /// rgba64()
    /// 
    /// Returns the RGB64 value of the color, including its alpha.
    /// 
    /// For an invalid color, the alpha value of the returned color is unspecified.
    /// 
    /// **See also:** setRgba64()
    /// rgba()
    /// rgb()
    /// 
    /// Returns the RGB value of the color. The alpha value is opaque.
    /// 
    /// **See also:** getRgb()
    /// rgba()
    rgb() -> Rgb,
    /// 
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    /// 
    /// All values must be in the range 0.0-1.0.
    /// 
    /// **See also:** rgb()
    /// getRgbF()
    /// setRgb()
    /// 
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    /// 
    /// All the values must be in the range 0-255.
    /// 
    /// **See also:** rgb()
    /// getRgb()
    /// setRgbF()
    /// 
    /// Sets the RGB value to *rgba,* including its alpha.
    /// 
    /// **See also:** rgba()
    /// rgb()
    /// setRgba64()
    /// 
    /// Sets the RGB64 value to *rgba,* including its alpha.
    /// 
    /// **See also:** \setRgba()
    /// rgba64()
    /// 
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    set_rgb(rgb: RgbType),
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// The color is implicitly converted to HSV.
    /// 
    /// **See also:** hsvHue()
    /// hueF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// The color is implicitly converted to HSV.
    /// 
    /// **See also:** hsvHueF()
    /// hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hue() -> i32,
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// The color is implicitly converted to HSV.
    /// 
    /// **See also:** hsvSaturation()
    /// saturationF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// The color is implicitly converted to HSV.
    /// 
    /// **See also:** hsvSaturationF()
    /// saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    saturation() -> i32,
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// **See also:** hueF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// **See also:** hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    hsv_hue() -> i32,
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// **See also:** saturationF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// **See also:** saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hsv_saturation() -> i32,
    /// 
    /// Returns the value color component of this color.
    /// 
    /// **See also:** valueF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Returns the value color component of this color.
    /// 
    /// **See also:** value()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    value() -> i32,
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// The color is implicitly converted to HSV.
    /// 
    /// **See also:** hsvHueF()
    /// hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hue_f() -> f32,
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// The color is implicitly converted to HSV.
    /// 
    /// **See also:** hsvSaturationF()
    /// saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    saturation_f() -> f32,
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// **See also:** hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    hsv_hue_f() -> f32,
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// **See also:** saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hsv_saturation_f() -> f32,
    /// 
    /// Returns the value color component of this color.
    /// 
    /// **See also:** value()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    value_f() -> f32,
    /// 
    /// Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    /// saturation, value, and alpha-channel (transparency) components of the
    /// color's HSV value.
    /// 
    /// These components can be retrieved individually using the hueF(),
    /// saturationF(), valueF() and alphaF() functions.
    /// 
    /// **See also:** setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    /// saturation, value, and alpha-channel (transparency) components of the
    /// color's HSV value.
    /// 
    /// These components can be retrieved individually using the hue(),
    /// saturation(), value() and alpha() functions.
    /// 
    /// **See also:** setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    get_hsv(h: *i32, s: *i32, v: *i32, a: *i32),
    /// 
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** getHsvF()
    /// setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    /// 
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    /// 
    /// **See also:** getHsv()
    /// setHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    set_hsv(h: i32, s: i32, v: i32, a: i32),
    /// 
    /// Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    /// saturation, value, and alpha-channel (transparency) components of the
    /// color's HSV value.
    /// 
    /// These components can be retrieved individually using the hueF(),
    /// saturationF(), valueF() and alphaF() functions.
    /// 
    /// **See also:** setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    get_hsv_f(h: *f32, s: *f32, v: *f32, a: *f32),
    /// 
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** getHsvF()
    /// setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    set_hsv_f(h: f32, s: f32, v: f32, a: f32),
    /// 
    /// Returns the cyan color component of this color.
    /// 
    /// **See also:** cyanF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// Returns the cyan color component of this color.
    /// 
    /// **See also:** cyan()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    cyan() -> i32,
    /// 
    /// Returns the magenta color component of this color.
    /// 
    /// **See also:** magentaF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// Returns the magenta color component of this color.
    /// 
    /// **See also:** magenta()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    magenta() -> i32,
    /// 
    /// Returns the yellow color component of this color.
    /// 
    /// **See also:** yellowF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// Returns the yellow color component of this color.
    /// 
    /// **See also:** yellow()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    yellow() -> i32,
    /// 
    /// Returns the black color component of this color.
    /// 
    /// **See also:** blackF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// 
    /// Returns the black color component of this color.
    /// 
    /// **See also:** black()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    black() -> i32,
    /// 
    /// Returns the cyan color component of this color.
    /// 
    /// **See also:** cyan()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    cyan_f() -> f32,
    /// 
    /// Returns the magenta color component of this color.
    /// 
    /// **See also:** magenta()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    magenta_f() -> f32,
    /// 
    /// Returns the yellow color component of this color.
    /// 
    /// **See also:** yellow()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    yellow_f() -> f32,
    /// 
    /// Returns the black color component of this color.
    /// 
    /// **See also:** black()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    black_f() -> f32,
    /// 
    /// Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    /// cyan, magenta, yellow, black, and alpha-channel (transparency) components
    /// of the color's CMYK value.
    /// 
    /// These components can be retrieved individually using the cyan(), magenta(),
    /// yellow(), black() and alpha() functions.
    /// 
    /// **See also:** setCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    /// cyan, magenta, yellow, black, and alpha-channel (transparency) components
    /// of the color's CMYK value.
    /// 
    /// These components can be retrieved individually using the cyanF(),
    /// magentaF(), yellowF(), blackF() and alphaF() functions.
    /// 
    /// **See also:** setCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    get_cmyk(c: *i32, m: *i32, y: *i32, k: *i32, a: *i32),
    /// 
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0-255.
    /// 
    /// **See also:** getCmyk()
    /// setCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** getCmykF()
    /// setCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    set_cmyk(c: i32, m: i32, y: i32, k: i32, a: i32),
    /// 
    /// Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    /// cyan, magenta, yellow, black, and alpha-channel (transparency) components
    /// of the color's CMYK value.
    /// 
    /// These components can be retrieved individually using the cyanF(),
    /// magentaF(), yellowF(), blackF() and alphaF() functions.
    /// 
    /// **See also:** setCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    get_cmyk_f(c: *f32, m: *f32, y: *f32, k: *f32, a: *f32),
    /// 
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** getCmykF()
    /// setCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    set_cmyk_f(c: f32, m: f32, y: f32, k: f32, a: f32),
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// **See also:** getHslF()
    /// getHsl()
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// **See also:** hue()
    /// getHslF()
    hsl_hue() -> i32,
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// **See also:** saturationF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// **See also:** saturationF()
    /// getHslF()
    hsl_saturation() -> i32,
    /// 
    /// Returns the lightness color component of this color.
    /// 
    /// **See also:** lightnessF()
    /// getHsl()
    /// 
    /// Returns the lightness color component of this color.
    /// 
    /// **See also:** value()
    /// getHslF()
    lightness() -> i32,
    /// 
    /// Returns the hue color component of this color.
    /// 
    /// **See also:** hue()
    /// getHslF()
    hsl_hue_f() -> f32,
    /// 
    /// Returns the saturation color component of this color.
    /// 
    /// **See also:** saturationF()
    /// getHslF()
    hsl_saturation_f() -> f32,
    /// 
    /// Returns the lightness color component of this color.
    /// 
    /// **See also:** value()
    /// getHslF()
    lightness_f() -> f32,
    /// 
    /// Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    /// saturation, lightness, and alpha-channel (transparency) components of the
    /// color's HSL value.
    /// 
    /// These components can be retrieved individually using the hslHueF(),
    /// hslSaturationF(), lightnessF() and alphaF() functions.
    /// 
    /// **See also:** setHsl()
    /// 
    /// Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    /// saturation, lightness, and alpha-channel (transparency) components of the
    /// color's HSL value.
    /// 
    /// These components can be retrieved individually using the hslHue(),
    /// hslSaturation(), lightness() and alpha() functions.
    /// 
    /// **See also:** setHsl()
    get_hsl(h: *i32, s: *i32, l: *i32, a: *i32),
    /// 
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** getHslF()
    /// setHsl()
    /// 
    /// Sets a HSL color value; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    /// 
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    /// 
    /// **See also:** getHsl()
    /// setHslF()
    set_hsl(h: i32, s: i32, l: i32, a: i32),
    /// 
    /// Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    /// saturation, lightness, and alpha-channel (transparency) components of the
    /// color's HSL value.
    /// 
    /// These components can be retrieved individually using the hslHueF(),
    /// hslSaturationF(), lightnessF() and alphaF() functions.
    /// 
    /// **See also:** setHsl()
    get_hsl_f(h: *f32, s: *f32, l: *f32, a: *f32),
    /// 
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** getHslF()
    /// setHsl()
    set_hsl_f(h: f32, s: f32, l: f32, a: f32),
    /// 
    /// Create and returns an RGB QColor based on this color.
    /// 
    /// **See also:** fromRgb()
    /// convertTo()
    /// isValid()
    to_rgb() -> Color,
    /// 
    /// Creates and returns an HSV QColor based on this color.
    /// 
    /// **See also:** fromHsv()
    /// convertTo()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    to_hsv() -> Color,
    /// 
    /// Creates and returns a CMYK QColor based on this color.
    /// 
    /// **See also:** fromCmyk()
    /// convertTo()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    to_cmyk() -> Color,
    /// 
    /// Creates and returns an HSL QColor based on this color.
    /// 
    /// **See also:** fromHsl()
    /// convertTo()
    /// isValid()
    to_hsl() -> Color,
    /// 
    /// Creates a copy of *this* color in the format specified by *colorSpec.*
    /// 
    /// **See also:** spec()
    /// toCmyk()
    /// toHsv()
    /// toRgb()
    /// isValid()
    convert_to(color_spec: Color::Spec) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    /// 
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    /// 
    /// **See also:** fromRgba()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    /// 
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    /// 
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0-255.
    /// 
    /// **See also:** toRgb()
    /// fromRgba64()
    /// fromRgbF()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    [static] from_rgb(rgb: RgbType) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    /// 
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    /// 
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    [static] from_rgba(rgba: RgbType) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    /// 
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    /// 
    /// **See also:** fromRgba()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    /// 
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    /// 
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0-255.
    /// 
    /// **See also:** toRgb()
    /// fromRgba64()
    /// fromRgbF()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    [static] from_rgb(r: i32, g: i32, b: i32, a: i32) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// toRgb()
    /// isValid()
    [static] from_rgb_f(r: f32, g: f32, b: f32, a: f32) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    [static] from_rgba64(r: ushort, g: ushort, b: ushort, a: ushort) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    /// 
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    [static] from_rgba64(rgba: Rgba64Type) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// The value of *s,* *v,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    /// 
    /// **See also:** toHsv()
    /// fromHsvF()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    /// 
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** toHsv()
    /// fromHsv()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    [static] from_hsv(h: i32, s: i32, v: i32, a: i32) -> Color,
    /// 
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** toHsv()
    /// fromHsv()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    [static] from_hsv_f(h: f32, s: f32, v: f32, a: f32) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0-255.
    /// 
    /// **See also:** toCmyk()
    /// fromCmykF()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    /// 
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** toCmyk()
    /// fromCmyk()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    [static] from_cmyk(c: i32, m: i32, y: i32, k: i32, a: i32) -> Color,
    /// 
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** toCmyk()
    /// fromCmyk()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    [static] from_cmyk_f(c: f32, m: f32, y: f32, k: f32, a: f32) -> Color,
    /// 
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// The value of *s,* *l,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    /// 
    /// **See also:** toHsl()
    /// fromHslF()
    /// isValid()
    /// 
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** toHsl()
    /// fromHsl()
    /// isValid()
    [static] from_hsl(h: i32, s: i32, l: i32, a: i32) -> Color,
    /// 
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    /// 
    /// All the values must be in the range 0.0-1.0.
    /// 
    /// **See also:** toHsl()
    /// fromHsl()
    /// isValid()
    [static] from_hsl_f(h: f32, s: f32, l: f32, a: f32) -> Color,
    /// 
    /// Returns the lightness color component of this color.
    /// 
    /// **See also:** lightnessF()
    /// getHsl()
    /// 
    /// Returns the lightness color component of this color.
    /// 
    /// **See also:** value()
    /// getHslF()
    /// 
    /// Returns a lighter (or darker) color, but does not change this object.
    /// 
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    /// 
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    /// 
    /// **See also:** darker()
    /// isValid()
    /// 
    /// Use lighter( *factor)* instead.
    light(f: i32) -> Color,
    /// 
    /// Returns a lighter (or darker) color, but does not change this object.
    /// 
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    /// 
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    /// 
    /// **See also:** darker()
    /// isValid()
    lighter(f: i32) -> Color,
    /// 
    /// Returns a darker (or lighter) color, but does not change this object.
    /// 
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    /// 
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    /// 
    /// **See also:** lighter()
    /// isValid()
    /// 
    /// Use darker( *factor)* instead.
    dark(f: i32) -> Color,
    /// 
    /// Returns a darker (or lighter) color, but does not change this object.
    /// 
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    /// 
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    /// 
    /// **See also:** lighter()
    /// isValid()
    darker(f: i32) -> Color,
    /// 
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    /// 
    /// It uses the same algorithm used in setNamedColor().
    /// 
    /// **See also:** setNamedColor()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [static] is_valid_color(name: String) -> bool,
    /// 
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    /// 
    /// It uses the same algorithm used in setNamedColor().
    /// 
    /// **See also:** setNamedColor()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [static] is_valid_color(arg0: StringViewType) -> bool,
    /// 
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    /// 
    /// It uses the same algorithm used in setNamedColor().
    /// 
    /// **See also:** setNamedColor()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [static] is_valid_color(arg0: Latin1StringType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
