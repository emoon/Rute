///     \class QScroller
///     \brief The QScroller class enables kinetic scrolling for any scrolling widget or graphics item.
///     \since 5.0
/// 
///     \inmodule QtWidgets
/// 
///     With kinetic scrolling, the user can push the widget in a given
///     direction and it will continue to scroll in this direction until it is
///     stopped either by the user or by friction.  Aspects of inertia, friction
///     and other physical concepts can be changed in order to fine-tune an
///     intuitive user experience.
/// 
///     The QScroller object is the object that stores the current position and
///     scrolling speed and takes care of updates.
///     QScroller can be triggered by a flick gesture
/// 
///     \code
///         QWidget *w = ...;
///         QScroller::grabGesture(w, QScroller::LeftMouseButtonGesture);
///     \endcode
/// 
///     or directly like this:
/// 
///     \code
///         QWidget *w = ...;
///         QScroller *scroller = QScroller::scroller(w);
///         scroller->scrollTo(QPointF(100, 100));
///     \endcode
/// 
///     The scrolled QObjects receive a QScrollPrepareEvent whenever the scroller needs to
///     update its geometry information and a QScrollEvent whenever the content of the object should
///     actually be scrolled.
/// 
///     The scroller uses the global QAbstractAnimation timer to generate its QScrollEvents. This
///     can be changed with QScrollerProperties::FrameRate on a per-QScroller basis.
/// 
///     Several examples in the \c scroller examples directory show how QScroller,
///     QScrollEvent and the scroller gesture can be used.
/// 
///     Even though this kinetic scroller has a large number of settings available via
///     QScrollerProperties, we recommend that you leave them all at their default, platform optimized
///     values. Before changing them you can experiment with the \c plot example in
///     the \c scroller examples directory.
/// 
///     \sa QScrollEvent, QScrollPrepareEvent, QScrollerProperties
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QScroller)]
enum State {
    Inactive,
    Pressed,
    Dragging,
    Scrolling,
}

[org_name(QScroller)]
enum ScrollerGestureType {
    TouchGesture,
    LeftMouseButtonGesture,
    RightMouseButtonGesture,
    MiddleMouseButtonGesture,
}

[org_name(QScroller)]
enum Input {
    InputPress,
    InputMove,
    InputRelease,
}

struct Scroller : Object {
    ///     Returns \c true if a QScroller object was already created for \a target; \c false otherwise.
    /// 
    ///     \sa scroller()
    [static] has_scroller(target: *ObjectType) -> bool,
    ///     \overload
    ///     This is the const version of scroller().
    [static] scroller(target: *ObjectType) -> Scroller?,
    ///     \overload
    ///     This is the const version of scroller().
    [static] scroller(target: *ObjectType) -> Scroller?,
    ///     Registers a custom scroll gesture recognizer, grabs it for the \a
    ///     target and returns the resulting gesture type.  If \a scrollGestureType is
    ///     set to TouchGesture the gesture triggers on touch events. If it is set to
    ///     one of LeftMouseButtonGesture, RightMouseButtonGesture or
    ///     MiddleMouseButtonGesture it triggers on mouse events of the
    ///     corresponding button.
    /// 
    ///     Only one scroll gesture can be active on a single object at the same
    ///     time. If you call this function twice on the same object, it will
    ///     ungrab the existing gesture before grabbing the new one.
    /// 
    ///     \note To avoid unwanted side-effects, mouse events are consumed while
    ///     the gesture is triggered. Since the initial mouse press event is
    ///     not consumed, the gesture sends a fake mouse release event
    ///     at the global position \c{(INT_MIN, INT_MIN)}. This ensures that
    ///     internal states of the widget that received the original mouse press
    ///     are consistent.
    /// 
    ///     \sa ungrabGesture(), grabbedGesture()
    [static] grab_gesture(target: *ObjectType, gesture_type: Scroller::ScrollerGestureType) -> Rute::GestureType,
    ///     Returns the gesture type currently grabbed for the \a target or 0 if no
    ///     gesture is grabbed.
    /// 
    ///     \sa grabGesture(), ungrabGesture()
    [static] grabbed_gesture(target: *ObjectType) -> Rute::GestureType,
    ///     Ungrabs the gesture for the \a target.
    ///     Does nothing if no gesture is grabbed.
    /// 
    ///     \sa grabGesture(), grabbedGesture()
    [static] ungrab_gesture(target: *ObjectType),
    ///     Returns an application wide list of currently active QScroller objects.
    ///     Active QScroller objects are in a state() that is not QScroller::Inactive.
    ///     This function is useful when writing your own gesture recognizer.
    [static] active_scrollers() -> [Scroller?],
    target() -> Object?,
    ///     \property QScroller::state
    ///     \brief the state of the scroller
    /// 
    ///     \sa QScroller::State
    state() -> Scroller::State,
    ///     This function is used by gesture recognizers to inform the scroller about a new input event.
    ///     The scroller changes its internal state() according to the input event and its attached
    ///     scroller properties. The scroller doesn't distinguish between the kind of input device the
    ///     event came from. Therefore the event needs to be split into the \a input type, a \a position and a
    ///     milli-second \a timestamp.  The \a position needs to be in the target's coordinate system.
    /// 
    ///     The return value is \c true if the event should be consumed by the calling filter or \c false
    ///     if the event should be forwarded to the control.
    /// 
    ///     \note Using grabGesture() should be sufficient for most use cases.
    handle_input(input: Scroller::Input, position: &PointFType, timestamp: i64) -> bool,
    ///     Stops the scroller and resets its state back to Inactive.
    stop(),
    ///     Returns the current scrolling velocity in meter per second when the state is Scrolling or Dragging.
    ///     Returns a zero velocity otherwise.
    /// 
    ///     The velocity is reported for both the x and y axis separately by using a QPointF.
    /// 
    ///     \sa pixelPerMeter()
    velocity() -> PointF,
    ///     Returns the estimated final position for the current scroll movement.
    ///     Returns the current position if the scroller state is not Scrolling.
    ///     The result is undefined when the scroller state is Inactive.
    /// 
    ///     The target position is in pixel.
    /// 
    ///     \sa pixelPerMeter(), scrollTo()
    final_position() -> PointF,
    ///     Returns the pixel per meter metric for the scrolled widget.
    /// 
    ///     The value is reported for both the x and y axis separately by using a QPointF.
    /// 
    ///     \note Please note that this value should be physically correct. The actual DPI settings
    ///     that Qt returns for the display may be reported wrongly on purpose by the underlying
    ///     windowing system, for example on \macos.
    pixel_per_meter() -> PointF,
    ///     \fn void QScroller::scrollerPropertiesChanged(const QScrollerProperties &newProperties);
    /// 
    ///     QScroller emits this signal whenever its scroller properties change.
    ///     \a newProperties are the new scroller properties.
    /// 
    ///     \sa scrollerProperties
    scroller_properties() -> ScrollerProperties,
    set_snap_positions_x(positions: [f32]),
    set_snap_positions_x(first: f32, interval: f32),
    set_snap_positions_y(positions: [f32]),
    set_snap_positions_y(first: f32, interval: f32),
    set_scroller_properties(prop: &ScrollerPropertiesType),
    ///     Starts scrolling the widget so that point \a pos is at the top-left position in
    ///     the viewport.
    /// 
    ///     The behaviour when scrolling outside the valid scroll area is undefined.
    ///     In this case the scroller might or might not overshoot.
    /// 
    ///     The scrolling speed will be calculated so that the given position will
    ///     be reached after a platform-defined time span.
    /// 
    ///     \a pos is given in viewport coordinates.
    /// 
    ///     \sa ensureVisible()
    scroll_to(pos: &PointFType),
    ///     Starts scrolling the widget so that point \a pos is at the top-left position in
    ///     the viewport.
    /// 
    ///     The behaviour when scrolling outside the valid scroll area is undefined.
    ///     In this case the scroller might or might not overshoot.
    /// 
    ///     The scrolling speed will be calculated so that the given position will
    ///     be reached after a platform-defined time span.
    /// 
    ///     \a pos is given in viewport coordinates.
    /// 
    ///     \sa ensureVisible()
    scroll_to(pos: &PointFType, scroll_time: i32),
    ///     Starts scrolling so that the rectangle \a rect is visible inside the
    ///     viewport with additional margins specified in pixels by \a xmargin and \a ymargin around
    ///     the rect.
    /// 
    ///     In cases where it is not possible to fit the rect plus margins inside the viewport the contents
    ///     are scrolled so that as much as possible is visible from \a rect.
    /// 
    ///     The scrolling speed is calculated so that the given position is reached after a platform-defined
    ///     time span.
    /// 
    ///     This function performs the actual scrolling by calling scrollTo().
    /// 
    ///     \sa scrollTo()
    ensure_visible(rect: &RectFType, xmargin: f32, ymargin: f32),
    ///     Starts scrolling so that the rectangle \a rect is visible inside the
    ///     viewport with additional margins specified in pixels by \a xmargin and \a ymargin around
    ///     the rect.
    /// 
    ///     In cases where it is not possible to fit the rect plus margins inside the viewport the contents
    ///     are scrolled so that as much as possible is visible from \a rect.
    /// 
    ///     The scrolling speed is calculated so that the given position is reached after a platform-defined
    ///     time span.
    /// 
    ///     This function performs the actual scrolling by calling scrollTo().
    /// 
    ///     \sa scrollTo()
    ensure_visible(rect: &RectFType, xmargin: f32, ymargin: f32, scroll_time: i32),
    resend_prepare_event(),
    [signal] state_changed(newstate: Scroller::State),
    [signal] scroller_properties_changed(arg0: &ScrollerPropertiesType),
}

// vim: syntax=rust expandtab ts=4 sw=4
