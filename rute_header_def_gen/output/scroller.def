#[org_name(QScroller)]
enum State {
    Inactive,
    Pressed,
    Dragging,
    Scrolling,
}

#[org_name(QScroller)]
enum ScrollerGestureType {
    TouchGesture,
    LeftMouseButtonGesture,
    RightMouseButtonGesture,
    MiddleMouseButtonGesture,
}

#[org_name(QScroller)]
enum Input {
    InputPress,
    InputMove,
    InputRelease,
}

struct Scroller : Object {
    [static] has_scroller(target: &ObjectType) -> bool,
    [static] scroller(target: &ObjectType) -> Scroller?,
    [static] scroller(target: &ObjectType) -> Scroller?,
    [static] grab_gesture(target: &ObjectType, gesture_type: Scroller::ScrollerGestureType) -> Rute::GestureType,
    [static] grabbed_gesture(target: &ObjectType) -> Rute::GestureType,
    [static] ungrab_gesture(target: &ObjectType),
    [static] active_scrollers() -> [Scroller?],
    target() -> Object?,
    state() -> Scroller::State,
    handle_input(input: Scroller::Input, position: &PointFType, timestamp: i64) -> bool,
    stop(),
    velocity() -> PointF,
    final_position() -> PointF,
    pixel_per_meter() -> PointF,
    scroller_properties() -> ScrollerProperties,
    set_snap_positions_x(positions: [f32]),
    set_snap_positions_x(first: f32, interval: f32),
    set_snap_positions_y(positions: [f32]),
    set_snap_positions_y(first: f32, interval: f32),
    set_scroller_properties(prop: &ScrollerPropertiesType),
    scroll_to(pos: &PointFType),
    scroll_to(pos: &PointFType, scroll_time: i32),
    ensure_visible(rect: &RectFType, xmargin: f32, ymargin: f32),
    ensure_visible(rect: &RectFType, xmargin: f32, ymargin: f32, scroll_time: i32),
    resend_prepare_event(),
    [event] state_changed(newstate: Scroller::State),
    [event] scroller_properties_changed(arg0: &ScrollerPropertiesType),
}

// vim: syntax=rust expandtab ts=4 sw=4
