///     \class QStyle
///     \brief The QStyle class is an abstract base class that encapsulates the look and feel of a GUI.
/// 
///     \ingroup appearance
///     \inmodule QtWidgets
/// 
///     Qt contains a set of QStyle subclasses that emulate the styles of
///     the different platforms supported by Qt (QWindowsStyle,
///     QMacStyle etc.). By default, these styles are built
///     into the Qt GUI module. Styles can also be made available as
///     plugins.
/// 
///     Qt's built-in widgets use QStyle to perform nearly all of their
///     drawing, ensuring that they look exactly like the equivalent
///     native widgets. The diagram below shows a QComboBox in nine
///     different styles.
/// 
///     \image qstyle-comboboxes.png Nine combo boxes
/// 
///     Topics:
/// 
///     \tableofcontents
/// 
///     \section1 Setting a Style
/// 
///     The style of the entire application can be set using the
///     QApplication::setStyle() function. It can also be specified by the
///     user of the application, using the \c -style command-line option:
/// 
///     \snippet code/src_gui_styles_qstyle.cpp 0
/// 
///     If no style is specified, Qt will choose the most appropriate
///     style for the user's platform or desktop environment.
/// 
///     A style can also be set on an individual widget using the
///     QWidget::setStyle() function.
/// 
///     \section1 Developing Style-Aware Custom Widgets
/// 
///     If you are developing custom widgets and want them to look good on
///     all platforms, you can use QStyle functions to perform parts of
///     the widget drawing, such as drawItemText(), drawItemPixmap(),
///     drawPrimitive(), drawControl(), and drawComplexControl().
/// 
///     Most QStyle draw functions take four arguments:
///     \list
///     \li an enum value specifying which graphical element to draw
///     \li a QStyleOption specifying how and where to render that element
///     \li a QPainter that should be used to draw the element
///     \li a QWidget on which the drawing is performed (optional)
///     \endlist
/// 
///     For example, if you want to draw a focus rectangle on your
///     widget, you can write:
/// 
///     \snippet styles/styles.cpp 1
/// 
///     QStyle gets all the information it needs to render the graphical
///     element from QStyleOption. The widget is passed as the last
///     argument in case the style needs it to perform special effects
///     (such as animated default buttons on \macos), but it isn't
///     mandatory. In fact, you can use QStyle to draw on any paint
///     device, not just widgets, by setting the QPainter properly.
/// 
///     QStyleOption has various subclasses for the various types of
///     graphical elements that can be drawn. For example,
///     PE_FrameFocusRect expects a QStyleOptionFocusRect argument.
/// 
///     To ensure that drawing operations are as fast as possible,
///     QStyleOption and its subclasses have public data members. See the
///     QStyleOption class documentation for details on how to use it.
/// 
///     For convenience, Qt provides the QStylePainter class, which
///     combines a QStyle, a QPainter, and a QWidget. This makes it
///     possible to write
/// 
///     \snippet styles/styles.cpp 5
///     \dots
///     \snippet styles/styles.cpp 7
/// 
///     instead of
/// 
///     \snippet styles/styles.cpp 2
///     \dots
///     \snippet styles/styles.cpp 3
/// 
///     \section1 Creating a Custom Style
/// 
///     You can create a custom look and feel for your application by
///     creating a custom style. There are two approaches to creating a
///     custom style. In the static approach, you either choose an
///     existing QStyle class, subclass it, and reimplement virtual
///     functions to provide the custom behavior, or you create an entire
///     QStyle class from scratch. In the dynamic approach, you modify the
///     behavior of your system style at runtime. The static approach is
///     described below. The dynamic approach is described in QProxyStyle.
/// 
///     The first step in the static approach is to pick one of the styles
///     provided by Qt from which you will build your custom style. Your
///     choice of QStyle class will depend on which style resembles your
///     desired style the most. The most general class that you can use as
///     a base is QCommonStyle (not QStyle). This is because Qt requires
///     its styles to be \l{QCommonStyle}s.
/// 
///     Depending on which parts of the base style you want to change,
///     you must reimplement the functions that are used to draw those
///     parts of the interface. To illustrate this, we will modify the
///     look of the spin box arrows drawn by QWindowsStyle. The arrows
///     are \e{primitive elements} that are drawn by the drawPrimitive()
///     function, so we need to reimplement that function. We need the
///     following class declaration:
/// 
///     \snippet customstyle/customstyle.h 0
/// 
///     To draw its up and down arrows, QSpinBox uses the
///     PE_IndicatorSpinUp and PE_IndicatorSpinDown primitive elements.
///     Here's how to reimplement the drawPrimitive() function to draw
///     them differently:
/// 
///     \snippet customstyle/customstyle.cpp 2
///     \snippet customstyle/customstyle.cpp 3
///     \snippet customstyle/customstyle.cpp 4
/// 
///     Notice that we don't use the \c widget argument, except to pass it
///     on to the QWindowStyle::drawPrimitive() function. As mentioned
///     earlier, the information about what is to be drawn and how it
///     should be drawn is specified by a QStyleOption object, so there is
///     no need to ask the widget.
/// 
///     If you need to use the \c widget argument to obtain additional
///     information, be careful to ensure that it isn't 0 and that it is
///     of the correct type before using it. For example:
/// 
///     \snippet customstyle/customstyle.cpp 0
///     \dots
///     \snippet customstyle/customstyle.cpp 1
/// 
///     When implementing a custom style, you cannot assume that the
///     widget is a QSpinBox just because the enum value is called
///     PE_IndicatorSpinUp or PE_IndicatorSpinDown.
/// 
///     The documentation for the \l{widgets/styles}{Styles} example
///     covers this topic in more detail.
/// 
///     \warning Qt style sheets are currently not supported for custom QStyle
///     subclasses. We plan to address this in some future release.
/// 
/// 
///     \section1 Using a Custom Style
/// 
///     There are several ways of using a custom style in a Qt
///     application. The simplest way is to pass the custom style to the
///     QApplication::setStyle() static function before creating the
///     QApplication object:
/// 
///     \snippet customstyle/main.cpp using a custom style
/// 
///     You can call QApplication::setStyle() at any time, but by calling
///     it before the constructor, you ensure that the user's preference,
///     set using the \c -style command-line option, is respected.
/// 
///     You may want to make your custom style available for use in other
///     applications, which may not be yours and hence not available for
///     you to recompile. The Qt Plugin system makes it possible to create
///     styles as plugins. Styles created as plugins are loaded as shared
///     objects at runtime by Qt itself. Please refer to the \l{How to Create Qt Plugins}{Qt Plugin}
///     documentation for more information on how to go about creating a style
///     plugin.
/// 
///     Compile your plugin and put it into Qt's \c plugins/styles
///     directory. We now have a pluggable style that Qt can load
///     automatically. To use your new style with existing applications,
///     simply start the application with the following argument:
/// 
///     \snippet code/src_gui_styles_qstyle.cpp 1
/// 
///     The application will use the look and feel from the custom style you
///     implemented.
/// 
///     \section1 Right-to-Left Desktops
/// 
///     Languages written from right to left (such as Arabic and Hebrew)
///     usually also mirror the whole layout of widgets, and require the
///     light to come from the screen's top-right corner instead of
///     top-left.
/// 
///     If you create a custom style, you should take special care when
///     drawing asymmetric elements to make sure that they also look
///     correct in a mirrored layout. An easy way to test your styles is
///     to run applications with the \c -reverse command-line option or
///     to call QApplication::setLayoutDirection() in your \c main()
///     function.
/// 
///     Here are some things to keep in mind when making a style work well in a
///     right-to-left environment:
/// 
///     \list
///     \li subControlRect() and subElementRect() return rectangles in screen coordinates
///     \li QStyleOption::direction indicates in which direction the item should be drawn in
///     \li If a style is not right-to-left aware it will display items as if it were left-to-right
///     \li visualRect(), visualPos(), and visualAlignment() are helpful functions that will
///        translate from logical to screen representations.
///     \li alignedRect() will return a logical rect aligned for the current direction
///     \endlist
/// 
///     \section1 Styles in Item Views
/// 
///     The painting of items in views is performed by a delegate. Qt's
///     default delegate, QStyledItemDelegate, is also used for calculating bounding
///     rectangles of items, and their sub-elements for the various kind
///     of item \l{Qt::ItemDataRole}{data roles}
///     QStyledItemDelegate supports. See the QStyledItemDelegate class
///     description to find out which datatypes and roles are supported. You
///     can read more about item data roles in \l{Model/View Programming}.
/// 
///     When QStyledItemDelegate paints its items, it draws
///     CE_ItemViewItem, and calculates their size with CT_ItemViewItem.
///     Note also that it uses SE_ItemViewItemText to set the size of
///     editors. When implementing a style to customize drawing of item
///     views, you need to check the implementation of QCommonStyle (and
///     any other subclasses from which your style
///     inherits). This way, you find out which and how
///     other style elements are painted, and you can then reimplement the
///     painting of elements that should be drawn differently.
/// 
///     We include a small example where we customize the drawing of item
///     backgrounds.
/// 
///     \snippet customviewstyle.cpp 0
/// 
///     The primitive element PE_PanelItemViewItem is responsible for
///     painting the background of items, and is called from
///     \l{QCommonStyle}'s implementation of CE_ItemViewItem.
/// 
///     To add support for drawing of new datatypes and item data roles,
///     it is necessary to create a custom delegate. But if you only
///     need to support the datatypes implemented by the default
///     delegate, a custom style does not need an accompanying
///     delegate. The QStyledItemDelegate class description gives more
///     information on custom delegates.
/// 
///     The drawing of item view headers is also done by the style, giving
///     control over size of header items and row and column sizes.
/// 
///     \sa QStyleOption, QStylePainter, {Styles Example},
///         {Styles and Style Aware Widgets}, QStyledItemDelegate, {Styling}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QStyle)]
enum StateFlag {
    State_None,
    State_Enabled,
    State_Raised,
    State_Sunken,
    State_Off,
    State_NoChange,
    State_On,
    State_DownArrow,
    State_Horizontal,
    State_HasFocus,
    State_Top,
    State_Bottom,
    State_FocusAtBorder,
    State_AutoRaise,
    State_MouseOver,
    State_UpArrow,
    State_Selected,
    State_Active,
    State_Window,
    State_Open,
    State_Children,
    State_Item,
    State_Sibling,
    State_Editing,
    State_KeyboardFocusChange,
    State_ReadOnly,
    State_Small,
    State_Mini,
}

[org_name(QStyle)]
enum PrimitiveElement {
    PE_Frame,
    PE_FrameDefaultButton,
    PE_FrameDockWidget,
    PE_FrameFocusRect,
    PE_FrameGroupBox,
    PE_FrameLineEdit,
    PE_FrameMenu,
    PE_FrameStatusBar,
    PE_FrameStatusBarItem,
    PE_FrameTabWidget,
    PE_FrameWindow,
    PE_FrameButtonBevel,
    PE_FrameButtonTool,
    PE_FrameTabBarBase,
    PE_PanelButtonCommand,
    PE_PanelButtonBevel,
    PE_PanelButtonTool,
    PE_PanelMenuBar,
    PE_PanelToolBar,
    PE_PanelLineEdit,
    PE_IndicatorArrowDown,
    PE_IndicatorArrowLeft,
    PE_IndicatorArrowRight,
    PE_IndicatorArrowUp,
    PE_IndicatorBranch,
    PE_IndicatorButtonDropDown,
    PE_IndicatorViewItemCheck,
    PE_IndicatorItemViewItemCheck,
    PE_IndicatorCheckBox,
    PE_IndicatorDockWidgetResizeHandle,
    PE_IndicatorHeaderArrow,
    PE_IndicatorMenuCheckMark,
    PE_IndicatorProgressChunk,
    PE_IndicatorRadioButton,
    PE_IndicatorSpinDown,
    PE_IndicatorSpinMinus,
    PE_IndicatorSpinPlus,
    PE_IndicatorSpinUp,
    PE_IndicatorToolBarHandle,
    PE_IndicatorToolBarSeparator,
    PE_PanelTipLabel,
    PE_IndicatorTabTear,
    PE_IndicatorTabTearLeft,
    PE_PanelScrollAreaCorner,
    PE_Widget,
    PE_IndicatorColumnViewArrow,
    PE_IndicatorItemViewItemDrop,
    PE_PanelItemViewItem,
    PE_PanelItemViewRow,
    PE_PanelStatusBar,
    PE_IndicatorTabClose,
    PE_PanelMenu,
    PE_IndicatorTabTearRight,
    PE_CustomBase,
}

[org_name(QStyle)]
enum ControlElement {
    CE_PushButton,
    CE_PushButtonBevel,
    CE_PushButtonLabel,
    CE_CheckBox,
    CE_CheckBoxLabel,
    CE_RadioButton,
    CE_RadioButtonLabel,
    CE_TabBarTab,
    CE_TabBarTabShape,
    CE_TabBarTabLabel,
    CE_ProgressBar,
    CE_ProgressBarGroove,
    CE_ProgressBarContents,
    CE_ProgressBarLabel,
    CE_MenuItem,
    CE_MenuScroller,
    CE_MenuVMargin,
    CE_MenuHMargin,
    CE_MenuTearoff,
    CE_MenuEmptyArea,
    CE_MenuBarItem,
    CE_MenuBarEmptyArea,
    CE_ToolButtonLabel,
    CE_Header,
    CE_HeaderSection,
    CE_HeaderLabel,
    CE_ToolBoxTab,
    CE_SizeGrip,
    CE_Splitter,
    CE_RubberBand,
    CE_DockWidgetTitle,
    CE_ScrollBarAddLine,
    CE_ScrollBarSubLine,
    CE_ScrollBarAddPage,
    CE_ScrollBarSubPage,
    CE_ScrollBarSlider,
    CE_ScrollBarFirst,
    CE_ScrollBarLast,
    CE_FocusFrame,
    CE_ComboBoxLabel,
    CE_ToolBar,
    CE_ToolBoxTabShape,
    CE_ToolBoxTabLabel,
    CE_HeaderEmptyArea,
    CE_ColumnViewGrip,
    CE_ItemViewItem,
    CE_ShapedFrame,
    CE_CustomBase,
}

[org_name(QStyle)]
enum SubElement {
    SE_PushButtonContents,
    SE_PushButtonFocusRect,
    SE_CheckBoxIndicator,
    SE_CheckBoxContents,
    SE_CheckBoxFocusRect,
    SE_CheckBoxClickRect,
    SE_RadioButtonIndicator,
    SE_RadioButtonContents,
    SE_RadioButtonFocusRect,
    SE_RadioButtonClickRect,
    SE_ComboBoxFocusRect,
    SE_SliderFocusRect,
    SE_ProgressBarGroove,
    SE_ProgressBarContents,
    SE_ProgressBarLabel,
    SE_ToolBoxTabContents,
    SE_HeaderLabel,
    SE_HeaderArrow,
    SE_TabWidgetTabBar,
    SE_TabWidgetTabPane,
    SE_TabWidgetTabContents,
    SE_TabWidgetLeftCorner,
    SE_TabWidgetRightCorner,
    SE_ViewItemCheckIndicator,
    SE_ItemViewItemCheckIndicator,
    SE_TabBarTearIndicator,
    SE_TabBarTearIndicatorLeft,
    SE_TreeViewDisclosureItem,
    SE_LineEditContents,
    SE_FrameContents,
    SE_DockWidgetCloseButton,
    SE_DockWidgetFloatButton,
    SE_DockWidgetTitleBarText,
    SE_DockWidgetIcon,
    SE_CheckBoxLayoutItem,
    SE_ComboBoxLayoutItem,
    SE_DateTimeEditLayoutItem,
    SE_DialogButtonBoxLayoutItem,
    SE_LabelLayoutItem,
    SE_ProgressBarLayoutItem,
    SE_PushButtonLayoutItem,
    SE_RadioButtonLayoutItem,
    SE_SliderLayoutItem,
    SE_SpinBoxLayoutItem,
    SE_ToolButtonLayoutItem,
    SE_FrameLayoutItem,
    SE_GroupBoxLayoutItem,
    SE_TabWidgetLayoutItem,
    SE_ItemViewItemDecoration,
    SE_ItemViewItemText,
    SE_ItemViewItemFocusRect,
    SE_TabBarTabLeftButton,
    SE_TabBarTabRightButton,
    SE_TabBarTabText,
    SE_ShapedFrameContents,
    SE_ToolBarHandle,
    SE_TabBarScrollLeftButton,
    SE_TabBarScrollRightButton,
    SE_TabBarTearIndicatorRight,
    SE_CustomBase,
}

[org_name(QStyle)]
enum ComplexControl {
    CC_SpinBox,
    CC_ComboBox,
    CC_ScrollBar,
    CC_Slider,
    CC_ToolButton,
    CC_TitleBar,
    CC_Dial,
    CC_GroupBox,
    CC_MdiControls,
    CC_CustomBase,
}

[org_name(QStyle)]
enum SubControl {
    SC_None,
    SC_ScrollBarAddLine,
    SC_ScrollBarSubLine,
    SC_ScrollBarAddPage,
    SC_ScrollBarSubPage,
    SC_ScrollBarFirst,
    SC_ScrollBarLast,
    SC_ScrollBarSlider,
    SC_ScrollBarGroove,
    SC_SpinBoxUp,
    SC_SpinBoxDown,
    SC_SpinBoxFrame,
    SC_SpinBoxEditField,
    SC_ComboBoxFrame,
    SC_ComboBoxEditField,
    SC_ComboBoxArrow,
    SC_ComboBoxListBoxPopup,
    SC_SliderGroove,
    SC_SliderHandle,
    SC_SliderTickmarks,
    SC_ToolButton,
    SC_ToolButtonMenu,
    SC_TitleBarSysMenu,
    SC_TitleBarMinButton,
    SC_TitleBarMaxButton,
    SC_TitleBarCloseButton,
    SC_TitleBarNormalButton,
    SC_TitleBarShadeButton,
    SC_TitleBarUnshadeButton,
    SC_TitleBarContextHelpButton,
    SC_TitleBarLabel,
    SC_DialGroove,
    SC_DialHandle,
    SC_DialTickmarks,
    SC_GroupBoxCheckBox,
    SC_GroupBoxLabel,
    SC_GroupBoxContents,
    SC_GroupBoxFrame,
    SC_MdiMinButton,
    SC_MdiNormalButton,
    SC_MdiCloseButton,
    SC_CustomBase,
    SC_All,
}

[org_name(QStyle)]
enum PixelMetric {
    PM_ButtonMargin,
    PM_ButtonDefaultIndicator,
    PM_MenuButtonIndicator,
    PM_ButtonShiftHorizontal,
    PM_ButtonShiftVertical,
    PM_DefaultFrameWidth,
    PM_SpinBoxFrameWidth,
    PM_ComboBoxFrameWidth,
    PM_MaximumDragDistance,
    PM_ScrollBarExtent,
    PM_ScrollBarSliderMin,
    PM_SliderThickness,
    PM_SliderControlThickness,
    PM_SliderLength,
    PM_SliderTickmarkOffset,
    PM_SliderSpaceAvailable,
    PM_DockWidgetSeparatorExtent,
    PM_DockWidgetHandleExtent,
    PM_DockWidgetFrameWidth,
    PM_TabBarTabOverlap,
    PM_TabBarTabHSpace,
    PM_TabBarTabVSpace,
    PM_TabBarBaseHeight,
    PM_TabBarBaseOverlap,
    PM_ProgressBarChunkWidth,
    PM_SplitterWidth,
    PM_TitleBarHeight,
    PM_MenuScrollerHeight,
    PM_MenuHMargin,
    PM_MenuVMargin,
    PM_MenuPanelWidth,
    PM_MenuTearoffHeight,
    PM_MenuDesktopFrameWidth,
    PM_MenuBarPanelWidth,
    PM_MenuBarItemSpacing,
    PM_MenuBarVMargin,
    PM_MenuBarHMargin,
    PM_IndicatorWidth,
    PM_IndicatorHeight,
    PM_ExclusiveIndicatorWidth,
    PM_ExclusiveIndicatorHeight,
    PM_DialogButtonsSeparator,
    PM_DialogButtonsButtonWidth,
    PM_DialogButtonsButtonHeight,
    PM_MdiSubWindowFrameWidth,
    PM_MDIFrameWidth,
    PM_MdiSubWindowMinimizedWidth,
    PM_MDIMinimizedWidth,
    PM_HeaderMargin,
    PM_HeaderMarkSize,
    PM_HeaderGripMargin,
    PM_TabBarTabShiftHorizontal,
    PM_TabBarTabShiftVertical,
    PM_TabBarScrollButtonWidth,
    PM_ToolBarFrameWidth,
    PM_ToolBarHandleExtent,
    PM_ToolBarItemSpacing,
    PM_ToolBarItemMargin,
    PM_ToolBarSeparatorExtent,
    PM_ToolBarExtensionExtent,
    PM_SpinBoxSliderHeight,
    PM_DefaultTopLevelMargin,
    PM_DefaultChildMargin,
    PM_DefaultLayoutSpacing,
    PM_ToolBarIconSize,
    PM_ListViewIconSize,
    PM_IconViewIconSize,
    PM_SmallIconSize,
    PM_LargeIconSize,
    PM_FocusFrameVMargin,
    PM_FocusFrameHMargin,
    PM_ToolTipLabelFrameWidth,
    PM_CheckBoxLabelSpacing,
    PM_TabBarIconSize,
    PM_SizeGripSize,
    PM_DockWidgetTitleMargin,
    PM_MessageBoxIconSize,
    PM_ButtonIconSize,
    PM_DockWidgetTitleBarButtonMargin,
    PM_RadioButtonLabelSpacing,
    PM_LayoutLeftMargin,
    PM_LayoutTopMargin,
    PM_LayoutRightMargin,
    PM_LayoutBottomMargin,
    PM_LayoutHorizontalSpacing,
    PM_LayoutVerticalSpacing,
    PM_TabBar_ScrollButtonOverlap,
    PM_TextCursorWidth,
    PM_TabCloseIndicatorWidth,
    PM_TabCloseIndicatorHeight,
    PM_ScrollView_ScrollBarSpacing,
    PM_ScrollView_ScrollBarOverlap,
    PM_SubMenuOverlap,
    PM_TreeViewIndentation,
    PM_HeaderDefaultSectionSizeHorizontal,
    PM_HeaderDefaultSectionSizeVertical,
    PM_TitleBarButtonIconSize,
    PM_TitleBarButtonSize,
    PM_CustomBase,
}

[org_name(QStyle)]
enum ContentsType {
    CT_PushButton,
    CT_CheckBox,
    CT_RadioButton,
    CT_ToolButton,
    CT_ComboBox,
    CT_Splitter,
    CT_ProgressBar,
    CT_MenuItem,
    CT_MenuBarItem,
    CT_MenuBar,
    CT_Menu,
    CT_TabBarTab,
    CT_Slider,
    CT_ScrollBar,
    CT_LineEdit,
    CT_SpinBox,
    CT_SizeGrip,
    CT_TabWidget,
    CT_DialogButtons,
    CT_HeaderSection,
    CT_GroupBox,
    CT_MdiControls,
    CT_ItemViewItem,
    CT_CustomBase,
}

[org_name(QStyle)]
enum RequestSoftwareInputPanel {
    RSIP_OnMouseClickAndAlreadyFocused,
    RSIP_OnMouseClick,
}

[org_name(QStyle)]
enum StyleHint {
    SH_EtchDisabledText,
    SH_DitherDisabledText,
    SH_ScrollBar_MiddleClickAbsolutePosition,
    SH_ScrollBar_ScrollWhenPointerLeavesControl,
    SH_TabBar_SelectMouseType,
    SH_TabBar_Alignment,
    SH_Header_ArrowAlignment,
    SH_Slider_SnapToValue,
    SH_Slider_SloppyKeyEvents,
    SH_ProgressDialog_CenterCancelButton,
    SH_ProgressDialog_TextLabelAlignment,
    SH_PrintDialog_RightAlignButtons,
    SH_MainWindow_SpaceBelowMenuBar,
    SH_FontDialog_SelectAssociatedText,
    SH_Menu_AllowActiveAndDisabled,
    SH_Menu_SpaceActivatesItem,
    SH_Menu_SubMenuPopupDelay,
    SH_ScrollView_FrameOnlyAroundContents,
    SH_MenuBar_AltKeyNavigation,
    SH_ComboBox_ListMouseTracking,
    SH_Menu_MouseTracking,
    SH_MenuBar_MouseTracking,
    SH_ItemView_ChangeHighlightOnFocus,
    SH_Widget_ShareActivation,
    SH_Workspace_FillSpaceOnMaximize,
    SH_ComboBox_Popup,
    SH_TitleBar_NoBorder,
    SH_Slider_StopMouseOverSlider,
    SH_ScrollBar_StopMouseOverSlider,
    SH_BlinkCursorWhenTextSelected,
    SH_RichText_FullWidthSelection,
    SH_Menu_Scrollable,
    SH_GroupBox_TextLabelVerticalAlignment,
    SH_GroupBox_TextLabelColor,
    SH_Menu_SloppySubMenus,
    SH_Table_GridLineColor,
    SH_LineEdit_PasswordCharacter,
    SH_DialogButtons_DefaultButton,
    SH_ToolBox_SelectedPageTitleBold,
    SH_TabBar_PreferNoArrows,
    SH_ScrollBar_LeftClickAbsolutePosition,
    SH_ListViewExpand_SelectMouseType,
    SH_UnderlineShortcut,
    SH_SpinBox_AnimateButton,
    SH_SpinBox_KeyPressAutoRepeatRate,
    SH_SpinBox_ClickAutoRepeatRate,
    SH_Menu_FillScreenWithScroll,
    SH_ToolTipLabel_Opacity,
    SH_DrawMenuBarSeparator,
    SH_TitleBar_ModifyNotification,
    SH_Button_FocusPolicy,
    SH_MessageBox_UseBorderForButtonSpacing,
    SH_TitleBar_AutoRaise,
    SH_ToolButton_PopupDelay,
    SH_FocusFrame_Mask,
    SH_RubberBand_Mask,
    SH_WindowFrame_Mask,
    SH_SpinControls_DisableOnBounds,
    SH_Dial_BackgroundRole,
    SH_ComboBox_LayoutDirection,
    SH_ItemView_EllipsisLocation,
    SH_ItemView_ShowDecorationSelected,
    SH_ItemView_ActivateItemOnSingleClick,
    SH_ScrollBar_ContextMenu,
    SH_ScrollBar_RollBetweenButtons,
    SH_Slider_AbsoluteSetButtons,
    SH_Slider_PageSetButtons,
    SH_Menu_KeyboardSearch,
    SH_TabBar_ElideMode,
    SH_DialogButtonLayout,
    SH_ComboBox_PopupFrameStyle,
    SH_MessageBox_TextInteractionFlags,
    SH_DialogButtonBox_ButtonsHaveIcons,
    SH_SpellCheckUnderlineStyle,
    SH_MessageBox_CenterButtons,
    SH_Menu_SelectionWrap,
    SH_ItemView_MovementWithoutUpdatingSelection,
    SH_ToolTip_Mask,
    SH_FocusFrame_AboveWidget,
    SH_TextControl_FocusIndicatorTextCharFormat,
    SH_WizardStyle,
    SH_ItemView_ArrowKeysNavigateIntoChildren,
    SH_Menu_Mask,
    SH_Menu_FlashTriggeredItem,
    SH_Menu_FadeOutOnHide,
    SH_SpinBox_ClickAutoRepeatThreshold,
    SH_ItemView_PaintAlternatingRowColorsForEmptyArea,
    SH_FormLayoutWrapPolicy,
    SH_TabWidget_DefaultTabPosition,
    SH_ToolBar_Movable,
    SH_FormLayoutFieldGrowthPolicy,
    SH_FormLayoutFormAlignment,
    SH_FormLayoutLabelAlignment,
    SH_ItemView_DrawDelegateFrame,
    SH_TabBar_CloseButtonPosition,
    SH_DockWidget_ButtonsHaveFrame,
    SH_ToolButtonStyle,
    SH_RequestSoftwareInputPanel,
    SH_ScrollBar_Transient,
    SH_Menu_SupportsSections,
    SH_ToolTip_WakeUpDelay,
    SH_ToolTip_FallAsleepDelay,
    SH_Widget_Animate,
    SH_Splitter_OpaqueResize,
    SH_ComboBox_UseNativePopup,
    SH_LineEdit_PasswordMaskDelay,
    SH_TabBar_ChangeCurrentDelay,
    SH_Menu_SubMenuUniDirection,
    SH_Menu_SubMenuUniDirectionFailCount,
    SH_Menu_SubMenuSloppySelectOtherActions,
    SH_Menu_SubMenuSloppyCloseTimeout,
    SH_Menu_SubMenuResetWhenReenteringParent,
    SH_Menu_SubMenuDontStartSloppyOnLeave,
    SH_ItemView_ScrollMode,
    SH_TitleBar_ShowToolTipsOnButtons,
    SH_Widget_Animation_Duration,
    SH_ComboBox_AllowWheelScrolling,
    SH_SpinBox_ButtonsInsideFrame,
    SH_CustomBase,
}

[org_name(QStyle)]
enum StandardPixmap {
    SP_TitleBarMenuButton,
    SP_TitleBarMinButton,
    SP_TitleBarMaxButton,
    SP_TitleBarCloseButton,
    SP_TitleBarNormalButton,
    SP_TitleBarShadeButton,
    SP_TitleBarUnshadeButton,
    SP_TitleBarContextHelpButton,
    SP_DockWidgetCloseButton,
    SP_MessageBoxInformation,
    SP_MessageBoxWarning,
    SP_MessageBoxCritical,
    SP_MessageBoxQuestion,
    SP_DesktopIcon,
    SP_TrashIcon,
    SP_ComputerIcon,
    SP_DriveFDIcon,
    SP_DriveHDIcon,
    SP_DriveCDIcon,
    SP_DriveDVDIcon,
    SP_DriveNetIcon,
    SP_DirOpenIcon,
    SP_DirClosedIcon,
    SP_DirLinkIcon,
    SP_DirLinkOpenIcon,
    SP_FileIcon,
    SP_FileLinkIcon,
    SP_ToolBarHorizontalExtensionButton,
    SP_ToolBarVerticalExtensionButton,
    SP_FileDialogStart,
    SP_FileDialogEnd,
    SP_FileDialogToParent,
    SP_FileDialogNewFolder,
    SP_FileDialogDetailedView,
    SP_FileDialogInfoView,
    SP_FileDialogContentsView,
    SP_FileDialogListView,
    SP_FileDialogBack,
    SP_DirIcon,
    SP_DialogOkButton,
    SP_DialogCancelButton,
    SP_DialogHelpButton,
    SP_DialogOpenButton,
    SP_DialogSaveButton,
    SP_DialogCloseButton,
    SP_DialogApplyButton,
    SP_DialogResetButton,
    SP_DialogDiscardButton,
    SP_DialogYesButton,
    SP_DialogNoButton,
    SP_ArrowUp,
    SP_ArrowDown,
    SP_ArrowLeft,
    SP_ArrowRight,
    SP_ArrowBack,
    SP_ArrowForward,
    SP_DirHomeIcon,
    SP_CommandLink,
    SP_VistaShield,
    SP_BrowserReload,
    SP_BrowserStop,
    SP_MediaPlay,
    SP_MediaStop,
    SP_MediaPause,
    SP_MediaSkipForward,
    SP_MediaSkipBackward,
    SP_MediaSeekForward,
    SP_MediaSeekBackward,
    SP_MediaVolume,
    SP_MediaVolumeMuted,
    SP_LineEditClearButton,
    SP_CustomBase,
}

struct Style : Object {
    ///     \fn void QStyle::polish(QPalette & palette)
    ///     \overload
    /// 
    ///     Changes the \a palette according to style specific requirements
    ///     for color palettes (if any).
    /// 
    ///     \sa QPalette, QApplication::setPalette()
    [event] polish(widget: *WidgetType),
    ///     \fn void QStyle::unpolish(QApplication * application)
    ///     \overload
    /// 
    ///     Uninitialize the given \a application.
    [event] unpolish(widget: *WidgetType),
    ///     \fn void QStyle::polish(QPalette & palette)
    ///     \overload
    /// 
    ///     Changes the \a palette according to style specific requirements
    ///     for color palettes (if any).
    /// 
    ///     \sa QPalette, QApplication::setPalette()
    [event] polish(application: *ApplicationType),
    ///     \fn void QStyle::unpolish(QApplication * application)
    ///     \overload
    /// 
    ///     Uninitialize the given \a application.
    [event] unpolish(application: *ApplicationType),
    ///     \fn void QStyle::polish(QPalette & palette)
    ///     \overload
    /// 
    ///     Changes the \a palette according to style specific requirements
    ///     for color palettes (if any).
    /// 
    ///     \sa QPalette, QApplication::setPalette()
    [event] polish(palette: &PaletteType),
    [event] item_text_rect(fm: &FontMetricsType, r: &RectType, flags: i32, enabled: bool, text: String) -> Rect,
    ///     \fn QRect QStyle::itemPixmapRect(const QRect &rectangle, int alignment, const QPixmap &pixmap) const
    /// 
    ///     Returns the area within the given \a rectangle in which to draw
    ///     the specified \a pixmap according to the defined \a alignment.
    [event] item_pixmap_rect(r: &RectType, flags: i32, pixmap: &PixmapType) -> Rect,
    [event] draw_item_text(painter: *PainterType, rect: &RectType, flags: i32, pal: &PaletteType, enabled: bool, text: String, text_role: Palette::ColorRole),
    [event] draw_item_pixmap(painter: *PainterType, rect: &RectType, alignment: i32, pixmap: &PixmapType),
    [event] standard_palette() -> Palette,
    [event] draw_primitive(pe: Style::PrimitiveElement, opt: *StyleOptionType, p: *PainterType, w: *WidgetType),
    [event] sub_element_rect(sub_element: Style::SubElement, option: *StyleOptionType, widget: *WidgetType) -> Rect,
    [event] size_from_contents(ct: Style::ContentsType, opt: *StyleOptionType, contents_size: &SizeType, w: *WidgetType) -> Size,
    [event] style_hint(stylehint: Style::StyleHint, opt: *StyleOptionType, widget: *WidgetType, return_data: *StyleHintReturnType) -> i32,
    [event] standard_pixmap(standard_pixmap: Style::StandardPixmap, opt: *StyleOptionType, widget: *WidgetType) -> Pixmap,
    [event] standard_icon(standard_icon: Style::StandardPixmap, option: *StyleOptionType, widget: *WidgetType) -> Icon,
    [event] generated_icon_pixmap(icon_mode: Icon::Mode, pixmap: &PixmapType, opt: *StyleOptionType) -> Pixmap,
    ///     \fn QRect QStyle::visualRect(Qt::LayoutDirection direction, const QRect &boundingRectangle, const QRect &logicalRectangle)
    /// 
    ///     Returns the given \a logicalRectangle converted to screen
    ///     coordinates based on the specified \a direction. The \a
    ///     boundingRectangle is used when performing the translation.
    /// 
    ///     This function is provided to support right-to-left desktops, and
    ///     is typically used in implementations of the subControlRect()
    ///     function.
    /// 
    ///     \sa QWidget::layoutDirection
    [static] visual_rect(direction: Rute::LayoutDirection, bounding_rect: &RectType, logical_rect: &RectType) -> Rect,
    ///     \fn QPoint QStyle::visualPos(Qt::LayoutDirection direction, const QRect &boundingRectangle, const QPoint &logicalPosition)
    /// 
    ///     Returns the given \a logicalPosition converted to screen
    ///     coordinates based on the specified \a direction.  The \a
    ///     boundingRectangle is used when performing the translation.
    /// 
    ///     \sa QWidget::layoutDirection
    [static] visual_pos(direction: Rute::LayoutDirection, bounding_rect: &RectType, logical_pos: &PointType) -> Point,
    ///     Converts the given \a logicalValue to a pixel position. The \a min
    ///     parameter maps to 0, \a max maps to \a span and other values are
    ///     distributed evenly in-between.
    /// 
    ///     This function can handle the entire integer range without
    ///     overflow, providing that \a span is less than 4096.
    /// 
    ///     By default, this function assumes that the maximum value is on the
    ///     right for horizontal items and on the bottom for vertical items.
    ///     Set the \a upsideDown parameter to true to reverse this behavior.
    /// 
    ///     \sa sliderValueFromPosition()
    [static] slider_position_from_value(min: i32, max: i32, val: i32, space: i32, upside_down: bool) -> i32,
    ///     \fn int QStyle::sliderValueFromPosition(int min, int max, int position, int span, bool upsideDown)
    /// 
    ///     Converts the given pixel \a position to a logical value. 0 maps to
    ///     the \a min parameter, \a span maps to \a max and other values are
    ///     distributed evenly in-between.
    /// 
    ///     This function can handle the entire integer range without
    ///     overflow.
    /// 
    ///     By default, this function assumes that the maximum value is on the
    ///     right for horizontal items and on the bottom for vertical
    ///     items. Set the \a upsideDown parameter to true to reverse this
    ///     behavior.
    /// 
    ///     \sa sliderPositionFromValue()
    [static] slider_value_from_position(min: i32, max: i32, pos: i32, space: i32, upside_down: bool) -> i32,
    ///   Transforms an \a alignment of Qt::AlignLeft or Qt::AlignRight
    ///   without Qt::AlignAbsolute into Qt::AlignLeft or Qt::AlignRight with
    ///   Qt::AlignAbsolute according to the layout \a direction. The other
    ///   alignment flags are left untouched.
    /// 
    ///   If no horizontal alignment was specified, the function returns the
    ///   default alignment for the given layout \a direction.
    /// 
    ///   QWidget::layoutDirection
    [static] visual_alignment(direction: Rute::LayoutDirection, alignment: Rute::Alignment) -> Rute::Alignment,
    [static] aligned_rect(direction: Rute::LayoutDirection, alignment: Rute::Alignment, size: &SizeType, rectangle: &RectType) -> Rect,
    [event] layout_spacing(control1: SizePolicy::ControlType, control2: SizePolicy::ControlType, orientation: Rute::Orientation, option: *StyleOptionType, widget: *WidgetType) -> i32,
    combined_layout_spacing(controls1: SizePolicy::ControlTypes, controls2: SizePolicy::ControlTypes, orientation: Rute::Orientation, option: *StyleOptionType, widget: *WidgetType) -> i32,
    ///     \since 4.6
    /// 
    ///     \fn const QStyle *QStyle::proxy() const
    /// 
    ///     This function returns the current proxy for this style.
    ///     By default most styles will return themselves. However
    ///     when a proxy style is in use, it will allow the style to
    ///     call back into its proxy.
    proxy() -> Style?,
}

// vim: syntax=rust expandtab ts=4 sw=4
