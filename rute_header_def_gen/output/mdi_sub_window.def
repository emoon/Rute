///     \class QMdiSubWindow
///     \brief The QMdiSubWindow class provides a subwindow class for
///     QMdiArea.
///     \since 4.3
///     \ingroup mainwindow-classes
///     \inmodule QtWidgets
/// 
///     QMdiSubWindow represents a top-level window in a QMdiArea, and consists
///     of a title bar with window decorations, an internal widget, and
///     (depending on the current style) a window frame and a size
///     grip. QMdiSubWindow has its own layout, which consists of the
///     title bar and a center area for the internal widget.
/// 
///     \image qmdisubwindowlayout.png
/// 
///     The most common way to construct a QMdiSubWindow is to call
///     QMdiArea::addSubWindow() with the internal widget as the argument.
///     You can also create a subwindow yourself, and set an internal
///     widget by calling setWidget().
/// 
///     You use the same API when programming with subwindows as with
///     regular top-level windows (e.g., you can call functions such as
///     show(), hide(), showMaximized(), and setWindowTitle()).
/// 
///     \section1 Subwindow Handling
/// 
///     QMdiSubWindow also supports behavior specific to subwindows in
///     an MDI area.
/// 
///     By default, each QMdiSubWindow is visible inside the MDI area
///     viewport when moved around, but it is also possible to specify
///     transparent window movement and resizing behavior, where only
///     the outline of a subwindow is updated during these operations.
///     The setOption() function is used to enable this behavior.
/// 
///     The isShaded() function detects whether the subwindow is
///     currently shaded (i.e., the window is collapsed so that only the
///     title bar is visible). To enter shaded mode, call showShaded().
///     QMdiSubWindow emits the windowStateChanged() signal whenever the
///     window state has changed (e.g., when the window becomes minimized,
///     or is restored). It also emits aboutToActivate() before it is
///     activated.
/// 
///     In keyboard-interactive mode, the windows are moved and resized
///     with the keyboard. You can enter this mode through the system menu
///     of the window. The keyboardSingleStep and keyboardPageStep
///     properties control the distance the widget is moved or resized for
///     each keypress event. When shift is pressed down page step is used;
///     otherwise single step is used.
/// 
///     You can also change the active window with the keyboard. By
///     pressing the control and tab keys at the same time, the next
///     (using the current \l{QMdiArea::}{WindowOrder}) subwindow will be
///     activated. By pressing control, shift, and tab, you will activate
///     the previous window. This is equivalent to calling
///     \l{QMdiArea::}{activateNextSubWindow()} and
///     \l{QMdiArea::}{activatePreviousSubWindow()}. Note that these
///     shortcuts overrides global shortcuts, but not the \l{QMdiArea}s
///     shortcuts.
/// 
///     \sa QMdiArea
[org_name(QMdiSubWindow)]
enum SubWindowOption {
    AllowOutsideAreaHorizontally,
    AllowOutsideAreaVertically,
    RubberBandResize,
    RubberBandMove,
}

struct MdiSubWindow : Widget {
    [event] size_hint() -> Size,
    [event] minimum_size_hint() -> Size,
    set_widget(widget: *WidgetType),
    widget() -> Widget?,
    maximized_buttons_widget() -> Widget?,
    maximized_system_menu_icon_widget() -> Widget?,
    is_shaded() -> bool,
    set_option(option: MdiSubWindow::SubWindowOption, on: bool),
    test_option(arg0: MdiSubWindow::SubWindowOption) -> bool,
    set_keyboard_single_step(step: i32),
    keyboard_single_step() -> i32,
    set_keyboard_page_step(step: i32),
    keyboard_page_step() -> i32,
    set_system_menu(system_menu: *MenuType),
    system_menu() -> Menu?,
    mdi_area() -> MdiArea?,
    [signal] window_state_changed(old_state: Rute::WindowStates, new_state: Rute::WindowStates),
    [signal] about_to_activate(),
    show_system_menu(),
    show_shaded(),
    [event] event_filter(object: *ObjectType, event: *EventType) -> bool,
    [event] event(event: *EventType) -> bool,
    [event] show_event(show_event: *ShowEventType),
    [event] hide_event(hide_event: *HideEventType),
    [event] change_event(change_event: *EventType),
    [event] close_event(close_event: *CloseEventType),
    [event] leave_event(leave_event: *EventType),
    [event] resize_event(resize_event: *ResizeEventType),
    [event] timer_event(timer_event: *TimerEventType),
    [event] move_event(move_event: *MoveEventType),
    [event] paint_event(paint_event: *PaintEventType),
    [event] mouse_press_event(mouse_event: *MouseEventType),
    [event] mouse_double_click_event(mouse_event: *MouseEventType),
    [event] mouse_release_event(mouse_event: *MouseEventType),
    [event] mouse_move_event(mouse_event: *MouseEventType),
    [event] key_press_event(key_event: *KeyEventType),
    [event] context_menu_event(context_menu_event: *ContextMenuEventType),
    [event] focus_in_event(focus_in_event: *FocusEventType),
    [event] focus_out_event(focus_out_event: *FocusEventType),
    [event] child_event(child_event: *ChildEventType),
}

// vim: syntax=rust expandtab ts=4 sw=4
