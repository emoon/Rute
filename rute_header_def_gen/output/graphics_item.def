///     \class QGraphicsItem
///     \brief The QGraphicsItem class is the base class for all graphical
///     items in a QGraphicsScene.
///     \since 4.2
/// 
///     \ingroup graphicsview-api
///     \inmodule QtWidgets
/// 
///     It provides a light-weight foundation for writing your own custom items.
///     This includes defining the item's geometry, collision detection, its
///     painting implementation and item interaction through its event handlers.
///     QGraphicsItem is part of the \l{Graphics View Framework}
/// 
///     \image graphicsview-items.png
/// 
///     For convenience, Qt provides a set of standard graphics items for the most
///     common shapes. These are:
/// 
///     \list
///     \li QGraphicsEllipseItem provides an ellipse item
///     \li QGraphicsLineItem provides a line item
///     \li QGraphicsPathItem provides an arbitrary path item
///     \li QGraphicsPixmapItem provides a pixmap item
///     \li QGraphicsPolygonItem provides a polygon item
///     \li QGraphicsRectItem provides a rectangular item
///     \li QGraphicsSimpleTextItem provides a simple text label item
///     \li QGraphicsTextItem provides an advanced text browser item
///     \endlist
/// 
///     All of an item's geometric information is based on its local coordinate
///     system. The item's position, pos(), is the only function that does not
///     operate in local coordinates, as it returns a position in parent
///     coordinates. \l {The Graphics View Coordinate System} describes the coordinate
///     system in detail.
/// 
///     You can set whether an item should be visible (i.e., drawn, and accepting
///     events), by calling setVisible(). Hiding an item will also hide its
///     children. Similarly, you can enable or disable an item by calling
///     setEnabled(). If you disable an item, all its children will also be
///     disabled. By default, items are both visible and enabled. To toggle
///     whether an item is selected or not, first enable selection by setting
///     the ItemIsSelectable flag, and then call setSelected(). Normally,
///     selection is toggled by the scene, as a result of user interaction.
/// 
///     To write your own graphics item, you first create a subclass of
///     QGraphicsItem, and then start by implementing its two pure virtual public
///     functions: boundingRect(), which returns an estimate of the area painted
///     by the item, and paint(), which implements the actual painting. For
///     example:
/// 
///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 0
/// 
///     The boundingRect() function has many different purposes.
///     QGraphicsScene bases its item index on boundingRect(), and
///     QGraphicsView uses it both for culling invisible items, and for
///     determining the area that needs to be recomposed when drawing
///     overlapping items. In addition, QGraphicsItem's collision
///     detection mechanisms use boundingRect() to provide an efficient
///     cut-off. The fine grained collision algorithm in
///     collidesWithItem() is based on calling shape(), which returns an
///     accurate outline of the item's shape as a QPainterPath.
/// 
///     QGraphicsScene expects all items boundingRect() and shape() to
///     remain unchanged unless it is notified. If you want to change an
///     item's geometry in any way, you must first call
///     prepareGeometryChange() to allow QGraphicsScene to update its
///     bookkeeping.
/// 
///     Collision detection can be done in two ways:
/// 
///     \list 1
/// 
///     \li Reimplement shape() to return an accurate shape for your item,
///     and rely on the default implementation of collidesWithItem() to do
///     shape-shape intersection. This can be rather expensive if the
///     shapes are complex.
/// 
///     \li Reimplement collidesWithItem() to provide your own custom item
///     and shape collision algorithm.
/// 
///     \endlist
/// 
///     The contains() function can be called to determine whether the item \e
///     contains a point or not. This function can also be reimplemented by the
///     item. The default behavior of contains() is based on calling shape().
/// 
///     Items can contain other items, and also be contained by other items. All
///     items can have a parent item and a list of children. Unless the item has
///     no parent, its position is in \e parent coordinates (i.e., the parent's
///     local coordinates). Parent items propagate both their position and their
///     transformation to all children.
/// 
///     \image graphicsview-parentchild.png
/// 
///     \target Transformations
///     \section1 Transformations
/// 
///     QGraphicsItem supports projective transformations in addition to its base
///     position, pos(). There are several ways to change an item's transformation.
///     For simple transformations, you can call either of the convenience
///     functions setRotation() or setScale(), or you can pass any transformation
///     matrix to setTransform(). For advanced transformation control you also have
///     the option of setting several combined transformations by calling
///     setTransformations().
/// 
///     Item transformations accumulate from parent to child, so if both a parent
///     and child item are rotated 90 degrees, the child's total transformation
///     will be 180 degrees. Similarly, if the item's parent is scaled to 2x its
///     original size, its children will also be twice as large. An item's
///     transformation does not affect its own local geometry; all geometry
///     functions (e.g., contains(), update(), and all the mapping functions) still
///     operate in local coordinates. For convenience, QGraphicsItem provides the
///     functions sceneTransform(), which returns the item's total transformation
///     matrix (including its position and all parents' positions and
///     transformations), and scenePos(), which returns its position in scene
///     coordinates. To reset an item's matrix, call resetTransform().
/// 
///     Certain transformation operations produce a different outcome depending on
///     the order in which they are applied. For example, if you scale an
///     transform, and then rotate it, you may get a different result than if the
///     transform was rotated first. However, the order you set the transformation
///     properties on QGraphicsItem does not affect the resulting transformation;
///     QGraphicsItem always applies the properties in a fixed, defined order:
/// 
///     \list
///     \li The item's base transform is applied (transform())
///     \li The item's transformations list is applied in order (transformations())
///     \li The item is rotated relative to its transform origin point (rotation(), transformOriginPoint())
///     \li The item is scaled relative to its transform origin point (scale(), transformOriginPoint())
///     \endlist
/// 
///     \section1 Painting
/// 
///     The paint() function is called by QGraphicsView to paint the item's
///     contents. The item has no background or default fill of its own; whatever
///     is behind the item will shine through all areas that are not explicitly
///     painted in this function.  You can call update() to schedule a repaint,
///     optionally passing the rectangle that needs a repaint. Depending on
///     whether or not the item is visible in a view, the item may or may not be
///     repainted; there is no equivalent to QWidget::repaint() in QGraphicsItem.
/// 
///     Items are painted by the view, starting with the parent items and then
///     drawing children, in ascending stacking order. You can set an item's
///     stacking order by calling setZValue(), and test it by calling
///     zValue(), where items with low z-values are painted before items with
///     high z-values. Stacking order applies to sibling items; parents are always
///     drawn before their children.
/// 
///     \section1 Sorting
/// 
///     All items are drawn in a defined, stable order, and this same order decides
///     which items will receive mouse input first when you click on the scene.
///     Normally you don't have to worry about sorting, as the items follow a
///     "natural order", following the logical structure of the scene.
/// 
///     An item's children are stacked on top of the parent, and sibling items are
///     stacked by insertion order (i.e., in the same order that they were either
///     added to the scene, or added to the same parent). If you add item A, and
///     then B, then B will be on top of A. If you then add C, the items' stacking
///     order will be A, then B, then C.
/// 
///     \image graphicsview-zorder.png
/// 
///     This example shows the stacking order of all limbs of the robot from the
///     \l{graphicsview/dragdroprobot}{Drag and Drop Robot} example. The torso is
///     the root item (all other items are children or descendants of the torso),
///     so it is drawn first. Next, the head is drawn, as it is the first item in
///     the torso's list of children. Then the upper left arm is drawn. As the
///     lower arm is a child of the upper arm, the lower arm is then drawn,
///     followed by the upper arm's next sibling, which is the upper right arm, and
///     so on.
/// 
///     For advanced users, there are ways to alter how your items are sorted:
/// 
///     \list
///     \li You can call setZValue() on an item to explicitly stack it on top of, or
///     under, other sibling items. The default Z value for an item is 0. Items
///     with the same Z value are stacked by insertion order.
/// 
///     \li You can call stackBefore() to reorder the list of children. This will
///     directly modify the insertion order.
/// 
///     \li You can set the ItemStacksBehindParent flag to stack a child item behind
///     its parent.
///     \endlist
/// 
///     The stacking order of two sibling items also counts for each item's
///     children and descendant items. So if one item is on top of another, then
///     all its children will also be on top of all the other item's children as
///     well.
/// 
///     \section1 Events
/// 
///     QGraphicsItem receives events from QGraphicsScene through the virtual
///     function sceneEvent(). This function distributes the most common events
///     to a set of convenience event handlers:
/// 
///     \list
///     \li contextMenuEvent() handles context menu events
///     \li focusInEvent() and focusOutEvent() handle focus in and out events
///     \li hoverEnterEvent(), hoverMoveEvent(), and hoverLeaveEvent() handles
///     hover enter, move and leave events
///     \li inputMethodEvent() handles input events, for accessibility support
///     \li keyPressEvent() and keyReleaseEvent() handle key press and release events
///     \li mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), and
///     mouseDoubleClickEvent() handles mouse press, move, release, click and
///     doubleclick events
///     \endlist
/// 
///     You can filter events for any other item by installing event filters. This
///     functionality is separate from Qt's regular event filters (see
///     QObject::installEventFilter()), which only work on subclasses of QObject. After
///     installing your item as an event filter for another item by calling
///     installSceneEventFilter(), the filtered events will be received by the virtual
///     function sceneEventFilter(). You can remove item event filters by calling
///     removeSceneEventFilter().
/// 
///     \section1 Custom Data
/// 
///     Sometimes it's useful to register custom data with an item, be it a custom
///     item, or a standard item. You can call setData() on any item to store data
///     in it using a key-value pair (the key being an integer, and the value is a
///     QVariant). To get custom data from an item, call data(). This
///     functionality is completely untouched by Qt itself; it is provided for the
///     user's convenience.
/// 
///     \sa QGraphicsScene, QGraphicsView, {Graphics View Framework}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QGraphicsItem)]
enum GraphicsItemFlag {
    ItemIsMovable,
    ItemIsSelectable,
    ItemIsFocusable,
    ItemClipsToShape,
    ItemClipsChildrenToShape,
    ItemIgnoresTransformations,
    ItemIgnoresParentOpacity,
    ItemDoesntPropagateOpacityToChildren,
    ItemStacksBehindParent,
    ItemUsesExtendedStyleOption,
    ItemHasNoContents,
    ItemSendsGeometryChanges,
    ItemAcceptsInputMethod,
    ItemNegativeZStacksBehindParent,
    ItemIsPanel,
    ItemIsFocusScope,
    ItemSendsScenePositionChanges,
    ItemStopsClickFocusPropagation,
    ItemStopsFocusHandling,
    ItemContainsChildrenInShape,
}

[org_name(QGraphicsItem)]
enum GraphicsItemChange {
    ItemPositionChange,
    ItemMatrixChange,
    ItemVisibleChange,
    ItemEnabledChange,
    ItemSelectedChange,
    ItemParentChange,
    ItemChildAddedChange,
    ItemChildRemovedChange,
    ItemTransformChange,
    ItemPositionHasChanged,
    ItemTransformHasChanged,
    ItemSceneChange,
    ItemVisibleHasChanged,
    ItemEnabledHasChanged,
    ItemSelectedHasChanged,
    ItemParentHasChanged,
    ItemSceneHasChanged,
    ItemCursorChange,
    ItemCursorHasChanged,
    ItemToolTipChange,
    ItemToolTipHasChanged,
    ItemFlagsChange,
    ItemFlagsHaveChanged,
    ItemZValueChange,
    ItemZValueHasChanged,
    ItemOpacityChange,
    ItemOpacityHasChanged,
    ItemScenePositionHasChanged,
    ItemRotationChange,
    ItemRotationHasChanged,
    ItemScaleChange,
    ItemScaleHasChanged,
    ItemTransformOriginPointChange,
    ItemTransformOriginPointHasChanged,
}

[org_name(QGraphicsItem)]
enum CacheMode {
    NoCache,
    ItemCoordinateCache,
    DeviceCoordinateCache,
}

[org_name(QGraphicsItem)]
enum PanelModality {
    NonModal,
    PanelModal,
    SceneModal,
}

[org_name(QGraphicsItem)]
enum GraphicsItemFixMeEnums {
    Type,
    UserType,
}

[org_name(QGraphicsItem)]
enum Extension {
    UserExtension,
}


struct GraphicsItem {
    ///     Returns the current scene for the item, or 0 if the item is not stored in
    ///     a scene.
    /// 
    ///     To add or move an item to a scene, call QGraphicsScene::addItem().
    scene() -> GraphicsScene?,
    ///     Returns a pointer to this item's parent item. If this item does not have a
    ///     parent, 0 is returned.
    /// 
    ///     \sa setParentItem(), childItems()
    parent_item() -> GraphicsItem?,
    ///     Returns this item's top-level item. The top-level item is the item's
    ///     topmost ancestor item whose parent is 0. If an item has no parent, its own
    ///     pointer is returned (i.e., a top-level item is its own top-level item).
    /// 
    ///     \sa parentItem()
    top_level_item() -> GraphicsItem?,
    ///     \since 4.6
    /// 
    ///     Returns a pointer to the item's parent, cast to a QGraphicsObject. returns 0 if the parent item
    ///     is not a QGraphicsObject.
    /// 
    ///     \sa parentItem(), childItems()
    parent_object() -> GraphicsObject?,
    ///     \since 4.4
    /// 
    ///     Returns a pointer to the item's parent widget. The item's parent widget is
    ///     the closest parent item that is a widget.
    /// 
    ///     \sa parentItem(), childItems()
    parent_widget() -> GraphicsWidget?,
    ///     \since 4.4
    /// 
    ///     Returns a pointer to the item's top level widget (i.e., the item's
    ///     ancestor whose parent is 0, or whose parent is not a widget), or 0 if this
    ///     item does not have a top level widget. If the item is its own top level
    ///     widget, this function returns a pointer to the item itself.
    top_level_widget() -> GraphicsWidget?,
    ///     \since 4.4
    /// 
    ///     Returns the item's window, or 0 if this item does not have a window. If
    ///     the item is a window, it will return itself.  Otherwise it will return the
    ///     closest ancestor that is a window.
    /// 
    ///     \sa QGraphicsWidget::isWindow()
    window() -> GraphicsWidget?,
    ///     \since 4.6
    /// 
    ///     Returns the item's panel, or 0 if this item does not have a panel. If the
    ///     item is a panel, it will return itself. Otherwise it will return the
    ///     closest ancestor that is a panel.
    /// 
    ///     \sa isPanel(), ItemIsPanel
    panel() -> GraphicsItem?,
    ///   Sets this item's parent item to \a newParent. If this item already
    ///   has a parent, it is first removed from the previous parent. If \a
    ///   newParent is 0, this item will become a top-level item.
    /// 
    ///   Note that this implicitly adds this graphics item to the scene of
    ///   the parent. You should not \l{QGraphicsScene::addItem()}{add} the
    ///   item to the scene yourself.
    /// 
    ///   The behavior when calling this function on an item that is an ancestor of
    ///   \a newParent is undefined.
    /// 
    ///   \sa parentItem(), childItems()
    set_parent_item(parent: *GraphicsItemType),
    ///     \since 4.4
    /// 
    ///     Returns a list of this item's children.
    /// 
    ///     The items are sorted by stacking order. This takes into account both the
    ///     items' insertion order and their Z-values.
    /// 
    ///     \sa setParentItem(), zValue(), {QGraphicsItem#Sorting}{Sorting}
    child_items() -> [GraphicsItem?],
    ///     \since 4.4
    ///     Returns \c true if this item is a widget (i.e., QGraphicsWidget); otherwise,
    ///     returns \c false.
    is_widget() -> bool,
    ///     \since 4.4
    ///     Returns \c true if the item is a QGraphicsWidget window, otherwise returns
    ///     false.
    /// 
    ///     \sa QGraphicsWidget::windowFlags()
    is_window() -> bool,
    ///     \since 4.6
    ///     Returns \c true if the item is a panel; otherwise returns \c false.
    /// 
    ///     \sa QGraphicsItem::panel(), ItemIsPanel
    is_panel() -> bool,
    ///   \since 4.6
    /// 
    ///   Return the graphics item cast to a QGraphicsObject, if the class is actually a
    ///   graphics object, 0 otherwise.
    to_graphics_object() -> GraphicsObject?,
    ///   \since 4.6
    /// 
    ///   Return the graphics item cast to a QGraphicsObject, if the class is actually a
    ///   graphics object, 0 otherwise.
    to_graphics_object() -> GraphicsObject?,
    ///     Returns a pointer to this item's item group, or 0 if this item is not
    ///     member of a group.
    /// 
    ///     \sa QGraphicsItemGroup, QGraphicsScene::createItemGroup()
    group() -> GraphicsItemGroup?,
    ///     Adds this item to the item group \a group. If \a group is 0, this item is
    ///     removed from any current group and added as a child of the previous
    ///     group's parent.
    /// 
    ///     \sa group(), QGraphicsScene::createItemGroup()
    set_group(group: *GraphicsItemGroupType),
    ///     Returns this item's flags. The flags describe what configurable features
    ///     of the item are enabled and not. For example, if the flags include
    ///     ItemIsFocusable, the item can accept input focus.
    /// 
    ///     By default, no flags are enabled.
    /// 
    ///     \sa setFlags(), setFlag()
    flags() -> GraphicsItem::GraphicsItemFlags,
    ///     If \a enabled is true, the item flag \a flag is enabled; otherwise, it is
    ///     disabled.
    /// 
    ///     \sa flags(), setFlags()
    set_flag(flag: GraphicsItem::GraphicsItemFlag, enabled: bool),
    ///     Sets the item flags to \a flags. All flags in \a flags are enabled; all
    ///     flags not in \a flags are disabled.
    /// 
    ///     If the item had focus and \a flags does not enable ItemIsFocusable, the
    ///     item loses focus as a result of calling this function. Similarly, if the
    ///     item was selected, and \a flags does not enabled ItemIsSelectable, the
    ///     item is automatically unselected.
    /// 
    ///     By default, no flags are enabled. (QGraphicsWidget enables the
    ///     ItemSendsGeometryChanges flag by default in order to track position
    ///     changes.)
    /// 
    ///     \sa flags(), setFlag()
    set_flags(flags: GraphicsItem::GraphicsItemFlags),
    ///     \since 4.4
    ///     Returns the cache mode for this item. The default mode is NoCache (i.e.,
    ///     cache is disabled and all painting is immediate).
    /// 
    ///     \sa setCacheMode()
    cache_mode() -> GraphicsItem::CacheMode,
    ///     \since 4.4
    ///     Sets the item's cache mode to \a mode.
    /// 
    ///     The optional \a logicalCacheSize argument is used only by
    ///     ItemCoordinateCache mode, and describes the resolution of the cache
    ///     buffer; if \a logicalCacheSize is (100, 100), QGraphicsItem will fit the
    ///     item into 100x100 pixels in graphics memory, regardless of the logical
    ///     size of the item itself. By default QGraphicsItem uses the size of
    ///     boundingRect(). For all other cache modes than ItemCoordinateCache, \a
    ///     logicalCacheSize is ignored.
    /// 
    ///     Caching can speed up rendering if your item spends a significant time
    ///     redrawing itself. In some cases the cache can also slow down rendering, in
    ///     particular when the item spends less time redrawing than QGraphicsItem
    ///     spends redrawing from the cache.
    /// 
    ///     When caching is enabled, an item's paint() function will generally draw into an
    ///     offscreen pixmap cache; for any subsequent
    ///     repaint requests, the Graphics View framework will redraw from the
    ///     cache. This approach works particularly well with QGLWidget, which stores
    ///     all the cache as OpenGL textures.
    /// 
    ///     Be aware that QPixmapCache's cache limit may need to be changed to obtain
    ///     optimal performance.
    /// 
    ///     You can read more about the different cache modes in the CacheMode
    ///     documentation.
    /// 
    ///     \note Enabling caching does not imply that the item's paint() function will be
    ///     called only in response to an explicit update() call. For instance, under
    ///     memory pressure, Qt may decide to drop some of the cache information;
    ///     in such cases an item's paint() function will be called even if there
    ///     was no update() call (that is, exactly as if there were no caching enabled).
    /// 
    ///     \sa CacheMode, QPixmapCache::setCacheLimit()
    set_cache_mode(mode: GraphicsItem::CacheMode, cache_size: &SizeType),
    ///     \since 4.6
    /// 
    ///     Returns the modality for this item.
    panel_modality() -> GraphicsItem::PanelModality,
    ///     \since 4.6
    /// 
    ///     Sets the modality for this item to \a panelModality.
    /// 
    ///     Changing the modality of a visible item takes effect immediately.
    set_panel_modality(panel_modality: GraphicsItem::PanelModality),
    ///     \since 4.6
    /// 
    ///     Returns \c true if this item is blocked by a modal panel, false otherwise. If \a blockingPanel is
    ///     non-zero, \a blockingPanel will be set to the modal panel that is blocking this item. If this
    ///     item is not blocked, \a blockingPanel will not be set by this function.
    /// 
    ///     This function always returns \c false for items not in a scene.
    /// 
    ///     \sa panelModality(), setPanelModality(), PanelModality
    is_blocked_by_modal_panel(blocking_panel: *GraphicsItemType) -> bool,
    ///     Returns the item's tool tip, or an empty QString if no tool tip has been
    ///     set.
    /// 
    ///     \sa setToolTip(), QToolTip
    tool_tip() -> String,
    ///     Sets the item's tool tip to \a toolTip. If \a toolTip is empty, the item's
    ///     tool tip is cleared.
    /// 
    ///     \sa toolTip(), QToolTip
    set_tool_tip(tool_tip: String),
    ///     Returns the current cursor shape for the item. The mouse cursor
    ///     will assume this shape when it's over this item.
    ///     See the \l{Qt::CursorShape}{list of predefined cursor objects} for a
    ///     range of useful shapes.
    /// 
    ///     An editor item might want to use an I-beam cursor:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 2
    /// 
    ///     If no cursor has been set, the cursor of the item beneath is used.
    /// 
    ///     \sa setCursor(), hasCursor(), unsetCursor(), QWidget::cursor,
    ///     QApplication::overrideCursor()
    cursor() -> Cursor,
    ///     Sets the current cursor shape for the item to \a cursor. The mouse cursor
    ///     will assume this shape when it's over this item.
    ///     See the \l{Qt::CursorShape}{list of predefined cursor objects} for a
    ///     range of useful shapes.
    /// 
    ///     An editor item might want to use an I-beam cursor:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 3
    /// 
    ///     If no cursor has been set, the cursor of the item beneath is used.
    /// 
    ///     \sa cursor(), hasCursor(), unsetCursor(), QWidget::cursor,
    ///     QApplication::overrideCursor()
    set_cursor(cursor: &CursorType),
    ///     Returns \c true if this item has a cursor set; otherwise, false is returned.
    /// 
    ///     By default, items don't have any cursor set. cursor() will return a
    ///     standard pointing arrow cursor.
    /// 
    ///     \sa unsetCursor()
    has_cursor() -> bool,
    ///     Clears the cursor from this item.
    /// 
    ///     \sa hasCursor(), setCursor()
    unset_cursor(),
    ///    Returns \c true if the item is visible; otherwise, false is returned.
    /// 
    ///    Note that the item's general visibility is unrelated to whether or not it
    ///    is actually being visualized by a QGraphicsView.
    /// 
    ///    \sa setVisible()
    is_visible() -> bool,
    ///     \since 4.4
    ///     Returns \c true if the item is visible to \a parent; otherwise, false is
    ///     returned. \a parent can be 0, in which case this function will return
    ///     whether the item is visible to the scene or not.
    /// 
    ///     An item may not be visible to its ancestors even if isVisible() is true. It
    ///     may also be visible to its ancestors even if isVisible() is false. If
    ///     any ancestor is hidden, the item itself will be implicitly hidden, in which
    ///     case this function will return false.
    /// 
    ///     \sa isVisible(), setVisible()
    is_visible_to(parent: *GraphicsItemType) -> bool,
    ///     If \a visible is true, the item is made visible. Otherwise, the item is
    ///     made invisible. Invisible items are not painted, nor do they receive any
    ///     events. In particular, mouse events pass right through invisible items,
    ///     and are delivered to any item that may be behind. Invisible items are also
    ///     unselectable, they cannot take input focus, and are not detected by
    ///     QGraphicsScene's item location functions.
    /// 
    ///     If an item becomes invisible while grabbing the mouse, (i.e., while it is
    ///     receiving mouse events,) it will automatically lose the mouse grab, and
    ///     the grab is not regained by making the item visible again; it must receive
    ///     a new mouse press to regain the mouse grab.
    /// 
    ///     Similarly, an invisible item cannot have focus, so if the item has focus
    ///     when it becomes invisible, it will lose focus, and the focus is not
    ///     regained by simply making the item visible again.
    /// 
    ///     If you hide a parent item, all its children will also be hidden. If you
    ///     show a parent item, all children will be shown, unless they have been
    ///     explicitly hidden (i.e., if you call setVisible(false) on a child, it will
    ///     not be reshown even if its parent is hidden, and then shown again).
    /// 
    ///     Items are visible by default; it is unnecessary to call
    ///     setVisible() on a new item.
    /// 
    ///     \note An item with opacity set to 0 will still be considered visible,
    ///     although it will be treated like an invisible item: mouse events will pass
    ///     through it, it will not be included in the items returned by
    ///     QGraphicsView::items(), and so on. However, the item will retain the focus.
    /// 
    ///     \sa isVisible(), show(), hide(), setOpacity()
    set_visible(visible: bool),
    hide(),
    show(),
    ///     Returns \c true if the item is enabled; otherwise, false is returned.
    /// 
    ///     \sa setEnabled()
    is_enabled() -> bool,
    ///     If \a enabled is true, the item is enabled; otherwise, it is disabled.
    /// 
    ///     Disabled items are visible, but they do not receive any events, and cannot
    ///     take focus nor be selected. Mouse events are discarded; they are not
    ///     propagated unless the item is also invisible, or if it does not accept
    ///     mouse events (see acceptedMouseButtons()). A disabled item cannot become the
    ///     mouse grabber, and as a result of this, an item loses the grab if it
    ///     becomes disabled when grabbing the mouse, just like it loses focus if it
    ///     had focus when it was disabled.
    /// 
    ///     Disabled items are traditionally drawn using grayed-out colors (see \l
    ///     QPalette::Disabled).
    /// 
    ///     If you disable a parent item, all its children will also be disabled. If
    ///     you enable a parent item, all children will be enabled, unless they have
    ///     been explicitly disabled (i.e., if you call setEnabled(false) on a child,
    ///     it will not be reenabled if its parent is disabled, and then enabled
    ///     again).
    /// 
    ///     Items are enabled by default.
    /// 
    ///     \note If you install an event filter, you can still intercept events
    ///     before they are delivered to items; this mechanism disregards the item's
    ///     enabled state.
    /// 
    ///     \sa isEnabled()
    set_enabled(enabled: bool),
    ///     Returns \c true if this item is selected; otherwise, false is returned.
    /// 
    ///     Items that are in a group inherit the group's selected state.
    /// 
    ///     Items are not selected by default.
    /// 
    ///     \sa setSelected(), QGraphicsScene::setSelectionArea()
    is_selected() -> bool,
    ///     If \a selected is true and this item is selectable, this item is selected;
    ///     otherwise, it is unselected.
    /// 
    ///     If the item is in a group, the whole group's selected state is toggled by
    ///     this function. If the group is selected, all items in the group are also
    ///     selected, and if the group is not selected, no item in the group is
    ///     selected.
    /// 
    ///     Only visible, enabled, selectable items can be selected.  If \a selected
    ///     is true and this item is either invisible or disabled or unselectable,
    ///     this function does nothing.
    /// 
    ///     By default, items cannot be selected. To enable selection, set the
    ///     ItemIsSelectable flag.
    /// 
    ///     This function is provided for convenience, allowing individual toggling of
    ///     the selected state of an item. However, a more common way of selecting
    ///     items is to call QGraphicsScene::setSelectionArea(), which will call this
    ///     function for all visible, enabled, and selectable items within a specified
    ///     area on the scene.
    /// 
    ///     \sa isSelected(), QGraphicsScene::selectedItems()
    set_selected(selected: bool),
    ///    Returns \c true if this item can accept drag and drop events; otherwise,
    ///    returns \c false. By default, items do not accept drag and drop events; items
    ///    are transparent to drag and drop.
    /// 
    ///    \sa setAcceptDrops()
    accept_drops() -> bool,
    ///     If \a on is true, this item will accept drag and drop events; otherwise,
    ///     it is transparent for drag and drop events. By default, items do not
    ///     accept drag and drop events.
    /// 
    ///     \sa acceptDrops()
    set_accept_drops(on: bool),
    ///     \since 4.5
    /// 
    ///     Returns this item's local opacity, which is between 0.0 (transparent) and
    ///     1.0 (opaque). This value is combined with parent and ancestor values into
    ///     the effectiveOpacity(). The effective opacity decides how the item is
    ///     rendered and also affects its visibility when queried by functions such as
    ///     QGraphicsView::items().
    /// 
    ///     The opacity property decides the state of the painter passed to the
    ///     paint() function. If the item is cached, i.e., ItemCoordinateCache or
    ///     DeviceCoordinateCache, the effective property will be applied to the item's
    ///     cache as it is rendered.
    /// 
    ///     The default opacity is 1.0; fully opaque.
    /// 
    ///     \sa setOpacity(), paint(), ItemIgnoresParentOpacity,
    ///     ItemDoesntPropagateOpacityToChildren
    opacity() -> f32,
    ///     \since 4.5
    /// 
    ///     Returns this item's \e effective opacity, which is between 0.0
    ///     (transparent) and 1.0 (opaque). This value is a combination of this item's
    ///     local opacity, and its parent and ancestors' opacities. The effective
    ///     opacity decides how the item is rendered.
    /// 
    ///     \sa opacity(), setOpacity(), paint(), ItemIgnoresParentOpacity,
    ///     ItemDoesntPropagateOpacityToChildren
    effective_opacity() -> f32,
    ///     \since 4.5
    /// 
    ///     Sets this item's local \a opacity, between 0.0 (transparent) and 1.0
    ///     (opaque). The item's local opacity is combined with parent and ancestor
    ///     opacities into the effectiveOpacity().
    /// 
    ///     By default, opacity propagates from parent to child, so if a parent's
    ///     opacity is 0.5 and the child is also 0.5, the child's effective opacity
    ///     will be 0.25.
    /// 
    ///     The opacity property decides the state of the painter passed to the
    ///     paint() function. If the item is cached, i.e., ItemCoordinateCache or
    ///     DeviceCoordinateCache, the effective property will be applied to the
    ///     item's cache as it is rendered.
    /// 
    ///     There are two item flags that affect how the item's opacity is combined
    ///     with the parent: ItemIgnoresParentOpacity and
    ///     ItemDoesntPropagateOpacityToChildren.
    /// 
    ///     \note Setting the opacity of an item to 0 will not make the item invisible
    ///     (according to isVisible()), but the item will be treated like an invisible
    ///     one. See the documentation of setVisible() for more information.
    /// 
    ///     \sa opacity(), effectiveOpacity(), setVisible()
    set_opacity(opacity: f32),
    ///     Returns a pointer to this item's effect if it has one; otherwise 0.
    /// 
    ///     \since 4.6
    graphics_effect() -> GraphicsEffect?,
    ///     Sets \a effect as the item's effect. If there already is an effect installed
    ///     on this item, QGraphicsItem will delete the existing effect before installing
    ///     the new \a effect. You can delete an existing effect by calling
    ///     setGraphicsEffect(0).
    /// 
    ///     If \a effect is the installed effect on a different item, setGraphicsEffect() will remove
    ///     the effect from the item and install it on this item.
    /// 
    ///     QGraphicsItem takes ownership of \a effect.
    /// 
    ///     \note This function will apply the effect on itself and all its children.
    /// 
    ///     \since 4.6
    set_graphics_effect(effect: *GraphicsEffectType),
    ///     Returns the mouse buttons that this item accepts mouse events for.  By
    ///     default, all mouse buttons are accepted.
    /// 
    ///     If an item accepts a mouse button, it will become the mouse
    ///     grabber item when a mouse press event is delivered for that mouse
    ///     button. However, if the item does not accept the button,
    ///     QGraphicsScene will forward the mouse events to the first item
    ///     beneath it that does.
    /// 
    ///     \sa setAcceptedMouseButtons(), mousePressEvent()
    accepted_mouse_buttons() -> Rute::MouseButtons,
    ///     Sets the mouse \a buttons that this item accepts mouse events for.
    /// 
    ///     By default, all mouse buttons are accepted. If an item accepts a
    ///     mouse button, it will become the mouse grabber item when a mouse
    ///     press event is delivered for that button. However, if the item
    ///     does not accept the mouse button, QGraphicsScene will forward the
    ///     mouse events to the first item beneath it that does.
    /// 
    ///     To disable mouse events for an item (i.e., make it transparent for mouse
    ///     events), call setAcceptedMouseButtons(0).
    /// 
    ///     \sa acceptedMouseButtons(), mousePressEvent()
    set_accepted_mouse_buttons(buttons: Rute::MouseButtons),
    ///     \since 4.4
    /// 
    ///     Returns \c true if an item accepts hover events
    ///     (QGraphicsSceneHoverEvent); otherwise, returns \c false. By default,
    ///     items do not accept hover events.
    /// 
    ///     \sa setAcceptedMouseButtons()
    accept_hover_events() -> bool,
    ///     \since 4.4
    /// 
    ///     If \a enabled is true, this item will accept hover events;
    ///     otherwise, it will ignore them. By default, items do not accept
    ///     hover events.
    /// 
    ///     Hover events are delivered when there is no current mouse grabber
    ///     item.  They are sent when the mouse cursor enters an item, when it
    ///     moves around inside the item, and when the cursor leaves an
    ///     item. Hover events are commonly used to highlight an item when
    ///     it's entered, and for tracking the mouse cursor as it hovers over
    ///     the item (equivalent to QWidget::mouseTracking).
    /// 
    ///     Parent items receive hover enter events before their children, and
    ///     leave events after their children. The parent does not receive a
    ///     hover leave event if the cursor enters a child, though; the parent
    ///     stays "hovered" until the cursor leaves its area, including its
    ///     children's areas.
    /// 
    ///     If a parent item handles child events, it will receive hover move,
    ///     drag move, and drop events as the cursor passes through its
    ///     children, but it does not receive hover enter and hover leave, nor
    ///     drag enter and drag leave events on behalf of its children.
    /// 
    ///     A QGraphicsWidget with window decorations will accept hover events
    ///     regardless of the value of acceptHoverEvents().
    /// 
    ///     \sa acceptHoverEvents(), hoverEnterEvent(), hoverMoveEvent(),
    ///     hoverLeaveEvent()
    set_accept_hover_events(enabled: bool),
    ///     \fn void QGraphicsItem::setAcceptsHoverEvents(bool enabled)
    ///     \obsolete
    /// 
    ///     Use setAcceptHoverEvents(\a enabled) instead.
    accept_touch_events() -> bool,
    ///     \since 4.6
    /// 
    ///     If \a enabled is true, this item will accept \l{QTouchEvent}{touch events};
    ///     otherwise, it will ignore them. By default, items do not accept
    ///     touch events.
    set_accept_touch_events(enabled: bool),
    ///     \since 4.6
    /// 
    ///     Returns \c true if this item filters child events (i.e., all events
    ///     intended for any of its children are instead sent to this item);
    ///     otherwise, false is returned.
    /// 
    ///     The default value is false; child events are not filtered.
    /// 
    ///     \sa setFiltersChildEvents()
    filters_child_events() -> bool,
    ///     \since 4.6
    /// 
    ///     If \a enabled is true, this item is set to filter all events for
    ///     all its children (i.e., all events intented for any of its
    ///     children are instead sent to this item); otherwise, if \a enabled
    ///     is false, this item will only handle its own events. The default
    ///     value is false.
    /// 
    ///     \sa filtersChildEvents()
    set_filters_child_events(enabled: bool),
    ///     \obsolete
    /// 
    ///     Returns \c true if this item handles child events (i.e., all events
    ///     intended for any of its children are instead sent to this item);
    ///     otherwise, false is returned.
    /// 
    ///     This property is useful for item groups; it allows one item to
    ///     handle events on behalf of its children, as opposed to its
    ///     children handling their events individually.
    /// 
    ///     The default is to return false; children handle their own events.
    ///     The exception for this is if the item is a QGraphicsItemGroup, then
    ///     it defaults to return true.
    /// 
    ///     \sa setHandlesChildEvents()
    handles_child_events() -> bool,
    ///     \obsolete
    /// 
    ///     If \a enabled is true, this item is set to handle all events for
    ///     all its children (i.e., all events intented for any of its
    ///     children are instead sent to this item); otherwise, if \a enabled
    ///     is false, this item will only handle its own events. The default
    ///     value is false.
    /// 
    ///     This property is useful for item groups; it allows one item to
    ///     handle events on behalf of its children, as opposed to its
    ///     children handling their events individually.
    /// 
    ///     If a child item accepts hover events, its parent will receive
    ///     hover move events as the cursor passes through the child, but it
    ///     does not receive hover enter and hover leave events on behalf of
    ///     its child.
    /// 
    ///     \sa handlesChildEvents()
    set_handles_child_events(enabled: bool),
    ///     \since 4.6
    ///     Returns \c true if this item is active; otherwise returns \c false.
    /// 
    ///     An item can only be active if the scene is active. An item is active
    ///     if it is, or is a descendent of, an active panel. Items in non-active
    ///     panels are not active.
    /// 
    ///     Items that are not part of a panel follow scene activation when the
    ///     scene has no active panel.
    /// 
    ///     Only active items can gain input focus.
    /// 
    ///     \sa QGraphicsScene::isActive(), QGraphicsScene::activePanel(), panel(), isPanel()
    is_active() -> bool,
    ///     \since 4.6
    /// 
    ///     If \a active is true, and the scene is active, this item's panel will be
    ///     activated. Otherwise, the panel is deactivated.
    /// 
    ///     If the item is not part of an active scene, \a active will decide what
    ///     happens to the panel when the scene becomes active or the item is added to
    ///     the scene. If true, the item's panel will be activated when the item is
    ///     either added to the scene or the scene is activated. Otherwise, the item
    ///     will stay inactive independent of the scene's activated state.
    /// 
    ///     \sa isPanel(), QGraphicsScene::setActivePanel(), QGraphicsScene::isActive()
    set_active(active: bool),
    ///     Returns \c true if this item is active, and it or its \l{focusProxy()}{focus
    ///     proxy} has keyboard input focus; otherwise, returns \c false.
    /// 
    ///     \sa focusItem(), setFocus(), QGraphicsScene::setFocusItem(), isActive()
    has_focus() -> bool,
    ///     Gives keyboard input focus to this item. The \a focusReason argument will
    ///     be passed into any \l{QFocusEvent}{focus event} generated by this function;
    ///     it is used to give an explanation of what caused the item to get focus.
    /// 
    ///     Only enabled items that set the ItemIsFocusable flag can accept keyboard
    ///     focus.
    /// 
    ///     If this item is not visible, not active, or not associated with a scene,
    ///     it will not gain immediate input focus. However, it will be registered as
    ///     the preferred focus item for its subtree of items, should it later become
    ///     visible.
    /// 
    ///     As a result of calling this function, this item will receive a
    ///     \l{focusInEvent()}{focus in event} with \a focusReason. If another item
    ///     already has focus, that item will first receive a \l{focusOutEvent()}
    ///     {focus out event} indicating that it has lost input focus.
    /// 
    ///     \sa clearFocus(), hasFocus(), focusItem(), focusProxy()
    set_focus(focus_reason: Rute::FocusReason),
    ///     Takes keyboard input focus from the item.
    /// 
    ///     If it has focus, a \l{focusOutEvent()}{focus out event} is sent to this
    ///     item to tell it that it is about to lose the focus.
    /// 
    ///     Only items that set the ItemIsFocusable flag, or widgets that set an
    ///     appropriate focus policy, can accept keyboard focus.
    /// 
    ///     \sa setFocus(), hasFocus(), QGraphicsWidget::focusPolicy
    clear_focus(),
    ///     \since 4.6
    /// 
    ///     Returns this item's focus proxy, or 0 if this item has no
    ///     focus proxy.
    /// 
    ///     \sa setFocusProxy(), setFocus(), hasFocus()
    focus_proxy() -> GraphicsItem?,
    ///     \since 4.6
    /// 
    ///     Sets the item's focus proxy to \a item.
    /// 
    ///     If an item has a focus proxy, the focus proxy will receive
    ///     input focus when the item gains input focus. The item itself
    ///     will still have focus (i.e., hasFocus() will return true),
    ///     but only the focus proxy will receive the keyboard input.
    /// 
    ///     A focus proxy can itself have a focus proxy, and so on. In
    ///     such case, keyboard input will be handled by the outermost
    ///     focus proxy.
    /// 
    ///     The focus proxy \a item must belong to the same scene as
    ///     this item.
    /// 
    ///     \sa focusProxy(), setFocus(), hasFocus()
    set_focus_proxy(item: *GraphicsItemType),
    ///     \since 4.6
    /// 
    ///     If this item, a child or descendant of this item currently has input
    ///     focus, this function will return a pointer to that item. If
    ///     no descendant has input focus, 0 is returned.
    /// 
    ///     \sa hasFocus(), setFocus(), QWidget::focusWidget()
    focus_item() -> GraphicsItem?,
    ///     \internal
    /// 
    ///     Returns this item's focus scope item.
    focus_scope_item() -> GraphicsItem?,
    ///     \since 4.4
    ///     Grabs the mouse input.
    /// 
    ///     This item will receive all mouse events for the scene until any of the
    ///     following events occurs:
    /// 
    ///     \list
    ///     \li The item becomes invisible
    ///     \li The item is removed from the scene
    ///     \li The item is deleted
    ///     \li The item call ungrabMouse()
    ///     \li Another item calls grabMouse(); the item will regain the mouse grab
    ///     when the other item calls ungrabMouse().
    ///     \endlist
    /// 
    ///     When an item gains the mouse grab, it receives a QEvent::GrabMouse
    ///     event. When it loses the mouse grab, it receives a QEvent::UngrabMouse
    ///     event. These events can be used to detect when your item gains or loses
    ///     the mouse grab through other means than receiving mouse button events.
    /// 
    ///     It is almost never necessary to explicitly grab the mouse in Qt, as Qt
    ///     grabs and releases it sensibly. In particular, Qt grabs the mouse when you
    ///     press a mouse button, and keeps the mouse grabbed until you release the
    ///     last mouse button. Also, Qt::Popup widgets implicitly call grabMouse()
    ///     when shown, and ungrabMouse() when hidden.
    /// 
    ///     Note that only visible items can grab mouse input. Calling grabMouse() on
    ///     an invisible item has no effect.
    /// 
    ///     Keyboard events are not affected.
    /// 
    ///     \sa QGraphicsScene::mouseGrabberItem(), ungrabMouse(), grabKeyboard()
    grab_mouse(),
    ///     \since 4.4
    ///     Releases the mouse grab.
    /// 
    ///     \sa grabMouse(), ungrabKeyboard()
    ungrab_mouse(),
    ///     \since 4.4
    ///     Grabs the keyboard input.
    /// 
    ///     The item will receive all keyboard input to the scene until one of the
    ///     following events occur:
    /// 
    ///     \list
    ///     \li The item becomes invisible
    ///     \li The item is removed from the scene
    ///     \li The item is deleted
    ///     \li The item calls ungrabKeyboard()
    ///     \li Another item calls grabKeyboard(); the item will regain the keyboard grab
    ///     when the other item calls ungrabKeyboard().
    ///     \endlist
    /// 
    ///     When an item gains the keyboard grab, it receives a QEvent::GrabKeyboard
    ///     event. When it loses the keyboard grab, it receives a
    ///     QEvent::UngrabKeyboard event. These events can be used to detect when your
    ///     item gains or loses the keyboard grab through other means than gaining
    ///     input focus.
    /// 
    ///     It is almost never necessary to explicitly grab the keyboard in Qt, as Qt
    ///     grabs and releases it sensibly. In particular, Qt grabs the keyboard when
    ///     your item gains input focus, and releases it when your item loses input
    ///     focus, or when the item is hidden.
    /// 
    ///     Note that only visible items can grab keyboard input. Calling
    ///     grabKeyboard() on an invisible item has no effect.
    /// 
    ///     Keyboard events are not affected.
    /// 
    ///     \sa ungrabKeyboard(), grabMouse(), setFocus()
    grab_keyboard(),
    ///     \since 4.4
    ///     Releases the keyboard grab.
    /// 
    ///     \sa grabKeyboard(), ungrabMouse()
    ungrab_keyboard(),
    ///     Returns the position of the item in parent coordinates. If the item has no
    ///     parent, its position is given in scene coordinates.
    /// 
    ///     The position of the item describes its origin (local coordinate
    ///     (0, 0)) in parent coordinates; this function returns the same as
    ///     mapToParent(0, 0).
    /// 
    ///     For convenience, you can also call scenePos() to determine the
    ///     item's position in scene coordinates, regardless of its parent.
    /// 
    ///     \sa x(), y(), setPos(), transform(), {The Graphics View Coordinate System}
    pos() -> PointF,
    x() -> f32,
    ///     \since 4.6
    /// 
    ///     Set's the \a x coordinate of the item's position. Equivalent to
    ///     calling setPos(x, y()).
    /// 
    ///     \sa x(), setPos()
    set_x(x: f32),
    y() -> f32,
    ///     \since 4.6
    /// 
    ///     Set's the \a y coordinate of the item's position. Equivalent to
    ///     calling setPos(x(), y).
    /// 
    ///     \sa x(), setPos()
    set_y(y: f32),
    ///     Returns the item's position in scene coordinates. This is
    ///     equivalent to calling \c mapToScene(0, 0).
    /// 
    ///     \sa pos(), sceneTransform(), {The Graphics View Coordinate System}
    scene_pos() -> PointF,
    ///     Sets the position of the item to \a pos, which is in parent
    ///     coordinates.  For items with no parent, \a pos is in scene
    ///     coordinates.
    /// 
    ///     The position of the item describes its origin (local coordinate
    ///     (0, 0)) in parent coordinates.
    /// 
    ///     \sa pos(), scenePos(), {The Graphics View Coordinate System}
    set_pos(pos: &PointFType),
    ///     Sets the position of the item to \a pos, which is in parent
    ///     coordinates.  For items with no parent, \a pos is in scene
    ///     coordinates.
    /// 
    ///     The position of the item describes its origin (local coordinate
    ///     (0, 0)) in parent coordinates.
    /// 
    ///     \sa pos(), scenePos(), {The Graphics View Coordinate System}
    set_pos(x: f32, y: f32),
    move_by(dx: f32, dy: f32),
    ///     If this item is part of a scene that is viewed by a QGraphicsView, this
    ///     convenience function will attempt to scroll the view to ensure that \a
    ///     rect is visible inside the view's viewport. If \a rect is a null rect (the
    ///     default), QGraphicsItem will default to the item's bounding rect. \a xmargin
    ///     and \a ymargin are the number of pixels the view should use for margins.
    /// 
    ///     If the specified rect cannot be reached, the contents are scrolled to the
    ///     nearest valid position.
    /// 
    ///     If this item is not viewed by a QGraphicsView, this function does nothing.
    /// 
    ///     \sa QGraphicsView::ensureVisible()
    ensure_visible(rect: &RectFType, xmargin: i32, ymargin: i32),
    ///     If this item is part of a scene that is viewed by a QGraphicsView, this
    ///     convenience function will attempt to scroll the view to ensure that \a
    ///     rect is visible inside the view's viewport. If \a rect is a null rect (the
    ///     default), QGraphicsItem will default to the item's bounding rect. \a xmargin
    ///     and \a ymargin are the number of pixels the view should use for margins.
    /// 
    ///     If the specified rect cannot be reached, the contents are scrolled to the
    ///     nearest valid position.
    /// 
    ///     If this item is not viewed by a QGraphicsView, this function does nothing.
    /// 
    ///     \sa QGraphicsView::ensureVisible()
    ensure_visible(x: f32, y: f32, w: f32, h: f32, xmargin: i32, ymargin: i32),
    ///     \since 4.3
    /// 
    ///     Returns this item's scene transformation matrix. This matrix can be used
    ///     to map coordinates and geometrical shapes from this item's local
    ///     coordinate system to the scene's coordinate system. To map coordinates
    ///     from the scene, you must first invert the returned matrix.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 4
    /// 
    ///     Unlike transform(), which returns only an item's local transformation, this
    ///     function includes the item's (and any parents') position, and all the transfomation properties.
    /// 
    ///     \sa transform(), setTransform(), scenePos(), {The Graphics View Coordinate System}, {Transformations}
    scene_transform() -> Transform,
    ///     \since 4.3
    /// 
    ///     Returns this item's device transformation matrix, using \a
    ///     viewportTransform to map from scene to device coordinates. This matrix can
    ///     be used to map coordinates and geometrical shapes from this item's local
    ///     coordinate system to the viewport's (or any device's) coordinate
    ///     system. To map coordinates from the viewport, you must first invert the
    ///     returned matrix.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 5
    /// 
    ///     This function is the same as combining this item's scene transform with
    ///     the view's viewport transform, but it also understands the
    ///     ItemIgnoresTransformations flag. The device transform can be used to do
    ///     accurate coordinate mapping (and collision detection) for untransformable
    ///     items.
    /// 
    ///     \sa transform(), setTransform(), scenePos(), {The Graphics View Coordinate
    ///     System}, itemTransform()
    device_transform(viewport_transform: &TransformType) -> Transform,
    ///     \since 4.5
    /// 
    ///     Returns a QTransform that maps coordinates from this item to \a other. If
    ///     \a ok is not null, and if there is no such transform, the boolean pointed
    ///     to by \a ok will be set to false; otherwise it will be set to true.
    /// 
    ///     This transform provides an alternative to the mapToItem() or mapFromItem()
    ///     functions, by returning the appropriate transform so that you can map
    ///     shapes and coordinates yourself. It also helps you write more efficient
    ///     code when repeatedly mapping between the same two items.
    /// 
    ///     \note In rare circumstances, there is no transform that maps between two
    ///     items.
    /// 
    ///     \sa mapToItem(), mapFromItem(), deviceTransform()
    item_transform(other: *GraphicsItemType, ok: *bool) -> Transform,
    ///     \since 4.3
    /// 
    ///     Sets the item's current transformation matrix to \a matrix.
    /// 
    ///     If \a combine is true, then \a matrix is combined with the current matrix;
    ///     otherwise, \a matrix \e replaces the current matrix. \a combine is false
    ///     by default.
    /// 
    ///     To simplify interaction with items using a transformed view, QGraphicsItem
    ///     provides mapTo... and mapFrom... functions that can translate between
    ///     items' and the scene's coordinates. For example, you can call mapToScene()
    ///     to map an item coordiate to a scene coordinate, or mapFromScene() to map
    ///     from scene coordinates to item coordinates.
    /// 
    ///     The transformation matrix is combined with the item's rotation(), scale()
    ///     and transformations() into a combined transformation that maps the item's
    ///     coordinate system to its parent.
    /// 
    ///     \sa transform(), setRotation(), setScale(), setTransformOriginPoint(), {The Graphics View Coordinate System}, {Transformations}
    set_transform(matrix: &TransformType, combine: bool),
    ///     \since 4.3
    /// 
    ///     Resets this item's transformation matrix to the identity matrix or
    ///     all the transformation properties to their default values.
    ///     This is equivalent to calling \c setTransform(QTransform()).
    /// 
    ///     \sa setTransform(), transform()
    reset_transform(),
    ///     \since 4.6
    /// 
    ///     Sets the clockwise rotation \a angle, in degrees, around the Z axis. The
    ///     default value is 0 (i.e., the item is not rotated). Assigning a negative
    ///     value will rotate the item counter-clockwise. Normally the rotation angle
    ///     is in the range (-360, 360), but it's also possible to assign values
    ///     outside of this range (e.g., a rotation of 370 degrees is the same as a
    ///     rotation of 10 degrees).
    /// 
    ///     The item is rotated around its transform origin point, which by default
    ///     is (0, 0). You can select a different transformation origin by calling
    ///     setTransformOriginPoint().
    /// 
    ///     The rotation is combined with the item's scale(), transform() and
    ///     transformations() to map the item's coordinate system to the parent item.
    /// 
    ///     \sa rotation(), setTransformOriginPoint(), {Transformations}
    set_rotation(angle: f32),
    ///     \since 4.6
    /// 
    ///     Returns the clockwise rotation, in degrees, around the Z axis. The default
    ///     value is 0 (i.e., the item is not rotated).
    /// 
    ///     The rotation is combined with the item's scale(), transform() and
    ///     transformations() to map the item's coordinate system to the parent item.
    /// 
    ///     \sa setRotation(), transformOriginPoint(), {Transformations}
    rotation() -> f32,
    ///     \since 4.6
    /// 
    ///     Sets the scale \a factor of the item. The default scale factor is 1.0
    ///     (i.e., the item is not scaled). A scale factor of 0.0 will collapse the
    ///     item to a single point. If you provide a negative scale factor, the
    ///     item will be flipped and mirrored (i.e., rotated 180 degrees).
    /// 
    ///     The item is scaled around its transform origin point, which by default
    ///     is (0, 0). You can select a different transformation origin by calling
    ///     setTransformOriginPoint().
    /// 
    ///     The scale is combined with the item's rotation(), transform() and
    ///     transformations() to map the item's coordinate system to the parent item.
    /// 
    ///     \sa scale(), setTransformOriginPoint(), {Transformations Example}
    set_scale(scale: f32),
    ///     \since 4.6
    /// 
    ///     Returns the scale factor of the item. The default scale factor is 1.0
    ///     (i.e., the item is not scaled).
    /// 
    ///     The scale is combined with the item's rotation(), transform() and
    ///     transformations() to map the item's coordinate system to the parent item.
    /// 
    ///     \sa setScale(), rotation(), {Transformations}
    scale() -> f32,
    ///     \since 4.6
    /// 
    ///     Sets a list of graphics \a transformations (QGraphicsTransform) that
    ///     currently apply to this item.
    /// 
    ///     If all you want is to rotate or scale an item, you should call setRotation()
    ///     or setScale() instead. If you want to set an arbitrary transformation on
    ///     an item, you can call setTransform().
    /// 
    ///     QGraphicsTransform is for applying and controlling a chain of individual
    ///     transformation operations on an item. It's particularly useful in
    ///     animations, where each transform operation needs to be interpolated
    ///     independently, or differently.
    /// 
    ///     The transformations are combined with the item's rotation(), scale() and
    ///     transform() to map the item's coordinate system to the parent item.
    /// 
    ///     \sa scale(), setTransformOriginPoint(), {Transformations}
    set_transformations(transformations: [*GraphicsTransformType]),
    ///     \since 4.6
    /// 
    ///     Sets the \a origin point for the transformation in item coordinates.
    /// 
    ///     \sa transformOriginPoint(), {Transformations}
    set_transform_origin_point(origin: &PointFType),
    ///     \since 4.6
    /// 
    ///     Sets the \a origin point for the transformation in item coordinates.
    /// 
    ///     \sa transformOriginPoint(), {Transformations}
    set_transform_origin_point(ax: f32, ay: f32),
    ///     This virtual function is called twice for all items by the
    ///     QGraphicsScene::advance() slot. In the first phase, all items are called
    ///     with \a phase == 0, indicating that items on the scene are about to
    ///     advance, and then all items are called with \a phase == 1. Reimplement
    ///     this function to update your item if you need simple scene-controlled
    ///     animation.
    /// 
    ///     The default implementation does nothing.
    /// 
    ///     This function is intended for animations. An alternative is to
    ///     multiple-inherit from QObject and QGraphicsItem and use the \l{The Animation
    ///     Framework}{Animation Framework}.
    /// 
    ///     \sa QGraphicsScene::advance(), QTimeLine
    [event] advance(phase: i32),
    ///     Returns the Z-value of the item. The Z-value affects the stacking order of
    ///     sibling (neighboring) items.
    /// 
    ///     The default Z-value is 0.
    /// 
    ///     \sa setZValue(), {QGraphicsItem#Sorting}{Sorting}, stackBefore(), ItemStacksBehindParent
    z_value() -> f32,
    ///     Sets the Z-value of the item to \a z. The Z value decides the stacking
    ///     order of sibling (neighboring) items. A sibling item of high Z value will
    ///     always be drawn on top of another sibling item with a lower Z value.
    /// 
    ///     If you restore the Z value, the item's insertion order will decide its
    ///     stacking order.
    /// 
    ///     The Z-value does not affect the item's size in any way.
    /// 
    ///     The default Z-value is 0.
    /// 
    ///     \sa zValue(), {QGraphicsItem#Sorting}{Sorting}, stackBefore(), ItemStacksBehindParent
    set_z_value(z: f32),
    ///     \since 4.6
    /// 
    ///     Stacks this item before \a sibling, which must be a sibling item (i.e., the
    ///     two items must share the same parent item, or must both be toplevel items).
    ///     The \a sibling must have the same Z value as this item, otherwise calling
    ///     this function will have no effect.
    /// 
    ///     By default, all sibling items are stacked by insertion order (i.e., the
    ///     first item you add is drawn before the next item you add). If two items' Z
    ///     values are different, then the item with the highest Z value is drawn on
    ///     top. When the Z values are the same, the insertion order will decide the
    ///     stacking order.
    /// 
    ///     \sa setZValue(), ItemStacksBehindParent, {QGraphicsItem#Sorting}{Sorting}
    stack_before(sibling: *GraphicsItemType),
    [event] bounding_rect() -> RectF,
    ///     Returns the bounding rect of this item's descendants (i.e., its
    ///     children, their children, etc.) in local coordinates. The
    ///     rectangle will contain all descendants after they have been mapped
    ///     to local coordinates. If the item has no children, this function
    ///     returns an empty QRectF.
    /// 
    ///     This does not include this item's own bounding rect; it only returns
    ///     its descendants' accumulated bounding rect. If you need to include this
    ///     item's bounding rect, you can add boundingRect() to childrenBoundingRect()
    ///     using QRectF::operator|().
    /// 
    ///     This function is linear in complexity; it determines the size of the
    ///     returned bounding rect by iterating through all descendants.
    /// 
    ///     \sa boundingRect(), sceneBoundingRect()
    children_bounding_rect() -> RectF,
    ///     Returns the bounding rect of this item in scene coordinates, by combining
    ///     sceneTransform() with boundingRect().
    /// 
    ///     \sa boundingRect(), {The Graphics View Coordinate System}
    scene_bounding_rect() -> RectF,
    ///     Returns the shape of this item as a QPainterPath in local
    ///     coordinates. The shape is used for many things, including collision
    ///     detection, hit tests, and for the QGraphicsScene::items() functions.
    /// 
    ///     The default implementation calls boundingRect() to return a simple
    ///     rectangular shape, but subclasses can reimplement this function to return
    ///     a more accurate shape for non-rectangular items. For example, a round item
    ///     may choose to return an elliptic shape for better collision detection. For
    ///     example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 9
    /// 
    ///     The outline of a shape can vary depending on the width and style of the
    ///     pen used when drawing. If you want to include this outline in the item's
    ///     shape, you can create a shape from the stroke using QPainterPathStroker.
    /// 
    ///     This function is called by the default implementations of contains() and
    ///     collidesWithPath().
    /// 
    ///     \sa boundingRect(), contains(), prepareGeometryChange(), QPainterPathStroker
    [event] shape() -> PainterPath,
    ///     Returns \c true if this item is clipped. An item is clipped if it has either
    ///     set the \l ItemClipsToShape flag, or if it or any of its ancestors has set
    ///     the \l ItemClipsChildrenToShape flag.
    /// 
    ///     Clipping affects the item's appearance (i.e., painting), as well as mouse
    ///     and hover event delivery.
    /// 
    ///     \sa clipPath(), shape(), setFlags()
    is_clipped() -> bool,
    ///     \since 4.5
    /// 
    ///     Returns this item's clip path, or an empty QPainterPath if this item is
    ///     not clipped. The clip path constrains the item's appearance and
    ///     interaction (i.e., restricts the area the item can draw within and receive
    ///     events for).
    /// 
    ///     You can enable clipping by setting the ItemClipsToShape or
    ///     ItemClipsChildrenToShape flags. The item's clip path is calculated by
    ///     intersecting all clipping ancestors' shapes. If the item sets
    ///     ItemClipsToShape, the final clip is intersected with the item's own shape.
    /// 
    ///     \note Clipping introduces a performance penalty for all items involved;
    ///     you should generally avoid using clipping if you can (e.g., if your items
    ///     always draw inside boundingRect() or shape() boundaries, clipping is not
    ///     necessary).
    /// 
    ///     \sa isClipped(), shape(), setFlags()
    clip_path() -> PainterPath,
    ///     Returns \c true if this item contains \a point, which is in local
    ///     coordinates; otherwise, false is returned. It is most often called from
    ///     QGraphicsView to determine what item is under the cursor, and for that
    ///     reason, the implementation of this function should be as light-weight as
    ///     possible.
    /// 
    ///     By default, this function calls shape(), but you can reimplement it in a
    ///     subclass to provide a (perhaps more efficient) implementation.
    /// 
    ///     \sa shape(), boundingRect(), collidesWithPath()
    [event] contains(point: &PointFType) -> bool,
    /// 
    ///     Returns \c true if this item collides with \a other; otherwise
    ///     returns \c false.
    /// 
    ///     The \a mode is applied to \a other, and the resulting shape or
    ///     bounding rectangle is then compared to this item's shape. The
    ///     default value for \a mode is Qt::IntersectsItemShape; \a other
    ///     collides with this item if it either intersects, contains, or is
    ///     contained by this item's shape (see Qt::ItemSelectionMode for
    ///     details).
    /// 
    ///     The default implementation is based on shape intersection, and it calls
    ///     shape() on both items. Because the complexity of arbitrary shape-shape
    ///     intersection grows with an order of magnitude when the shapes are complex,
    ///     this operation can be noticably time consuming. You have the option of
    ///     reimplementing this function in a subclass of QGraphicsItem to provide a
    ///     custom algorithm. This allows you to make use of natural constraints in
    ///     the shapes of your own items, in order to improve the performance of the
    ///     collision detection. For instance, two untransformed perfectly circular
    ///     items' collision can be determined very efficiently by comparing their
    ///     positions and radii.
    /// 
    ///     Keep in mind that when reimplementing this function and calling shape() or
    ///     boundingRect() on \a other, the returned coordinates must be mapped to
    ///     this item's coordinate system before any intersection can take place.
    /// 
    ///     \sa contains(), shape()
    [event] collides_with_item(other: *GraphicsItemType, mode: Rute::ItemSelectionMode) -> bool,
    ///     Returns \c true if this item collides with \a path.
    /// 
    ///     The collision is determined by \a mode. The default value for \a mode is
    ///     Qt::IntersectsItemShape; \a path collides with this item if it either
    ///     intersects, contains, or is contained by this item's shape.
    /// 
    ///     Note that this function checks whether the item's shape or
    ///     bounding rectangle (depending on \a mode) is contained within \a
    ///     path, and not whether \a path is contained within the items shape
    ///     or bounding rectangle.
    /// 
    ///     \sa collidesWithItem(), contains(), shape()
    [event] collides_with_path(path: &PainterPathType, mode: Rute::ItemSelectionMode) -> bool,
    ///     Returns a list of all items that collide with this item.
    /// 
    ///     The way collisions are detected is determined by applying \a mode
    ///     to items that are compared to this item, i.e., each item's shape
    ///     or bounding rectangle is checked against this item's shape. The
    ///     default value for \a mode is Qt::IntersectsItemShape.
    /// 
    ///     \sa collidesWithItem()
    colliding_items(mode: Rute::ItemSelectionMode) -> [GraphicsItem?],
    ///     \overload
    ///     \since 4.3
    /// 
    ///     Returns \c true if \a rect is completely obscured by the opaque shape of any
    ///     of colliding items above it (i.e., with a higher Z value than this item).
    /// 
    ///     \sa opaqueArea()
    is_obscured(rect: &RectFType) -> bool,
    ///     \overload
    ///     \since 4.3
    /// 
    ///     Returns \c true if \a rect is completely obscured by the opaque shape of any
    ///     of colliding items above it (i.e., with a higher Z value than this item).
    /// 
    ///     \sa opaqueArea()
    is_obscured(x: f32, y: f32, w: f32, h: f32) -> bool,
    ///     Returns \c true if this item's bounding rect is completely obscured by the
    ///     opaque shape of \a item.
    /// 
    ///     The base implementation maps \a item's opaqueArea() to this item's
    ///     coordinate system, and then checks if this item's boundingRect() is fully
    ///     contained within the mapped shape.
    /// 
    ///     You can reimplement this function to provide a custom algorithm for
    ///     determining whether this item is obscured by \a item.
    /// 
    ///     \sa opaqueArea(), isObscured()
    [event] is_obscured_by(item: *GraphicsItemType) -> bool,
    ///     This virtual function returns a shape representing the area where this
    ///     item is opaque. An area is opaque if it is filled using an opaque brush or
    ///     color (i.e., not transparent).
    /// 
    ///     This function is used by isObscuredBy(), which is called by underlying
    ///     items to determine if they are obscured by this item.
    /// 
    ///     The default implementation returns an empty QPainterPath, indicating that
    ///     this item is completely transparent and does not obscure any other items.
    /// 
    ///     \sa isObscuredBy(), isObscured(), shape()
    [event] opaque_area() -> PainterPath,
    ///     \since 4.4
    /// 
    ///     Returns the bounding region for this item. The coordinate space of the
    ///     returned region depends on \a itemToDeviceTransform. If you pass an
    ///     identity QTransform as a parameter, this function will return a local
    ///     coordinate region.
    /// 
    ///     The bounding region describes a coarse outline of the item's visual
    ///     contents. Although it's expensive to calculate, it's also more precise
    ///     than boundingRect(), and it can help to avoid unnecessary repainting when
    ///     an item is updated. This is particularly efficient for thin items (e.g.,
    ///     lines or simple polygons). You can tune the granularity for the bounding
    ///     region by calling setBoundingRegionGranularity(). The default granularity
    ///     is 0; in which the item's bounding region is the same as its bounding
    ///     rect.
    /// 
    ///     \a itemToDeviceTransform is the transformation from item coordinates to
    ///     device coordinates. If you want this function to return a QRegion in scene
    ///     coordinates, you can pass sceneTransform() as an argument.
    /// 
    ///     \sa boundingRegionGranularity()
    bounding_region(item_to_device_transform: &TransformType) -> Region,
    ///     \since 4.4
    /// 
    ///     Returns the item's bounding region granularity; a value between and
    ///     including 0 and 1. The default value is 0 (i.e., the lowest granularity,
    ///     where the bounding region corresponds to the item's bounding rectangle).
    /// 
    /// \omit
    /// ### NOTE
    /// \endomit
    /// 
    ///     \sa setBoundingRegionGranularity()
    bounding_region_granularity() -> f32,
    ///     \since 4.4
    ///     Sets the bounding region granularity to \a granularity; a value between
    ///     and including 0 and 1. The default value is 0 (i.e., the lowest
    ///     granularity, where the bounding region corresponds to the item's bounding
    ///     rectangle).
    /// 
    ///     The granularity is used by boundingRegion() to calculate how fine the
    ///     bounding region of the item should be. The highest achievable granularity
    ///     is 1, where boundingRegion() will return the finest outline possible for
    ///     the respective device (e.g., for a QGraphicsView viewport, this gives you
    ///     a pixel-perfect bounding region). The lowest possible granularity is
    ///     0. The value of \a granularity describes the ratio between device
    ///     resolution and the resolution of the bounding region (e.g., a value of
    ///     0.25 will provide a region where each chunk corresponds to 4x4 device
    ///     units / pixels).
    /// 
    ///     \sa boundingRegionGranularity()
    set_bounding_region_granularity(granularity: f32),
    [event] paint(painter: *PainterType, option: *StyleOptionGraphicsItemType, widget: *WidgetType),
    ///     Schedules a redraw of the area covered by \a rect in this item. You can
    ///     call this function whenever your item needs to be redrawn, such as if it
    ///     changes appearance or size.
    /// 
    ///     This function does not cause an immediate paint; instead it schedules a
    ///     paint request that is processed by QGraphicsView after control reaches the
    ///     event loop. The item will only be redrawn if it is visible in any
    ///     associated view.
    /// 
    ///     As a side effect of the item being repainted, other items that overlap the
    ///     area \a rect may also be repainted.
    /// 
    ///     If the item is invisible (i.e., isVisible() returns \c false), this function
    ///     does nothing.
    /// 
    ///     \sa paint(), boundingRect()
    update(rect: &RectFType),
    ///     Schedules a redraw of the area covered by \a rect in this item. You can
    ///     call this function whenever your item needs to be redrawn, such as if it
    ///     changes appearance or size.
    /// 
    ///     This function does not cause an immediate paint; instead it schedules a
    ///     paint request that is processed by QGraphicsView after control reaches the
    ///     event loop. The item will only be redrawn if it is visible in any
    ///     associated view.
    /// 
    ///     As a side effect of the item being repainted, other items that overlap the
    ///     area \a rect may also be repainted.
    /// 
    ///     If the item is invisible (i.e., isVisible() returns \c false), this function
    ///     does nothing.
    /// 
    ///     \sa paint(), boundingRect()
    update(x: f32, y: f32, width: f32, height: f32),
    ///     \since 4.4
    ///     Scrolls the contents of \a rect by \a dx, \a dy. If \a rect is a null rect
    ///     (the default), the item's bounding rect is scrolled.
    /// 
    ///     Scrolling provides a fast alternative to simply redrawing when the
    ///     contents of the item (or parts of the item) are shifted vertically or
    ///     horizontally. Depending on the current transformation and the capabilities
    ///     of the paint device (i.e., the viewport), this operation may consist of
    ///     simply moving pixels from one location to another using memmove(). In most
    ///     cases this is faster than rerendering the entire area.
    /// 
    ///     After scrolling, the item will issue an update for the newly exposed
    ///     areas. If scrolling is not supported (e.g., you are rendering to an OpenGL
    ///     viewport, which does not benefit from scroll optimizations), this function
    ///     is equivalent to calling update(\a rect).
    /// 
    ///     \b{Note:} Scrolling is only supported when QGraphicsItem::ItemCoordinateCache
    ///     is enabled; in all other cases calling this function is equivalent to calling
    ///     update(\a rect). If you for sure know that the item is opaque and not overlapped
    ///     by other items, you can map the \a rect to viewport coordinates and scroll the
    ///     viewport.
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 19
    /// 
    ///     \sa boundingRect()
    scroll(dx: f32, dy: f32, rect: &RectFType),
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_to_item(item: *GraphicsItemType, point: &PointFType) -> PointF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped path. If the
    ///     item has no parent, \a path will be mapped to the scene's coordinate
    ///     system.
    /// 
    ///     \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View
    ///     Coordinate System}
    map_to_parent(point: &PointFType) -> PointF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     the scene's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View
    ///     Coordinate System}
    map_to_scene(point: &PointFType) -> PointF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_to_item(item: *GraphicsItemType, rect: &RectFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped path. If the
    ///     item has no parent, \a path will be mapped to the scene's coordinate
    ///     system.
    /// 
    ///     \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View
    ///     Coordinate System}
    map_to_parent(rect: &RectFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     the scene's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View
    ///     Coordinate System}
    map_to_scene(rect: &RectFType) -> PolygonF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     If \a item is 0, this function returns the same as mapRectToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_to_item(item: *GraphicsItemType, rect: &RectFType) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_to_parent(rect: &RectFType) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's coordinate system, to
    ///     the scene coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_to_scene(rect: &RectFType) -> RectF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_to_item(item: *GraphicsItemType, polygon: &PolygonFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped path. If the
    ///     item has no parent, \a path will be mapped to the scene's coordinate
    ///     system.
    /// 
    ///     \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View
    ///     Coordinate System}
    map_to_parent(polygon: &PolygonFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     the scene's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View
    ///     Coordinate System}
    map_to_scene(polygon: &PolygonFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_to_item(item: *GraphicsItemType, path: &PainterPathType) -> PainterPath,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped path. If the
    ///     item has no parent, \a path will be mapped to the scene's coordinate
    ///     system.
    /// 
    ///     \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View
    ///     Coordinate System}
    map_to_parent(path: &PainterPathType) -> PainterPath,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     the scene's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View
    ///     Coordinate System}
    map_to_scene(path: &PainterPathType) -> PainterPath,
    ///     Maps the path \a path, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapFromScene().
    /// 
    ///     \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The
    ///     Graphics View Coordinate System}
    map_from_item(item: *GraphicsItemType, point: &PointFType) -> PointF,
    ///     Maps the path \a path, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View
    ///     Coordinate System}
    map_from_parent(point: &PointFType) -> PointF,
    ///     Maps the path \a path, which is in this item's scene's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View
    ///     Coordinate System}
    map_from_scene(point: &PointFType) -> PointF,
    ///     Maps the path \a path, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapFromScene().
    /// 
    ///     \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The
    ///     Graphics View Coordinate System}
    map_from_item(item: *GraphicsItemType, rect: &RectFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View
    ///     Coordinate System}
    map_from_parent(rect: &RectFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's scene's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View
    ///     Coordinate System}
    map_from_scene(rect: &RectFType) -> PolygonF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     If \a item is 0, this function returns the same as mapRectFromScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_from_item(item: *GraphicsItemType, rect: &RectFType) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped rectangle
    ///     as a new rectangle (i.e., the bounding rectangle of the resulting
    ///     polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_from_parent(rect: &RectFType) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in scene coordinates, to this item's
    ///     coordinate system, and returns the mapped rectangle as a new rectangle
    ///     (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_from_scene(rect: &RectFType) -> RectF,
    ///     Maps the path \a path, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapFromScene().
    /// 
    ///     \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The
    ///     Graphics View Coordinate System}
    map_from_item(item: *GraphicsItemType, polygon: &PolygonFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View
    ///     Coordinate System}
    map_from_parent(polygon: &PolygonFType) -> PolygonF,
    ///     Maps the path \a path, which is in this item's scene's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View
    ///     Coordinate System}
    map_from_scene(polygon: &PolygonFType) -> PolygonF,
    ///     Maps the path \a path, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapFromScene().
    /// 
    ///     \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The
    ///     Graphics View Coordinate System}
    map_from_item(item: *GraphicsItemType, path: &PainterPathType) -> PainterPath,
    ///     Maps the path \a path, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View
    ///     Coordinate System}
    map_from_parent(path: &PainterPathType) -> PainterPath,
    ///     Maps the path \a path, which is in this item's scene's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View
    ///     Coordinate System}
    map_from_scene(path: &PainterPathType) -> PainterPath,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_to_item(item: *GraphicsItemType, x: f32, y: f32) -> PointF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped path. If the
    ///     item has no parent, \a path will be mapped to the scene's coordinate
    ///     system.
    /// 
    ///     \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View
    ///     Coordinate System}
    map_to_parent(x: f32, y: f32) -> PointF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     the scene's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View
    ///     Coordinate System}
    map_to_scene(x: f32, y: f32) -> PointF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_to_item(item: *GraphicsItemType, x: f32, y: f32, w: f32, h: f32) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped path. If the
    ///     item has no parent, \a path will be mapped to the scene's coordinate
    ///     system.
    /// 
    ///     \sa mapToScene(), mapToItem(), mapFromParent(), {The Graphics View
    ///     Coordinate System}
    map_to_parent(x: f32, y: f32, w: f32, h: f32) -> PolygonF,
    ///     Maps the path \a path, which is in this item's coordinate system, to
    ///     the scene's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapToParent(), mapToItem(), mapFromScene(), {The Graphics View
    ///     Coordinate System}
    map_to_scene(x: f32, y: f32, w: f32, h: f32) -> PolygonF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's coordinate system, to
    ///     \a item's coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     If \a item is 0, this function returns the same as mapRectToScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_to_item(item: *GraphicsItemType, x: f32, y: f32, w: f32, h: f32) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's coordinate system, to
    ///     its parent's coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_to_parent(x: f32, y: f32, w: f32, h: f32) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's coordinate system, to
    ///     the scene coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_to_scene(x: f32, y: f32, w: f32, h: f32) -> RectF,
    ///     Maps the path \a path, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapFromScene().
    /// 
    ///     \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The
    ///     Graphics View Coordinate System}
    map_from_item(item: *GraphicsItemType, x: f32, y: f32) -> PointF,
    ///     Maps the path \a path, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View
    ///     Coordinate System}
    map_from_parent(x: f32, y: f32) -> PointF,
    ///     Maps the path \a path, which is in this item's scene's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View
    ///     Coordinate System}
    map_from_scene(x: f32, y: f32) -> PointF,
    ///     Maps the path \a path, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped path.
    /// 
    ///     If \a item is 0, this function returns the same as mapFromScene().
    /// 
    ///     \sa itemTransform(), mapFromParent(), mapFromScene(), mapToItem(), {The
    ///     Graphics View Coordinate System}
    map_from_item(item: *GraphicsItemType, x: f32, y: f32, w: f32, h: f32) -> PolygonF,
    ///     Maps the path \a path, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromScene(), mapFromItem(), mapToParent(), {The Graphics View
    ///     Coordinate System}
    map_from_parent(x: f32, y: f32, w: f32, h: f32) -> PolygonF,
    ///     Maps the path \a path, which is in this item's scene's coordinate
    ///     system, to this item's coordinate system, and returns the mapped path.
    /// 
    ///     \sa mapFromParent(), mapFromItem(), mapToScene(), {The Graphics View
    ///     Coordinate System}
    map_from_scene(x: f32, y: f32, w: f32, h: f32) -> PolygonF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in \a item's coordinate system, to
    ///     this item's coordinate system, and returns the mapped rectangle as a new
    ///     rectangle (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     If \a item is 0, this function returns the same as mapRectFromScene().
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_from_item(item: *GraphicsItemType, x: f32, y: f32, w: f32, h: f32) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in this item's parent's coordinate
    ///     system, to this item's coordinate system, and returns the mapped rectangle
    ///     as a new rectangle (i.e., the bounding rectangle of the resulting
    ///     polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_from_parent(x: f32, y: f32, w: f32, h: f32) -> RectF,
    ///     \since 4.5
    /// 
    ///     Maps the rectangle \a rect, which is in scene coordinates, to this item's
    ///     coordinate system, and returns the mapped rectangle as a new rectangle
    ///     (i.e., the bounding rectangle of the resulting polygon).
    /// 
    ///     \sa itemTransform(), mapToParent(), mapToScene(), mapFromItem(), {The
    ///     Graphics View Coordinate System}
    map_rect_from_scene(x: f32, y: f32, w: f32, h: f32) -> RectF,
    ///     Returns \c true if this item is an ancestor of \a child (i.e., if this item
    ///     is \a child's parent, or one of \a child's parent's ancestors).
    /// 
    ///     \sa parentItem()
    is_ancestor_of(child: *GraphicsItemType) -> bool,
    ///     \since 4.4
    /// 
    ///     Returns the closest common ancestor item of this item and \a other, or 0
    ///     if either \a other is 0, or there is no common ancestor.
    /// 
    ///     \sa isAncestorOf()
    common_ancestor_item(other: *GraphicsItemType) -> GraphicsItem?,
    ///     \since 4.4
    ///     Returns \c true if this item is currently under the mouse cursor in one of
    ///     the views; otherwise, false is returned.
    /// 
    ///     \sa QGraphicsScene::views(), QCursor::pos()
    is_under_mouse() -> bool,
    ///     Returns this item's custom data for the key \a key as a QVariant.
    /// 
    ///     Custom item data is useful for storing arbitrary properties in any
    ///     item. Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 11
    /// 
    ///     Qt does not use this feature for storing data; it is provided solely
    ///     for the convenience of the user.
    /// 
    ///     \sa setData()
    data(key: i32) -> Variant,
    ///     Sets this item's custom data for the key \a key to \a value.
    /// 
    ///     Custom item data is useful for storing arbitrary properties for any
    ///     item. Qt does not use this feature for storing data; it is provided solely
    ///     for the convenience of the user.
    /// 
    ///     \sa data()
    set_data(key: i32, value: &VariantType),
    ///     Returns the current input method hints of this item.
    /// 
    ///     Input method hints are only relevant for input items.
    ///     The hints are used by the input method to indicate how it should operate.
    ///     For example, if the Qt::ImhNumbersOnly flag is set, the input method may change
    ///     its visual components to reflect that only numbers can be entered.
    /// 
    ///     The effect may vary between input method implementations.
    /// 
    ///     \since 4.6
    /// 
    ///     \sa setInputMethodHints(), inputMethodQuery()
    input_method_hints() -> Rute::InputMethodHints,
    ///     Sets the current input method hints of this item to \a hints.
    /// 
    ///     \since 4.6
    /// 
    ///     \sa inputMethodHints(), inputMethodQuery()
    set_input_method_hints(hints: Rute::InputMethodHints),
    ///     Returns the type of an item as an int. All standard graphicsitem classes
    ///     are associated with a unique value; see QGraphicsItem::Type. This type
    ///     information is used by qgraphicsitem_cast() to distinguish between types.
    /// 
    ///     The default implementation (in QGraphicsItem) returns UserType.
    /// 
    ///     To enable use of qgraphicsitem_cast() with a custom item, reimplement this
    ///     function and declare a Type enum value equal to your custom item's type.
    ///     Custom items must return a value larger than or equal to UserType (65536).
    /// 
    ///     For example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 1
    /// 
    ///     \sa UserType
    [event] type() -> i32,
    ///     Installs an event filter for this item on \a filterItem, causing
    ///     all events for this item to first pass through \a filterItem's
    ///     sceneEventFilter() function.
    /// 
    ///     To filter another item's events, install this item as an event filter
    ///     for the other item. Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 12
    /// 
    ///     An item can only filter events for other items in the same
    ///     scene. Also, an item cannot filter its own events; instead, you
    ///     can reimplement sceneEvent() directly.
    /// 
    ///     Items must belong to a scene for scene event filters to be installed and
    ///     used.
    /// 
    ///     \sa removeSceneEventFilter(), sceneEventFilter(), sceneEvent()
    install_scene_event_filter(filter_item: *GraphicsItemType),
    ///     Removes an event filter on this item from \a filterItem.
    /// 
    ///     \sa installSceneEventFilter()
    remove_scene_event_filter(filter_item: *GraphicsItemType),
    ///     Updates the item's micro focus.
    /// 
    ///     \since 4.7
    /// 
    ///     \sa QInputMethod
    update_micro_focus(),
    ///     Filters events for the item \a watched. \a event is the filtered
    ///     event.
    /// 
    ///     Reimplementing this function in a subclass makes it possible
    ///     for the item to be used as an event filter for other items,
    ///     intercepting all the events sent to those items before they are
    ///     able to respond.
    /// 
    ///     Reimplementations must return true to prevent further processing of
    ///     a given event, ensuring that it will not be delivered to the watched
    ///     item, or return false to indicate that the event should be propagated
    ///     further by the event system.
    /// 
    ///     \sa installSceneEventFilter()
    [event] scene_event_filter(watched: *GraphicsItemType, event: *EventType) -> bool,
    ///     This virtual function receives events to this item. Reimplement
    ///     this function to intercept events before they are dispatched to
    ///     the specialized event handlers contextMenuEvent(), focusInEvent(),
    ///     focusOutEvent(), hoverEnterEvent(), hoverMoveEvent(),
    ///     hoverLeaveEvent(), keyPressEvent(), keyReleaseEvent(),
    ///     mousePressEvent(), mouseReleaseEvent(), mouseMoveEvent(), and
    ///     mouseDoubleClickEvent().
    /// 
    ///     Returns \c true if the event was recognized and handled; otherwise, (e.g., if
    ///     the event type was not recognized,) false is returned.
    /// 
    ///     \a event is the intercepted event.
    [event] scene_event(event: *EventType) -> bool,
    ///     This event handler can be reimplemented in a subclass to process context
    ///     menu events. The \a event parameter contains details about the event to
    ///     be handled.
    /// 
    ///     If you ignore the event (i.e., by calling QEvent::ignore()), \a event
    ///     will propagate to any item beneath this item. If no items accept the
    ///     event, it will be ignored by the scene and propagate to the view.
    /// 
    ///     It's common to open a QMenu in response to receiving a context menu
    ///     event. Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 13
    /// 
    ///     The default implementation ignores the event.
    /// 
    ///     \sa sceneEvent()
    [event] context_menu_event(event: *GraphicsSceneContextMenuEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     drag enter events for this item. Drag enter events are generated as the
    ///     cursor enters the item's area.
    /// 
    ///     By accepting the event (i.e., by calling QEvent::accept()), the item will
    ///     accept drop events, in addition to receiving drag move and drag
    ///     leave. Otherwise, the event will be ignored and propagate to the item
    ///     beneath. If the event is accepted, the item will receive a drag move event
    ///     before control goes back to the event loop.
    /// 
    ///     A common implementation of dragEnterEvent accepts or ignores \a event
    ///     depending on the associated mime data in \a event. Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 14
    /// 
    ///     Items do not receive drag and drop events by default; to enable this
    ///     feature, call \c setAcceptDrops(true).
    /// 
    ///     The default implementation does nothing.
    /// 
    ///     \sa dropEvent(), dragMoveEvent(), dragLeaveEvent()
    [event] drag_enter_event(event: *GraphicsSceneDragDropEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     drag leave events for this item. Drag leave events are generated as the
    ///     cursor leaves the item's area. Most often you will not need to reimplement
    ///     this function, but it can be useful for resetting state in your item
    ///     (e.g., highlighting).
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.
    /// 
    ///     Items do not receive drag and drop events by default; to enable this
    ///     feature, call \c setAcceptDrops(true).
    /// 
    ///     The default implementation does nothing.
    /// 
    ///     \sa dragEnterEvent(), dropEvent(), dragMoveEvent()
    [event] drag_leave_event(event: *GraphicsSceneDragDropEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     drag move events for this item. Drag move events are generated as the
    ///     cursor moves around inside the item's area. Most often you will not need
    ///     to reimplement this function; it is used to indicate that only parts of
    ///     the item can accept drops.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event toggles whether
    ///     or not the item will accept drops at the position from the event. By
    ///     default, \a event is accepted, indicating that the item allows drops at
    ///     the specified position.
    /// 
    ///     Items do not receive drag and drop events by default; to enable this
    ///     feature, call \c setAcceptDrops(true).
    /// 
    ///     The default implementation does nothing.
    /// 
    ///     \sa dropEvent(), dragEnterEvent(), dragLeaveEvent()
    [event] drag_move_event(event: *GraphicsSceneDragDropEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     drop events for this item. Items can only receive drop events if the last
    ///     drag move event was accepted.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.
    /// 
    ///     Items do not receive drag and drop events by default; to enable this
    ///     feature, call \c setAcceptDrops(true).
    /// 
    ///     The default implementation does nothing.
    /// 
    ///     \sa dragEnterEvent(), dragMoveEvent(), dragLeaveEvent()
    [event] drop_event(event: *GraphicsSceneDragDropEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     focus in events for this item. The default implementation calls
    ///     ensureVisible().
    /// 
    ///     \sa focusOutEvent(), sceneEvent(), setFocus()
    [event] focus_in_event(event: *FocusEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     focus out events for this item. The default implementation does nothing.
    /// 
    ///     \sa focusInEvent(), sceneEvent(), setFocus()
    [event] focus_out_event(event: *FocusEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     hover enter events for this item. The default implementation calls
    ///     update(); otherwise it does nothing.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.
    /// 
    ///     \sa hoverMoveEvent(), hoverLeaveEvent(), sceneEvent(), setAcceptHoverEvents()
    [event] hover_enter_event(event: *GraphicsSceneHoverEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     hover move events for this item. The default implementation does nothing.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.
    /// 
    ///     \sa hoverEnterEvent(), hoverLeaveEvent(), sceneEvent(), setAcceptHoverEvents()
    [event] hover_move_event(event: *GraphicsSceneHoverEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     hover leave events for this item. The default implementation calls
    ///     update(); otherwise it does nothing.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no effect.
    /// 
    ///     \sa hoverEnterEvent(), hoverMoveEvent(), sceneEvent(), setAcceptHoverEvents()
    [event] hover_leave_event(event: *GraphicsSceneHoverEventType),
    ///     This event handler, for event \a event, can be reimplemented to
    ///     receive key press events for this item. The default implementation
    ///     ignores the event. If you reimplement this handler, the event will by
    ///     default be accepted.
    /// 
    ///     Note that key events are only received for items that set the
    ///     ItemIsFocusable flag, and that have keyboard input focus.
    /// 
    ///     \sa keyReleaseEvent(), setFocus(), QGraphicsScene::setFocusItem(),
    ///     sceneEvent()
    [event] key_press_event(event: *KeyEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     key release events for this item. The default implementation
    ///     ignores the event. If you reimplement this handler, the event will by
    ///     default be accepted.
    /// 
    ///     Note that key events are only received for items that set the
    ///     ItemIsFocusable flag, and that have keyboard input focus.
    /// 
    ///     \sa keyPressEvent(), setFocus(), QGraphicsScene::setFocusItem(),
    ///     sceneEvent()
    [event] key_release_event(event: *KeyEventType),
    ///     This event handler, for event \a event, can be reimplemented to
    ///     receive mouse press events for this item. Mouse press events are
    ///     only delivered to items that accept the mouse button that is
    ///     pressed. By default, an item accepts all mouse buttons, but you
    ///     can change this by calling setAcceptedMouseButtons().
    /// 
    ///     The mouse press event decides which item should become the mouse
    ///     grabber (see QGraphicsScene::mouseGrabberItem()). If you do not
    ///     reimplement this function, the press event will propagate to any
    ///     topmost item beneath this item, and no other mouse events will be
    ///     delivered to this item.
    /// 
    ///     If you do reimplement this function, \a event will by default be
    ///     accepted (see QEvent::accept()), and this item is then the mouse
    ///     grabber. This allows the item to receive future move, release and
    ///     doubleclick events. If you call QEvent::ignore() on \a event, this
    ///     item will lose the mouse grab, and \a event will propagate to any
    ///     topmost item beneath. No further mouse events will be delivered to
    ///     this item unless a new mouse press event is received.
    /// 
    ///     The default implementation handles basic item interaction, such as
    ///     selection and moving. If you want to keep the base implementation
    ///     when reimplementing this function, call
    ///     QGraphicsItem::mousePressEvent() in your reimplementation.
    /// 
    ///     The event is \l{QEvent::ignore()}d for items that are neither
    ///     \l{QGraphicsItem::ItemIsMovable}{movable} nor
    ///     \l{QGraphicsItem::ItemIsSelectable}{selectable}.
    /// 
    ///     \sa mouseMoveEvent(), mouseReleaseEvent(),
    ///     mouseDoubleClickEvent(), sceneEvent()
    [event] mouse_press_event(event: *GraphicsSceneMouseEventType),
    ///     This event handler, for event \a event, can be reimplemented to
    ///     receive mouse move events for this item. If you do receive this
    ///     event, you can be certain that this item also received a mouse
    ///     press event, and that this item is the current mouse grabber.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no
    ///     effect.
    /// 
    ///     The default implementation handles basic item interaction, such as
    ///     selection and moving. If you want to keep the base implementation
    ///     when reimplementing this function, call
    ///     QGraphicsItem::mouseMoveEvent() in your reimplementation.
    /// 
    ///     Please note that mousePressEvent() decides which graphics item it
    ///     is that receives mouse events. See the mousePressEvent()
    ///     description for details.
    /// 
    ///     \sa mousePressEvent(), mouseReleaseEvent(),
    ///     mouseDoubleClickEvent(), sceneEvent()
    [event] mouse_move_event(event: *GraphicsSceneMouseEventType),
    ///     This event handler, for event \a event, can be reimplemented to
    ///     receive mouse release events for this item.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no
    ///     effect.
    /// 
    ///     The default implementation handles basic item interaction, such as
    ///     selection and moving. If you want to keep the base implementation
    ///     when reimplementing this function, call
    ///     QGraphicsItem::mouseReleaseEvent() in your reimplementation.
    /// 
    ///     Please note that mousePressEvent() decides which graphics item it
    ///     is that receives mouse events. See the mousePressEvent()
    ///     description for details.
    /// 
    ///     \sa mousePressEvent(), mouseMoveEvent(), mouseDoubleClickEvent(),
    ///     sceneEvent()
    [event] mouse_release_event(event: *GraphicsSceneMouseEventType),
    ///     This event handler, for event \a event, can be reimplemented to
    ///     receive mouse doubleclick events for this item.
    /// 
    ///     When doubleclicking an item, the item will first receive a mouse
    ///     press event, followed by a release event (i.e., a click), then a
    ///     doubleclick event, and finally a release event.
    /// 
    ///     Calling QEvent::ignore() or QEvent::accept() on \a event has no
    ///     effect.
    /// 
    ///     The default implementation calls mousePressEvent(). If you want to
    ///     keep the base implementation when reimplementing this function,
    ///     call QGraphicsItem::mouseDoubleClickEvent() in your
    ///     reimplementation.
    /// 
    ///     Note that an item will not receive double click events if it is
    ///     neither \l {QGraphicsItem::ItemIsSelectable}{selectable} nor
    ///     \l{QGraphicsItem::ItemIsMovable}{movable} (single mouse clicks are
    ///     ignored in this case, and that stops the generation of double
    ///     clicks).
    /// 
    ///     \sa mousePressEvent(), mouseMoveEvent(), mouseReleaseEvent(), sceneEvent()
    [event] mouse_double_click_event(event: *GraphicsSceneMouseEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     wheel events for this item. If you reimplement this function, \a event
    ///     will be accepted by default.
    /// 
    ///     If you ignore the event, (i.e., by calling QEvent::ignore(),) it will
    ///     propagate to any item beneath this item. If no items accept the event, it
    ///     will be ignored by the scene, and propagate to the view (e.g., the view's
    ///     vertical scroll bar).
    /// 
    ///     The default implementation ignores the event.
    /// 
    ///     \sa sceneEvent()
    [event] wheel_event(event: *GraphicsSceneWheelEventType),
    ///     This event handler, for event \a event, can be reimplemented to receive
    ///     input method events for this item. The default implementation ignores the
    ///     event.
    /// 
    ///     \sa inputMethodQuery(), sceneEvent()
    [event] input_method_event(event: *InputMethodEventType),
    ///     This method is only relevant for input items. It is used by the
    ///     input method to query a set of properties of the item to be able
    ///     to support complex input method operations, such as support for
    ///     surrounding text and reconversions. \a query specifies which
    ///     property is queried.
    /// 
    ///     \sa inputMethodEvent(), QInputMethodEvent
    [event] input_method_query(query: Rute::InputMethodQuery) -> Variant,
    ///     This virtual function is called by QGraphicsItem to notify custom items
    ///     that some part of the item's state changes. By reimplementing this
    ///     function, you can react to a change, and in some cases (depending on \a
    ///     change), adjustments can be made.
    /// 
    ///     \a change is the parameter of the item that is changing. \a value is the
    ///     new value; the type of the value depends on \a change.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_gui_graphicsview_qgraphicsitem.cpp 15
    /// 
    ///     The default implementation does nothing, and returns \a value.
    /// 
    ///     Note: Certain QGraphicsItem functions cannot be called in a
    ///     reimplementation of this function; see the GraphicsItemChange
    ///     documentation for details.
    /// 
    ///     \sa GraphicsItemChange
    [event] item_change(change: GraphicsItem::GraphicsItemChange, value: &VariantType) -> Variant,
    ///     \internal
    /// 
    ///     Note: This is provided as a hook to avoid future problems related
    ///     to adding virtual functions.
    [event] supports_extension(extension: GraphicsItem::Extension) -> bool,
    ///     \internal
    /// 
    ///     Note: This is provided as a hook to avoid future problems related
    ///     to adding virtual functions.
    [event] set_extension(extension: GraphicsItem::Extension, variant: &VariantType),
    ///     \internal
    /// 
    ///     Note: This is provided as a hook to avoid future problems related
    ///     to adding virtual functions.
    [event] extension(variant: &VariantType) -> Variant,
    ///     \internal
    /// 
    ///     Adds this item to the scene's index. Called in conjunction with
    ///     removeFromIndex() to ensure the index bookkeeping is correct when
    ///     the item's position, transformation or shape changes.
    add_to_index(),
    ///     \internal
    /// 
    ///     Removes this item from the scene's index. Called in conjunction
    ///     with addToIndex() to ensure the index bookkeeping is correct when
    ///     the item's position, transformation or shape changes.
    remove_from_index(),
}

// vim: syntax=rust expandtab ts=4 sw=4
