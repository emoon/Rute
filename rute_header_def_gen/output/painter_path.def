/// 
/// A painter path is an object composed of a number of graphical
/// building blocks, such as rectangles, ellipses, lines, and curves.
/// Building blocks can be joined in closed subpaths, for example as a
/// rectangle or an ellipse. A closed path has coinciding start and
/// end points. Or they can exist independently as unclosed subpaths,
/// such as lines and curves.
/// 
/// A QPainterPath object can be used for filling, outlining, and
/// clipping. To generate fillable outlines for a given painter path,
/// use the QPainterPathStroker class. The main advantage of painter
/// paths over normal drawing operations is that complex shapes only
/// need to be created once; then they can be drawn many times using
/// only calls to the QPainter::drawPath() function.
/// 
/// QPainterPath provides a collection of functions that can be used
/// to obtain information about the path and its elements. In addition
/// it is possible to reverse the order of the elements using the
/// toReversed() function. There are also several functions to convert
/// this painter path object into a polygon representation.
/// 
/// # Composing a QPainterPath
/// 
/// A QPainterPath object can be constructed as an empty path, with a
/// given start point, or as a copy of another QPainterPath object.
/// Once created, lines and curves can be added to the path using the
/// lineTo(), arcTo(), cubicTo() and quadTo() functions. The lines and
/// curves stretch from the currentPosition() to the position passed
/// as argument.
/// 
/// The currentPosition() of the QPainterPath object is always the end
/// position of the last subpath that was added (or the initial start
/// point). Use the moveTo() function to move the currentPosition()
/// without adding a component. The moveTo() function implicitly
/// starts a new subpath, and closes the previous one. Another way of
/// starting a new subpath is to call the closeSubpath() function
/// which closes the current path by adding a line from the
/// currentPosition() back to the path's start position. Note that the
/// new path will have (0, 0) as its initial currentPosition().
/// 
/// QPainterPath class also provides several convenience functions to
/// add closed subpaths to a painter path: addEllipse(), addPath(),
/// addRect(), addRegion() and addText(). The addPolygon() function
/// adds an *unclosed* subpath. In fact, these functions are all
/// collections of moveTo(), lineTo() and cubicTo() operations.
/// 
/// In addition, a path can be added to the current path using the
/// connectPath() function. But note that this function will connect
/// the last element of the current path to the first element of given
/// one by adding a line.
/// 
/// Below is a code snippet that shows how a QPainterPath object can
/// be used:
/// 
/// * ![qpainterpath-construction.png](qpainterpath-construction.png)
/// 
/// 
/// 
/// The painter path is initially empty when constructed. We first add
/// a rectangle, which is a closed subpath. Then we add two bezier
/// curves which together form a closed subpath even though they are
/// not closed individually. Finally we draw the entire path. The path
/// is filled using the default fill rule, Qt::OddEvenFill. Qt
/// provides two methods for filling paths:
/// 
/// * Qt::OddEvenFill
/// * Qt::WindingFill
/// 
/// * ![qt-fillrule-oddeven.png](qt-fillrule-oddeven.png)
/// 
/// * ![qt-fillrule-winding.png](qt-fillrule-winding.png)
/// 
/// See the Qt::FillRule documentation for the definition of the
/// rules. A painter path's currently set fill rule can be retrieved
/// using the fillRule() function, and altered using the setFillRule()
/// function.
/// 
/// # QPainterPath Information
/// 
/// The QPainterPath class provides a collection of functions that
/// returns information about the path and its elements.
/// 
/// The currentPosition() function returns the end point of the last
/// subpath that was added (or the initial start point). The
/// elementAt() function can be used to retrieve the various subpath
/// elements, the *number* of elements can be retrieved using the
/// elementCount() function, and the isEmpty() function tells whether
/// this QPainterPath object contains any elements at all.
/// 
/// The controlPointRect() function returns the rectangle containing
/// all the points and control points in this path. This function is
/// significantly faster to compute than the exact boundingRect()
/// which returns the bounding rectangle of this painter path with
/// floating point precision.
/// 
/// Finally, QPainterPath provides the contains() function which can
/// be used to determine whether a given point or rectangle is inside
/// the path, and the intersects() function which determines if any of
/// the points inside a given rectangle also are inside this path.
/// 
/// # QPainterPath Conversion
/// 
/// For compatibility reasons, it might be required to simplify the
/// representation of a painter path: QPainterPath provides the
/// toFillPolygon(), toFillPolygons() and toSubpathPolygons()
/// functions which convert the painter path into a polygon. The
/// toFillPolygon() returns the painter path as one single polygon,
/// while the two latter functions return a list of polygons.
/// 
/// The toFillPolygons() and toSubpathPolygons() functions are
/// provided because it is usually faster to draw several small
/// polygons than to draw one large polygon, even though the total
/// number of points drawn is the same. The difference between the two
/// is the *number* of polygons they return: The toSubpathPolygons()
/// creates one polygon for each subpath regardless of intersecting
/// subpaths (i.e. overlapping bounding rectangles), while the
/// toFillPolygons() functions creates only one polygon for
/// overlapping subpaths.
/// 
/// The toFillPolygon() and toFillPolygons() functions first convert
/// all the subpaths to polygons, then uses a rewinding technique to
/// make sure that overlapping subpaths can be filled using the
/// correct fill rule. Note that rewinding inserts additional lines in
/// the polygon so the outline of the fill polygon does not match the
/// outline of the path.
/// 
/// # Examples
/// 
/// Qt provides the [Painter Paths Example](painting/painterpaths)
/// 
/// and the [Vector Deformation example](painting/deform)
/// which are
/// located in Qt's example directory.
/// 
/// The [Painter Paths Example](painting/painterpaths)
/// shows how
/// painter paths can be used to build complex shapes for rendering
/// and lets the user experiment with the filling and stroking. The
/// [Vector Deformation Example](painting/deform)
/// shows how to use
/// QPainterPath to draw text.
/// 
/// * [Painter Paths Example](painting/painterpaths)
/// 
/// * [Vector Deformation Example](painting/deform)
/// 
/// * ![qpainterpath-example.png](qpainterpath-example.png)
/// 
/// * ![qpainterpath-demo.png](qpainterpath-demo.png)
/// 
/// **See also:** [`PainterPathStroker`]
/// [`Painter`]
/// [`Region`]
/// {Painter Paths Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct PainterPath {
    /// 
    /// Swaps painter path *other* with this painter path. This operation is very
    /// fast and never fails.
    swap(other: &PainterPathType),
    /// 
    /// Closes the current subpath by drawing a line to the beginning of
    /// the subpath, automatically starting a new path. The current point
    /// of the new path is (0, 0).
    /// 
    /// If the subpath does not contain any elements, this function does
    /// nothing.
    /// 
    /// **See also:** [`move_to()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    close_subpath(),
    /// 
    /// **Overloads**
    /// Moves the current position to ( *x* , *y* ) and starts a new
    /// subpath, implicitly closing the previous path.
    /// 
    /// Moves the current point to the given *point,* implicitly starting
    /// a new subpath and closing the previous one.
    /// 
    /// **See also:** [`close_subpath()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    move_to(p: &PointFType),
    /// 
    /// **Overloads**
    /// Moves the current position to ( *x* , *y* ) and starts a new
    /// subpath, implicitly closing the previous path.
    /// 
    /// Moves the current point to the given *point,* implicitly starting
    /// a new subpath and closing the previous one.
    /// 
    /// **See also:** [`close_subpath()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    [org_name(moveTo)]
    move_to_2(x: f32, y: f32),
    /// 
    /// **Overloads**
    /// Draws a line from the current position to the point ( *x* ,
    /// *y* ).
    /// 
    /// Adds a straight line from the current position to the given *endPoint.* After the line is drawn, the current position is updated
    /// to be at the end point of the line.
    /// 
    /// **See also:** [`add_polygon()`]
    /// [`add_rect()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    line_to(p: &PointFType),
    /// 
    /// **Overloads**
    /// Draws a line from the current position to the point ( *x* ,
    /// *y* ).
    /// 
    /// Adds a straight line from the current position to the given *endPoint.* After the line is drawn, the current position is updated
    /// to be at the end point of the line.
    /// 
    /// **See also:** [`add_polygon()`]
    /// [`add_rect()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    [org_name(lineTo)]
    line_to_2(x: f32, y: f32),
    /// 
    /// **Overloads**
    /// Creates a move to that lies on the arc that occupies the
    /// QRectF( *x,* *y,* *width,* *height)* at *angle.*
    /// 
    /// Creates a move to that lies on the arc that occupies the given *rectangle* at *angle.*
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// **See also:** [`move_to()`]
    /// [`arc_to()`]
    arc_move_to(rect: &RectFType, angle: f32),
    /// 
    /// **Overloads**
    /// Creates a move to that lies on the arc that occupies the
    /// QRectF( *x,* *y,* *width,* *height)* at *angle.*
    /// 
    /// Creates a move to that lies on the arc that occupies the given *rectangle* at *angle.*
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// **See also:** [`move_to()`]
    /// [`arc_to()`]
    [org_name(arcMoveTo)]
    arc_move_to_2(x: f32, y: f32, w: f32, h: f32, angle: f32),
    /// 
    /// height, qreal startAngle, qreal sweepLength)
    /// 
    /// **Overloads**
    /// Creates an arc that occupies the rectangle QRectF( *x,* *y,* *width,* *height),* beginning at the specified *startAngle* and
    /// extending *sweepLength* degrees counter-clockwise.
    /// 
    /// 
    /// Creates an arc that occupies the given *rectangle,* beginning at
    /// the specified *startAngle* and extending *sweepLength* degrees
    /// counter-clockwise.
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// Note that this function connects the starting point of the arc to
    /// the current position if they are not already connected. After the
    /// arc has been added, the current position is the last point in
    /// arc. To draw a line back to the first point, use the
    /// closeSubpath() function.
    /// 
    /// * ![qpainterpath-arcto.png](qpainterpath-arcto.png)
    /// 
    /// 
    /// 
    /// **See also:** [`arc_move_to()`]
    /// [`add_ellipse()`]
    /// [`Painter::draw_arc`]
    /// [`Painter::draw_pie`]
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    arc_to(rect: &RectFType, start_angle: f32, arc_length: f32),
    /// 
    /// height, qreal startAngle, qreal sweepLength)
    /// 
    /// **Overloads**
    /// Creates an arc that occupies the rectangle QRectF( *x,* *y,* *width,* *height),* beginning at the specified *startAngle* and
    /// extending *sweepLength* degrees counter-clockwise.
    /// 
    /// 
    /// Creates an arc that occupies the given *rectangle,* beginning at
    /// the specified *startAngle* and extending *sweepLength* degrees
    /// counter-clockwise.
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// Note that this function connects the starting point of the arc to
    /// the current position if they are not already connected. After the
    /// arc has been added, the current position is the last point in
    /// arc. To draw a line back to the first point, use the
    /// closeSubpath() function.
    /// 
    /// * ![qpainterpath-arcto.png](qpainterpath-arcto.png)
    /// 
    /// 
    /// 
    /// **See also:** [`arc_move_to()`]
    /// [`add_ellipse()`]
    /// [`Painter::draw_arc`]
    /// [`Painter::draw_pie`]
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    [org_name(arcTo)]
    arc_to_2(x: f32, y: f32, w: f32, h: f32, start_angle: f32, arc_length: f32),
    /// 
    /// qreal c2Y, qreal endPointX, qreal endPointY);
    /// 
    /// **Overloads**
    /// Adds a cubic Bezier curve between the current position and the end
    /// point ( *endPointX* , *endPointY* ) with control points specified
    /// by ( *c1X* , *c1Y* ) and ( *c2X* , *c2Y* ).
    /// 
    /// Adds a cubic Bezier curve between the current position and the
    /// given *endPoint* using the control points specified by *c1,* and
    /// *c2.*
    /// 
    /// After the curve is added, the current position is updated to be at
    /// the end point of the curve.
    /// 
    /// * ![qpainterpath-cubicto.png](qpainterpath-cubicto.png)
    /// 
    /// 
    /// 
    /// **See also:** [`quad_to()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    cubic_to(ctrl_pt1: &PointFType, ctrl_pt2: &PointFType, end_pt: &PointFType),
    /// 
    /// qreal c2Y, qreal endPointX, qreal endPointY);
    /// 
    /// **Overloads**
    /// Adds a cubic Bezier curve between the current position and the end
    /// point ( *endPointX* , *endPointY* ) with control points specified
    /// by ( *c1X* , *c1Y* ) and ( *c2X* , *c2Y* ).
    /// 
    /// Adds a cubic Bezier curve between the current position and the
    /// given *endPoint* using the control points specified by *c1,* and
    /// *c2.*
    /// 
    /// After the curve is added, the current position is updated to be at
    /// the end point of the curve.
    /// 
    /// * ![qpainterpath-cubicto.png](qpainterpath-cubicto.png)
    /// 
    /// 
    /// 
    /// **See also:** [`quad_to()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    [org_name(cubicTo)]
    cubic_to_2(ctrl_pt1x: f32, ctrl_pt1y: f32, ctrl_pt2x: f32, ctrl_pt2y: f32, end_ptx: f32, end_pty: f32),
    /// 
    /// **Overloads**
    /// Adds a quadratic Bezier curve between the current point and the endpoint
    /// ( *endPointX* , *endPointY* ) with the control point specified by
    /// ( *cx* , *cy* ).
    /// 
    /// Adds a quadratic Bezier curve between the current position and the
    /// given *endPoint* with the control point specified by *c.*
    /// 
    /// After the curve is added, the current point is updated to be at
    /// the end point of the curve.
    /// 
    /// **See also:** [`cubic_to()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    quad_to(ctrl_pt: &PointFType, end_pt: &PointFType),
    /// 
    /// **Overloads**
    /// Adds a quadratic Bezier curve between the current point and the endpoint
    /// ( *endPointX* , *endPointY* ) with the control point specified by
    /// ( *cx* , *cy* ).
    /// 
    /// Adds a quadratic Bezier curve between the current position and the
    /// given *endPoint* with the control point specified by *c.*
    /// 
    /// After the curve is added, the current point is updated to be at
    /// the end point of the curve.
    /// 
    /// **See also:** [`cubic_to()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    [org_name(quadTo)]
    quad_to_2(ctrl_ptx: f32, ctrl_pty: f32, end_ptx: f32, end_pty: f32),
    /// 
    /// Returns the current position of the path.
    current_position() -> PointF,
    /// 
    /// **Overloads**
    /// Adds a rectangle at position ( *x* , *y* ), with the given *width* and *height,* as a closed subpath.
    /// 
    /// Adds the given *rectangle* to this path as a closed subpath.
    /// 
    /// The *rectangle* is added as a clockwise set of lines. The painter
    /// path's current position after the *rectangle* has been added is
    /// at the top-left corner of the rectangle.
    /// 
    /// * ![qpainterpath-addrectangle.png](qpainterpath-addrectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** [`add_region()`]
    /// [`line_to()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    add_rect(rect: &RectFType),
    /// 
    /// **Overloads**
    /// Adds a rectangle at position ( *x* , *y* ), with the given *width* and *height,* as a closed subpath.
    /// 
    /// Adds the given *rectangle* to this path as a closed subpath.
    /// 
    /// The *rectangle* is added as a clockwise set of lines. The painter
    /// path's current position after the *rectangle* has been added is
    /// at the top-left corner of the rectangle.
    /// 
    /// * ![qpainterpath-addrectangle.png](qpainterpath-addrectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** [`add_region()`]
    /// [`line_to()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    [org_name(addRect)]
    add_rect_2(x: f32, y: f32, w: f32, h: f32),
    /// 
    /// **Overloads**
    /// Creates an ellipse within the bounding rectangle defined by its top-left
    /// corner at ( *x,* *y),* *width* and *height,* and adds it to the
    /// painter path as a closed subpath.
    /// 
    /// **Overloads**
    /// Creates an ellipse positioned at *center* with radii *rx* and *ry* ,
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// Creates an ellipse within the specified *boundingRectangle*
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// The ellipse is composed of a clockwise curve, starting and
    /// finishing at zero degrees (the 3 o'clock position).
    /// 
    /// * ![qpainterpath-addellipse.png](qpainterpath-addellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** [`arc_to()`]
    /// [`Painter::draw_ellipse`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    add_ellipse(rect: &RectFType),
    /// 
    /// **Overloads**
    /// Creates an ellipse within the bounding rectangle defined by its top-left
    /// corner at ( *x,* *y),* *width* and *height,* and adds it to the
    /// painter path as a closed subpath.
    /// 
    /// **Overloads**
    /// Creates an ellipse positioned at *center* with radii *rx* and *ry* ,
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// Creates an ellipse within the specified *boundingRectangle*
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// The ellipse is composed of a clockwise curve, starting and
    /// finishing at zero degrees (the 3 o'clock position).
    /// 
    /// * ![qpainterpath-addellipse.png](qpainterpath-addellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** [`arc_to()`]
    /// [`Painter::draw_ellipse`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    [org_name(addEllipse)]
    add_ellipse_2(x: f32, y: f32, w: f32, h: f32),
    /// 
    /// **Overloads**
    /// Creates an ellipse within the bounding rectangle defined by its top-left
    /// corner at ( *x,* *y),* *width* and *height,* and adds it to the
    /// painter path as a closed subpath.
    /// 
    /// **Overloads**
    /// Creates an ellipse positioned at *center* with radii *rx* and *ry* ,
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// Creates an ellipse within the specified *boundingRectangle*
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// The ellipse is composed of a clockwise curve, starting and
    /// finishing at zero degrees (the 3 o'clock position).
    /// 
    /// * ![qpainterpath-addellipse.png](qpainterpath-addellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** [`arc_to()`]
    /// [`Painter::draw_ellipse`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    [org_name(addEllipse)]
    add_ellipse_3(center: &PointFType, rx: f32, ry: f32),
    /// 
    /// Adds the given *polygon* to the path as an (unclosed) subpath.
    /// 
    /// Note that the current position after the polygon has been added,
    /// is the last point in *polygon.* To draw a line back to the first
    /// point, use the closeSubpath() function.
    /// 
    /// * ![qpainterpath-addpolygon.png](qpainterpath-addpolygon.png)
    /// 
    /// 
    /// 
    /// **See also:** [`line_to()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    add_polygon(polygon: &PolygonFType),
    /// 
    /// **Overloads**
    /// Adds the given *text* to this path as a set of closed subpaths created
    /// from the *font* supplied. The subpaths are positioned so that the left
    /// end of the text's baseline lies at the point specified by ( *x,* *y).*
    /// 
    /// Adds the given *text* to this path as a set of closed subpaths
    /// created from the *font* supplied. The subpaths are positioned so
    /// that the left end of the text's baseline lies at the specified *point.*
    /// 
    /// * ![qpainterpath-addtext.png](qpainterpath-addtext.png)
    /// 
    /// 
    /// 
    /// **See also:** [`Painter::draw_text`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    add_text(point: &PointFType, f: &FontType, text: String),
    /// 
    /// **Overloads**
    /// Adds the given *text* to this path as a set of closed subpaths created
    /// from the *font* supplied. The subpaths are positioned so that the left
    /// end of the text's baseline lies at the point specified by ( *x,* *y).*
    /// 
    /// Adds the given *text* to this path as a set of closed subpaths
    /// created from the *font* supplied. The subpaths are positioned so
    /// that the left end of the text's baseline lies at the specified *point.*
    /// 
    /// * ![qpainterpath-addtext.png](qpainterpath-addtext.png)
    /// 
    /// 
    /// 
    /// **See also:** [`Painter::draw_text`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    [org_name(addText)]
    add_text_2(x: f32, y: f32, f: &FontType, text: String),
    /// 
    /// Adds the given *path* to *this* path as a closed subpath.
    /// 
    /// **See also:** [`connect_path()`]
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    add_path(path: &PainterPathType),
    /// 
    /// Adds the given *region* to the path by adding each rectangle in
    /// the region as a separate closed subpath.
    /// 
    /// **See also:** [`add_rect()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    add_region(region: &RegionType),
    /// 
    /// Adds the given rectangle *rect* with rounded corners to the path.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii of
    /// the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range 0.0 to 100.0.
    /// 
    /// **See also:** [`add_rect()`]
    /// 
    /// **Overloads**
    /// Adds the given rectangle *x,* *y,* *w,* *h* with rounded corners to the path.
    add_rounded_rect(rect: &RectFType, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    /// 
    /// Adds the given rectangle *rect* with rounded corners to the path.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii of
    /// the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range 0.0 to 100.0.
    /// 
    /// **See also:** [`add_rect()`]
    /// 
    /// **Overloads**
    /// Adds the given rectangle *x,* *y,* *w,* *h* with rounded corners to the path.
    [org_name(addRoundedRect)]
    add_rounded_rect_2(x: f32, y: f32, w: f32, h: f32, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    add_round_rect(rect: &RectFType, x_rnd: i32, y_rnd: i32),
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    [org_name(addRoundRect)]
    add_round_rect_2(x: f32, y: f32, w: f32, h: f32, x_rnd: i32, y_rnd: i32),
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    [org_name(addRoundRect)]
    add_round_rect_3(rect: &RectFType, roundness: i32),
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** [`add_rounded_rect()`]
    [org_name(addRoundRect)]
    add_round_rect_4(x: f32, y: f32, w: f32, h: f32, roundness: i32),
    /// 
    /// Connects the given *path* to *this* path by adding a line from the
    /// last element of this path to the first element of the given path.
    /// 
    /// **See also:** [`add_path()`]
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    connect_path(path: &PainterPathType),
    /// 
    /// Returns `true` if the given *point* is inside the path, otherwise
    /// returns `false.`
    /// 
    /// **See also:** [`intersects()`]
    /// 
    /// Returns `true` if the given *rectangle* is inside the path,
    /// otherwise returns `false.`
    /// 
    /// Returns `true` if the given path *p* is contained within
    /// the current path. Returns `false` if any edges of the current path and
    /// *p* intersect.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** [`intersects()`]
    contains(pt: &PointFType) -> bool,
    /// 
    /// Returns `true` if the given *point* is inside the path, otherwise
    /// returns `false.`
    /// 
    /// **See also:** [`intersects()`]
    /// 
    /// Returns `true` if the given *rectangle* is inside the path,
    /// otherwise returns `false.`
    /// 
    /// Returns `true` if the given path *p* is contained within
    /// the current path. Returns `false` if any edges of the current path and
    /// *p* intersect.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** [`intersects()`]
    [org_name(contains)]
    contains_2(rect: &RectFType) -> bool,
    /// 
    /// Returns `true` if any point in the given *rectangle* intersects the
    /// path; otherwise returns `false.`
    /// 
    /// There is an intersection if any of the lines making up the
    /// rectangle crosses a part of the path or if any part of the
    /// rectangle overlaps with any area enclosed by the path. This
    /// function respects the current fillRule to determine what is
    /// considered inside the path.
    /// 
    /// **See also:** [`contains()`]
    /// 
    /// Returns `true` if the current path intersects at any point the given path *p.*
    /// Also returns `true` if the current path contains or is contained by any part of *p.*
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** [`contains()`]
    intersects(rect: &RectFType) -> bool,
    /// 
    /// Returns the bounding rectangle of this painter path as a rectangle with
    /// floating point precision.
    /// 
    /// **See also:** [`control_point_rect()`]
    bounding_rect() -> RectF,
    /// 
    /// Returns the painter path's currently set fill rule.
    /// 
    /// **See also:** [`set_fill_rule()`]
    fill_rule() -> Rute::FillRule,
    /// 
    /// Sets the fill rule of the painter path to the given *fillRule.* Qt provides two methods for filling paths:
    /// 
    /// * Qt::OddEvenFill (default)
    /// * Qt::WindingFill
    /// 
    /// * ![qt-fillrule-oddeven.png](qt-fillrule-oddeven.png)
    /// 
    /// * ![qt-fillrule-winding.png](qt-fillrule-winding.png)
    /// 
    /// **See also:** [`fill_rule()`]
    set_fill_rule(fill_rule: Rute::FillRule),
    /// 
    /// Returns `true` if either there are no elements in this path, or if the only
    /// element is a MoveToElement; otherwise returns `false.`
    /// 
    /// **See also:** [`element_count()`]
    is_empty() -> bool,
    /// 
    /// Creates and returns a reversed copy of the path.
    /// 
    /// It is the order of the elements that is reversed: If a
    /// QPainterPath is composed by calling the moveTo(), lineTo() and
    /// cubicTo() functions in the specified order, the reversed copy is
    /// composed by calling cubicTo(), lineTo() and moveTo().
    to_reversed() -> PainterPath,
    /// 
    /// Converts the path into a list of polygons using the QTransform
    /// *matrix,* and returns the list.
    /// 
    /// This function creates one polygon for each subpath regardless of
    /// intersecting subpaths (i.e. overlapping bounding rectangles). To
    /// make sure that such overlapping subpaths are filled correctly, use
    /// the toFillPolygons() function instead.
    /// 
    /// **See also:** [`to_fill_polygons()`]
    /// [`to_fill_polygon()`]
    /// {QPainterPath#QPainterPath
    /// Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    to_subpath_polygons(matrix: &MatrixType) -> [PolygonF],
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** [`to_subpath_polygons()`]
    /// [`to_fill_polygon()`]
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    to_fill_polygons(matrix: &MatrixType) -> [PolygonF],
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** [`to_subpath_polygons()`]
    /// [`to_fill_polygon()`]
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    /// 
    /// Converts the path into a polygon using the QTransform
    /// *matrix,* and returns the polygon.
    /// 
    /// The polygon is created by first converting all subpaths to
    /// polygons, then using a rewinding technique to make sure that
    /// overlapping subpaths can be filled using the correct fill rule.
    /// 
    /// Note that rewinding inserts addition lines in the polygon so
    /// the outline of the fill polygon does not match the outline of
    /// the path.
    /// 
    /// **See also:** [`to_subpath_polygons()`]
    /// [`to_fill_polygons()`]
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    to_fill_polygon(matrix: &MatrixType) -> PolygonF,
    /// 
    /// Converts the path into a list of polygons using the QTransform
    /// *matrix,* and returns the list.
    /// 
    /// This function creates one polygon for each subpath regardless of
    /// intersecting subpaths (i.e. overlapping bounding rectangles). To
    /// make sure that such overlapping subpaths are filled correctly, use
    /// the toFillPolygons() function instead.
    /// 
    /// **See also:** [`to_fill_polygons()`]
    /// [`to_fill_polygon()`]
    /// {QPainterPath#QPainterPath
    /// Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    [org_name(toSubpathPolygons)]
    to_subpath_polygons_2(matrix: &TransformType) -> [PolygonF],
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** [`to_subpath_polygons()`]
    /// [`to_fill_polygon()`]
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    [org_name(toFillPolygons)]
    to_fill_polygons_2(matrix: &TransformType) -> [PolygonF],
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** [`to_subpath_polygons()`]
    /// [`to_fill_polygon()`]
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    /// 
    /// Converts the path into a polygon using the QTransform
    /// *matrix,* and returns the polygon.
    /// 
    /// The polygon is created by first converting all subpaths to
    /// polygons, then using a rewinding technique to make sure that
    /// overlapping subpaths can be filled using the correct fill rule.
    /// 
    /// Note that rewinding inserts addition lines in the polygon so
    /// the outline of the fill polygon does not match the outline of
    /// the path.
    /// 
    /// **See also:** [`to_subpath_polygons()`]
    /// [`to_fill_polygons()`]
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    [org_name(toFillPolygon)]
    to_fill_polygon_2(matrix: &TransformType) -> PolygonF,
    /// 
    /// Returns the number of path elements in the painter path.
    /// 
    /// **See also:** ElementType
    /// [`element_at()`]
    /// [`is_empty()`]
    element_count() -> i32,
    /// 
    /// Returns the element at the given *index* in the painter path.
    /// 
    /// **See also:** ElementType
    /// [`element_count()`]
    /// [`is_empty()`]
    element_at(i: i32) -> PainterPath::Element,
    /// 
    /// Sets the x and y coordinate of the element at index *index* to *x* and *y.*
    set_element_position_at(i: i32, x: f32, y: f32),
    /// 
    /// Returns the length of the current path.
    length() -> f32,
    /// 
    /// Returns percentage of the whole path at the specified length *len.*
    /// 
    /// Note that similarly to other percent methods, the percentage measurement
    /// is not linear with regards to the length, if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    percent_at_length(t: f32) -> f32,
    /// 
    /// Returns the point at at the percentage *t* of the current path.
    /// The argument *t* has to be between 0 and 1.
    /// 
    /// Note that similarly to other percent methods, the percentage measurement
    /// is not linear with regards to the length, if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    point_at_percent(t: f32) -> PointF,
    /// 
    /// Returns the angle of the path tangent at the percentage *t.*
    /// The argument *t* has to be between 0 and 1.
    /// 
    /// Positive values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock position.
    /// 
    /// Note that similarly to the other percent methods, the percentage measurement
    /// is not linear with regards to the length if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    angle_at_percent(t: f32) -> f32,
    /// 
    /// Returns the slope of the path at the percentage *t.* The
    /// argument *t* has to be between 0 and 1.
    /// 
    /// Note that similarly to other percent methods, the percentage measurement
    /// is not linear with regards to the length, if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    slope_at_percent(t: f32) -> f32,
    /// 
    /// Returns `true` if any point in the given *rectangle* intersects the
    /// path; otherwise returns `false.`
    /// 
    /// There is an intersection if any of the lines making up the
    /// rectangle crosses a part of the path or if any part of the
    /// rectangle overlaps with any area enclosed by the path. This
    /// function respects the current fillRule to determine what is
    /// considered inside the path.
    /// 
    /// **See also:** [`contains()`]
    /// 
    /// Returns `true` if the current path intersects at any point the given path *p.*
    /// Also returns `true` if the current path contains or is contained by any part of *p.*
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** [`contains()`]
    [org_name(intersects)]
    intersects_2(p: &PainterPathType) -> bool,
    /// 
    /// Returns `true` if the given *point* is inside the path, otherwise
    /// returns `false.`
    /// 
    /// **See also:** [`intersects()`]
    /// 
    /// Returns `true` if the given *rectangle* is inside the path,
    /// otherwise returns `false.`
    /// 
    /// Returns `true` if the given path *p* is contained within
    /// the current path. Returns `false` if any edges of the current path and
    /// *p* intersect.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** [`intersects()`]
    [org_name(contains)]
    contains_3(p: &PainterPathType) -> bool,
    /// 
    /// Returns a path which is the union of this path's fill area and *p's* fill area.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// Bezier curves may be flattened to line segments due to numerical instability of
    /// doing bezier curve intersections.
    /// 
    /// **See also:** [`intersected()`]
    /// [`subtracted()`]
    united(r: &PainterPathType) -> PainterPath,
    /// 
    /// Returns a path which is the intersection of this path's fill area and *p's* fill area.
    /// Bezier curves may be flattened to line segments due to numerical instability of
    /// doing bezier curve intersections.
    intersected(r: &PainterPathType) -> PainterPath,
    /// 
    /// Returns a simplified version of this path. This implies merging all subpaths that intersect,
    /// and returning a path containing no intersecting edges. Consecutive parallel lines will also
    /// be merged. The simplified path will always use the default fill rule, Qt::OddEvenFill.
    /// Bezier curves may be flattened to line segments due to numerical instability of
    /// doing bezier curve intersections.
    simplified() -> PainterPath,
}

[org_name(QPainterPath)]
enum ElementType {
    /// A new subpath. See also moveTo().
    MoveToElement,
    /// A line. See also lineTo().
    LineToElement,
    /// A curve. See also cubicTo() and quadTo().
    CurveToElement,
    /// The extra data required to describe a curve in a CurveToElement element.
    CurveToDataElement,
}

// vim: syntax=rust expandtab ts=4 sw=4
