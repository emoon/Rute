/// 
/// QObject is the heart of the Qt [Object Model](Object%20Model)
/// . The central
/// feature in this model is a very powerful mechanism for seamless
/// object communication called [signals and slots](signals%20and%20slots)
/// . You can
/// connect a signal to a slot with connect() and destroy the
/// connection with disconnect(). To avoid never ending notification
/// loops you can temporarily block signals with blockSignals(). The
/// protected functions connectNotify() and disconnectNotify() make
/// it possible to track connections.
/// 
/// QObjects organize themselves in [object trees](Object%20Trees%20&%20Ownership)
/// . When you create a QObject with another object as
/// parent, the object will automatically add itself to the parent's
/// children() list. The parent takes ownership of the object; i.e.,
/// it will automatically delete its children in its destructor. You
/// can look for an object by name and optionally type using
/// findChild() or findChildren().
/// 
/// Every object has an objectName() and its class name can be found
/// via the corresponding metaObject() (see QMetaObject::className()).
/// You can determine whether the object's class inherits another
/// class in the QObject inheritance hierarchy by using the
/// inherits() function.
/// 
/// When an object is deleted, it emits a destroyed() signal. You can
/// catch this signal to avoid dangling references to QObjects.
/// 
/// QObjects can receive events through event() and filter the events
/// of other objects. See installEventFilter() and eventFilter() for
/// details. A convenience handler, childEvent(), can be reimplemented
/// to catch child events.
/// 
/// Last but not least, QObject provides the basic timer support in
/// Qt; see QTimer for high-level support for timers.
/// 
/// Notice that the Q_OBJECT macro is mandatory for any object that
/// implements signals, slots or properties. You also need to run the
/// [Meta Object Compiler](moc)
/// on the source file. We strongly
/// recommend the use of this macro in all subclasses of QObject
/// regardless of whether or not they actually use signals, slots and
/// properties, since failure to do so may lead certain functions to
/// exhibit strange behavior.
/// 
/// All Qt widgets inherit QObject. The convenience function
/// isWidgetType() returns whether an object is actually a widget. It
/// is much faster than
/// [qobject_cast](qobject_cast())
/// <QWidget *>( *obj* ) or
/// *obj* -> [inherits](inherits())
/// ("QWidget").
/// 
/// Some QObject functions, e.g. children(), return a QObjectList.
/// QObjectList is a typedef for QList<QObject *>.
/// 
/// # Thread Affinity
/// 
/// A QObject instance is said to have a *thread affinity* , or that
/// it *lives* in a certain thread. When a QObject receives a
/// [queued signal](Qt::QueuedConnection)
/// or a [posted event](The%20Event%0A%20%20%20%20System%23Sending%20Events)
/// , the slot or event handler
/// will run in the thread that the object lives in.
/// 
/// **Note**: If a QObject has no thread affinity (that is, if thread()
/// returns zero), or if it lives in a thread that has no running event
/// loop, then it cannot receive queued signals or posted events.
/// 
/// By default, a QObject lives in the thread in which it is created.
/// An object's thread affinity can be queried using thread() and
/// changed using moveToThread().
/// 
/// All QObjects must live in the same thread as their parent. Consequently:
/// 
/// * setParent() will fail if the two QObjects involved live in different threads.
/// * When a QObject is moved to another thread, all its children will be automatically moved too.
/// * moveToThread() will fail if the QObject has a parent.
/// * If QObjects are created within QThread::run(), they cannot become children of the QThread object because the QThread does not live in the thread that calls QThread::run().
/// 
/// **Note**: A QObject's member variables *do not* automatically become
/// its children. The parent-child relationship must be set by either
/// passing a pointer to the child's [constructor](QObject())
/// , or by
/// calling setParent(). Without this step, the object's member variables
/// will remain in the old thread when moveToThread() is called.
/// 
/// # No Copy Constructor or Assignment Operator
/// 
/// QObject has neither a copy constructor nor an assignment operator.
/// This is by design. Actually, they are declared, but in a
/// `private` section with the macro Q_DISABLE_COPY(). In fact, all
/// Qt classes derived from QObject (direct or indirect) use this
/// macro to declare their copy constructor and assignment operator to
/// be private. The reasoning is found in the discussion on
/// [Identity vs Value](Identity%20vs%20Value)
/// on the Qt [Object
/// Model](Object%0A%20%20%20%20Model)
/// page.
/// 
/// The main consequence is that you should use pointers to QObject
/// (or to your QObject subclass) where you might otherwise be tempted
/// to use your QObject subclass as a value. For example, without a
/// copy constructor, you can't use a subclass of QObject as the value
/// to be stored in one of the container classes. You must store
/// pointers.
/// 
/// # Auto-Connection
/// 
/// Qt's meta-object system provides a mechanism to automatically connect
/// signals and slots between QObject subclasses and their children. As long
/// as objects are defined with suitable object names, and slots follow a
/// simple naming convention, this connection can be performed at run-time
/// by the QMetaObject::connectSlotsByName() function.
/// 
/// [uic](uic)
/// generates code that invokes this function to enable
/// auto-connection to be performed between widgets on forms created
/// with *Qt Designer* . More information about using auto-connection with *Qt Designer* is
/// given in the [Using a Designer UI File in Your Application](Using%20a%20Designer%20UI%20File%20in%20Your%20Application)
/// section of
/// the *Qt Designer* manual.
/// 
/// # Dynamic Properties
/// 
/// From Qt 4.2, dynamic properties can be added to and removed from QObject
/// instances at run-time. Dynamic properties do not need to be declared at
/// compile-time, yet they provide the same advantages as static properties
/// and are manipulated using the same API - using property() to read them
/// and setProperty() to write them.
/// 
/// From Qt 4.3, dynamic properties are supported by
/// [Qt Designer](Qt%20Designer's%20Widget%20Editing%20Mode%23The%20Property%20Editor)
/// 
/// and both standard Qt widgets and user-created forms can be given dynamic
/// properties.
/// 
/// # Internationalization (I18n)
/// 
/// All QObject subclasses support Qt's translation features, making it possible
/// to translate an application's user interface into different languages.
/// 
/// To make user-visible text translatable, it must be wrapped in calls to
/// the tr() function. This is explained in detail in the
/// [Writing Source Code for Translation](Writing%20Source%20Code%20for%20Translation)
/// document.
/// 
/// **See also:** QMetaObject
/// QPointer
/// QObjectCleanupHandler
/// Q_DISABLE_COPY()
/// **See also:** {Object Trees & Ownership}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.

struct Object {
    /// 
    /// This virtual function receives events to an object and should
    /// return true if the event *e* was recognized and processed.
    /// 
    /// The event() function can be reimplemented to customize the
    /// behavior of an object.
    /// 
    /// Make sure you call the parent event class implementation
    /// for all the events you did not handle.
    /// 
    /// Example:
    /// 
    /// **See also:** installEventFilter()
    /// timerEvent()
    /// QCoreApplication::sendEvent()
    /// QCoreApplication::postEvent()
    /// 
    /// Filters events if this object has been installed as an event
    /// filter for the *watched* object.
    /// 
    /// In your reimplementation of this function, if you want to filter
    /// the *event* out, i.e. stop it being handled further, return
    /// true; otherwise return false.
    /// 
    /// Example:
    /// 
    /// Notice in the example above that unhandled events are passed to
    /// the base class's eventFilter() function, since the base class
    /// might have reimplemented eventFilter() for its own internal
    /// purposes.
    /// 
    /// **Warning**: If you delete the receiver object in this function, be
    /// sure to return true. Otherwise, Qt will forward the event to the
    /// deleted object and the program might crash.
    /// 
    /// **See also:** installEventFilter()
    [event] event(event: *EventType) -> bool,
    /// 
    /// Filters events if this object has been installed as an event
    /// filter for the *watched* object.
    /// 
    /// In your reimplementation of this function, if you want to filter
    /// the *event* out, i.e. stop it being handled further, return
    /// true; otherwise return false.
    /// 
    /// Example:
    /// 
    /// Notice in the example above that unhandled events are passed to
    /// the base class's eventFilter() function, since the base class
    /// might have reimplemented eventFilter() for its own internal
    /// purposes.
    /// 
    /// **Warning**: If you delete the receiver object in this function, be
    /// sure to return true. Otherwise, Qt will forward the event to the
    /// deleted object and the program might crash.
    /// 
    /// **See also:** installEventFilter()
    [event] event_filter(watched: *ObjectType, event: *EventType) -> bool,
    /// 
    /// You can find an object by name (and type) using findChild().
    /// You can find a set of objects with findChildren().
    /// 
    /// By default, this property contains an empty string.
    /// 
    /// **See also:** metaObject()
    /// QMetaObject::className()
    /// 
    /// This signal is emitted after the object's name has been changed. The new object name is passed as *objectName.*
    /// 
    /// **See also:** QObject::objectName
    object_name() -> String,
    set_object_name(name: String),
    /// 
    /// Returns `true` if the object is a widget; otherwise returns `false.`
    /// 
    /// Calling this function is equivalent to calling
    /// `inherits("QWidget")` , except that it is much faster.
    is_widget_type() -> bool,
    /// 
    /// Returns `true` if the object is a window; otherwise returns `false.`
    /// 
    /// Calling this function is equivalent to calling
    /// `inherits("QWindow")` , except that it is much faster.
    is_window_type() -> bool,
    /// 
    /// Returns `true` if signals are blocked; otherwise returns `false.`
    /// 
    /// Signals are not blocked by default.
    /// 
    /// **See also:** blockSignals()
    /// QSignalBlocker
    signals_blocked() -> bool,
    /// 
    /// If *block* is true, signals emitted by this object are blocked
    /// (i.e., emitting a signal will not invoke anything connected to it).
    /// If *block* is false, no such blocking will occur.
    /// 
    /// The return value is the previous value of signalsBlocked().
    /// 
    /// Note that the destroyed() signal will be emitted even if the signals
    /// for this object have been blocked.
    /// 
    /// Signals emitted while being blocked are not buffered.
    /// 
    /// **See also:** signalsBlocked()
    /// QSignalBlocker
    block_signals(b: bool) -> bool,
    /// 
    /// Returns the thread in which the object lives.
    /// 
    /// **See also:** moveToThread()
    thread() -> Thread?,
    /// 
    /// Changes the thread affinity for this object and its children. The
    /// object cannot be moved if it has a parent. Event processing will
    /// continue in the *targetThread.*
    /// 
    /// To move an object to the main thread, use QApplication::instance()
    /// to retrieve a pointer to the current application, and then use
    /// QApplication::thread() to retrieve the thread in which the
    /// application lives. For example:
    /// 
    /// If *targetThread* is zero, all event processing for this object
    /// and its children stops.
    /// 
    /// Note that all active timers for the object will be reset. The
    /// timers are first stopped in the current thread and restarted (with
    /// the same interval) in the *targetThread.* As a result, constantly
    /// moving an object between threads can postpone timer events
    /// indefinitely.
    /// 
    /// A QEvent::ThreadChange event is sent to this object just before
    /// the thread affinity is changed. You can handle this event to
    /// perform any special processing. Note that any new events that are
    /// posted to this object will be handled in the *targetThread.*
    /// 
    /// **Warning**: This function is *not* thread-safe; the current thread
    /// must be same as the current thread affinity. In other words, this
    /// function can only an object from the current thread to
    /// another thread, it cannot an object from any arbitrary
    /// thread to the current thread.
    /// 
    /// **See also:** thread()
    move_to_thread(thread: *ThreadType),
    /// 
    /// Starts a timer and returns a timer identifier, or returns zero if
    /// it could not start a timer.
    /// 
    /// A timer event will occur every *interval* milliseconds until
    /// killTimer() is called. If *interval* is 0, then the timer event
    /// occurs once every time there are no more window system events to
    /// process.
    /// 
    /// The virtual timerEvent() function is called with the QTimerEvent
    /// event parameter class when a timer event occurs. Reimplement this
    /// function to get timer events.
    /// 
    /// If multiple timers are running, the QTimerEvent::timerId() can be
    /// used to find out which timer was activated.
    /// 
    /// Example:
    /// 
    /// Note that QTimer's accuracy depends on the underlying operating system and
    /// hardware. The *timerType* argument allows you to customize the accuracy of
    /// the timer. See Qt::TimerType for information on the different timer types.
    /// Most platforms support an accuracy of 20 milliseconds; some provide more.
    /// If Qt is unable to deliver the requested number of timer events, it will
    /// silently discard some.
    /// 
    /// The QTimer class provides a high-level programming interface with
    /// single-shot timers and timer signals instead of events. There is
    /// also a QBasicTimer class that is more lightweight than QTimer and
    /// less clumsy than using timer IDs directly.
    /// 
    /// **See also:** timerEvent()
    /// killTimer()
    /// QTimer::singleShot()
    /// 
    /// **Overloads**
    /// Starts a timer and returns a timer identifier, or returns zero if
    /// it could not start a timer.
    /// 
    /// A timer event will occur every *time* interval until killTimer()
    /// is called. If *time* is equal to `std::chrono::duration::zero()` ,
    /// then the timer event occurs once every time there are no more window
    /// system events to process.
    /// 
    /// The virtual timerEvent() function is called with the QTimerEvent
    /// event parameter class when a timer event occurs. Reimplement this
    /// function to get timer events.
    /// 
    /// If multiple timers are running, the QTimerEvent::timerId() can be
    /// used to find out which timer was activated.
    /// 
    /// Example:
    /// 
    /// Note that QTimer's accuracy depends on the underlying operating system and
    /// hardware. The *timerType* argument allows you to customize the accuracy of
    /// the timer. See Qt::TimerType for information on the different timer types.
    /// Most platforms support an accuracy of 20 milliseconds; some provide more.
    /// If Qt is unable to deliver the requested number of timer events, it will
    /// silently discard some.
    /// 
    /// The QTimer class provides a high-level programming interface with
    /// single-shot timers and timer signals instead of events. There is
    /// also a QBasicTimer class that is more lightweight than QTimer and
    /// less clumsy than using timer IDs directly.
    /// 
    /// **See also:** timerEvent()
    /// killTimer()
    /// QTimer::singleShot()
    start_timer(interval: i32, timer_type: Rute::TimerType) -> i32,
    /// 
    /// Kills the timer with timer identifier, *id.*
    /// 
    /// The timer identifier is returned by startTimer() when a timer
    /// event is started.
    /// 
    /// **See also:** timerEvent()
    /// startTimer()
    kill_timer(id: i32),
    /// 
    /// Returns a list of child objects.
    /// The QObjectList class is defined in the `<QObject>` header
    /// file as the following:
    /// 
    /// The first child added is the [first](QList::first())
    /// object in
    /// the list and the last child added is the [last](QList::last())
    /// 
    /// object in the list, i.e. new children are appended at the end.
    /// 
    /// Note that the list order changes when QWidget children are
    /// [raised](QWidget::raise())
    /// or [lowered](QWidget::lower())
    /// . A
    /// widget that is raised becomes the last object in the list, and a
    /// widget that is lowered becomes the first object in the list.
    /// 
    /// **See also:** findChild()
    /// findChildren()
    /// parent()
    /// setParent()
    children() -> ObjectList?,
    /// 
    /// Makes the object a child of *parent.*
    /// 
    /// **See also:** parent()
    /// children()
    set_parent(parent: *ObjectType),
    /// 
    /// Installs an event filter *filterObj* on this object. For example:
    /// 
    /// An event filter is an object that receives all events that are
    /// sent to this object. The filter can either stop the event or
    /// forward it to this object. The event filter *filterObj* receives
    /// events via its eventFilter() function. The eventFilter() function
    /// must return true if the event should be filtered, (i.e. stopped);
    /// otherwise it must return false.
    /// 
    /// If multiple event filters are installed on a single object, the
    /// filter that was installed last is activated first.
    /// 
    /// Here's a `KeyPressEater` class that eats the key presses of its
    /// monitored objects:
    /// 
    /// And here's how to install it on two widgets:
    /// 
    /// The QShortcut class, for example, uses this technique to intercept
    /// shortcut key presses.
    /// 
    /// **Warning**: If you delete the receiver object in your eventFilter()
    /// function, be sure to return true. If you return false, Qt sends
    /// the event to the deleted object and the program will crash.
    /// 
    /// Note that the filtering object must be in the same thread as this
    /// object. If *filterObj* is in a different thread, this function does
    /// nothing. If either *filterObj* or this object are moved to a different
    /// thread after calling this function, the event filter will not be
    /// called until both objects have the same thread affinity again (it
    /// is *not* removed).
    /// 
    /// **See also:** removeEventFilter()
    /// eventFilter()
    /// event()
    install_event_filter(filter_obj: *ObjectType),
    /// 
    /// Removes an event filter object *obj* from this object. The
    /// request is ignored if such an event filter has not been installed.
    /// 
    /// All event filters for this object are automatically removed when
    /// this object is destroyed.
    /// 
    /// It is always safe to remove an event filter, even during event
    /// filter activation (i.e. from the eventFilter() function).
    /// 
    /// **See also:** installEventFilter()
    /// eventFilter()
    /// event()
    remove_event_filter(obj: *ObjectType),
    /// 
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// You must use the `SIGNAL()` and `SLOT()` macros when specifying
    /// the *signal* and the *method,* for example:
    /// 
    /// This example ensures that the label always displays the current
    /// scroll bar value. Note that the signal and slots parameters must not
    /// contain any variable names, only the type. E.g. the following would
    /// not work and return false:
    /// 
    /// A signal can also be connected to another signal:
    /// 
    /// In this example, the `MyWidget` constructor relays a signal from
    /// a private member variable, and makes it available under a name
    /// that relates to `MyWidget.`
    /// 
    /// A signal can be connected to many slots and signals. Many signals
    /// can be connected to one slot.
    /// 
    /// If a signal is connected to several slots, the slots are activated
    /// in the same order in which the connections were made, when the
    /// signal is emitted.
    /// 
    /// The function returns a QMetaObject::Connection that represents
    /// a handle to a connection if it successfully
    /// connects the signal to the slot. The connection handle will be invalid
    /// if it cannot create the connection, for example, if QObject is unable
    /// to verify the existence of either *signal* or *method,* or if their
    /// signatures aren't compatible.
    /// You can check if the handle is valid by casting it to a bool.
    /// 
    /// By default, a signal is emitted for every connection you make;
    /// two signals are emitted for duplicate connections. You can break
    /// all of these connections with a single disconnect() call.
    /// If you pass the Qt::UniqueConnection *type,* the connection will only
    /// be made if it is not a duplicate. If there is already a duplicate
    /// (exact same signal to the exact same slot on the same objects),
    /// the connection will fail and connect will return an invalid QMetaObject::Connection.
    /// 
    /// **Note**: Qt::UniqueConnections do not work for lambdas, non-member functions
    /// and functors; they only apply to connecting to member functions.
    /// 
    /// The optional *type* parameter describes the type of connection
    /// to establish. In particular, it determines whether a particular
    /// signal is delivered to a slot immediately or queued for delivery
    /// at a later time. If the signal is queued, the parameters must be
    /// of types that are known to Qt's meta-object system, because Qt
    /// needs to copy the arguments to store them in an event behind the
    /// scenes. If you try to use a queued connection and get the error
    /// message
    /// 
    /// call qRegisterMetaType() to register the data type before you
    /// establish the connection.
    /// 
    /// **See also:** disconnect()
    /// sender()
    /// qRegisterMetaType()
    /// Q_DECLARE_METATYPE()
    /// {Differences between String-Based and Functor-Based Connections}
    /// 
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// The Connection handle will be invalid if it cannot create the
    /// connection, for example, the parameters were invalid.
    /// You can check if the QMetaObject::Connection is valid by casting it to a bool.
    /// 
    /// This function works in the same way as
    /// `connect(const QObject *sender, const char *signal,
    /// const QObject *receiver, const char *method,
    /// Qt::ConnectionType type)`
    /// but it uses QMetaMethod to specify signal and method.
    /// 
    /// **See also:** connect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method
    /// Qt::ConnectionType type)
    /// 
    /// **Overloads** connect()
    /// Connects *signal* from the *sender* object to this object's *method.*
    /// 
    /// Equivalent to connect( *sender,* *signal,* `this,` *method,* *type).*
    /// 
    /// Every connection you make emits a signal, so duplicate connections emit
    /// two signals. You can break a connection using disconnect().
    /// 
    /// **See also:** disconnect()
    /// 
    /// This virtual function is called when something has been connected
    /// to *signal* in this object.
    /// 
    /// If you want to compare *signal* with a specific signal, you can
    /// use QMetaMethod::fromSignal() as follows:
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful when you need to perform
    /// expensive initialization only if something is connected to a
    /// signal.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// connection, which may be a different thread from the thread in
    /// which this object lives.
    /// 
    /// **See also:** connect()
    /// disconnectNotify()
    /// 
    /// **Overloads** connect()
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any member function that can be connected
    /// to the signal.
    /// A slot can be connected to a given signal if the signal has at
    /// least as many arguments as the slot, and there is an implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// This example ensures that the label always displays the current
    /// line edit text.
    /// 
    /// A signal can be connected to many slots and signals. Many signals
    /// can be connected to one slot.
    /// 
    /// If a signal is connected to several slots, the slots are activated
    /// in the same order as the order the connection was made, when the
    /// signal is emitted
    /// 
    /// The function returns an handle to a connection if it successfully
    /// connects the signal to the slot. The Connection handle will be invalid
    /// if it cannot create the connection, for example, if QObject is unable
    /// to verify the existence of *signal* (if it was not declared as a signal)
    /// You can check if the QMetaObject::Connection is valid by casting it to a bool.
    /// 
    /// By default, a signal is emitted for every connection you make;
    /// two signals are emitted for duplicate connections. You can break
    /// all of these connections with a single disconnect() call.
    /// If you pass the Qt::UniqueConnection *type,* the connection will only
    /// be made if it is not a duplicate. If there is already a duplicate
    /// (exact same signal to the exact same slot on the same objects),
    /// the connection will fail and connect will return an invalid QMetaObject::Connection.
    /// 
    /// The optional *type* parameter describes the type of connection
    /// to establish. In particular, it determines whether a particular
    /// signal is delivered to a slot immediately or queued for delivery
    /// at a later time. If the signal is queued, the parameters must be
    /// of types that are known to Qt's meta-object system, because Qt
    /// needs to copy the arguments to store them in an event behind the
    /// scenes. If you try to use a queued connection and get the error
    /// message
    /// 
    /// make sure to declare the argument type with Q_DECLARE_METATYPE
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    /// **See also:** {Differences between String-Based and Functor-Based Connections}
    /// 
    /// **Overloads** connect()
    /// Creates a connection from *signal* in
    /// *sender* object to *functor,* and returns a handle to the connection
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any function or functor that can be connected
    /// to the signal.
    /// A function can be connected to a given signal if the signal as at
    /// least as many argument as the slot. A functor can be connected to a signal
    /// if they have exactly the same number of arguments. There must exist implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// Lambda expressions can also be used:
    /// 
    /// The connection will automatically disconnect if the sender is destroyed.
    /// However, you should take care that any objects used within the functor
    /// are still alive when the signal is emitted.
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    /// 
    /// **Overloads** connect()
    /// 
    /// Creates a connection of a given *type* from *signal* in
    /// *sender* object to *functor* to be placed in a specific event
    /// loop of *context,* and returns a handle to the connection.
    /// 
    /// **Note**: Qt::UniqueConnections do not work for lambdas, non-member functions
    /// and functors; they only apply to connecting to member functions.
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any function or functor that can be connected
    /// to the signal.
    /// A function can be connected to a given signal if the signal as at
    /// least as many argument as the slot. A functor can be connected to a signal
    /// if they have exactly the same number of arguments. There must exist implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// Lambda expressions can also be used:
    /// 
    /// The connection will automatically disconnect if the sender or the context
    /// is destroyed.
    /// However, you should take care that any objects used within the functor
    /// are still alive when the signal is emitted.
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    [static] connect(sender: *ObjectType, signal: *char, receiver: *ObjectType, member: *char, arg0: Rute::ConnectionType) -> MetaObject::Connection,
    /// 
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// You must use the `SIGNAL()` and `SLOT()` macros when specifying
    /// the *signal* and the *method,* for example:
    /// 
    /// This example ensures that the label always displays the current
    /// scroll bar value. Note that the signal and slots parameters must not
    /// contain any variable names, only the type. E.g. the following would
    /// not work and return false:
    /// 
    /// A signal can also be connected to another signal:
    /// 
    /// In this example, the `MyWidget` constructor relays a signal from
    /// a private member variable, and makes it available under a name
    /// that relates to `MyWidget.`
    /// 
    /// A signal can be connected to many slots and signals. Many signals
    /// can be connected to one slot.
    /// 
    /// If a signal is connected to several slots, the slots are activated
    /// in the same order in which the connections were made, when the
    /// signal is emitted.
    /// 
    /// The function returns a QMetaObject::Connection that represents
    /// a handle to a connection if it successfully
    /// connects the signal to the slot. The connection handle will be invalid
    /// if it cannot create the connection, for example, if QObject is unable
    /// to verify the existence of either *signal* or *method,* or if their
    /// signatures aren't compatible.
    /// You can check if the handle is valid by casting it to a bool.
    /// 
    /// By default, a signal is emitted for every connection you make;
    /// two signals are emitted for duplicate connections. You can break
    /// all of these connections with a single disconnect() call.
    /// If you pass the Qt::UniqueConnection *type,* the connection will only
    /// be made if it is not a duplicate. If there is already a duplicate
    /// (exact same signal to the exact same slot on the same objects),
    /// the connection will fail and connect will return an invalid QMetaObject::Connection.
    /// 
    /// **Note**: Qt::UniqueConnections do not work for lambdas, non-member functions
    /// and functors; they only apply to connecting to member functions.
    /// 
    /// The optional *type* parameter describes the type of connection
    /// to establish. In particular, it determines whether a particular
    /// signal is delivered to a slot immediately or queued for delivery
    /// at a later time. If the signal is queued, the parameters must be
    /// of types that are known to Qt's meta-object system, because Qt
    /// needs to copy the arguments to store them in an event behind the
    /// scenes. If you try to use a queued connection and get the error
    /// message
    /// 
    /// call qRegisterMetaType() to register the data type before you
    /// establish the connection.
    /// 
    /// **See also:** disconnect()
    /// sender()
    /// qRegisterMetaType()
    /// Q_DECLARE_METATYPE()
    /// {Differences between String-Based and Functor-Based Connections}
    /// 
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// The Connection handle will be invalid if it cannot create the
    /// connection, for example, the parameters were invalid.
    /// You can check if the QMetaObject::Connection is valid by casting it to a bool.
    /// 
    /// This function works in the same way as
    /// `connect(const QObject *sender, const char *signal,
    /// const QObject *receiver, const char *method,
    /// Qt::ConnectionType type)`
    /// but it uses QMetaMethod to specify signal and method.
    /// 
    /// **See also:** connect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method
    /// Qt::ConnectionType type)
    /// 
    /// **Overloads** connect()
    /// Connects *signal* from the *sender* object to this object's *method.*
    /// 
    /// Equivalent to connect( *sender,* *signal,* `this,` *method,* *type).*
    /// 
    /// Every connection you make emits a signal, so duplicate connections emit
    /// two signals. You can break a connection using disconnect().
    /// 
    /// **See also:** disconnect()
    /// 
    /// This virtual function is called when something has been connected
    /// to *signal* in this object.
    /// 
    /// If you want to compare *signal* with a specific signal, you can
    /// use QMetaMethod::fromSignal() as follows:
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful when you need to perform
    /// expensive initialization only if something is connected to a
    /// signal.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// connection, which may be a different thread from the thread in
    /// which this object lives.
    /// 
    /// **See also:** connect()
    /// disconnectNotify()
    /// 
    /// **Overloads** connect()
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any member function that can be connected
    /// to the signal.
    /// A slot can be connected to a given signal if the signal has at
    /// least as many arguments as the slot, and there is an implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// This example ensures that the label always displays the current
    /// line edit text.
    /// 
    /// A signal can be connected to many slots and signals. Many signals
    /// can be connected to one slot.
    /// 
    /// If a signal is connected to several slots, the slots are activated
    /// in the same order as the order the connection was made, when the
    /// signal is emitted
    /// 
    /// The function returns an handle to a connection if it successfully
    /// connects the signal to the slot. The Connection handle will be invalid
    /// if it cannot create the connection, for example, if QObject is unable
    /// to verify the existence of *signal* (if it was not declared as a signal)
    /// You can check if the QMetaObject::Connection is valid by casting it to a bool.
    /// 
    /// By default, a signal is emitted for every connection you make;
    /// two signals are emitted for duplicate connections. You can break
    /// all of these connections with a single disconnect() call.
    /// If you pass the Qt::UniqueConnection *type,* the connection will only
    /// be made if it is not a duplicate. If there is already a duplicate
    /// (exact same signal to the exact same slot on the same objects),
    /// the connection will fail and connect will return an invalid QMetaObject::Connection.
    /// 
    /// The optional *type* parameter describes the type of connection
    /// to establish. In particular, it determines whether a particular
    /// signal is delivered to a slot immediately or queued for delivery
    /// at a later time. If the signal is queued, the parameters must be
    /// of types that are known to Qt's meta-object system, because Qt
    /// needs to copy the arguments to store them in an event behind the
    /// scenes. If you try to use a queued connection and get the error
    /// message
    /// 
    /// make sure to declare the argument type with Q_DECLARE_METATYPE
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    /// **See also:** {Differences between String-Based and Functor-Based Connections}
    /// 
    /// **Overloads** connect()
    /// Creates a connection from *signal* in
    /// *sender* object to *functor,* and returns a handle to the connection
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any function or functor that can be connected
    /// to the signal.
    /// A function can be connected to a given signal if the signal as at
    /// least as many argument as the slot. A functor can be connected to a signal
    /// if they have exactly the same number of arguments. There must exist implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// Lambda expressions can also be used:
    /// 
    /// The connection will automatically disconnect if the sender is destroyed.
    /// However, you should take care that any objects used within the functor
    /// are still alive when the signal is emitted.
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    /// 
    /// **Overloads** connect()
    /// 
    /// Creates a connection of a given *type* from *signal* in
    /// *sender* object to *functor* to be placed in a specific event
    /// loop of *context,* and returns a handle to the connection.
    /// 
    /// **Note**: Qt::UniqueConnections do not work for lambdas, non-member functions
    /// and functors; they only apply to connecting to member functions.
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any function or functor that can be connected
    /// to the signal.
    /// A function can be connected to a given signal if the signal as at
    /// least as many argument as the slot. A functor can be connected to a signal
    /// if they have exactly the same number of arguments. There must exist implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// Lambda expressions can also be used:
    /// 
    /// The connection will automatically disconnect if the sender or the context
    /// is destroyed.
    /// However, you should take care that any objects used within the functor
    /// are still alive when the signal is emitted.
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    [static] connect(sender: *ObjectType, signal: &MetaMethodType, receiver: *ObjectType, method: &MetaMethodType, type: Rute::ConnectionType) -> MetaObject::Connection,
    /// 
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// You must use the `SIGNAL()` and `SLOT()` macros when specifying
    /// the *signal* and the *method,* for example:
    /// 
    /// This example ensures that the label always displays the current
    /// scroll bar value. Note that the signal and slots parameters must not
    /// contain any variable names, only the type. E.g. the following would
    /// not work and return false:
    /// 
    /// A signal can also be connected to another signal:
    /// 
    /// In this example, the `MyWidget` constructor relays a signal from
    /// a private member variable, and makes it available under a name
    /// that relates to `MyWidget.`
    /// 
    /// A signal can be connected to many slots and signals. Many signals
    /// can be connected to one slot.
    /// 
    /// If a signal is connected to several slots, the slots are activated
    /// in the same order in which the connections were made, when the
    /// signal is emitted.
    /// 
    /// The function returns a QMetaObject::Connection that represents
    /// a handle to a connection if it successfully
    /// connects the signal to the slot. The connection handle will be invalid
    /// if it cannot create the connection, for example, if QObject is unable
    /// to verify the existence of either *signal* or *method,* or if their
    /// signatures aren't compatible.
    /// You can check if the handle is valid by casting it to a bool.
    /// 
    /// By default, a signal is emitted for every connection you make;
    /// two signals are emitted for duplicate connections. You can break
    /// all of these connections with a single disconnect() call.
    /// If you pass the Qt::UniqueConnection *type,* the connection will only
    /// be made if it is not a duplicate. If there is already a duplicate
    /// (exact same signal to the exact same slot on the same objects),
    /// the connection will fail and connect will return an invalid QMetaObject::Connection.
    /// 
    /// **Note**: Qt::UniqueConnections do not work for lambdas, non-member functions
    /// and functors; they only apply to connecting to member functions.
    /// 
    /// The optional *type* parameter describes the type of connection
    /// to establish. In particular, it determines whether a particular
    /// signal is delivered to a slot immediately or queued for delivery
    /// at a later time. If the signal is queued, the parameters must be
    /// of types that are known to Qt's meta-object system, because Qt
    /// needs to copy the arguments to store them in an event behind the
    /// scenes. If you try to use a queued connection and get the error
    /// message
    /// 
    /// call qRegisterMetaType() to register the data type before you
    /// establish the connection.
    /// 
    /// **See also:** disconnect()
    /// sender()
    /// qRegisterMetaType()
    /// Q_DECLARE_METATYPE()
    /// {Differences between String-Based and Functor-Based Connections}
    /// 
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// The Connection handle will be invalid if it cannot create the
    /// connection, for example, the parameters were invalid.
    /// You can check if the QMetaObject::Connection is valid by casting it to a bool.
    /// 
    /// This function works in the same way as
    /// `connect(const QObject *sender, const char *signal,
    /// const QObject *receiver, const char *method,
    /// Qt::ConnectionType type)`
    /// but it uses QMetaMethod to specify signal and method.
    /// 
    /// **See also:** connect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method
    /// Qt::ConnectionType type)
    /// 
    /// **Overloads** connect()
    /// Connects *signal* from the *sender* object to this object's *method.*
    /// 
    /// Equivalent to connect( *sender,* *signal,* `this,` *method,* *type).*
    /// 
    /// Every connection you make emits a signal, so duplicate connections emit
    /// two signals. You can break a connection using disconnect().
    /// 
    /// **See also:** disconnect()
    /// 
    /// This virtual function is called when something has been connected
    /// to *signal* in this object.
    /// 
    /// If you want to compare *signal* with a specific signal, you can
    /// use QMetaMethod::fromSignal() as follows:
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful when you need to perform
    /// expensive initialization only if something is connected to a
    /// signal.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// connection, which may be a different thread from the thread in
    /// which this object lives.
    /// 
    /// **See also:** connect()
    /// disconnectNotify()
    /// 
    /// **Overloads** connect()
    /// Creates a connection of the given *type* from the *signal* in
    /// the *sender* object to the *method* in the *receiver* object.
    /// Returns a handle to the connection that can be used to disconnect
    /// it later.
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any member function that can be connected
    /// to the signal.
    /// A slot can be connected to a given signal if the signal has at
    /// least as many arguments as the slot, and there is an implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// This example ensures that the label always displays the current
    /// line edit text.
    /// 
    /// A signal can be connected to many slots and signals. Many signals
    /// can be connected to one slot.
    /// 
    /// If a signal is connected to several slots, the slots are activated
    /// in the same order as the order the connection was made, when the
    /// signal is emitted
    /// 
    /// The function returns an handle to a connection if it successfully
    /// connects the signal to the slot. The Connection handle will be invalid
    /// if it cannot create the connection, for example, if QObject is unable
    /// to verify the existence of *signal* (if it was not declared as a signal)
    /// You can check if the QMetaObject::Connection is valid by casting it to a bool.
    /// 
    /// By default, a signal is emitted for every connection you make;
    /// two signals are emitted for duplicate connections. You can break
    /// all of these connections with a single disconnect() call.
    /// If you pass the Qt::UniqueConnection *type,* the connection will only
    /// be made if it is not a duplicate. If there is already a duplicate
    /// (exact same signal to the exact same slot on the same objects),
    /// the connection will fail and connect will return an invalid QMetaObject::Connection.
    /// 
    /// The optional *type* parameter describes the type of connection
    /// to establish. In particular, it determines whether a particular
    /// signal is delivered to a slot immediately or queued for delivery
    /// at a later time. If the signal is queued, the parameters must be
    /// of types that are known to Qt's meta-object system, because Qt
    /// needs to copy the arguments to store them in an event behind the
    /// scenes. If you try to use a queued connection and get the error
    /// message
    /// 
    /// make sure to declare the argument type with Q_DECLARE_METATYPE
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    /// **See also:** {Differences between String-Based and Functor-Based Connections}
    /// 
    /// **Overloads** connect()
    /// Creates a connection from *signal* in
    /// *sender* object to *functor,* and returns a handle to the connection
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any function or functor that can be connected
    /// to the signal.
    /// A function can be connected to a given signal if the signal as at
    /// least as many argument as the slot. A functor can be connected to a signal
    /// if they have exactly the same number of arguments. There must exist implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// Lambda expressions can also be used:
    /// 
    /// The connection will automatically disconnect if the sender is destroyed.
    /// However, you should take care that any objects used within the functor
    /// are still alive when the signal is emitted.
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    /// 
    /// **Overloads** connect()
    /// 
    /// Creates a connection of a given *type* from *signal* in
    /// *sender* object to *functor* to be placed in a specific event
    /// loop of *context,* and returns a handle to the connection.
    /// 
    /// **Note**: Qt::UniqueConnections do not work for lambdas, non-member functions
    /// and functors; they only apply to connecting to member functions.
    /// 
    /// The signal must be a function declared as a signal in the header.
    /// The slot function can be any function or functor that can be connected
    /// to the signal.
    /// A function can be connected to a given signal if the signal as at
    /// least as many argument as the slot. A functor can be connected to a signal
    /// if they have exactly the same number of arguments. There must exist implicit
    /// conversion between the types of the corresponding arguments in the
    /// signal and the slot.
    /// 
    /// Example:
    /// 
    /// Lambda expressions can also be used:
    /// 
    /// The connection will automatically disconnect if the sender or the context
    /// is destroyed.
    /// However, you should take care that any objects used within the functor
    /// are still alive when the signal is emitted.
    /// 
    /// Overloaded functions can be resolved with help of [qOverload.](qOverload.)
    /// 
    connect(sender: *ObjectType, signal: *char, member: *char, type: Rute::ConnectionType) -> MetaObject::Connection,
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals: equivalent to the non-static overloaded function
    /// * Disconnect everything connected to a specific signal: equivalent to the non-static overloaded function
    /// * Disconnect a specific receiver: equivalent to the non-static overloaded function
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **See also:** connect()
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// This function provides the same possibilities like
    /// `disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)`
    /// but uses QMetaMethod to represent the signal and the method to be disconnected.
    /// 
    /// Additionally this function returnsfalse and no signals and slots disconnected
    /// if:
    /// 
    /// * *signal* is not a member of sender class or one of its parent classes.
    /// * *method* is not a member of receiver class or one of its parent classes.
    /// * *signal* instance represents not a signal.
    /// 
    /// QMetaMethod() may be used as wildcard in the meaning or .
    /// In the same way 0 can be used for *receiver* in the meaning . In this case
    /// method should also be QMetaMethod(). *sender* parameter should be never 0.
    /// 
    /// **See also:** disconnect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method)
    /// 
    /// **Overloads** disconnect()
    /// Disconnects *signal* from *method* of *receiver.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// **Overloads** disconnect()
    /// Disconnects all signals in this object from *receiver's* *method.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// This virtual function is called when something has been
    /// disconnected from *signal* in this object.
    /// 
    /// See connectNotify() for an example of how to compare
    /// *signal* with a specific signal.
    /// 
    /// If all signals were disconnected from this object (e.g., the
    /// signal argument to disconnect() was 0), disconnectNotify()
    /// is only called once, and the *signal* will be an invalid
    /// QMetaMethod (QMetaMethod::isValid() returns `false).`
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful for optimizing access to
    /// expensive resources.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// disconnection, which may be a different thread from the thread in
    /// which this object lives. This function may also be called with a QObject
    /// internal mutex locked. It is therefore not allowed to re-enter any
    /// of any QObject functions from your reimplementation and if you lock
    /// a mutex in your reimplementation, make sure that you don't call QObject
    /// functions with that mutex held in other places or it will result in
    /// a deadlock.
    /// 
    /// **See also:** disconnect()
    /// connectNotify()
    /// 
    /// Disconnect a connection.
    /// 
    /// If the *connection* is invalid or has already been disconnected, do nothing
    /// and return false.
    /// 
    /// **See also:** connect()
    /// **Overloads** diconnect()
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals:
    /// * Disconnect everything connected to a specific signal:
    /// * Disconnect a specific receiver:
    /// * Disconnect a connection from one specific signal to a specific slot:
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **Note**: It is not possible to use this overload to diconnect signals
    /// connected to functors or lambda expressions. That is because it is not
    /// possible to compare them. Instead, use the overload that takes a
    /// QMetaObject::Connection
    /// 
    /// **See also:** connect()
    [static] disconnect(sender: *ObjectType, signal: &MetaMethodType, receiver: *ObjectType, member: &MetaMethodType) -> bool,
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals: equivalent to the non-static overloaded function
    /// * Disconnect everything connected to a specific signal: equivalent to the non-static overloaded function
    /// * Disconnect a specific receiver: equivalent to the non-static overloaded function
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **See also:** connect()
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// This function provides the same possibilities like
    /// `disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)`
    /// but uses QMetaMethod to represent the signal and the method to be disconnected.
    /// 
    /// Additionally this function returnsfalse and no signals and slots disconnected
    /// if:
    /// 
    /// * *signal* is not a member of sender class or one of its parent classes.
    /// * *method* is not a member of receiver class or one of its parent classes.
    /// * *signal* instance represents not a signal.
    /// 
    /// QMetaMethod() may be used as wildcard in the meaning or .
    /// In the same way 0 can be used for *receiver* in the meaning . In this case
    /// method should also be QMetaMethod(). *sender* parameter should be never 0.
    /// 
    /// **See also:** disconnect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method)
    /// 
    /// **Overloads** disconnect()
    /// Disconnects *signal* from *method* of *receiver.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// **Overloads** disconnect()
    /// Disconnects all signals in this object from *receiver's* *method.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// This virtual function is called when something has been
    /// disconnected from *signal* in this object.
    /// 
    /// See connectNotify() for an example of how to compare
    /// *signal* with a specific signal.
    /// 
    /// If all signals were disconnected from this object (e.g., the
    /// signal argument to disconnect() was 0), disconnectNotify()
    /// is only called once, and the *signal* will be an invalid
    /// QMetaMethod (QMetaMethod::isValid() returns `false).`
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful for optimizing access to
    /// expensive resources.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// disconnection, which may be a different thread from the thread in
    /// which this object lives. This function may also be called with a QObject
    /// internal mutex locked. It is therefore not allowed to re-enter any
    /// of any QObject functions from your reimplementation and if you lock
    /// a mutex in your reimplementation, make sure that you don't call QObject
    /// functions with that mutex held in other places or it will result in
    /// a deadlock.
    /// 
    /// **See also:** disconnect()
    /// connectNotify()
    /// 
    /// Disconnect a connection.
    /// 
    /// If the *connection* is invalid or has already been disconnected, do nothing
    /// and return false.
    /// 
    /// **See also:** connect()
    /// **Overloads** diconnect()
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals:
    /// * Disconnect everything connected to a specific signal:
    /// * Disconnect a specific receiver:
    /// * Disconnect a connection from one specific signal to a specific slot:
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **Note**: It is not possible to use this overload to diconnect signals
    /// connected to functors or lambda expressions. That is because it is not
    /// possible to compare them. Instead, use the overload that takes a
    /// QMetaObject::Connection
    /// 
    /// **See also:** connect()
    disconnect(signal: *char, receiver: *ObjectType, member: *char) -> bool,
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals: equivalent to the non-static overloaded function
    /// * Disconnect everything connected to a specific signal: equivalent to the non-static overloaded function
    /// * Disconnect a specific receiver: equivalent to the non-static overloaded function
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **See also:** connect()
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// This function provides the same possibilities like
    /// `disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)`
    /// but uses QMetaMethod to represent the signal and the method to be disconnected.
    /// 
    /// Additionally this function returnsfalse and no signals and slots disconnected
    /// if:
    /// 
    /// * *signal* is not a member of sender class or one of its parent classes.
    /// * *method* is not a member of receiver class or one of its parent classes.
    /// * *signal* instance represents not a signal.
    /// 
    /// QMetaMethod() may be used as wildcard in the meaning or .
    /// In the same way 0 can be used for *receiver* in the meaning . In this case
    /// method should also be QMetaMethod(). *sender* parameter should be never 0.
    /// 
    /// **See also:** disconnect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method)
    /// 
    /// **Overloads** disconnect()
    /// Disconnects *signal* from *method* of *receiver.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// **Overloads** disconnect()
    /// Disconnects all signals in this object from *receiver's* *method.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// This virtual function is called when something has been
    /// disconnected from *signal* in this object.
    /// 
    /// See connectNotify() for an example of how to compare
    /// *signal* with a specific signal.
    /// 
    /// If all signals were disconnected from this object (e.g., the
    /// signal argument to disconnect() was 0), disconnectNotify()
    /// is only called once, and the *signal* will be an invalid
    /// QMetaMethod (QMetaMethod::isValid() returns `false).`
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful for optimizing access to
    /// expensive resources.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// disconnection, which may be a different thread from the thread in
    /// which this object lives. This function may also be called with a QObject
    /// internal mutex locked. It is therefore not allowed to re-enter any
    /// of any QObject functions from your reimplementation and if you lock
    /// a mutex in your reimplementation, make sure that you don't call QObject
    /// functions with that mutex held in other places or it will result in
    /// a deadlock.
    /// 
    /// **See also:** disconnect()
    /// connectNotify()
    /// 
    /// Disconnect a connection.
    /// 
    /// If the *connection* is invalid or has already been disconnected, do nothing
    /// and return false.
    /// 
    /// **See also:** connect()
    /// **Overloads** diconnect()
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals:
    /// * Disconnect everything connected to a specific signal:
    /// * Disconnect a specific receiver:
    /// * Disconnect a connection from one specific signal to a specific slot:
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **Note**: It is not possible to use this overload to diconnect signals
    /// connected to functors or lambda expressions. That is because it is not
    /// possible to compare them. Instead, use the overload that takes a
    /// QMetaObject::Connection
    /// 
    /// **See also:** connect()
    disconnect(receiver: *ObjectType, member: *char) -> bool,
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals: equivalent to the non-static overloaded function
    /// * Disconnect everything connected to a specific signal: equivalent to the non-static overloaded function
    /// * Disconnect a specific receiver: equivalent to the non-static overloaded function
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **See also:** connect()
    /// 
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// This function provides the same possibilities like
    /// `disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method)`
    /// but uses QMetaMethod to represent the signal and the method to be disconnected.
    /// 
    /// Additionally this function returnsfalse and no signals and slots disconnected
    /// if:
    /// 
    /// * *signal* is not a member of sender class or one of its parent classes.
    /// * *method* is not a member of receiver class or one of its parent classes.
    /// * *signal* instance represents not a signal.
    /// 
    /// QMetaMethod() may be used as wildcard in the meaning or .
    /// In the same way 0 can be used for *receiver* in the meaning . In this case
    /// method should also be QMetaMethod(). *sender* parameter should be never 0.
    /// 
    /// **See also:** disconnect(const QObject *sender
    /// const char *signal
    /// const QObject *receiver
    /// const char *method)
    /// 
    /// **Overloads** disconnect()
    /// Disconnects *signal* from *method* of *receiver.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// **Overloads** disconnect()
    /// Disconnects all signals in this object from *receiver's* *method.*
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// This virtual function is called when something has been
    /// disconnected from *signal* in this object.
    /// 
    /// See connectNotify() for an example of how to compare
    /// *signal* with a specific signal.
    /// 
    /// If all signals were disconnected from this object (e.g., the
    /// signal argument to disconnect() was 0), disconnectNotify()
    /// is only called once, and the *signal* will be an invalid
    /// QMetaMethod (QMetaMethod::isValid() returns `false).`
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful for optimizing access to
    /// expensive resources.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// disconnection, which may be a different thread from the thread in
    /// which this object lives. This function may also be called with a QObject
    /// internal mutex locked. It is therefore not allowed to re-enter any
    /// of any QObject functions from your reimplementation and if you lock
    /// a mutex in your reimplementation, make sure that you don't call QObject
    /// functions with that mutex held in other places or it will result in
    /// a deadlock.
    /// 
    /// **See also:** disconnect()
    /// connectNotify()
    /// 
    /// Disconnect a connection.
    /// 
    /// If the *connection* is invalid or has already been disconnected, do nothing
    /// and return false.
    /// 
    /// **See also:** connect()
    /// **Overloads** diconnect()
    /// Disconnects *signal* in object *sender* from *method* in object
    /// *receiver.* Returns `true` if the connection is successfully broken;
    /// otherwise returns `false.`
    /// 
    /// A signal-slot connection is removed when either of the objects
    /// involved are destroyed.
    /// 
    /// disconnect() is typically used in three ways, as the following
    /// examples demonstrate.
    /// * Disconnect everything connected to an object's signals:
    /// * Disconnect everything connected to a specific signal:
    /// * Disconnect a specific receiver:
    /// * Disconnect a connection from one specific signal to a specific slot:
    /// 
    /// 0 may be used as a wildcard, meaning , , or , respectively.
    /// 
    /// The *sender* may never be 0. (You cannot disconnect signals from
    /// more than one object in a single call.)
    /// 
    /// If *signal* is 0, it disconnects *receiver* and *method* from
    /// any signal. If not, only the specified signal is disconnected.
    /// 
    /// If *receiver* is 0, it disconnects anything connected to *signal.* If not, slots in objects other than *receiver* are not
    /// disconnected.
    /// 
    /// If *method* is 0, it disconnects anything that is connected to *receiver.* If not, only slots named *method* will be disconnected,
    /// and all other slots are left alone. The *method* must be 0 if *receiver* is left out, so you cannot disconnect a
    /// specifically-named slot on all objects.
    /// 
    /// **Note**: It is not possible to use this overload to diconnect signals
    /// connected to functors or lambda expressions. That is because it is not
    /// possible to compare them. Instead, use the overload that takes a
    /// QMetaObject::Connection
    /// 
    /// **See also:** connect()
    [static] disconnect(arg0: onst QMetaObject::Connection &) -> bool,
    /// 
    /// **Overloads**
    /// Dumps a tree of children to the debug output.
    /// 
    /// **See also:** dumpObjectInfo()
    /// 
    /// Dumps a tree of children to the debug output.
    /// 
    /// **Note**: before Qt 5.9, this function was not const.
    /// 
    /// **See also:** dumpObjectInfo()
    dump_object_tree(),
    /// 
    /// **Overloads**
    /// Dumps information about signal connections, etc. for this object
    /// to the debug output.
    /// 
    /// **See also:** dumpObjectTree()
    /// 
    /// Dumps information about signal connections, etc. for this object
    /// to the debug output.
    /// 
    /// **Note**: before Qt 5.9, this function was not const.
    /// 
    /// **See also:** dumpObjectTree()
    dump_object_info(),
    /// 
    /// **Overloads**
    /// Dumps a tree of children to the debug output.
    /// 
    /// **See also:** dumpObjectInfo()
    /// 
    /// Dumps a tree of children to the debug output.
    /// 
    /// **Note**: before Qt 5.9, this function was not const.
    /// 
    /// **See also:** dumpObjectInfo()
    dump_object_tree(),
    /// 
    /// **Overloads**
    /// Dumps information about signal connections, etc. for this object
    /// to the debug output.
    /// 
    /// **See also:** dumpObjectTree()
    /// 
    /// Dumps information about signal connections, etc. for this object
    /// to the debug output.
    /// 
    /// **Note**: before Qt 5.9, this function was not const.
    /// 
    /// **See also:** dumpObjectTree()
    dump_object_info(),
    /// 
    /// Sets the value of the object's *name* property to *value.*
    /// 
    /// If the property is defined in the class using Q_PROPERTY then
    /// true is returned on success and false otherwise. If the property
    /// is not defined using Q_PROPERTY, and therefore not listed in the
    /// meta-object, it is added as a dynamic property and false is returned.
    /// 
    /// Information about all available properties is provided through the
    /// metaObject() and dynamicPropertyNames().
    /// 
    /// Dynamic properties can be queried again using property() and can be
    /// removed by setting the property value to an invalid QVariant.
    /// Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
    /// to be sent to the object.
    /// 
    /// **Note:** Dynamic properties starting with are reserved for internal
    /// purposes.
    /// 
    /// **See also:** property()
    /// metaObject()
    /// dynamicPropertyNames()
    /// QMetaProperty::write()
    set_property(name: *char, value: &VariantType) -> bool,
    /// 
    /// Returns the value of the object's *name* property.
    /// 
    /// If no such property exists, the returned variant is invalid.
    /// 
    /// Information about all available properties is provided through the
    /// metaObject() and dynamicPropertyNames().
    /// 
    /// **See also:** setProperty()
    /// QVariant::isValid()
    /// metaObject()
    /// dynamicPropertyNames()
    property(name: *char) -> Variant,
    /// 
    /// Returns the names of all properties that were dynamically added to
    /// the object using setProperty().
    dynamic_property_names() -> [ByteArray],
    [static] register_user_data() -> uint,
    set_user_data(id: uint, data: *ObjectUserDataType),
    user_data(id: uint) -> ObjectUserData?,
    /// 
    /// This signal is emitted after the object's name has been changed. The new object name is passed as *objectName.*
    /// 
    /// **See also:** QObject::objectName
    [signal] object_name_changed(object_name: String, arg0: Object::QPrivateSignal),
    /// 
    /// Returns a pointer to the parent object.
    /// 
    /// **See also:** children()
    parent() -> Object?,
    /// 
    /// Returns `true` if this object is an instance of a class that
    /// inherits *className* or a QObject subclass that inherits *className;* otherwise returns `false.`
    /// 
    /// A class is considered to inherit itself.
    /// 
    /// Example:
    /// 
    /// If you need to determine whether an object is an instance of a particular
    /// class for the purpose of casting it, consider using qobject_cast<Type *>(object)
    /// instead.
    /// 
    /// **See also:** metaObject()
    /// qobject_cast()
    inherits(classname: *char) -> bool,
    /// 
    /// Schedules this object for deletion.
    /// 
    /// The object will be deleted when control returns to the event
    /// loop. If the event loop is not running when this function is
    /// called (e.g. deleteLater() is called on an object before
    /// QCoreApplication::exec()), the object will be deleted once the
    /// event loop is started. If deleteLater() is called after the main event loop
    /// has stopped, the object will not be deleted.
    /// Since Qt 4.8, if deleteLater() is called on an object that lives in a
    /// thread with no running event loop, the object will be destroyed when the
    /// thread finishes.
    /// 
    /// Note that entering and leaving a new event loop (e.g., by opening a modal
    /// dialog) will *not* perform the deferred deletion; for the object to be
    /// deleted, the control must return to the event loop from which
    /// deleteLater() was called.
    /// 
    /// **Note:** It is safe to call this function more than once; when the
    /// first deferred deletion event is delivered, any pending events for the
    /// object are removed from the event queue.
    /// 
    /// **See also:** destroyed()
    /// QPointer
    delete_later(),
    /// 
    /// Returns a pointer to the object that sent the signal, if called in
    /// a slot activated by a signal; otherwise it returns 0. The pointer
    /// is valid only during the execution of the slot that calls this
    /// function from this object's thread context.
    /// 
    /// The pointer returned by this function becomes invalid if the
    /// sender is destroyed, or if the slot is disconnected from the
    /// sender's signal.
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, getting access to the sender might be useful
    /// when many signals are connected to a single slot.
    /// 
    /// **Warning**: As mentioned above, the return value of this function is
    /// not valid when the slot is called via a Qt::DirectConnection from
    /// a thread different from this object's thread. Do not use this
    /// function in this type of scenario.
    /// 
    /// **See also:** senderSignalIndex()
    /// 
    /// Returns the meta-method index of the signal that called the currently
    /// executing slot, which is a member of the class returned by sender().
    /// If called outside of a slot activated by a signal, -1 is returned.
    /// 
    /// For signals with default parameters, this function will always return
    /// the index with all parameters, regardless of which was used with
    /// connect(). For example, the signal `destroyed(QObject *obj = 0)`
    /// will have two different indexes (with and without the parameter), but
    /// this function will always return the index with a parameter. This does
    /// not apply when overloading signals with different parameters.
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, getting access to the signal index might be useful
    /// when many signals are connected to a single slot.
    /// 
    /// **Warning**: The return value of this function is not valid when the slot
    /// is called via a Qt::DirectConnection from a thread different from this
    /// object's thread. Do not use this function in this type of scenario.
    /// 
    /// **See also:** sender()
    /// QMetaObject::indexOfSignal()
    /// QMetaObject::method()
    sender() -> Object?,
    /// 
    /// Returns the meta-method index of the signal that called the currently
    /// executing slot, which is a member of the class returned by sender().
    /// If called outside of a slot activated by a signal, -1 is returned.
    /// 
    /// For signals with default parameters, this function will always return
    /// the index with all parameters, regardless of which was used with
    /// connect(). For example, the signal `destroyed(QObject *obj = 0)`
    /// will have two different indexes (with and without the parameter), but
    /// this function will always return the index with a parameter. This does
    /// not apply when overloading signals with different parameters.
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, getting access to the signal index might be useful
    /// when many signals are connected to a single slot.
    /// 
    /// **Warning**: The return value of this function is not valid when the slot
    /// is called via a Qt::DirectConnection from a thread different from this
    /// object's thread. Do not use this function in this type of scenario.
    /// 
    /// **See also:** sender()
    /// QMetaObject::indexOfSignal()
    /// QMetaObject::method()
    sender_signal_index() -> i32,
    /// 
    /// Returns the number of receivers connected to the *signal.*
    /// 
    /// Since both slots and signals can be used as receivers for signals,
    /// and the same connections can be made many times, the number of
    /// receivers is the same as the number of connections made from this
    /// signal.
    /// 
    /// When calling this function, you can use the `SIGNAL()` macro to
    /// pass a specific signal:
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful when you need to perform
    /// expensive initialization only if something is connected to a
    /// signal.
    /// 
    /// **See also:** isSignalConnected()
    receivers(signal: *char) -> i32,
    /// 
    /// Returns `true` if the *signal* is connected to at least one receiver,
    /// otherwise returns `false.`
    /// 
    /// *signal* must be a signal member of this object, otherwise the behaviour
    /// is undefined.
    /// 
    /// As the code snippet above illustrates, you can use this function
    /// to avoid emitting a signal that nobody listens to.
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful when you need to perform
    /// expensive initialization only if something is connected to a
    /// signal.
    is_signal_connected(signal: &MetaMethodType) -> bool,
    /// 
    /// This event handler can be reimplemented in a subclass to receive
    /// timer events for the object.
    /// 
    /// QTimer provides a higher-level interface to the timer
    /// functionality, and also more general information about timers. The
    /// timer event is passed in the *event* parameter.
    /// 
    /// **See also:** startTimer()
    /// killTimer()
    /// event()
    [event] timer_event(event: *TimerEventType),
    /// 
    /// This event handler can be reimplemented in a subclass to receive
    /// child events. The event is passed in the *event* parameter.
    /// 
    /// QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
    /// objects when children are added or removed. In both cases you can
    /// only rely on the child being a QObject, or if isWidgetType()
    /// returns `true,` a QWidget. (This is because, in the
    /// [ChildAdded](QEvent::ChildAdded)
    /// case, the child is not yet
    /// fully constructed, and in the [ChildRemoved](QEvent::ChildRemoved)
    /// 
    /// case it might have been destructed already).
    /// 
    /// QEvent::ChildPolished events are sent to widgets when children
    /// are polished, or when polished children are added. If you receive
    /// a child polished event, the child's construction is usually
    /// completed. However, this is not guaranteed, and multiple polish
    /// events may be delivered during the execution of a widget's
    /// constructor.
    /// 
    /// For every child widget, you receive one
    /// [ChildAdded](QEvent::ChildAdded)
    /// event, zero or more
    /// [ChildPolished](QEvent::ChildPolished)
    /// events, and one
    /// [ChildRemoved](QEvent::ChildRemoved)
    /// event.
    /// 
    /// The [ChildPolished](QEvent::ChildPolished)
    /// event is omitted if
    /// a child is removed immediately after it is added. If a child is
    /// polished several times during construction and destruction, you
    /// may receive several child polished events for the same child,
    /// each time with a different virtual table.
    /// 
    /// **See also:** event()
    [event] child_event(event: *ChildEventType),
    /// 
    /// This event handler can be reimplemented in a subclass to receive
    /// custom events. Custom events are user-defined events with a type
    /// value at least as large as the QEvent::User item of the
    /// QEvent::Type enum, and is typically a QEvent subclass. The event
    /// is passed in the *event* parameter.
    /// 
    /// **See also:** event()
    /// QEvent
    [event] custom_event(event: *EventType),
    /// 
    /// This virtual function is called when something has been connected
    /// to *signal* in this object.
    /// 
    /// If you want to compare *signal* with a specific signal, you can
    /// use QMetaMethod::fromSignal() as follows:
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful when you need to perform
    /// expensive initialization only if something is connected to a
    /// signal.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// connection, which may be a different thread from the thread in
    /// which this object lives.
    /// 
    /// **See also:** connect()
    /// disconnectNotify()
    [event] connect_notify(signal: &MetaMethodType),
    /// 
    /// This virtual function is called when something has been
    /// disconnected from *signal* in this object.
    /// 
    /// See connectNotify() for an example of how to compare
    /// *signal* with a specific signal.
    /// 
    /// If all signals were disconnected from this object (e.g., the
    /// signal argument to disconnect() was 0), disconnectNotify()
    /// is only called once, and the *signal* will be an invalid
    /// QMetaMethod (QMetaMethod::isValid() returns `false).`
    /// 
    /// **Warning**: This function violates the object-oriented principle of
    /// modularity. However, it might be useful for optimizing access to
    /// expensive resources.
    /// 
    /// **Warning**: This function is called from the thread which performs the
    /// disconnection, which may be a different thread from the thread in
    /// which this object lives. This function may also be called with a QObject
    /// internal mutex locked. It is therefore not allowed to re-enter any
    /// of any QObject functions from your reimplementation and if you lock
    /// a mutex in your reimplementation, make sure that you don't call QObject
    /// functions with that mutex held in other places or it will result in
    /// a deadlock.
    /// 
    /// **See also:** disconnect()
    /// connectNotify()
    [event] disconnect_notify(signal: &MetaMethodType),
}

// vim: syntax=rust expandtab ts=4 sw=4
