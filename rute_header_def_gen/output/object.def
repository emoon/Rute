///     \class QObject
///     \inmodule QtCore
///     \brief The QObject class is the base class of all Qt objects.
/// 
///     \ingroup objectmodel
/// 
///     \reentrant
/// 
///     QObject is the heart of the Qt \l{Object Model}. The central
///     feature in this model is a very powerful mechanism for seamless
///     object communication called \l{signals and slots}. You can
///     connect a signal to a slot with connect() and destroy the
///     connection with disconnect(). To avoid never ending notification
///     loops you can temporarily block signals with blockSignals(). The
///     protected functions connectNotify() and disconnectNotify() make
///     it possible to track connections.
/// 
///     QObjects organize themselves in \l {Object Trees & Ownership}
///     {object trees}. When you create a QObject with another object as
///     parent, the object will automatically add itself to the parent's
///     children() list. The parent takes ownership of the object; i.e.,
///     it will automatically delete its children in its destructor. You
///     can look for an object by name and optionally type using
///     findChild() or findChildren().
/// 
///     Every object has an objectName() and its class name can be found
///     via the corresponding metaObject() (see QMetaObject::className()).
///     You can determine whether the object's class inherits another
///     class in the QObject inheritance hierarchy by using the
///     inherits() function.
/// 
///     When an object is deleted, it emits a destroyed() signal. You can
///     catch this signal to avoid dangling references to QObjects.
/// 
///     QObjects can receive events through event() and filter the events
///     of other objects. See installEventFilter() and eventFilter() for
///     details. A convenience handler, childEvent(), can be reimplemented
///     to catch child events.
/// 
///     Last but not least, QObject provides the basic timer support in
///     Qt; see QTimer for high-level support for timers.
/// 
///     Notice that the Q_OBJECT macro is mandatory for any object that
///     implements signals, slots or properties. You also need to run the
///     \l{moc}{Meta Object Compiler} on the source file. We strongly
///     recommend the use of this macro in all subclasses of QObject
///     regardless of whether or not they actually use signals, slots and
///     properties, since failure to do so may lead certain functions to
///     exhibit strange behavior.
/// 
///     All Qt widgets inherit QObject. The convenience function
///     isWidgetType() returns whether an object is actually a widget. It
///     is much faster than
///     \l{qobject_cast()}{qobject_cast}<QWidget *>(\e{obj}) or
///     \e{obj}->\l{inherits()}{inherits}("QWidget").
/// 
///     Some QObject functions, e.g. children(), return a QObjectList.
///     QObjectList is a typedef for QList<QObject *>.
/// 
///     \section1 Thread Affinity
/// 
///     A QObject instance is said to have a \e{thread affinity}, or that
///     it \e{lives} in a certain thread. When a QObject receives a
///     \l{Qt::QueuedConnection}{queued signal} or a \l{The Event
///     System#Sending Events}{posted event}, the slot or event handler
///     will run in the thread that the object lives in.
/// 
///     \note If a QObject has no thread affinity (that is, if thread()
///     returns zero), or if it lives in a thread that has no running event
///     loop, then it cannot receive queued signals or posted events.
/// 
///     By default, a QObject lives in the thread in which it is created.
///     An object's thread affinity can be queried using thread() and
///     changed using moveToThread().
/// 
///     All QObjects must live in the same thread as their parent. Consequently:
/// 
///     \list
///     \li setParent() will fail if the two QObjects involved live in
///         different threads.
///     \li When a QObject is moved to another thread, all its children
///         will be automatically moved too.
///     \li moveToThread() will fail if the QObject has a parent.
///     \li If QObjects are created within QThread::run(), they cannot
///         become children of the QThread object because the QThread does
///         not live in the thread that calls QThread::run().
///     \endlist
/// 
///     \note A QObject's member variables \e{do not} automatically become
///     its children. The parent-child relationship must be set by either
///     passing a pointer to the child's \l{QObject()}{constructor}, or by
///     calling setParent(). Without this step, the object's member variables
///     will remain in the old thread when moveToThread() is called.
/// 
///     \target No copy constructor
///     \section1 No Copy Constructor or Assignment Operator
/// 
///     QObject has neither a copy constructor nor an assignment operator.
///     This is by design. Actually, they are declared, but in a
///     \c{private} section with the macro Q_DISABLE_COPY(). In fact, all
///     Qt classes derived from QObject (direct or indirect) use this
///     macro to declare their copy constructor and assignment operator to
///     be private. The reasoning is found in the discussion on
///     \l{Identity vs Value} {Identity vs Value} on the Qt \l{Object
///     Model} page.
/// 
///     The main consequence is that you should use pointers to QObject
///     (or to your QObject subclass) where you might otherwise be tempted
///     to use your QObject subclass as a value. For example, without a
///     copy constructor, you can't use a subclass of QObject as the value
///     to be stored in one of the container classes. You must store
///     pointers.
/// 
///     \section1 Auto-Connection
/// 
///     Qt's meta-object system provides a mechanism to automatically connect
///     signals and slots between QObject subclasses and their children. As long
///     as objects are defined with suitable object names, and slots follow a
///     simple naming convention, this connection can be performed at run-time
///     by the QMetaObject::connectSlotsByName() function.
/// 
///     \l uic generates code that invokes this function to enable
///     auto-connection to be performed between widgets on forms created
///     with \e{Qt Designer}. More information about using auto-connection with \e{Qt Designer} is
///     given in the \l{Using a Designer UI File in Your Application} section of
///     the \e{Qt Designer} manual.
/// 
///     \section1 Dynamic Properties
/// 
///     From Qt 4.2, dynamic properties can be added to and removed from QObject
///     instances at run-time. Dynamic properties do not need to be declared at
///     compile-time, yet they provide the same advantages as static properties
///     and are manipulated using the same API - using property() to read them
///     and setProperty() to write them.
/// 
///     From Qt 4.3, dynamic properties are supported by
///     \l{Qt Designer's Widget Editing Mode#The Property Editor}{Qt Designer},
///     and both standard Qt widgets and user-created forms can be given dynamic
///     properties.
/// 
///     \section1 Internationalization (I18n)
/// 
///     All QObject subclasses support Qt's translation features, making it possible
///     to translate an application's user interface into different languages.
/// 
///     To make user-visible text translatable, it must be wrapped in calls to
///     the tr() function. This is explained in detail in the
///     \l{Writing Source Code for Translation} document.
/// 
///     \sa QMetaObject, QPointer, QObjectCleanupHandler, Q_DISABLE_COPY()
///     \sa {Object Trees & Ownership}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.

struct Object {
    ///     This virtual function receives events to an object and should
    ///     return true if the event \a e was recognized and processed.
    /// 
    ///     The event() function can be reimplemented to customize the
    ///     behavior of an object.
    /// 
    ///     Make sure you call the parent event class implementation
    ///     for all the events you did not handle.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 52
    /// 
    ///     \sa installEventFilter(), timerEvent(), QCoreApplication::sendEvent(),
    ///     QCoreApplication::postEvent()
    [event] event(event: *EventType) -> bool,
    ///     Filters events if this object has been installed as an event
    ///     filter for the \a watched object.
    /// 
    ///     In your reimplementation of this function, if you want to filter
    ///     the \a event out, i.e. stop it being handled further, return
    ///     true; otherwise return false.
    /// 
    ///     Example:
    ///     \snippet code/src_corelib_kernel_qobject.cpp 6
    /// 
    ///     Notice in the example above that unhandled events are passed to
    ///     the base class's eventFilter() function, since the base class
    ///     might have reimplemented eventFilter() for its own internal
    ///     purposes.
    /// 
    ///     \warning If you delete the receiver object in this function, be
    ///     sure to return true. Otherwise, Qt will forward the event to the
    ///     deleted object and the program might crash.
    /// 
    ///     \sa installEventFilter()
    [event] event_filter(watched: *ObjectType, event: *EventType) -> bool,
    ///     \property QObject::objectName
    /// 
    ///     \brief the name of this object
    /// 
    ///     You can find an object by name (and type) using findChild().
    ///     You can find a set of objects with findChildren().
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 5
    /// 
    ///     By default, this property contains an empty string.
    /// 
    ///     \sa metaObject(), QMetaObject::className()
    object_name() -> String,
    set_object_name(name: String),
    is_widget_type() -> bool,
    is_window_type() -> bool,
    signals_blocked() -> bool,
    ///     If \a block is true, signals emitted by this object are blocked
    ///     (i.e., emitting a signal will not invoke anything connected to it).
    ///     If \a block is false, no such blocking will occur.
    /// 
    ///     The return value is the previous value of signalsBlocked().
    /// 
    ///     Note that the destroyed() signal will be emitted even if the signals
    ///     for this object have been blocked.
    /// 
    ///     Signals emitted while being blocked are not buffered.
    /// 
    ///     \sa signalsBlocked(), QSignalBlocker
    block_signals(b: bool) -> bool,
    ///     Returns the thread in which the object lives.
    /// 
    ///     \sa moveToThread()
    thread() -> Thread?,
    move_to_thread(thread: *ThreadType),
    ///     Starts a timer and returns a timer identifier, or returns zero if
    ///     it could not start a timer.
    /// 
    ///     A timer event will occur every \a interval milliseconds until
    ///     killTimer() is called. If \a interval is 0, then the timer event
    ///     occurs once every time there are no more window system events to
    ///     process.
    /// 
    ///     The virtual timerEvent() function is called with the QTimerEvent
    ///     event parameter class when a timer event occurs. Reimplement this
    ///     function to get timer events.
    /// 
    ///     If multiple timers are running, the QTimerEvent::timerId() can be
    ///     used to find out which timer was activated.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 8
    /// 
    ///     Note that QTimer's accuracy depends on the underlying operating system and
    ///     hardware. The \a timerType argument allows you to customize the accuracy of
    ///     the timer. See Qt::TimerType for information on the different timer types.
    ///     Most platforms support an accuracy of 20 milliseconds; some provide more.
    ///     If Qt is unable to deliver the requested number of timer events, it will
    ///     silently discard some.
    /// 
    ///     The QTimer class provides a high-level programming interface with
    ///     single-shot timers and timer signals instead of events. There is
    ///     also a QBasicTimer class that is more lightweight than QTimer and
    ///     less clumsy than using timer IDs directly.
    /// 
    ///     \sa timerEvent(), killTimer(), QTimer::singleShot()
    start_timer(interval: i32, timer_type: Rute::TimerType) -> i32,
    ///     Kills the timer with timer identifier, \a id.
    /// 
    ///     The timer identifier is returned by startTimer() when a timer
    ///     event is started.
    /// 
    ///     \sa timerEvent(), startTimer()
    kill_timer(id: i32),
    children() -> ObjectList?,
    ///     Makes the object a child of \a parent.
    /// 
    ///     \sa parent(), children()
    set_parent(parent: *ObjectType),
    ///     \fn void QObject::installEventFilter(QObject *filterObj)
    /// 
    ///     Installs an event filter \a filterObj on this object. For example:
    ///     \snippet code/src_corelib_kernel_qobject.cpp 14
    /// 
    ///     An event filter is an object that receives all events that are
    ///     sent to this object. The filter can either stop the event or
    ///     forward it to this object. The event filter \a filterObj receives
    ///     events via its eventFilter() function. The eventFilter() function
    ///     must return true if the event should be filtered, (i.e. stopped);
    ///     otherwise it must return false.
    /// 
    ///     If multiple event filters are installed on a single object, the
    ///     filter that was installed last is activated first.
    /// 
    ///     Here's a \c KeyPressEater class that eats the key presses of its
    ///     monitored objects:
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 15
    /// 
    ///     And here's how to install it on two widgets:
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 16
    /// 
    ///     The QShortcut class, for example, uses this technique to intercept
    ///     shortcut key presses.
    /// 
    ///     \warning If you delete the receiver object in your eventFilter()
    ///     function, be sure to return true. If you return false, Qt sends
    ///     the event to the deleted object and the program will crash.
    /// 
    ///     Note that the filtering object must be in the same thread as this
    ///     object. If \a filterObj is in a different thread, this function does
    ///     nothing. If either \a filterObj or this object are moved to a different
    ///     thread after calling this function, the event filter will not be
    ///     called until both objects have the same thread affinity again (it
    ///     is \e not removed).
    /// 
    ///     \sa removeEventFilter(), eventFilter(), event()
    install_event_filter(filter_obj: *ObjectType),
    ///     Removes an event filter object \a obj from this object. The
    ///     request is ignored if such an event filter has not been installed.
    /// 
    ///     All event filters for this object are automatically removed when
    ///     this object is destroyed.
    /// 
    ///     It is always safe to remove an event filter, even during event
    ///     filter activation (i.e. from the eventFilter() function).
    /// 
    ///     \sa installEventFilter(), eventFilter(), event()
    remove_event_filter(obj: *ObjectType),
    [static] connect(sender: *ObjectType, signal: *char, receiver: *ObjectType, member: *char, arg0: Rute::ConnectionType) -> MetaObject::Connection,
    [static] connect(sender: *ObjectType, signal: &MetaMethodType, receiver: *ObjectType, method: &MetaMethodType, type: Rute::ConnectionType) -> MetaObject::Connection,
    connect(sender: *ObjectType, signal: *char, member: *char, type: Rute::ConnectionType) -> MetaObject::Connection,
    [static] disconnect(sender: *ObjectType, signal: &MetaMethodType, receiver: *ObjectType, member: &MetaMethodType) -> bool,
    disconnect(signal: *char, receiver: *ObjectType, member: *char) -> bool,
    disconnect(receiver: *ObjectType, member: *char) -> bool,
    [static] disconnect(arg0: onst QMetaObject::Connection &) -> bool,
    ///     Dumps a tree of children to the debug output.
    /// 
    ///     \note before Qt 5.9, this function was not const.
    /// 
    ///     \sa dumpObjectInfo()
    dump_object_tree(),
    ///     Dumps information about signal connections, etc. for this object
    ///     to the debug output.
    /// 
    ///     \note before Qt 5.9, this function was not const.
    /// 
    ///     \sa dumpObjectTree()
    dump_object_info(),
    ///     Dumps a tree of children to the debug output.
    /// 
    ///     \note before Qt 5.9, this function was not const.
    /// 
    ///     \sa dumpObjectInfo()
    dump_object_tree(),
    ///     Dumps information about signal connections, etc. for this object
    ///     to the debug output.
    /// 
    ///     \note before Qt 5.9, this function was not const.
    /// 
    ///     \sa dumpObjectTree()
    dump_object_info(),
    ///   Sets the value of the object's \a name property to \a value.
    /// 
    ///   If the property is defined in the class using Q_PROPERTY then
    ///   true is returned on success and false otherwise. If the property
    ///   is not defined using Q_PROPERTY, and therefore not listed in the
    ///   meta-object, it is added as a dynamic property and false is returned.
    /// 
    ///   Information about all available properties is provided through the
    ///   metaObject() and dynamicPropertyNames().
    /// 
    ///   Dynamic properties can be queried again using property() and can be
    ///   removed by setting the property value to an invalid QVariant.
    ///   Changing the value of a dynamic property causes a QDynamicPropertyChangeEvent
    ///   to be sent to the object.
    /// 
    ///   \b{Note:} Dynamic properties starting with "_q_" are reserved for internal
    ///   purposes.
    /// 
    ///   \sa property(), metaObject(), dynamicPropertyNames(), QMetaProperty::write()
    set_property(name: *char, value: &VariantType) -> bool,
    ///   Returns the value of the object's \a name property.
    /// 
    ///   If no such property exists, the returned variant is invalid.
    /// 
    ///   Information about all available properties is provided through the
    ///   metaObject() and dynamicPropertyNames().
    /// 
    ///   \sa setProperty(), QVariant::isValid(), metaObject(), dynamicPropertyNames()
    property(name: *char) -> Variant,
    ///     \since 4.2
    /// 
    ///     Returns the names of all properties that were dynamically added to
    ///     the object using setProperty().
    dynamic_property_names() -> [ByteArray],
    [static] register_user_data() -> uint,
    set_user_data(id: uint, data: *ObjectUserDataType),
    user_data(id: uint) -> ObjectUserData?,
    [signal] object_name_changed(object_name: String, arg0: Object::QPrivateSignal),
    parent() -> Object?,
    inherits(classname: *char) -> bool,
    ///     Schedules this object for deletion.
    /// 
    ///     The object will be deleted when control returns to the event
    ///     loop. If the event loop is not running when this function is
    ///     called (e.g. deleteLater() is called on an object before
    ///     QCoreApplication::exec()), the object will be deleted once the
    ///     event loop is started. If deleteLater() is called after the main event loop
    ///     has stopped, the object will not be deleted.
    ///     Since Qt 4.8, if deleteLater() is called on an object that lives in a
    ///     thread with no running event loop, the object will be destroyed when the
    ///     thread finishes.
    /// 
    ///     Note that entering and leaving a new event loop (e.g., by opening a modal
    ///     dialog) will \e not perform the deferred deletion; for the object to be
    ///     deleted, the control must return to the event loop from which
    ///     deleteLater() was called.
    /// 
    ///     \b{Note:} It is safe to call this function more than once; when the
    ///     first deferred deletion event is delivered, any pending events for the
    ///     object are removed from the event queue.
    /// 
    ///     \sa destroyed(), QPointer
    delete_later(),
    ///     Returns a pointer to the object that sent the signal, if called in
    ///     a slot activated by a signal; otherwise it returns 0. The pointer
    ///     is valid only during the execution of the slot that calls this
    ///     function from this object's thread context.
    /// 
    ///     The pointer returned by this function becomes invalid if the
    ///     sender is destroyed, or if the slot is disconnected from the
    ///     sender's signal.
    /// 
    ///     \warning This function violates the object-oriented principle of
    ///     modularity. However, getting access to the sender might be useful
    ///     when many signals are connected to a single slot.
    /// 
    ///     \warning As mentioned above, the return value of this function is
    ///     not valid when the slot is called via a Qt::DirectConnection from
    ///     a thread different from this object's thread. Do not use this
    ///     function in this type of scenario.
    /// 
    ///     \sa senderSignalIndex()
    sender() -> Object?,
    ///     \since 4.8
    /// 
    ///     Returns the meta-method index of the signal that called the currently
    ///     executing slot, which is a member of the class returned by sender().
    ///     If called outside of a slot activated by a signal, -1 is returned.
    /// 
    ///     For signals with default parameters, this function will always return
    ///     the index with all parameters, regardless of which was used with
    ///     connect(). For example, the signal \c {destroyed(QObject *obj = 0)}
    ///     will have two different indexes (with and without the parameter), but
    ///     this function will always return the index with a parameter. This does
    ///     not apply when overloading signals with different parameters.
    /// 
    ///     \warning This function violates the object-oriented principle of
    ///     modularity. However, getting access to the signal index might be useful
    ///     when many signals are connected to a single slot.
    /// 
    ///     \warning The return value of this function is not valid when the slot
    ///     is called via a Qt::DirectConnection from a thread different from this
    ///     object's thread. Do not use this function in this type of scenario.
    /// 
    ///     \sa sender(), QMetaObject::indexOfSignal(), QMetaObject::method()
    sender_signal_index() -> i32,
    ///     Returns the number of receivers connected to the \a signal.
    /// 
    ///     Since both slots and signals can be used as receivers for signals,
    ///     and the same connections can be made many times, the number of
    ///     receivers is the same as the number of connections made from this
    ///     signal.
    /// 
    ///     When calling this function, you can use the \c SIGNAL() macro to
    ///     pass a specific signal:
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 21
    /// 
    ///     \warning This function violates the object-oriented principle of
    ///     modularity. However, it might be useful when you need to perform
    ///     expensive initialization only if something is connected to a
    ///     signal.
    /// 
    ///     \sa isSignalConnected()
    receivers(signal: *char) -> i32,
    ///     \since 5.0
    ///     Returns \c true if the \a signal is connected to at least one receiver,
    ///     otherwise returns \c false.
    /// 
    ///     \a signal must be a signal member of this object, otherwise the behaviour
    ///     is undefined.
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 49
    /// 
    ///     As the code snippet above illustrates, you can use this function
    ///     to avoid emitting a signal that nobody listens to.
    /// 
    ///     \warning This function violates the object-oriented principle of
    ///     modularity. However, it might be useful when you need to perform
    ///     expensive initialization only if something is connected to a
    ///     signal.
    is_signal_connected(signal: &MetaMethodType) -> bool,
    ///     \fn void QObject::timerEvent(QTimerEvent *event)
    /// 
    ///     This event handler can be reimplemented in a subclass to receive
    ///     timer events for the object.
    /// 
    ///     QTimer provides a higher-level interface to the timer
    ///     functionality, and also more general information about timers. The
    ///     timer event is passed in the \a event parameter.
    /// 
    ///     \sa startTimer(), killTimer(), event()
    [event] timer_event(event: *TimerEventType),
    ///     This event handler can be reimplemented in a subclass to receive
    ///     child events. The event is passed in the \a event parameter.
    /// 
    ///     QEvent::ChildAdded and QEvent::ChildRemoved events are sent to
    ///     objects when children are added or removed. In both cases you can
    ///     only rely on the child being a QObject, or if isWidgetType()
    ///     returns \c true, a QWidget. (This is because, in the
    ///     \l{QEvent::ChildAdded}{ChildAdded} case, the child is not yet
    ///     fully constructed, and in the \l{QEvent::ChildRemoved}{ChildRemoved}
    ///     case it might have been destructed already).
    /// 
    ///     QEvent::ChildPolished events are sent to widgets when children
    ///     are polished, or when polished children are added. If you receive
    ///     a child polished event, the child's construction is usually
    ///     completed. However, this is not guaranteed, and multiple polish
    ///     events may be delivered during the execution of a widget's
    ///     constructor.
    /// 
    ///     For every child widget, you receive one
    ///     \l{QEvent::ChildAdded}{ChildAdded} event, zero or more
    ///     \l{QEvent::ChildPolished}{ChildPolished} events, and one
    ///     \l{QEvent::ChildRemoved}{ChildRemoved} event.
    /// 
    ///     The \l{QEvent::ChildPolished}{ChildPolished} event is omitted if
    ///     a child is removed immediately after it is added. If a child is
    ///     polished several times during construction and destruction, you
    ///     may receive several child polished events for the same child,
    ///     each time with a different virtual table.
    /// 
    ///     \sa event()
    [event] child_event(event: *ChildEventType),
    ///     This event handler can be reimplemented in a subclass to receive
    ///     custom events. Custom events are user-defined events with a type
    ///     value at least as large as the QEvent::User item of the
    ///     QEvent::Type enum, and is typically a QEvent subclass. The event
    ///     is passed in the \a event parameter.
    /// 
    ///     \sa event(), QEvent
    [event] custom_event(event: *EventType),
    ///     \since 5.0
    /// 
    ///     This virtual function is called when something has been connected
    ///     to \a signal in this object.
    /// 
    ///     If you want to compare \a signal with a specific signal, you can
    ///     use QMetaMethod::fromSignal() as follows:
    /// 
    ///     \snippet code/src_corelib_kernel_qobject.cpp 32
    /// 
    ///     \warning This function violates the object-oriented principle of
    ///     modularity. However, it might be useful when you need to perform
    ///     expensive initialization only if something is connected to a
    ///     signal.
    /// 
    ///     \warning This function is called from the thread which performs the
    ///     connection, which may be a different thread from the thread in
    ///     which this object lives.
    /// 
    ///     \sa connect(), disconnectNotify()
    [event] connect_notify(signal: &MetaMethodType),
    ///     \since 5.0
    /// 
    ///     This virtual function is called when something has been
    ///     disconnected from \a signal in this object.
    /// 
    ///     See connectNotify() for an example of how to compare
    ///     \a signal with a specific signal.
    /// 
    ///     If all signals were disconnected from this object (e.g., the
    ///     signal argument to disconnect() was 0), disconnectNotify()
    ///     is only called once, and the \a signal will be an invalid
    ///     QMetaMethod (QMetaMethod::isValid() returns \c false).
    /// 
    ///     \warning This function violates the object-oriented principle of
    ///     modularity. However, it might be useful for optimizing access to
    ///     expensive resources.
    /// 
    ///     \warning This function is called from the thread which performs the
    ///     disconnection, which may be a different thread from the thread in
    ///     which this object lives. This function may also be called with a QObject
    ///     internal mutex locked. It is therefore not allowed to re-enter any
    ///     of any QObject functions from your reimplementation and if you lock
    ///     a mutex in your reimplementation, make sure that you don't call QObject
    ///     functions with that mutex held in other places or it will result in
    ///     a deadlock.
    /// 
    ///     \sa disconnect(), connectNotify()
    [event] disconnect_notify(signal: &MetaMethodType),
}

// vim: syntax=rust expandtab ts=4 sw=4
