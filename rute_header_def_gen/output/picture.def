///     \class QPicture
///     \brief The QPicture class is a paint device that records and
///     replays QPainter commands.
/// 
///     \inmodule QtGui
///     \ingroup shared
/// 
/// 
///     A picture serializes painter commands to an IO device in a
///     platform-independent format. They are sometimes referred to as meta-files.
/// 
///     Qt pictures use a proprietary binary format. Unlike native picture
///     (meta-file) formats on many window systems, Qt pictures have no
///     limitations regarding their contents. Everything that can be
///     painted on a widget or pixmap (e.g., fonts, pixmaps, regions,
///     transformed graphics, etc.)  can also be stored in a picture.
/// 
///     QPicture is resolution independent, i.e. a QPicture can be
///     displayed on different devices (for example svg, pdf, ps, printer
///     and screen) looking the same. This is, for instance, needed for
///     WYSIWYG print preview. QPicture runs in the default system dpi,
///     and scales the painter to match differences in resolution
///     depending on the window system.
/// 
///     Example of how to record a picture:
///     \snippet picture/picture.cpp 0
/// 
///     Note that the list of painter commands is reset on each call to
///     the QPainter::begin() function.
/// 
///     Example of how to replay a picture:
///     \snippet picture/picture.cpp 1
/// 
///     Pictures can also be drawn using play(). Some basic data about a
///     picture is available, for example, size(), isNull() and
///     boundingRect().
/// 
///     \sa QMovie
struct Picture : PaintDevice {
    ///     \fn const char* QPicture::data() const
    /// 
    ///     Returns a pointer to the picture data. The pointer is only valid
    ///     until the next non-const function is called on this picture. The
    ///     returned pointer is 0 if the picture contains no data.
    /// 
    ///     \sa size(), isNull()
    is_null() -> bool,
    ///   \internal
    [event] dev_type() -> i32,
    size() -> uint,
    data() -> char?,
    ///     Sets the picture data directly from \a data and \a size. This
    ///     function copies the input data.
    /// 
    ///     \sa data(), size()
    [event] set_data(data: *char, size: uint),
    ///     Replays the picture using \a painter, and returns \c true if
    ///     successful; otherwise returns \c false.
    /// 
    ///     This function does exactly the same as QPainter::drawPicture()
    ///     with (x, y) = (0, 0).
    play(p: *PainterType) -> bool,
    ///     \overload
    /// 
    ///     \a dev is the device to use for loading.
    load(dev: *IODeviceType, format: *char) -> bool,
    ///     \overload
    /// 
    ///     \a dev is the device to use for loading.
    load(file_name: String, format: *char) -> bool,
    ///     \overload
    /// 
    ///     \a dev is the device to use for saving.
    save(dev: *IODeviceType, format: *char) -> bool,
    ///     \overload
    /// 
    ///     \a dev is the device to use for saving.
    save(file_name: String, format: *char) -> bool,
    ///     Returns the picture's bounding rectangle or an invalid rectangle
    ///     if the picture contains no data.
    bounding_rect() -> Rect,
    ///     Sets the picture's bounding rectangle to \a r. The automatically
    ///     calculated value is overridden.
    set_bounding_rect(r: &RectType),
    swap(other: &PictureType),
    detach(),
    ///     \fn void QPicture::detach()
    ///     \internal
    ///     Detaches from shared picture data and makes sure that this picture
    ///     is the only one referring to the data.
    /// 
    ///     If multiple pictures share common data, this picture makes a copy
    ///     of the data and detaches itself from the sharing mechanism.
    ///     Nothing is done if there is just a single reference.
    is_detached() -> bool,
    ///     \obsolete
    /// 
    ///     Returns a string that specifies the picture format of the file \a
    ///     fileName, or 0 if the file cannot be read or if the format is not
    ///     recognized.
    /// 
    ///     \sa load(), save()
    [static] picture_format(file_name: String) -> char?,
    ///     \obsolete
    /// 
    ///     Returns a list of picture formats that are supported for picture
    ///     input.
    /// 
    ///     \sa outputFormats(), inputFormatList(), QPictureIO
    [static] input_formats() -> [ByteArray],
    ///     \obsolete
    /// 
    ///     Returns a list of picture formats that are supported for picture
    ///     output.
    /// 
    ///     \sa inputFormats(), outputFormatList(), QPictureIO
    [static] output_formats() -> [ByteArray],
    ///     \obsolete
    /// 
    ///     Returns a list of picture formats that are supported for picture
    ///     input.
    /// 
    ///     Note that if you want to iterate over the list, you should iterate
    ///     over a copy, e.g.
    ///     \snippet picture/picture.cpp 2
    /// 
    ///     \sa outputFormatList(), inputFormats(), QPictureIO
    [static] input_format_list() -> [String],
    ///     \obsolete
    /// 
    ///     Returns a list of picture formats that are supported for picture
    ///     output.
    /// 
    ///     Note that if you want to iterate over the list, you should iterate
    ///     over a copy, e.g.
    ///     \snippet picture/picture.cpp 3
    /// 
    ///     \sa inputFormatList(), outputFormats(), QPictureIO
    [static] output_format_list() -> [String],
    [event] paint_engine() -> PaintEngine?,
}

// vim: syntax=rust expandtab ts=4 sw=4
