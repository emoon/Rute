///     \class QMdiArea
///     \brief The QMdiArea widget provides an area in which MDI windows are displayed.
///     \since 4.3
///     \ingroup mainwindow-classes
///     \inmodule QtWidgets
/// 
///     QMdiArea functions, essentially, like a window manager for MDI
///     windows. For instance, it draws the windows it manages on itself
///     and arranges them in a cascading or tile pattern. QMdiArea is
///     commonly used as the center widget in a QMainWindow to create MDI
///     applications, but can also be placed in any layout. The following
///     code adds an area to a main window:
/// 
///     \snippet mdiareasnippets.cpp 0
/// 
///     Unlike the window managers for top-level windows, all window flags
///     (Qt::WindowFlags) are supported by QMdiArea as long as the flags
///     are supported by the current widget style. If a specific flag is
///     not supported by the style (e.g., the
///     \l{Qt::}{WindowShadeButtonHint}), you can still shade the window
///     with showShaded().
/// 
///     Subwindows in QMdiArea are instances of QMdiSubWindow. They
///     are added to an MDI area with addSubWindow(). It is common to pass
///     a QWidget, which is set as the internal widget, to this function,
///     but it is also possible to pass a QMdiSubWindow directly.The class
///     inherits QWidget, and you can use the same API as with a normal
///     top-level window when programming. QMdiSubWindow also has behavior
///     that is specific to MDI windows. See the QMdiSubWindow class
///     description for more details.
/// 
///     A subwindow becomes active when it gets the keyboard focus, or
///     when setFocus() is called. The user activates a window by moving
///     focus in the usual ways. The MDI area emits the
///     subWindowActivated() signal when the active window changes, and
///     the activeSubWindow() function returns the active subwindow.
/// 
///     The convenience function subWindowList() returns a list of all
///     subwindows. This information could be used in a popup menu
///     containing a list of windows, for example.
/// 
///     The subwindows are sorted by the current
///     \l{QMdiArea::}{WindowOrder}. This is used for the subWindowList()
///     and for activateNextSubWindow() and activatePreviousSubWindow().
///     Also, it is used when cascading or tiling the windows with
///     cascadeSubWindows() and tileSubWindows().
/// 
///     QMdiArea provides two built-in layout strategies for
///     subwindows: cascadeSubWindows() and tileSubWindows(). Both are
///     slots and are easily connected to menu entries.
/// 
///     \table
///     \row \li \inlineimage mdi-cascade.png
///          \li \inlineimage mdi-tile.png
///     \endtable
/// 
///     \note The default scroll bar property for QMdiArea is Qt::ScrollBarAlwaysOff.
/// 
///     \sa QMdiSubWindow
[org_name(QMdiArea)]
enum AreaOption {
    DontMaximizeSubWindowOnActivation,
}

[org_name(QMdiArea)]
enum WindowOrder {
    CreationOrder,
    StackingOrder,
    ActivationHistoryOrder,
}

[org_name(QMdiArea)]
enum ViewMode {
    SubWindowView,
    TabbedView,
}

struct MdiArea : AbstractScrollArea {
    [event] size_hint() -> Size,
    [event] minimum_size_hint() -> Size,
    current_sub_window() -> MdiSubWindow?,
    active_sub_window() -> MdiSubWindow?,
    sub_window_list(order: MdiArea::WindowOrder) -> [MdiSubWindow?],
    add_sub_window(widget: *WidgetType, flags: Rute::WindowFlags) -> MdiSubWindow?,
    remove_sub_window(widget: *WidgetType),
    background() -> Brush,
    set_background(background: &BrushType),
    activation_order() -> MdiArea::WindowOrder,
    set_activation_order(order: MdiArea::WindowOrder),
    set_option(option: MdiArea::AreaOption, on: bool),
    test_option(opton: MdiArea::AreaOption) -> bool,
    set_view_mode(mode: MdiArea::ViewMode),
    view_mode() -> MdiArea::ViewMode,
    document_mode() -> bool,
    set_document_mode(enabled: bool),
    set_tabs_closable(closable: bool),
    tabs_closable() -> bool,
    set_tabs_movable(movable: bool),
    tabs_movable() -> bool,
    set_tab_shape(shape: TabWidget::TabShape),
    tab_shape() -> TabWidget::TabShape,
    set_tab_position(position: TabWidget::TabPosition),
    tab_position() -> TabWidget::TabPosition,
    [signal] sub_window_activated(arg0: *MdiSubWindowType),
    set_active_sub_window(window: *MdiSubWindowType),
    tile_sub_windows(),
    cascade_sub_windows(),
    close_active_sub_window(),
    close_all_sub_windows(),
    activate_next_sub_window(),
    activate_previous_sub_window(),
    [event] setup_viewport(viewport: *WidgetType),
    [event] event(event: *EventType) -> bool,
    [event] event_filter(object: *ObjectType, event: *EventType) -> bool,
    [event] paint_event(paint_event: *PaintEventType),
    [event] child_event(child_event: *ChildEventType),
    [event] resize_event(resize_event: *ResizeEventType),
    [event] timer_event(timer_event: *TimerEventType),
    [event] show_event(show_event: *ShowEventType),
    [event] viewport_event(event: *EventType) -> bool,
    [event] scroll_contents_by(dx: i32, dy: i32),
}

// vim: syntax=rust expandtab ts=4 sw=4
