///     \class QSplitter
///     \brief The QSplitter class implements a splitter widget.
/// 
///     \ingroup organizers
///     \inmodule QtWidgets
/// 
/// 
///     A splitter lets the user control the size of child widgets by dragging the
///     boundary between them. Any number of widgets may be controlled by a
///     single splitter. The typical use of a QSplitter is to create several
///     widgets and add them using insertWidget() or addWidget().
/// 
///     The following example will show a QListView, QTreeView, and
///     QTextEdit side by side, with two splitter handles:
/// 
///     \snippet splitter/splitter.cpp 0
/// 
///     If a widget is already inside a QSplitter when insertWidget() or
///     addWidget() is called, it will move to the new position. This can be used
///     to reorder widgets in the splitter later. You can use indexOf(),
///     widget(), and count() to get access to the widgets inside the splitter.
/// 
///     A default QSplitter lays out its children horizontally (side by side); you
///     can use setOrientation(Qt::Vertical) to lay its
///     children out vertically.
/// 
///     By default, all widgets can be as large or as small as the user
///     wishes, between the \l minimumSizeHint() (or \l minimumSize())
///     and \l maximumSize() of the widgets.
/// 
///     QSplitter resizes its children dynamically by default. If you
///     would rather have QSplitter resize the children only at the end of
///     a resize operation, call setOpaqueResize(false).
/// 
///     The initial distribution of size between the widgets is determined by
///     multiplying the initial size with the stretch factor.
///     You can also use setSizes() to set the sizes
///     of all the widgets. The function sizes() returns the sizes set by the user.
///     Alternatively, you can save and restore the sizes of the widgets from a
///     QByteArray using saveState() and restoreState() respectively.
/// 
///     When you hide() a child, its space will be distributed among the
///     other children. It will be reinstated when you show() it again.
/// 
///     \note Adding a QLayout to a QSplitter is not supported (either through
///     setLayout() or making the QSplitter a parent of the QLayout); use addWidget()
///     instead (see example above).
/// 
///     \sa QSplitterHandle, QHBoxLayout, QVBoxLayout, QTabWidget
struct Splitter : Frame {
    add_widget(widget: *WidgetType),
    insert_widget(index: i32, widget: *WidgetType),
    replace_widget(index: i32, widget: *WidgetType) -> Widget?,
    set_orientation(arg0: Rute::Orientation),
    orientation() -> Rute::Orientation,
    set_children_collapsible(arg0: bool),
    children_collapsible() -> bool,
    set_collapsible(index: i32, arg0: bool),
    is_collapsible(index: i32) -> bool,
    set_opaque_resize(opaque: bool),
    opaque_resize() -> bool,
    refresh(),
    [event] size_hint() -> Size,
    [event] minimum_size_hint() -> Size,
    sizes() -> [i32],
    set_sizes(list: [i32]),
    save_state() -> ByteArray,
    restore_state(state: &ByteArrayType) -> bool,
    handle_width() -> i32,
    set_handle_width(arg0: i32),
    index_of(w: *WidgetType) -> i32,
    widget(index: i32) -> Widget?,
    count() -> i32,
    get_range(index: i32, arg0: *i32, arg1: *i32),
    handle(index: i32) -> SplitterHandle?,
    [signal] splitter_moved(pos: i32, index: i32),
    [event] create_handle() -> SplitterHandle?,
    [event] child_event(arg0: *ChildEventType),
    [event] event(arg0: *EventType) -> bool,
    [event] resize_event(arg0: *ResizeEventType),
    [event] change_event(arg0: *EventType),
    move_splitter(pos: i32, index: i32),
    set_rubber_band(position: i32),
    closest_legal_position(arg0: i32, arg1: i32) -> i32,
}

// vim: syntax=rust expandtab ts=4 sw=4
