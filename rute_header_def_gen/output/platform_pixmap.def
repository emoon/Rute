///     \class QPlatformPixmap
///     \since 5.0
///     \internal
///     \preliminary
///     \ingroup qpa
/// 
///     \brief The QPlatformPixmap class provides an abstraction for native pixmaps.
///  */
/// QPlatformPixmap *QPlatformPixmap::create(int w, int h, PixelType type)
/// {
///     if (Q_UNLIKELY(!QGuiApplicationPrivate::platformIntegration()))
///         qFatal("QPlatformPixmap: QGuiApplication required");
/// 
///     QPlatformPixmap *data = QGuiApplicationPrivate::platformIntegration()->createPlatformPixmap(static_cast<QPlatformPixmap::PixelType>(type));
///     data->resize(w, h);
///     return data;
/// }
/// 
/// 
/// QPlatformPixmap::QPlatformPixmap(PixelType pixelType, int objectId)
///     : w(0),
///       h(0),
///       d(0),
///       is_null(true),
///       ref(0),
///       detach_no(0),
///       type(pixelType),
///       id(objectId),
///       ser_no(0),
///       is_cached(false)
/// {
/// }
/// 
/// QPlatformPixmap::~QPlatformPixmap()
/// {
///     // Sometimes the pixmap cleanup hooks will be called from derrived classes, which will
///     // then set is_cached to false. For example, on X11 Qt GUI needs to delete the GLXPixmap
///     // or EGL Pixmap Surface for a given pixmap _before_ the native X11 pixmap is deleted,
///     // otherwise some drivers will leak the GL surface. In this case, QX11PlatformPixmap will
///     // call the cleanup hooks itself before deleting the native pixmap and set is_cached to
///     // false.
///     if (is_cached) {
///         QImagePixmapCleanupHooks::executePlatformPixmapDestructionHooks(this);
///         is_cached = false;
///     }
/// }
/// 
/// QPlatformPixmap *QPlatformPixmap::createCompatiblePlatformPixmap() const
/// {
///     QPlatformPixmap *d = QGuiApplicationPrivate::platformIntegration()->createPlatformPixmap(pixelType());
///     return d;
/// }
/// 
/// static QImage makeBitmapCompliantIfNeeded(QPlatformPixmap *d, const QImage &image, Qt::ImageConversionFlags flags)
/// {
///     if (d->pixelType() == QPlatformPixmap::BitmapType) {
///         QImage img = image.convertToFormat(QImage::Format_MonoLSB, flags);
/// 
///         // make sure image.color(0) == Qt::color0 (white)
///         // and image.color(1) == Qt::color1 (black)
///         const QRgb c0 = QColor(Qt::black).rgb();
///         const QRgb c1 = QColor(Qt::white).rgb();
///         if (img.color(0) == c0 && img.color(1) == c1) {
///             img.invertPixels();
///             img.setColor(0, c1);
///             img.setColor(1, c0);
///         }
///         return img;
///     }
/// 
///     return image;
/// }
/// 
/// void QPlatformPixmap::fromImageReader(QImageReader *imageReader,
///                                   Qt::ImageConversionFlags flags)
/// {
///     const QImage image = imageReader->read();
///     fromImage(image, flags);
/// }
/// 
/// bool QPlatformPixmap::fromFile(const QString &fileName, const char *format,
///                            Qt::ImageConversionFlags flags)
/// {
///     QImage image = QImageReader(fileName, format).read();
///     if (image.isNull())
///         return false;
///     fromImage(makeBitmapCompliantIfNeeded(this, image, flags), flags);
///     return !isNull();
/// }
/// 
/// bool QPlatformPixmap::fromData(const uchar *buf, uint len, const char *format, Qt::ImageConversionFlags flags)
/// {
///     QByteArray a = QByteArray::fromRawData(reinterpret_cast<const char *>(buf), len);
///     QBuffer b(&a);
///     b.open(QIODevice::ReadOnly);
///     QImage image = QImageReader(&b, format).read();
///     if (image.isNull())
///         return false;
///     fromImage(makeBitmapCompliantIfNeeded(this, image, flags), flags);
///     return !isNull();
/// }
/// 
/// void QPlatformPixmap::copy(const QPlatformPixmap *data, const QRect &rect)
/// {
///     fromImage(data->toImage(rect), Qt::NoOpaqueDetection);
/// }
/// 
/// bool QPlatformPixmap::scroll(int dx, int dy, const QRect &rect)
/// {
///     Q_UNUSED(dx);
///     Q_UNUSED(dy);
///     Q_UNUSED(rect);
///     return false;
/// }
/// 
/// QBitmap QPlatformPixmap::mask() const
/// {
///     if (!hasAlphaChannel())
///         return QBitmap();
/// 
///     const QImage img = toImage();
///     bool shouldConvert = (img.format() != QImage::Format_ARGB32 && img.format() != QImage::Format_ARGB32_Premultiplied);
///     const QImage image = (shouldConvert ? img.convertToFormat(QImage::Format_ARGB32_Premultiplied) : img);
///     const int w = image.width();
///     const int h = image.height();
/// 
///     QImage mask(w, h, QImage::Format_MonoLSB);
///     if (mask.isNull()) // allocation failed
///         return QBitmap();
/// 
///     mask.setColorCount(2);
///     mask.setColor(0, QColor(Qt::color0).rgba());
///     mask.setColor(1, QColor(Qt::color1).rgba());
/// 
///     const int bpl = mask.bytesPerLine();
/// 
///     for (int y = 0; y < h; ++y) {
///         const QRgb *src = reinterpret_cast<const QRgb*>(image.scanLine(y));
///         uchar *dest = mask.scanLine(y);
///         memset(dest, 0, bpl);
///         for (int x = 0; x < w; ++x) {
///             if (qAlpha(*src) > 0)
///                 dest[x >> 3] |= (1 << (x & 7));
///             ++src;
///         }
///     }
/// 
///     return QBitmap::fromImage(mask);
/// }
/// 
/// void QPlatformPixmap::setMask(const QBitmap &mask)
/// {
///     QImage image = toImage();
///     if (mask.size().isEmpty()) {
///         if (image.depth() != 1) { // hw: ????
///             image = image.convertToFormat(QImage::Format_RGB32);
///         }
///     } else {
///         const int w = image.width();
///         const int h = image.height();
/// 
///         switch (image.depth()) {
///         case 1: {
///             const QImage imageMask = mask.toImage().convertToFormat(image.format());
///             for (int y = 0; y < h; ++y) {
///                 const uchar *mscan = imageMask.scanLine(y);
///                 uchar *tscan = image.scanLine(y);
///                 int bytesPerLine = image.bytesPerLine();
///                 for (int i = 0; i < bytesPerLine; ++i)
///                     tscan[i] &= mscan[i];
///             }
///             break;
///         }
///         default: {
///             const QImage imageMask = mask.toImage().convertToFormat(QImage::Format_MonoLSB);
///             image = image.convertToFormat(QImage::Format_ARGB32_Premultiplied);
///             for (int y = 0; y < h; ++y) {
///                 const uchar *mscan = imageMask.scanLine(y);
///                 QRgb *tscan = (QRgb *)image.scanLine(y);
///                 for (int x = 0; x < w; ++x) {
///                     if (!(mscan[x>>3] & (1 << (x&7))))
///                         tscan[x] = 0;
///                 }
///             }
///             break;
///         }
///         }
///     }
///     fromImage(image, Qt::AutoColor);
/// }
/// 
/// QPixmap QPlatformPixmap::transformed(const QTransform &matrix,
///                                      Qt::TransformationMode mode) const
/// {
///     return QPixmap::fromImage(toImage().transformed(matrix, mode));
/// }
/// 
/// void QPlatformPixmap::setSerialNumber(int serNo)
/// {
///     ser_no = serNo;
/// }
/// 
/// void QPlatformPixmap::setDetachNumber(int detNo)
/// {
///     detach_no = detNo;
/// }
/// 
/// QImage QPlatformPixmap::toImage(const QRect &rect) const
/// {
///     if (rect.contains(QRect(0, 0, w, h)))
///         return toImage();
///     else
///         return toImage().copy(rect);
/// }
/// 
/// QImage* QPlatformPixmap::buffer()
/// {
///     return 0;
/// }
/// 
/// 
/// QT_END_NAMESPACE
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QPlatformPixmap)]
enum PixelType {
    PixmapType,
    BitmapType,
}

[org_name(QPlatformPixmap)]
enum ClassId {
    RasterClass,
    DirectFBClass,
    BlitterClass,
    Direct2DClass,
    X11Class,
    CustomClass,
}


struct PlatformPixmap {
    [event] create_compatible_platform_pixmap() -> PlatformPixmap?,
    [event] resize(width: i32, height: i32),
    [event] from_image(image: &ImageType, flags: Rute::ImageConversionFlags),
    [event] from_image_in_place(image: &ImageType, flags: Rute::ImageConversionFlags),
    [event] from_image_reader(image_reader: *ImageReaderType, flags: Rute::ImageConversionFlags),
    [event] from_file(filename: String, format: *char, flags: Rute::ImageConversionFlags) -> bool,
    [event] from_data(buffer: *uchar, len: uint, format: *char, flags: Rute::ImageConversionFlags) -> bool,
    [event] copy(data: *PlatformPixmapType, rect: &RectType),
    [event] scroll(dx: i32, dy: i32, rect: &RectType) -> bool,
    [event] fill(color: &ColorType),
    [event] mask() -> Bitmap,
    [event] set_mask(mask: &BitmapType),
    [event] has_alpha_channel() -> bool,
    [event] to_image() -> Image,
    [event] to_image(rect: &RectType) -> Image,
    [event] paint_engine() -> PaintEngine?,
    serial_number() -> i32,
    pixel_type() -> PlatformPixmap::PixelType,
    class_id() -> PlatformPixmap::ClassId,
    [event] device_pixel_ratio() -> f32,
    [event] set_device_pixel_ratio(scale_factor: f32),
    [event] buffer() -> Image?,
    width() -> i32,
    height() -> i32,
    color_count() -> i32,
    depth() -> i32,
    is_null() -> bool,
    cache_key() -> i64,
    [static] create(w: i32, h: i32, type: PlatformPixmap::PixelType) -> PlatformPixmap?,
    set_serial_number(ser_no: i32),
    set_detach_number(det_no: i32),
}

// vim: syntax=rust expandtab ts=4 sw=4
