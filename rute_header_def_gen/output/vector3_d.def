///     \class QVector3D
///     \brief The QVector3D class represents a vector or vertex in 3D space.
///     \since 4.6
///     \ingroup painting-3D
///     \inmodule QtGui
/// 
///     Vectors are one of the main building blocks of 3D representation and
///     drawing.  They consist of three coordinates, traditionally called
///     x, y, and z.
/// 
///     The QVector3D class can also be used to represent vertices in 3D space.
///     We therefore do not need to provide a separate vertex class.
/// 
///     \sa QVector2D, QVector4D, QQuaternion
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.

struct Vector3D {
    is_null() -> bool,
    x() -> f32,
    y() -> f32,
    z() -> f32,
    set_x(x: f32),
    set_y(y: f32),
    set_z(z: f32),
    ///     Returns the length of the vector from the origin.
    /// 
    ///     \sa lengthSquared(), normalized()
    length() -> f32,
    ///     Returns the squared length of the vector from the origin.
    ///     This is equivalent to the dot product of the vector with itself.
    /// 
    ///     \sa length(), dotProduct()
    length_squared() -> f32,
    ///     Returns the normalized unit vector form of this vector.
    /// 
    ///     If this vector is null, then a null vector is returned.  If the length
    ///     of the vector is very close to 1, then the vector will be returned as-is.
    ///     Otherwise the normalized form of the vector of length 1 will be returned.
    /// 
    ///     \sa length(), normalize()
    normalized() -> Vector3D,
    ///     Normalizes the currect vector in place.  Nothing happens if this
    ///     vector is a null vector or the length of the vector is very close to 1.
    /// 
    ///     \sa length(), normalized()
    normalize(),
    ///     Returns the dot product of \a v1 and \a v2.
    [static] dot_product(v1: &Vector3DType, v2: &Vector3DType) -> f32,
    ///     Returns the cross-product of vectors \a v1 and \a v2, which corresponds
    ///     to the normal vector of a plane defined by \a v1 and \a v2.
    /// 
    ///     \sa normal()
    [static] cross_product(v1: &Vector3DType, v2: &Vector3DType) -> Vector3D,
    ///     Returns the normal vector of a plane defined by vectors \a v1 and \a v2,
    ///     normalized to be a unit vector.
    /// 
    ///     Use crossProduct() to compute the cross-product of \a v1 and \a v2 if you
    ///     do not need the result to be normalized to a unit vector.
    /// 
    ///     \sa crossProduct(), distanceToPlane()
    [static] normal(v1: &Vector3DType, v2: &Vector3DType) -> Vector3D,
    ///     Returns the normal vector of a plane defined by vectors \a v1 and \a v2,
    ///     normalized to be a unit vector.
    /// 
    ///     Use crossProduct() to compute the cross-product of \a v1 and \a v2 if you
    ///     do not need the result to be normalized to a unit vector.
    /// 
    ///     \sa crossProduct(), distanceToPlane()
    [static] normal(v1: &Vector3DType, v2: &Vector3DType, v3: &Vector3DType) -> Vector3D,
    project(model_view: &Matrix4x4Type, projection: &Matrix4x4Type, viewport: &RectType) -> Vector3D,
    unproject(model_view: &Matrix4x4Type, projection: &Matrix4x4Type, viewport: &RectType) -> Vector3D,
    ///     \since 5.1
    /// 
    ///     Returns the distance from this vertex to a point defined by
    ///     the vertex \a point.
    /// 
    ///     \sa distanceToPlane(), distanceToLine()
    distance_to_point(point: &Vector3DType) -> f32,
    distance_to_plane(plane: &Vector3DType, normal: &Vector3DType) -> f32,
    distance_to_plane(plane1: &Vector3DType, plane2: &Vector3DType, plane3: &Vector3DType) -> f32,
    distance_to_line(point: &Vector3DType, direction: &Vector3DType) -> f32,
    ///     Returns the 2D vector form of this 3D vector, dropping the z coordinate.
    /// 
    ///     \sa toVector4D(), toPoint()
    to_vector2_d() -> Vector2D,
    ///     Returns the 4D form of this 3D vector, with the w coordinate set to zero.
    /// 
    ///     \sa toVector2D(), toPoint()
    to_vector4_d() -> Vector4D,
    to_point() -> Point,
    to_point_f() -> PointF,
}

// vim: syntax=rust expandtab ts=4 sw=4
