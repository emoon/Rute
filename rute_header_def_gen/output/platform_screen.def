[org_name(QPlatformScreen)]
enum SubpixelAntialiasingType {
    Subpixel_None,
    Subpixel_RGB,
    Subpixel_BGR,
    Subpixel_VRGB,
    Subpixel_VBGR,
}

[org_name(QPlatformScreen)]
enum PowerState {
    PowerStateOn,
    PowerStateStandby,
    PowerStateSuspend,
    PowerStateOff,
}


struct PlatformScreen {
    [event] grab_window(window: WId, x: i32, y: i32, width: i32, height: i32) -> Pixmap,
    [event] depth() -> i32,
    [event] format() -> Image::Format,
    [event] physical_size() -> SizeF,
    [event] logical_dpi() -> Dpi,
    [event] device_pixel_ratio() -> f32,
    [event] pixel_density() -> f32,
    [event] refresh_rate() -> f32,
    [event] native_orientation() -> Rute::ScreenOrientation,
    [event] orientation() -> Rute::ScreenOrientation,
    [event] set_orientation_update_mask(mask: Rute::ScreenOrientations),
    [event] top_level_at(point: &PointType) -> Window?,
    windows() -> WindowList,
    [event] virtual_siblings() -> [PlatformScreen?],
    screen_for_position(point: &PointType) -> PlatformScreen?,
    screen() -> Screen?,
    [static] platform_screen_for_window(window: *WindowType) -> PlatformScreen?,
    [event] name() -> String,
    [event] manufacturer() -> String,
    [event] model() -> String,
    [event] serial_number() -> String,
    [event] cursor() -> PlatformCursor?,
    [event] subpixel_antialiasing_type_hint() -> PlatformScreen::SubpixelAntialiasingType,
    [event] power_state() -> PlatformScreen::PowerState,
    [event] set_power_state(state: PlatformScreen::PowerState),
    [event] modes() -> Vector<QPlatformScreen::Mode>,
    [event] current_mode() -> i32,
    [event] preferred_mode() -> i32,
    [static] angle_between(a: Rute::ScreenOrientation, b: Rute::ScreenOrientation) -> i32,
    [static] map_between(a: Rute::ScreenOrientation, b: Rute::ScreenOrientation, rect: &RectType) -> Rect,
    resize_maximized_windows(),
}

// vim: syntax=rust expandtab ts=4 sw=4
