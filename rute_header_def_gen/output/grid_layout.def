///     \class QGridLayout
/// 
///     \brief The QGridLayout class lays out widgets in a grid.
/// 
///     \ingroup geomanagement
///     \inmodule QtWidgets
/// 
///     QGridLayout takes the space made available to it (by its parent
///     layout or by the parentWidget()), divides it up into rows and
///     columns, and puts each widget it manages into the correct cell.
/// 
///     Columns and rows behave identically; we will discuss columns, but
///     there are equivalent functions for rows.
/// 
///     Each column has a minimum width and a stretch factor. The minimum
///     width is the greatest of that set using setColumnMinimumWidth() and the
///     minimum width of each widget in that column. The stretch factor is
///     set using setColumnStretch() and determines how much of the available
///     space the column will get over and above its necessary minimum.
/// 
///     Normally, each managed widget or layout is put into a cell of its
///     own using addWidget(). It is also possible for a widget to occupy
///     multiple cells using the row and column spanning overloads of
///     addItem() and addWidget(). If you do this, QGridLayout will guess
///     how to distribute the size over the columns/rows (based on the
///     stretch factors).
/// 
///     To remove a widget from a layout, call removeWidget(). Calling
///     QWidget::hide() on a widget also effectively removes the widget
///     from the layout until QWidget::show() is called.
/// 
///     This illustration shows a fragment of a dialog with a five-column,
///     three-row grid (the grid is shown overlaid in magenta):
/// 
///     \image gridlayout.png A grid layout
/// 
///     Columns 0, 2 and 4 in this dialog fragment are made up of a
///     QLabel, a QLineEdit, and a QListBox. Columns 1 and 3 are
///     placeholders made with setColumnMinimumWidth(). Row 0 consists of three
///     QLabel objects, row 1 of three QLineEdit objects and row 2 of
///     three QListBox objects. We used placeholder columns (1 and 3) to
///     get the right amount of space between the columns.
/// 
///     Note that the columns and rows are not equally wide or tall. If
///     you want two columns to have the same width, you must set their
///     minimum widths and stretch factors to be the same yourself. You do
///     this using setColumnMinimumWidth() and setColumnStretch().
/// 
///     If the QGridLayout is not the top-level layout (i.e. does not
///     manage all of the widget's area and children), you must add it to
///     its parent layout when you create it, but before you do anything
///     with it. The normal way to add a layout is by calling
///     addLayout() on the parent layout.
/// 
///     Once you have added your layout you can start putting widgets and
///     other layouts into the cells of your grid layout using
///     addWidget(), addItem(), and addLayout().
/// 
///     QGridLayout also includes two margin widths:
///     the \l{getContentsMargins()}{contents margin} and the spacing().
///     The contents margin is the width of the reserved space along each
///     of the QGridLayout's four sides. The spacing() is the width of the
///     automatically allocated spacing between neighboring boxes.
/// 
///     The default contents margin values are provided by the
///     \l{QStyle::pixelMetric()}{style}. The default value Qt styles specify
///     is 9 for child widgets and 11 for windows. The spacing defaults to the same as
///     the margin width for a top-level layout, or to the same as the
///     parent layout.
/// 
///     \sa QBoxLayout, QStackedLayout, {Layout Management}, {Basic Layouts Example}
struct GridLayout : Layout {
    ///     \reimp
    [event] size_hint() -> Size,
    ///     \reimp
    [event] minimum_size() -> Size,
    ///     \reimp
    [event] maximum_size() -> Size,
    ///     \property QGridLayout::horizontalSpacing
    ///     \brief the spacing between widgets that are laid out side by side
    ///     \since 4.3
    /// 
    ///     If no value is explicitly set, the layout's horizontal spacing is
    ///     inherited from the parent layout, or from the style settings for
    ///     the parent widget.
    /// 
    ///     \sa verticalSpacing, QStyle::pixelMetric(), {QStyle::}{PM_LayoutHorizontalSpacing}
    set_horizontal_spacing(spacing: i32),
    horizontal_spacing() -> i32,
    ///     \property QGridLayout::verticalSpacing
    ///     \brief the spacing between widgets that are laid out on top of each other
    ///     \since 4.3
    /// 
    ///     If no value is explicitly set, the layout's vertical spacing is
    ///     inherited from the parent layout, or from the style settings for
    ///     the parent widget.
    /// 
    ///     \sa horizontalSpacing, QStyle::pixelMetric(), {QStyle::}{PM_LayoutHorizontalSpacing}
    set_vertical_spacing(spacing: i32),
    vertical_spacing() -> i32,
    ///     This function sets both the vertical and horizontal spacing to
    ///     \a spacing.
    /// 
    ///     \sa setVerticalSpacing(), setHorizontalSpacing()
    set_spacing(spacing: i32),
    ///     If the vertical spacing is equal to the horizontal spacing,
    ///     this function returns that value; otherwise it return -1.
    /// 
    ///     \sa setSpacing(), verticalSpacing(), horizontalSpacing()
    spacing() -> i32,
    ///     Sets the minimum height of row \a row to \a minSize pixels.
    /// 
    ///     \sa rowMinimumHeight(), setColumnMinimumWidth()
    set_row_minimum_height(row: i32, min_size: i32),
    ///     Sets the minimum width of column \a column to \a minSize pixels.
    /// 
    ///     \sa columnMinimumWidth(), setRowMinimumHeight()
    set_column_minimum_width(column: i32, min_size: i32),
    ///     Returns the minimum width set for row \a row.
    /// 
    ///     \sa setRowMinimumHeight()
    row_minimum_height(row: i32) -> i32,
    ///     Returns the column spacing for column \a column.
    /// 
    ///     \sa setColumnMinimumWidth()
    column_minimum_width(column: i32) -> i32,
    ///     Returns the number of columns in this grid.
    column_count() -> i32,
    ///     Returns the number of rows in this grid.
    row_count() -> i32,
    ///     Returns the geometry of the cell with row \a row and column \a column
    ///     in the grid. Returns an invalid rectangle if \a row or \a column is
    ///     outside the grid.
    /// 
    ///     \warning in the current version of Qt this function does not
    ///     return valid results until setGeometry() has been called, i.e.
    ///     after the parentWidget() is visible.
    cell_rect(row: i32, column: i32) -> Rect,
    ///     \reimp
    [event] has_height_for_width() -> bool,
    ///     \reimp
    [event] height_for_width(arg0: i32) -> i32,
    ///     \reimp
    [event] minimum_height_for_width(arg0: i32) -> i32,
    ///     \reimp
    [event] expanding_directions() -> Rute::Orientations,
    ///     \reimp
    [event] invalidate(),
    ///     Adds the given \a widget to the cell grid at \a row, \a column. The
    ///     top-left position is (0, 0) by default.
    /// 
    ///     The alignment is specified by \a alignment. The default
    ///     alignment is 0, which means that the widget fills the entire cell.
    /// 
    add_widget(w: *WidgetType),
    ///     Adds the given \a widget to the cell grid at \a row, \a column. The
    ///     top-left position is (0, 0) by default.
    /// 
    ///     The alignment is specified by \a alignment. The default
    ///     alignment is 0, which means that the widget fills the entire cell.
    /// 
    add_widget(arg0: *WidgetType, row: i32, column: i32, arg1: Rute::Alignment),
    ///     Adds the given \a widget to the cell grid at \a row, \a column. The
    ///     top-left position is (0, 0) by default.
    /// 
    ///     The alignment is specified by \a alignment. The default
    ///     alignment is 0, which means that the widget fills the entire cell.
    /// 
    add_widget(arg0: *WidgetType, row: i32, column: i32, row_span: i32, column_span: i32, arg1: Rute::Alignment),
    ///     Places the \a layout at position (\a row, \a column) in the grid. The
    ///     top-left position is (0, 0).
    /// 
    ///     The alignment is specified by \a alignment. The default
    ///     alignment is 0, which means that the widget fills the entire cell.
    /// 
    ///     A non-zero alignment indicates that the layout should not grow to
    ///     fill the available space but should be sized according to
    ///     sizeHint().
    /// 
    /// 
    ///     \a layout becomes a child of the grid layout.
    add_layout(arg0: *LayoutType, row: i32, column: i32, arg1: Rute::Alignment),
    ///     Places the \a layout at position (\a row, \a column) in the grid. The
    ///     top-left position is (0, 0).
    /// 
    ///     The alignment is specified by \a alignment. The default
    ///     alignment is 0, which means that the widget fills the entire cell.
    /// 
    ///     A non-zero alignment indicates that the layout should not grow to
    ///     fill the available space but should be sized according to
    ///     sizeHint().
    /// 
    /// 
    ///     \a layout becomes a child of the grid layout.
    add_layout(arg0: *LayoutType, row: i32, column: i32, row_span: i32, column_span: i32, arg1: Rute::Alignment),
    ///     Sets the grid's origin corner, i.e. position (0, 0), to \a corner.
    set_origin_corner(arg0: Rute::Corner),
    ///     Returns the corner that's used for the grid's origin, i.e. for
    ///     position (0, 0).
    origin_corner() -> Rute::Corner,
    ///     \reimp
    [event] item_at(index: i32) -> LayoutItem?,
    ///     \since 4.4
    /// 
    ///     Returns the layout item that occupies cell (\a row, \a column), or 0 if
    ///     the cell is empty.
    /// 
    ///     \sa getItemPosition(), indexOf()
    item_at_position(row: i32, column: i32) -> LayoutItem?,
    ///     \reimp
    [event] take_at(index: i32) -> LayoutItem?,
    ///     \reimp
    [event] count() -> i32,
    ///     Adds \a item at position \a row, \a column, spanning \a rowSpan
    ///     rows and \a columnSpan columns, and aligns it according to \a
    ///     alignment. If \a rowSpan and/or \a columnSpan is -1, then the item
    ///     will extend to the bottom and/or right edge, respectively. The
    ///     layout takes ownership of the \a item.
    /// 
    ///     \warning Do not use this function to add child layouts or child
    ///     widget items. Use addLayout() or addWidget() instead.
    add_item(item: *LayoutItemType, row: i32, column: i32, row_span: i32, column_span: i32, arg0: Rute::Alignment),
    /// \internal (mostly)
    /// 
    /// Sets the positioning mode used by addItem(). If \a orient is
    /// Qt::Horizontal, this layout is expanded to \a n columns, and items
    /// will be added columns-first. Otherwise it is expanded to \a n rows and
    /// items will be added rows-first.
    set_default_positioning(n: i32, orient: Rute::Orientation),
    ///   Returns the position information of the item with the given \a index.
    /// 
    ///   The variables passed as \a row and \a column are updated with the position of the
    ///   item in the layout, and the \a rowSpan and \a columnSpan variables are updated
    ///   with the vertical and horizontal spans of the item.
    /// 
    ///   \sa itemAtPosition(), itemAt()
    get_item_position(idx: i32, row: *i32, column: *i32, row_span: *i32, column_span: *i32),
    ///     Adds \a item at position \a row, \a column, spanning \a rowSpan
    ///     rows and \a columnSpan columns, and aligns it according to \a
    ///     alignment. If \a rowSpan and/or \a columnSpan is -1, then the item
    ///     will extend to the bottom and/or right edge, respectively. The
    ///     layout takes ownership of the \a item.
    /// 
    ///     \warning Do not use this function to add child layouts or child
    ///     widget items. Use addLayout() or addWidget() instead.
    [event] add_item(arg0: *LayoutItemType),
}

// vim: syntax=rust expandtab ts=4 sw=4
