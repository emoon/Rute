///     \class QGuiApplication
///     \brief The QGuiApplication class manages the GUI application's control
///     flow and main settings.
/// 
///     \inmodule QtGui
///     \since 5.0
/// 
///     QGuiApplication contains the main event loop, where all events from the window
///     system and other sources are processed and dispatched. It also handles the
///     application's initialization and finalization, and provides session management.
///     In addition, QGuiApplication handles most of the system-wide and application-wide
///     settings.
/// 
///     For any GUI application using Qt, there is precisely \b one QGuiApplication
///     object no matter whether the application has 0, 1, 2 or more windows at
///     any given time. For non-GUI Qt applications, use QCoreApplication instead,
///     as it does not depend on the Qt GUI module. For QWidget based Qt applications,
///     use QApplication instead, as it provides some functionality needed for creating
///     QWidget instances.
/// 
///     The QGuiApplication object is accessible through the instance() function, which
///     returns a pointer equivalent to the global \l qApp pointer.
/// 
///     QGuiApplication's main areas of responsibility are:
///         \list
///             \li  It initializes the application with the user's desktop settings,
///                 such as palette(), font() and styleHints(). It keeps
///                 track of these properties in case the user changes the desktop
///                 globally, for example, through some kind of control panel.
/// 
///             \li  It performs event handling, meaning that it receives events
///                 from the underlying window system and dispatches them to the
///                 relevant widgets. You can send your own events to windows by
///                 using sendEvent() and postEvent().
/// 
///             \li  It parses common command line arguments and sets its internal
///                 state accordingly. See the \l{QGuiApplication::QGuiApplication()}
///                 {constructor documentation} below for more details.
/// 
///             \li  It provides localization of strings that are visible to the
///                 user via translate().
/// 
///             \li  It provides some magical objects like the clipboard().
/// 
///             \li  It knows about the application's windows. You can ask which
///                 window is at a certain position using topLevelAt(), get a list of
///                 topLevelWindows(), etc.
/// 
///             \li  It manages the application's mouse cursor handling, see
///                 setOverrideCursor()
/// 
///             \li  It provides support for sophisticated \l{Session Management}
///                 {session management}. This makes it possible for applications
///                 to terminate gracefully when the user logs out, to cancel a
///                 shutdown process if termination isn't possible and even to
///                 preserve the entire application's state for a future session.
///                 See isSessionRestored(), sessionId() and commitDataRequest() and
///                 saveStateRequest() for details.
///         \endlist
/// 
///     Since the QGuiApplication object does so much initialization, it \e{must} be
///     created before any other objects related to the user interface are created.
///     QGuiApplication also deals with common command line arguments. Hence, it is
///     usually a good idea to create it \e before any interpretation or
///     modification of \c argv is done in the application itself.
/// 
///     \table
///     \header
///         \li{2,1} Groups of functions
/// 
///         \row
///         \li  System settings
///         \li  desktopSettingsAware(),
///             setDesktopSettingsAware(),
///             styleHints(),
///             palette(),
///             setPalette(),
///             font(),
///             setFont().
/// 
///         \row
///         \li  Event handling
///         \li  exec(),
///             processEvents(),
///             exit(),
///             quit().
///             sendEvent(),
///             postEvent(),
///             sendPostedEvents(),
///             removePostedEvents(),
///             hasPendingEvents(),
///             notify().
/// 
///         \row
///         \li  Windows
///         \li  allWindows(),
///             topLevelWindows(),
///             focusWindow(),
///             clipboard(),
///             topLevelAt().
/// 
///         \row
///         \li  Advanced cursor handling
///         \li  overrideCursor(),
///             setOverrideCursor(),
///             restoreOverrideCursor().
/// 
///         \row
///         \li  Session management
///         \li  isSessionRestored(),
///             sessionId(),
///             commitDataRequest(),
///             saveStateRequest().
/// 
///         \row
///         \li  Miscellaneous
///         \li  startingUp(),
///             closingDown().
///     \endtable
/// 
///     \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct GuiApplication : CoreApplication {
    ///     \property QGuiApplication::applicationDisplayName
    ///     \brief the user-visible name of this application
    ///     \since 5.0
    /// 
    ///     This name is shown to the user, for instance in window titles.
    ///     It can be translated, if necessary.
    /// 
    ///     If not set, the application display name defaults to the application name.
    /// 
    ///     \sa applicationName
    [static] set_application_display_name(name: String),
    [static] application_display_name() -> String,
    ///     \property QGuiApplication::desktopFileName
    ///     \brief the base name of the desktop entry for this application
    ///     \since 5.7
    /// 
    ///     This is the file name, without the full path, of the desktop entry
    ///     that represents this application according to the freedesktop desktop
    ///     entry specification.
    /// 
    ///     This property gives a precise indication of what desktop entry represents
    ///     the application and it is needed by the windowing system to retrieve
    ///     such information without resorting to imprecise heuristics.
    /// 
    ///     The latest version of the freedesktop desktop entry specification can be obtained
    ///     \l{http://standards.freedesktop.org/desktop-entry-spec/latest/}{here}.
    [static] set_desktop_file_name(name: String),
    [static] desktop_file_name() -> String,
    [static] all_windows() -> WindowList,
    [static] top_level_windows() -> WindowList,
    ///     Returns the top level window at the given position \a pos, if any.
    [static] top_level_at(pos: &PointType) -> Window?,
    [static] set_window_icon(icon: &IconType),
    ///     \property QGuiApplication::windowIcon
    ///     \brief the default window icon
    /// 
    ///     \sa QWindow::setIcon(), {Setting the Application Icon}
    [static] window_icon() -> Icon,
    ///     \property QGuiApplication::platformName
    ///     \brief The name of the underlying platform plugin.
    /// 
    ///     The QPA platform plugins are located in \c {qtbase\src\plugins\platforms}.
    ///     At the time of writing, the following platform plugin names are supported:
    /// 
    ///     \list
    ///         \li \c android
    ///         \li \c cocoa is a platform plugin for \macos.
    ///         \li \c directfb
    ///         \li \c eglfs is a platform plugin for running Qt5 applications on top of
    ///             EGL and  OpenGL ES 2.0 without an actual windowing system (like X11
    ///             or Wayland). For more information, see \l{EGLFS}.
    ///         \li \c ios (also used for tvOS)
    ///         \li \c kms is an experimental platform plugin using kernel modesetting
    ///             and \l{http://dri.freedesktop.org/wiki/DRM}{DRM} (Direct Rendering
    ///             Manager).
    ///         \li \c linuxfb writes directly to the framebuffer. For more information,
    ///             see \l{LinuxFB}.
    ///         \li \c minimal is provided as an examples for developers who want to
    ///             write their own platform plugins. However, you can use the plugin to
    ///             run GUI applications in environments without a GUI, such as servers.
    ///         \li \c minimalegl is an example plugin.
    ///         \li \c offscreen
    ///         \li \c openwfd
    ///         \li \c qnx
    ///         \li \c windows
    ///         \li \c wayland is a platform plugin for modern Linux desktops and some
    ///             embedded systems.
    ///         \li \c xcb is the X11 plugin used on regular desktop Linux platforms.
    ///     \endlist
    /// 
    ///     For more information about the platform plugins for embedded Linux devices,
    ///     see \l{Qt for Embedded Linux}.
    [static] platform_name() -> String,
    ///     Returns the most recently shown modal window. If no modal windows are
    ///     visible, this function returns zero.
    /// 
    ///     A modal window is a window which has its
    ///     \l{QWindow::modality}{modality} property set to Qt::WindowModal
    ///     or Qt::ApplicationModal. A modal window must be closed before the user can
    ///     continue with other parts of the program.
    /// 
    ///     Modal window are organized in a stack. This function returns the modal
    ///     window at the top of the stack.
    /// 
    ///     \sa Qt::WindowModality, QWindow::setModality()
    [static] modal_window() -> Window?,
    ///     Returns the QWindow that receives events tied to focus,
    ///     such as key events.
    [static] focus_window() -> Window?,
    [static] focus_object() -> Object?,
    [static] primary_screen() -> Screen?,
    ///     Returns a list of all the screens associated with the
    ///     windowing system the application is connected to.
    [static] screens() -> [Screen?],
    ///     Returns the screen at \a point, or \c nullptr if outside of any screen.
    /// 
    ///     The \a point is in relation to the virtualGeometry() of each set of virtual
    ///     siblings. If the point maps to more than one set of virtual siblings the first
    ///     match is returned.
    /// 
    ///     \since 5.10
    [static] screen_at(point: &PointType) -> Screen?,
    ///     Returns the highest screen device pixel ratio found on
    ///     the system. This is the ratio between physical pixels and
    ///     device-independent pixels.
    /// 
    ///     Use this function only when you don't know which window you are targeting.
    ///     If you do know the target window, use QWindow::devicePixelRatio() instead.
    /// 
    ///     \sa QWindow::devicePixelRatio()
    device_pixel_ratio() -> f32,
    ///     \fn QCursor *QGuiApplication::overrideCursor()
    /// 
    ///     Returns the active application override cursor.
    /// 
    ///     This function returns 0 if no application cursor has been defined (i.e. the
    ///     internal cursor stack is empty).
    /// 
    ///     \sa setOverrideCursor(), restoreOverrideCursor()
    [static] override_cursor() -> Cursor?,
    ///     \fn void QGuiApplication::setOverrideCursor(const QCursor &cursor)
    /// 
    ///     Sets the application override cursor to \a cursor.
    /// 
    ///     Application override cursors are intended for showing the user that the
    ///     application is in a special state, for example during an operation that
    ///     might take some time.
    /// 
    ///     This cursor will be displayed in all the application's widgets until
    ///     restoreOverrideCursor() or another setOverrideCursor() is called.
    /// 
    ///     Application cursors are stored on an internal stack. setOverrideCursor()
    ///     pushes the cursor onto the stack, and restoreOverrideCursor() pops the
    ///     active cursor off the stack. changeOverrideCursor() changes the curently
    ///     active application override cursor.
    /// 
    ///     Every setOverrideCursor() must eventually be followed by a corresponding
    ///     restoreOverrideCursor(), otherwise the stack will never be emptied.
    /// 
    ///     Example:
    ///     \snippet code/src_gui_kernel_qguiapplication_x11.cpp 0
    /// 
    ///     \sa overrideCursor(), restoreOverrideCursor(), changeOverrideCursor(),
    ///     QWidget::setCursor()
    [static] set_override_cursor(arg0: &CursorType),
    [static] change_override_cursor(arg0: &CursorType),
    ///     \fn void QGuiApplication::restoreOverrideCursor()
    /// 
    ///     Undoes the last setOverrideCursor().
    /// 
    ///     If setOverrideCursor() has been called twice, calling
    ///     restoreOverrideCursor() will activate the first cursor set. Calling this
    ///     function a second time restores the original widgets' cursors.
    /// 
    ///     \sa setOverrideCursor(), overrideCursor()
    [static] restore_override_cursor(),
    ///     Returns the default application font.
    /// 
    ///     \sa setFont()
    [static] font() -> Font,
    ///     Changes the default application font to \a font.
    /// 
    ///     \sa font()
    [static] set_font(arg0: &FontType),
    ///     Returns the object for interacting with the clipboard.
    [static] clipboard() -> Clipboard?,
    ///     Returns the default application palette.
    /// 
    ///     \sa setPalette()
    [static] palette() -> Palette,
    ///     Changes the default application palette to \a pal.
    /// 
    ///     \sa palette()
    [static] set_palette(pal: &PaletteType),
    ///     Returns the current state of the modifier keys on the keyboard. The current
    ///     state is updated sychronously as the event queue is emptied of events that
    ///     will spontaneously change the keyboard state (QEvent::KeyPress and
    ///     QEvent::KeyRelease events).
    /// 
    ///     It should be noted this may not reflect the actual keys held on the input
    ///     device at the time of calling but rather the modifiers as last reported in
    ///     one of the above events. If no keys are being held Qt::NoModifier is
    ///     returned.
    /// 
    ///     \sa mouseButtons(), queryKeyboardModifiers()
    [static] keyboard_modifiers() -> Rute::KeyboardModifiers,
    ///     \fn Qt::KeyboardModifiers QGuiApplication::queryKeyboardModifiers()
    /// 
    ///     Queries and returns the state of the modifier keys on the keyboard.
    ///     Unlike keyboardModifiers, this method returns the actual keys held
    ///     on the input device at the time of calling the method.
    /// 
    ///     It does not rely on the keypress events having been received by this
    ///     process, which makes it possible to check the modifiers while moving
    ///     a window, for instance. Note that in most cases, you should use
    ///     keyboardModifiers(), which is faster and more accurate since it contains
    ///     the state of the modifiers as they were when the currently processed
    ///     event was received.
    /// 
    ///     \sa keyboardModifiers()
    [static] query_keyboard_modifiers() -> Rute::KeyboardModifiers,
    ///     Returns the current state of the buttons on the mouse. The current state is
    ///     updated syncronously as the event queue is emptied of events that will
    ///     spontaneously change the mouse state (QEvent::MouseButtonPress and
    ///     QEvent::MouseButtonRelease events).
    /// 
    ///     It should be noted this may not reflect the actual buttons held on the
    ///     input device at the time of calling but rather the mouse buttons as last
    ///     reported in one of the above events. If no mouse buttons are being held
    ///     Qt::NoButton is returned.
    /// 
    ///     \sa keyboardModifiers()
    [static] mouse_buttons() -> Rute::MouseButtons,
    [static] set_layout_direction(direction: Rute::LayoutDirection),
    [static] layout_direction() -> Rute::LayoutDirection,
    [static] is_right_to_left() -> bool,
    [static] is_left_to_right() -> bool,
    [static] style_hints() -> StyleHints?,
    ///     Sets whether Qt should use the system's standard colors, fonts, etc., to
    ///     \a on. By default, this is \c true.
    /// 
    ///     This function must be called before creating the QGuiApplication object, like
    ///     this:
    /// 
    ///     \snippet code/src_gui_kernel_qguiapplication.cpp 0
    /// 
    ///     \sa desktopSettingsAware()
    [static] set_desktop_settings_aware(on: bool),
    ///     Returns \c true if Qt is set to use the system's standard colors, fonts, etc.;
    ///     otherwise returns \c false. The default is \c true.
    /// 
    ///     \sa setDesktopSettingsAware()
    [static] desktop_settings_aware() -> bool,
    [static] input_method() -> InputMethod?,
    ///     Returns the platform's native interface, for platform specific
    ///     functionality.
    [static] platform_native_interface() -> PlatformNativeInterface?,
    ///     Returns a function pointer from the platformplugin matching \a function
    [static] platform_function(function: &ByteArrayType) -> FunctionPointer,
    [static] set_quit_on_last_window_closed(quit: bool),
    [static] quit_on_last_window_closed() -> bool,
    [static] application_state() -> Rute::ApplicationState,
    ///     Enters the main event loop and waits until exit() is called, and then
    ///     returns the value that was set to exit() (which is 0 if exit() is called
    ///     via quit()).
    /// 
    ///     It is necessary to call this function to start event handling. The main
    ///     event loop receives events from the window system and dispatches these to
    ///     the application widgets.
    /// 
    ///     Generally, no user interaction can take place before calling exec().
    /// 
    ///     To make your application perform idle processing, e.g., executing a special
    ///     function whenever there are no pending events, use a QTimer with 0 timeout.
    ///     More advanced idle processing schemes can be achieved using processEvents().
    /// 
    ///     We recommend that you connect clean-up code to the
    ///     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your
    ///     application's \c{main()} function. This is because, on some platforms, the
    ///     QApplication::exec() call may not return.
    /// 
    ///     \sa quitOnLastWindowClosed, quit(), exit(), processEvents(),
    ///         QCoreApplication::exec()
    [static] exec() -> i32,
    [event] notify(arg0: *ObjectType, arg1: *EventType) -> bool,
    ///     \fn QString QGuiApplication::sessionKey() const
    /// 
    ///     Returns the session key in the current \l{Session Management}{session}.
    /// 
    ///     If the application has been restored from an earlier session, this key is
    ///     the same as it was when the previous session ended.
    /// 
    ///     The session key changes every time the session is saved. If the shutdown process
    ///     is cancelled, another session key will be used when shutting down again.
    /// 
    ///     \sa isSessionRestored(), sessionId(), commitDataRequest(), saveStateRequest()
    is_session_restored() -> bool,
    session_id() -> String,
    session_key() -> String,
    is_saving_session() -> bool,
    ///     \since 5.6
    /// 
    ///     Returns whether QGuiApplication will use fallback session management.
    /// 
    ///     The default is \c true.
    /// 
    ///     If this is \c true and the session manager allows user interaction,
    ///     QGuiApplication will try to close toplevel windows after
    ///     commitDataRequest() has been emitted. If a window cannot be closed, session
    ///     shutdown will be canceled and the application will keep running.
    /// 
    ///     Fallback session management only benefits applications that have an
    ///     "are you sure you want to close this window?" feature or other logic that
    ///     prevents closing a toplevel window depending on certain conditions, and
    ///     that do nothing to explicitly implement session management. In applications
    ///     that \e do implement session management using the proper session management
    ///     API, fallback session management interferes and may break session
    ///     management logic.
    /// 
    ///     \warning If all windows \e are closed due to fallback session management
    ///     and quitOnLastWindowClosed() is \c true, the application will quit before
    ///     it is explicitly instructed to quit through the platform's session
    ///     management protocol. That violation of protocol may prevent the platform
    ///     session manager from saving application state.
    /// 
    ///     \sa setFallbackSessionManagementEnabled(),
    ///     QSessionManager::allowsInteraction(), saveStateRequest(),
    ///     commitDataRequest(), {Session Management}
    [static] is_fallback_session_management_enabled() -> bool,
    ///    \since 5.6
    /// 
    ///     Sets whether QGuiApplication will use fallback session management to
    ///     \a enabled.
    /// 
    ///     \sa isFallbackSessionManagementEnabled()
    [static] set_fallback_session_management_enabled(arg0: bool),
    ///     \since 5.2
    /// 
    ///     Function that can be used to sync Qt state with the Window Systems state.
    /// 
    ///     This function will first empty Qts events by calling QCoreApplication::processEvents(),
    ///     then the platform plugin will sync up with the windowsystem, and finally Qts events
    ///     will be delived by another call to QCoreApplication::processEvents();
    /// 
    ///     This function is timeconsuming and its use is discouraged.
    [static] sync(),
    [signal] font_database_changed(),
    [signal] screen_added(screen: *ScreenType),
    [signal] screen_removed(screen: *ScreenType),
    [signal] primary_screen_changed(screen: *ScreenType),
    [signal] last_window_closed(),
    [signal] focus_object_changed(focus_object: *ObjectType),
    [signal] focus_window_changed(focus_window: *WindowType),
    [signal] application_state_changed(state: Rute::ApplicationState),
    [signal] layout_direction_changed(direction: Rute::LayoutDirection),
    [signal] commit_data_request(session_manager: &SessionManagerType),
    [signal] save_state_request(session_manager: &SessionManagerType),
    [signal] palette_changed(pal: &PaletteType),
    [signal] application_display_name_changed(),
    [signal] font_changed(font: &FontType),
    [event] event(arg0: *EventType) -> bool,
    ///     \internal
    [event] compress_event(arg0: *EventType, receiver: *ObjectType, arg1: *PostEventListType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
