///     \class QGraphicsLayout
///     \brief The QGraphicsLayout class provides the base class for all layouts
///     in Graphics View.
///     \since 4.4
///     \ingroup graphicsview-api
///     \inmodule QtWidgets
/// 
///     QGraphicsLayout is an abstract class that defines a virtual API for
///     arranging QGraphicsWidget children and other QGraphicsLayoutItem objects
///     for a QGraphicsWidget. QGraphicsWidget assigns responsibility to a
///     QGraphicsLayout through QGraphicsWidget::setLayout(). As the widget
///     is resized, the layout will automatically arrange the widget's children.
///     QGraphicsLayout inherits QGraphicsLayoutItem, so, it can be managed by
///     any layout, including its own subclasses.
/// 
///     \section1 Writing a Custom Layout
/// 
///     You can use QGraphicsLayout as a base to write your own custom layout
///     (e.g., a flowlayout), but it is more common to use one of its subclasses
///     instead - QGraphicsLinearLayout or QGraphicsGridLayout. When creating
///     a custom layout, the following functions must be reimplemented as a bare
///     minimum:
/// 
///     \table
///     \header \li Function                     \li Description
///     \row     \li QGraphicsLayoutItem::setGeometry()
///                \li Notifies you when the geometry of the layout is set. You can
///                    store the geometry in your own layout class in a reimplementation
///                    of this function.
///     \row    \li QGraphicsLayoutItem::sizeHint()
///                \li Returns the layout's size hints.
///     \row    \li QGraphicsLayout::count()
///               \li Returns the number of items in your layout.
///     \row    \li QGraphicsLayout::itemAt()
///               \li Returns a pointer to an item in your layout.
///     \row    \li QGraphicsLayout::removeAt()
///               \li Removes an item from your layout without destroying it.
///     \endtable
/// 
///     For more details on how to implement each function, refer to the individual
///     function documentation.
/// 
///     Each layout defines its own API for arranging widgets and layout items.
///     For example, with a grid layout, you require a row and a
///     column index with optional row and column spans, alignment, spacing, and more.
///     A linear layout, however, requires a single row or column index to position its
///     items. For a grid layout, the order of insertion does not affect the layout in
///     any way, but for a linear layout, the order is essential. When writing your own
///     layout subclass, you are free to choose the API that best suits your layout.
/// 
///     QGraphicsLayout provides the addChildLayoutItem() convenience function to add
///     layout items to a custom layout. The function will automatically reparent
///     graphics items, if required.
/// 
///     \section1 Activating the Layout
/// 
///     When the layout's geometry changes, QGraphicsLayout immediately rearranges
///     all of its managed items by calling setGeometry() on each item. This
///     rearrangement is called \e activating the layout.
/// 
///     QGraphicsLayout updates its own geometry to match the contentsRect() of the
///     QGraphicsLayoutItem it is managing. Thus, it will automatically rearrange all
///     its items when the widget is resized. QGraphicsLayout caches the sizes of all
///     its managed items to avoid calling setGeometry() too often.
/// 
///     \note A QGraphicsLayout will have the same geometry as the contentsRect()
///     of the widget (not the layout) it is assigned to.
/// 
///     \section2 Activating the Layout Implicitly
/// 
///     The layout can be activated implicitly using one of two ways: by calling
///     activate() or by calling invalidate(). Calling activate() activates the layout
///     immediately. In contrast, calling invalidate() is delayed, as it posts a
///     \l{QEvent::LayoutRequest}{LayoutRequest} event to the managed widget. Due
///     to event compression, the activate() will only be called once after control has
///     returned to the event loop. This is referred to as \e invalidating the layout.
///     Invalidating the layout also invalidates any cached information. Also, the
///     invalidate() function is a virtual function. So, you can invalidate your own
///     cache in a subclass of QGraphicsLayout by reimplementing this function.
/// 
///     \section1 Event Handling
/// 
///     QGraphicsLayout listens to events for the widget it manages through the
///     virtual widgetEvent() event handler. When the layout is assigned to a
///     widget, all events delivered to the widget are first processed by
///     widgetEvent(). This allows the layout to be aware of any relevant state
///     changes on the widget such as visibility changes or layout direction changes.
/// 
///     \section1 Margin Handling
/// 
///     The margins of a QGraphicsLayout can be modified by reimplementing
///     setContentsMargins() and getContentsMargins().
/// 
struct GraphicsLayout : GraphicsLayoutItem {
    ///     Sets the contents margins to \a left, \a top, \a right and \a bottom. The
    ///     default contents margins for toplevel layouts are style dependent
    ///     (by querying the pixelMetric for QStyle::PM_LayoutLeftMargin,
    ///     QStyle::PM_LayoutTopMargin, QStyle::PM_LayoutRightMargin and
    ///     QStyle::PM_LayoutBottomMargin).
    /// 
    ///     For sublayouts the default margins are 0.
    /// 
    ///     Changing the contents margins automatically invalidates the layout.
    /// 
    ///     \sa invalidate()
    set_contents_margins(left: f32, top: f32, right: f32, bottom: f32),
    ///     \reimp
    [event] get_contents_margins(left: *f32, top: *f32, right: *f32, bottom: *f32),
    ///     Activates the layout, causing all items in the layout to be immediately
    ///     rearranged. This function is based on calling count() and itemAt(), and
    ///     then calling setGeometry() on all items sequentially. When activated,
    ///     the layout will adjust its geometry to its parent's contentsRect().
    ///     The parent will then invalidate any layout of its own.
    /// 
    ///     If called in sequence or recursively, e.g., by one of the arranged items
    ///     in response to being resized, this function will do nothing.
    /// 
    ///     Note that the layout is free to use geometry caching to optimize this
    ///     process.  To forcefully invalidate any such cache, you can call
    ///     invalidate() before calling activate().
    /// 
    ///     \sa invalidate()
    activate(),
    ///     Returns \c true if the layout is currently being activated; otherwise,
    ///     returns \c false. If the layout is being activated, this means that it is
    ///     currently in the process of rearranging its items (i.e., the activate()
    ///     function has been called, and has not yet returned).
    /// 
    ///     \sa activate(), invalidate()
    is_activated() -> bool,
    ///     Clears any cached geometry and size hint information in the layout, and
    ///     posts a \l{QEvent::LayoutRequest}{LayoutRequest} event to the managed
    ///     parent QGraphicsLayoutItem.
    /// 
    ///     \sa activate(), setGeometry()
    [event] invalidate(),
    ///     This virtual event handler receives all events for the managed
    ///     widget. QGraphicsLayout uses this event handler to listen for layout
    ///     related events such as geometry changes, layout changes or layout
    ///     direction changes.
    /// 
    ///     \a e is a pointer to the event.
    /// 
    ///     You can reimplement this event handler to track similar events for your
    ///     own custom layout.
    /// 
    ///     \sa QGraphicsWidget::event(), QGraphicsItem::sceneEvent()
    [event] widget_event(e: *EventType),
    [event] count() -> i32,
    [event] item_at(i: i32) -> GraphicsLayoutItem?,
    [event] remove_at(index: i32),
    ///     \internal
    ///     \since 4.8
    ///     \sa instantInvalidatePropagation()
    /// 
    ///     Calling this function with \a enable set to true will enable a feature that
    ///     makes propagation of invalidation up to ancestor layout items to be done in
    ///     one go. It will propagate up the parentLayoutItem() hierarchy until it has
    ///     reached the root. If the root item is a QGraphicsWidget, it will *post* a
    ///     layout request to it. When the layout request is consumed it will traverse
    ///     down the hierarchy of layouts and widgets and activate all layouts that is
    ///     invalid (not activated). This is the recommended behaviour.
    /// 
    ///     If not set it will also propagate up the parentLayoutItem() hierarchy, but
    ///     it will stop at the \e{first widget} it encounters, and post a layout
    ///     request to the widget. When the layout request is consumed, this might
    ///     cause it to continue propagation up to the parentLayoutItem() of the
    ///     widget. It will continue in this fashion until it has reached a widget with
    ///     no parentLayoutItem(). This strategy might cause drawing artifacts, since
    ///     it is not done in one go, and the consumption of layout requests might be
    ///     interleaved by consumption of paint events, which might cause significant
    ///     flicker.
    ///     Note, this is not the recommended behavior, but for compatibility reasons
    ///     this is the default behaviour.
    [static] set_instant_invalidate_propagation(enable: bool),
    ///     \internal
    ///     \since 4.8
    ///     \sa setInstantInvalidatePropagation()
    /// 
    ///     returns \c true if the complete widget/layout hierarchy is rearranged in one go.
    [static] instant_invalidate_propagation() -> bool,
    add_child_layout_item(layout_item: *GraphicsLayoutItemType),
}

// vim: syntax=rust expandtab ts=4 sw=4
