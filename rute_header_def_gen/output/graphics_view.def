/// 
/// QGraphicsView visualizes the contents of a QGraphicsScene in a scrollable
/// viewport. To create a scene with geometrical items, see QGraphicsScene's
/// documentation. QGraphicsView is part of the [Graphics View Framework](Graphics%20View%20Framework)
/// 
/// 
/// To visualize a scene, you start by constructing a QGraphicsView object,
/// passing the address of the scene you want to visualize to QGraphicsView's
/// constructor. Alternatively, you can call setScene() to set the scene at a
/// later point. After you call show(), the view will by default scroll to the
/// center of the scene and display any items that are visible at this
/// point. For example:
/// 
/// You can explicitly scroll to any position on the scene by using the
/// scroll bars, or by calling centerOn(). By passing a point to centerOn(),
/// QGraphicsView will scroll its viewport to ensure that the point is
/// centered in the view. An overload is provided for scrolling to a
/// QGraphicsItem, in which case QGraphicsView will see to that the center of
/// the item is centered in the view. If all you want is to ensure that a
/// certain area is visible, (but not necessarily centered,) you can call
/// ensureVisible() instead.
/// 
/// QGraphicsView can be used to visualize a whole scene, or only parts of it.
/// The visualized area is by default detected automatically when the view is
/// displayed for the first time (by calling
/// QGraphicsScene::itemsBoundingRect()). To set the visualized area rectangle
/// yourself, you can call setSceneRect(). This will adjust the scroll bars'
/// ranges appropriately. Note that although the scene supports a virtually
/// unlimited size, the range of the scroll bars will never exceed the range of
/// an integer (INT_MIN, INT_MAX).
/// 
/// QGraphicsView visualizes the scene by calling render(). By default, the
/// items are drawn onto the viewport by using a regular QPainter, and using
/// default render hints. To change the default render hints that
/// QGraphicsView passes to QPainter when painting items, you can call
/// setRenderHints().
/// 
/// By default, QGraphicsView provides a regular QWidget for the viewport
/// widget. You can access this widget by calling viewport(), or you can
/// replace it by calling setViewport(). To render using OpenGL, simply call
/// setViewport(new QGLWidget). QGraphicsView takes ownership of the viewport
/// widget.
/// 
/// QGraphicsView supports affine transformations, using QTransform. You can
/// either pass a matrix to setTransform(), or you can call one of the
/// convenience functions rotate(), scale(), translate() or shear(). The most
/// two common transformations are scaling, which is used to implement
/// zooming, and rotation. QGraphicsView keeps the center of the view fixed
/// during a transformation. Because of the scene alignment (setAligment()),
/// translating the view will have no visual impact.
/// 
/// You can interact with the items on the scene by using the mouse and
/// keyboard. QGraphicsView translates the mouse and key events into *scene*
/// events, (events that inherit QGraphicsSceneEvent,), and forward them to
/// the visualized scene. In the end, it's the individual item that handles
/// the events and reacts to them. For example, if you click on a selectable
/// item, the item will typically let the scene know that it has been
/// selected, and it will also redraw itself to display a selection
/// rectangle. Similiary, if you click and drag the mouse to move a movable
/// item, it's the item that handles the mouse moves and moves itself. Item
/// interaction is enabled by default, and you can toggle it by calling
/// setInteractive().
/// 
/// You can also provide your own custom scene interaction, by creating a
/// subclass of QGraphicsView, and reimplementing the mouse and key event
/// handlers. To simplify how you programmatically interact with items in the
/// view, QGraphicsView provides the mapping functions mapToScene() and
/// mapFromScene(), and the item accessors items() and itemAt(). These
/// functions allow you to map points, rectangles, polygons and paths between
/// view coordinates and scene coordinates, and to find items on the scene
/// using view coordinates.
/// 
/// ![graphicsview-view.png](graphicsview-view.png)
/// 
/// **See also:** [`GraphicsScene`]
/// [`GraphicsItem`]
/// [`GraphicsSceneEvent`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct GraphicsView : AbstractScrollArea {
    /// 
    [event] size_hint() -> Size,
    /// 
    /// These hints are
    /// used to initialize QPainter before each visible item is drawn. QPainter
    /// uses render hints to toggle rendering features such as antialiasing and
    /// smooth pixmap transformation.
    /// 
    /// QPainter::TextAntialiasing is enabled by default.
    /// 
    /// Example:
    /// 
    render_hints() -> Painter::RenderHints,
    /// 
    /// If *enabled* is true, the render hint *hint* is enabled; otherwise it
    /// is disabled.
    /// 
    /// **See also:** renderHints
    set_render_hint(hint: Painter::RenderHint, enabled: bool),
    set_render_hints(hints: Painter::RenderHints),
    /// 
    /// If the whole scene is visible in the view, (i.e., there are no visible
    /// scroll bars,) the view's alignment will decide where the scene will be
    /// rendered in the view. For example, if the alignment is Qt::AlignCenter,
    /// which is default, the scene will be centered in the view, and if the
    /// alignment is (Qt::AlignLeft | Qt::AlignTop), the scene will be rendered in
    /// the top-left corner of the view.
    alignment() -> Rute::Alignment,
    set_alignment(alignment: Rute::Alignment),
    set_transformation_anchor(anchor: GraphicsView::ViewportAnchor),
    /// 
    /// QGraphicsView uses this property to decide how to position the scene in
    /// the viewport when the viewport widget's size changes. The default
    /// behavior, NoAnchor, leaves the scene's position unchanged during a resize;
    /// the top-left corner of the view will appear to be anchored while resizing.
    /// 
    /// Note that the effect of this property is noticeable when only a part of the
    /// scene is visible (i.e., when there are scroll bars). Otherwise, if the
    /// whole scene fits in the view, QGraphicsScene uses the view [alignment](alignment)
    /// to
    /// position the scene in the view.
    /// 
    /// **See also:** alignment
    /// transformationAnchor
    resize_anchor() -> GraphicsView::ViewportAnchor,
    set_resize_anchor(anchor: GraphicsView::ViewportAnchor),
    /// 
    /// QGraphicsView uses this property to decide how to update areas of the
    /// scene that have been reexposed or changed. Usually you do not need to
    /// modify this property, but there are some cases where doing so can improve
    /// rendering performance. See the ViewportUpdateMode documentation for
    /// specific details.
    /// 
    /// The default value is MinimalViewportUpdate, where QGraphicsView will
    /// update as small an area of the viewport as possible when the contents
    /// change.
    /// 
    /// **See also:** ViewportUpdateMode
    /// cacheMode
    viewport_update_mode() -> GraphicsView::ViewportUpdateMode,
    set_viewport_update_mode(mode: GraphicsView::ViewportUpdateMode),
    /// 
    /// QGraphicsView uses clipping, extra bounding rect adjustments, and certain
    /// other aids to improve rendering quality and performance for the common
    /// case graphics scene. However, depending on the target platform, the scene,
    /// and the viewport in use, some of these operations can degrade performance.
    /// 
    /// The effect varies from flag to flag; see the OptimizationFlags
    /// documentation for details.
    /// 
    /// By default, no optimization flags are enabled.
    /// 
    /// **See also:** [`set_optimization_flag()`]
    optimization_flags() -> GraphicsView::OptimizationFlags,
    /// 
    /// Enables *flag* if *enabled* is true; otherwise disables *flag.*
    /// 
    /// **See also:** optimizationFlags
    set_optimization_flag(flag: GraphicsView::OptimizationFlag, enabled: bool),
    set_optimization_flags(flags: GraphicsView::OptimizationFlags),
    /// 
    /// This property defines what should happen when the user clicks on the scene
    /// background and drags the mouse (e.g., scrolling the viewport contents
    /// using a pointing hand cursor, or selecting multiple items with a rubber
    /// band). The default value, NoDrag, does nothing.
    /// 
    /// This behavior only affects mouse clicks that are not handled by any item.
    /// You can define a custom behavior by creating a subclass of QGraphicsView
    /// and reimplementing mouseMoveEvent().
    drag_mode() -> GraphicsView::DragMode,
    set_drag_mode(mode: GraphicsView::DragMode),
    /// 
    /// This property defines how items are selected when using the RubberBandDrag
    /// drag mode.
    /// 
    /// The default value is Qt::IntersectsItemShape; all items whose shape
    /// intersects with or is contained by the rubber band are selected.
    /// 
    /// **See also:** dragMode
    /// [`items()`]
    /// [`rubber_band_rect()`]
    rubber_band_selection_mode() -> Rute::ItemSelectionMode,
    set_rubber_band_selection_mode(mode: Rute::ItemSelectionMode),
    /// 
    /// This functions returns the current rubber band area (in viewport coordinates) if the user
    /// is currently doing an itemselection with rubber band. When the user is not using the
    /// rubber band this functions returns (a null) QRectF().
    /// 
    /// Notice that part of this QRect can be outise the visual viewport. It can e.g
    /// contain negative values.
    /// 
    /// **See also:** rubberBandSelectionMode
    /// [`rubber_band_changed()`]
    rubber_band_rect() -> Rect,
    /// 
    /// QGraphicsView can cache pre-rendered content in a QPixmap, which is then
    /// drawn onto the viewport. The purpose of such caching is to speed up the
    /// total rendering time for areas that are slow to render. Texture, gradient
    /// and alpha blended backgrounds, for example, can be notibly slow to render;
    /// especially with a transformed view. The CacheBackground flag enables
    /// caching of the view's background. For example:
    /// 
    /// The cache is invalidated every time the view is transformed. However, when
    /// scrolling, only partial invalidation is required.
    /// 
    /// By default, nothing is cached.
    /// 
    /// **See also:** [`reset_cached_content()`]
    /// [`PixmapCache`]
    cache_mode() -> GraphicsView::CacheMode,
    set_cache_mode(mode: GraphicsView::CacheMode),
    /// 
    /// Resets any cached content. Calling this function will clear
    /// QGraphicsView's cache. If the current cache mode is [CacheNone,](CacheNone,)
    /// this
    /// function does nothing.
    /// 
    /// This function is called automatically for you when the backgroundBrush or
    /// QGraphicsScene::backgroundBrush properties change; you only need to call
    /// this function if you have reimplemented QGraphicsScene::drawBackground()
    /// or QGraphicsView::drawBackground() to draw a custom background, and need
    /// to trigger a full redraw.
    /// 
    /// **See also:** [`cache_mode()`]
    reset_cached_content(),
    is_interactive() -> bool,
    set_interactive(allowed: bool),
    /// 
    /// Returns a pointer to the scene that is currently visualized in the
    /// view. If no scene is currently visualized, 0 is returned.
    /// 
    /// **See also:** [`set_scene()`]
    /// 
    /// The scene rectangle defines the extent of the scene, and in the view's case,
    /// this means the area of the scene that you can navigate using the scroll
    /// bars.
    /// 
    /// If unset, or if a null QRectF is set, this property has the same value as
    /// QGraphicsScene::sceneRect, and it changes with
    /// QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected
    /// by the scene.
    /// 
    /// Note that, although the scene supports a virtually unlimited size, the
    /// range of the scroll bars will never exceed the range of an integer
    /// (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values,
    /// you can choose to use translate() to navigate the scene instead.
    /// 
    /// By default, this property contains a rectangle at the origin with zero
    /// width and height.
    /// 
    /// **See also:** [`GraphicsScene::scene_rect()`]
    scene() -> GraphicsScene?,
    /// 
    /// Sets the current scene to *scene.* If *scene* is already being
    /// viewed, this function does nothing.
    /// 
    /// When a scene is set on a view, the QGraphicsScene::changed() signal
    /// is automatically connected to this view's updateScene() slot, and the
    /// view's scroll bars are adjusted to fit the size of the scene.
    /// 
    /// The view does not take ownership of *scene.*
    set_scene(scene: *GraphicsSceneType),
    /// 
    /// The scene rectangle defines the extent of the scene, and in the view's case,
    /// this means the area of the scene that you can navigate using the scroll
    /// bars.
    /// 
    /// If unset, or if a null QRectF is set, this property has the same value as
    /// QGraphicsScene::sceneRect, and it changes with
    /// QGraphicsScene::sceneRect. Otherwise, the view's scene rect is unaffected
    /// by the scene.
    /// 
    /// Note that, although the scene supports a virtually unlimited size, the
    /// range of the scroll bars will never exceed the range of an integer
    /// (INT_MIN, INT_MAX). When the scene is larger than the scroll bars' values,
    /// you can choose to use translate() to navigate the scene instead.
    /// 
    /// By default, this property contains a rectangle at the origin with zero
    /// width and height.
    /// 
    /// **See also:** [`GraphicsScene::scene_rect()`]
    scene_rect() -> RectF,
    set_scene_rect(rect: &RectFType),
    [org_name(setSceneRect)]
    set_scene_rect_2(x: f32, y: f32, w: f32, h: f32),
    /// 
    /// Returns a matrix that maps scene coordinates to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// [`map_from_scene()`]
    viewport_transform() -> Transform,
    /// 
    /// Returns `true` if the view is transformed (i.e., a non-identity transform
    /// has been assigned, or the scrollbars are adjusted).
    /// 
    /// **See also:** [`set_transform()`]
    /// [`horizontal_scroll_bar()`]
    /// [`vertical_scroll_bar()`]
    is_transformed() -> bool,
    /// 
    /// Sets the view's current transformation matrix to *matrix.*
    /// 
    /// If *combine* is true, then *matrix* is combined with the current matrix;
    /// otherwise, *matrix* *replaces* the current matrix. *combine* is false
    /// by default.
    /// 
    /// The transformation matrix tranforms the scene into view coordinates. Using
    /// the default transformation, provided by the identity matrix, one pixel in
    /// the view represents one unit in the scene (e.g., a 10x10 rectangular item
    /// is drawn using 10x10 pixels in the view). If a 2x2 scaling matrix is
    /// applied, the scene will be drawn in 1:2 (e.g., a 10x10 rectangular item is
    /// then drawn using 20x20 pixels in the view).
    /// 
    /// Example:
    /// 
    /// To simplify interation with items using a transformed view, QGraphicsView
    /// provides mapTo... and mapFrom... functions that can translate between
    /// scene and view coordinates. For example, you can call mapToScene() to map
    /// a view coordiate to a floating point scene coordinate, or mapFromScene()
    /// to map from floating point scene coordinates to view coordinates.
    /// 
    /// **See also:** [`transform()`]
    /// [`rotate()`]
    /// [`scale()`]
    /// [`shear()`]
    /// [`translate()`]
    set_transform(matrix: &TransformType, combine: bool),
    /// 
    /// Resets the view transformation to the identity matrix.
    /// 
    /// **See also:** [`transform()`]
    /// [`set_transform()`]
    reset_transform(),
    /// 
    /// Rotates the current view transformation *angle* degrees clockwise.
    /// 
    /// **See also:** [`set_transform()`]
    /// [`transform()`]
    /// [`scale()`]
    /// [`shear()`]
    /// [`translate()`]
    rotate(angle: f32),
    /// 
    /// Scales the current view transformation by ( *sx,* *sy).*
    /// 
    /// **See also:** [`set_transform()`]
    /// [`transform()`]
    /// [`rotate()`]
    /// [`shear()`]
    /// [`translate()`]
    scale(sx: f32, sy: f32),
    /// 
    /// Shears the current view transformation by ( *sh,* *sv).*
    /// 
    /// **See also:** [`set_transform()`]
    /// [`transform()`]
    /// [`rotate()`]
    /// [`scale()`]
    /// [`translate()`]
    shear(sh: f32, sv: f32),
    /// 
    /// Scrolls the contents of the viewport to ensure that the scene
    /// coordinate *pos,* is centered in the view.
    /// 
    /// Because *pos* is a floating point coordinate, and the scroll bars operate
    /// on integer coordinates, the centering is only an approximation.
    /// 
    /// **Note**: If the item is close to or outside the border, it will be visible
    /// in the view, but not centered.
    /// 
    /// **See also:** [`ensure_visible()`]
    /// 
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to calling
    /// centerOn(QPointF( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Scrolls the contents of the viewport to ensure that *item*
    /// is centered in the view.
    /// 
    /// **See also:** [`ensure_visible()`]
    center_on(pos: &PointFType),
    /// 
    /// Scrolls the contents of the viewport to ensure that the scene
    /// coordinate *pos,* is centered in the view.
    /// 
    /// Because *pos* is a floating point coordinate, and the scroll bars operate
    /// on integer coordinates, the centering is only an approximation.
    /// 
    /// **Note**: If the item is close to or outside the border, it will be visible
    /// in the view, but not centered.
    /// 
    /// **See also:** [`ensure_visible()`]
    /// 
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to calling
    /// centerOn(QPointF( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Scrolls the contents of the viewport to ensure that *item*
    /// is centered in the view.
    /// 
    /// **See also:** [`ensure_visible()`]
    [org_name(centerOn)]
    center_on_2(x: f32, y: f32),
    /// 
    /// Scrolls the contents of the viewport to ensure that the scene
    /// coordinate *pos,* is centered in the view.
    /// 
    /// Because *pos* is a floating point coordinate, and the scroll bars operate
    /// on integer coordinates, the centering is only an approximation.
    /// 
    /// **Note**: If the item is close to or outside the border, it will be visible
    /// in the view, but not centered.
    /// 
    /// **See also:** [`ensure_visible()`]
    /// 
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to calling
    /// centerOn(QPointF( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Scrolls the contents of the viewport to ensure that *item*
    /// is centered in the view.
    /// 
    /// **See also:** [`ensure_visible()`]
    [org_name(centerOn)]
    center_on_3(item: *GraphicsItemType),
    /// 
    /// Scrolls the contents of the viewport so that the scene rectangle *rect*
    /// is visible, with margins specified in pixels by *xmargin* and *ymargin.* If the specified rect cannot be reached, the contents are
    /// scrolled to the nearest valid position. The default value for both margins
    /// is 50 pixels.
    /// 
    /// **See also:** [`center_on()`]
    /// 
    /// int xmargin, int ymargin)
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to calling
    /// ensureVisible(QRectF( *x,* *y,* *w,* *h),* *xmargin,* *ymargin).*
    /// 
    /// **Overloads**
    /// Scrolls the contents of the viewport so that the center of item *item* is
    /// visible, with margins specified in pixels by *xmargin* and *ymargin.* If
    /// the specified point cannot be reached, the contents are scrolled to the
    /// nearest valid position. The default value for both margins is 50 pixels.
    /// 
    /// **See also:** [`center_on()`]
    ensure_visible(rect: &RectFType, xmargin: i32, ymargin: i32),
    /// 
    /// Scrolls the contents of the viewport so that the scene rectangle *rect*
    /// is visible, with margins specified in pixels by *xmargin* and *ymargin.* If the specified rect cannot be reached, the contents are
    /// scrolled to the nearest valid position. The default value for both margins
    /// is 50 pixels.
    /// 
    /// **See also:** [`center_on()`]
    /// 
    /// int xmargin, int ymargin)
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to calling
    /// ensureVisible(QRectF( *x,* *y,* *w,* *h),* *xmargin,* *ymargin).*
    /// 
    /// **Overloads**
    /// Scrolls the contents of the viewport so that the center of item *item* is
    /// visible, with margins specified in pixels by *xmargin* and *ymargin.* If
    /// the specified point cannot be reached, the contents are scrolled to the
    /// nearest valid position. The default value for both margins is 50 pixels.
    /// 
    /// **See also:** [`center_on()`]
    [org_name(ensureVisible)]
    ensure_visible_2(x: f32, y: f32, w: f32, h: f32, xmargin: i32, ymargin: i32),
    /// 
    /// Scrolls the contents of the viewport so that the scene rectangle *rect*
    /// is visible, with margins specified in pixels by *xmargin* and *ymargin.* If the specified rect cannot be reached, the contents are
    /// scrolled to the nearest valid position. The default value for both margins
    /// is 50 pixels.
    /// 
    /// **See also:** [`center_on()`]
    /// 
    /// int xmargin, int ymargin)
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to calling
    /// ensureVisible(QRectF( *x,* *y,* *w,* *h),* *xmargin,* *ymargin).*
    /// 
    /// **Overloads**
    /// Scrolls the contents of the viewport so that the center of item *item* is
    /// visible, with margins specified in pixels by *xmargin* and *ymargin.* If
    /// the specified point cannot be reached, the contents are scrolled to the
    /// nearest valid position. The default value for both margins is 50 pixels.
    /// 
    /// **See also:** [`center_on()`]
    [org_name(ensureVisible)]
    ensure_visible_3(item: *GraphicsItemType, xmargin: i32, ymargin: i32),
    /// 
    /// Scales the view matrix and scrolls the scroll bars to ensure that the
    /// scene rectangle *rect* fits inside the viewport. *rect* must be inside
    /// the scene rect; otherwise, fitInView() cannot guarantee that the whole
    /// rect is visible.
    /// 
    /// This function keeps the view's rotation, translation, or shear. The view
    /// is scaled according to *aspectRatioMode.* *rect* will be centered in the
    /// view if it does not fit tightly.
    /// 
    /// It's common to call fitInView() from inside a reimplementation of
    /// resizeEvent(), to ensure that the whole scene, or parts of the scene,
    /// scales automatically to fit the new size of the viewport as the view is
    /// resized. Note though, that calling fitInView() from inside resizeEvent()
    /// can lead to unwanted resize recursion, if the new transformation toggles
    /// the automatic state of the scrollbars. You can toggle the scrollbar
    /// policies to always on or always off to prevent this (see
    /// horizontalScrollBarPolicy() and verticalScrollBarPolicy()).
    /// 
    /// If *rect* is empty, or if the viewport is too small, this
    /// function will do nothing.
    /// 
    /// **See also:** [`set_transform()`]
    /// [`ensure_visible()`]
    /// [`center_on()`]
    /// 
    /// Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio)
    /// 
    /// **Overloads**
    /// This convenience function is equivalent to calling
    /// fitInView(QRectF( *x,* *y,* *w,* *h),* *aspectRatioMode).*
    /// 
    /// **See also:** [`ensure_visible()`]
    /// [`center_on()`]
    /// 
    /// **Overloads**
    /// Ensures that *item* fits tightly inside the view, scaling the view
    /// according to *aspectRatioMode.*
    /// 
    /// **See also:** [`ensure_visible()`]
    /// [`center_on()`]
    fit_in_view(rect: &RectFType, aspect_radio_mode: Rute::AspectRatioMode),
    /// 
    /// Scales the view matrix and scrolls the scroll bars to ensure that the
    /// scene rectangle *rect* fits inside the viewport. *rect* must be inside
    /// the scene rect; otherwise, fitInView() cannot guarantee that the whole
    /// rect is visible.
    /// 
    /// This function keeps the view's rotation, translation, or shear. The view
    /// is scaled according to *aspectRatioMode.* *rect* will be centered in the
    /// view if it does not fit tightly.
    /// 
    /// It's common to call fitInView() from inside a reimplementation of
    /// resizeEvent(), to ensure that the whole scene, or parts of the scene,
    /// scales automatically to fit the new size of the viewport as the view is
    /// resized. Note though, that calling fitInView() from inside resizeEvent()
    /// can lead to unwanted resize recursion, if the new transformation toggles
    /// the automatic state of the scrollbars. You can toggle the scrollbar
    /// policies to always on or always off to prevent this (see
    /// horizontalScrollBarPolicy() and verticalScrollBarPolicy()).
    /// 
    /// If *rect* is empty, or if the viewport is too small, this
    /// function will do nothing.
    /// 
    /// **See also:** [`set_transform()`]
    /// [`ensure_visible()`]
    /// [`center_on()`]
    /// 
    /// Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio)
    /// 
    /// **Overloads**
    /// This convenience function is equivalent to calling
    /// fitInView(QRectF( *x,* *y,* *w,* *h),* *aspectRatioMode).*
    /// 
    /// **See also:** [`ensure_visible()`]
    /// [`center_on()`]
    /// 
    /// **Overloads**
    /// Ensures that *item* fits tightly inside the view, scaling the view
    /// according to *aspectRatioMode.*
    /// 
    /// **See also:** [`ensure_visible()`]
    /// [`center_on()`]
    [org_name(fitInView)]
    fit_in_view_2(x: f32, y: f32, w: f32, h: f32, aspect_radio_mode: Rute::AspectRatioMode),
    /// 
    /// Scales the view matrix and scrolls the scroll bars to ensure that the
    /// scene rectangle *rect* fits inside the viewport. *rect* must be inside
    /// the scene rect; otherwise, fitInView() cannot guarantee that the whole
    /// rect is visible.
    /// 
    /// This function keeps the view's rotation, translation, or shear. The view
    /// is scaled according to *aspectRatioMode.* *rect* will be centered in the
    /// view if it does not fit tightly.
    /// 
    /// It's common to call fitInView() from inside a reimplementation of
    /// resizeEvent(), to ensure that the whole scene, or parts of the scene,
    /// scales automatically to fit the new size of the viewport as the view is
    /// resized. Note though, that calling fitInView() from inside resizeEvent()
    /// can lead to unwanted resize recursion, if the new transformation toggles
    /// the automatic state of the scrollbars. You can toggle the scrollbar
    /// policies to always on or always off to prevent this (see
    /// horizontalScrollBarPolicy() and verticalScrollBarPolicy()).
    /// 
    /// If *rect* is empty, or if the viewport is too small, this
    /// function will do nothing.
    /// 
    /// **See also:** [`set_transform()`]
    /// [`ensure_visible()`]
    /// [`center_on()`]
    /// 
    /// Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio)
    /// 
    /// **Overloads**
    /// This convenience function is equivalent to calling
    /// fitInView(QRectF( *x,* *y,* *w,* *h),* *aspectRatioMode).*
    /// 
    /// **See also:** [`ensure_visible()`]
    /// [`center_on()`]
    /// 
    /// **Overloads**
    /// Ensures that *item* fits tightly inside the view, scaling the view
    /// according to *aspectRatioMode.*
    /// 
    /// **See also:** [`ensure_visible()`]
    /// [`center_on()`]
    [org_name(fitInView)]
    fit_in_view_3(item: *GraphicsItemType, aspect_radio_mode: Rute::AspectRatioMode),
    /// 
    /// These hints are
    /// used to initialize QPainter before each visible item is drawn. QPainter
    /// uses render hints to toggle rendering features such as antialiasing and
    /// smooth pixmap transformation.
    /// 
    /// QPainter::TextAntialiasing is enabled by default.
    /// 
    /// Example:
    /// 
    /// 
    /// Renders the *source* rect, which is in view coordinates, from the scene
    /// into *target,* which is in paint device coordinates, using *painter.* This function is useful for capturing the contents of the view
    /// onto a paint device, such as a QImage (e.g., to take a screenshot), or for
    /// printing to QPrinter. For example:
    /// 
    /// If *source* is a null rect, this function will use viewport()->rect() to
    /// determine what to draw. If *target* is a null rect, the full dimensions
    /// of *painter's* paint device (e.g., for a QPrinter, the page size) will be
    /// used.
    /// 
    /// The source rect contents will be transformed according to *aspectRatioMode* to fit into the target rect. By default, the aspect ratio
    /// is kept, and *source* is scaled to fit in *target.*
    /// 
    /// **See also:** [`GraphicsScene::render`]
    render(painter: *PainterType, target: &RectFType, source: &RectType, aspect_ratio_mode: Rute::AspectRatioMode),
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    items() -> [GraphicsItem?],
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    [org_name(items)]
    items_2(pos: &PointType) -> [GraphicsItem?],
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    [org_name(items)]
    items_3(x: i32, y: i32) -> [GraphicsItem?],
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    [org_name(items)]
    items_4(rect: &RectType, mode: Rute::ItemSelectionMode) -> [GraphicsItem?],
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    [org_name(items)]
    items_5(x: i32, y: i32, w: i32, h: i32, mode: Rute::ItemSelectionMode) -> [GraphicsItem?],
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    [org_name(items)]
    items_6(polygon: &PolygonType, mode: Rute::ItemSelectionMode) -> [GraphicsItem?],
    /// 
    /// Returns a list of all the items in the associated scene, in descending
    /// stacking order (i.e., the first item in the returned list is the uppermost
    /// item).
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// Returns a list of all the items at the position *pos* in the view. The
    /// items are listed in descending stacking order (i.e., the first item in the
    /// list is the uppermost item, and the last item is the lowermost item). *pos* is in viewport coordinates.
    /// 
    /// This function is most commonly called from within mouse event handlers in
    /// a subclass in QGraphicsView. *pos* is in untransformed viewport
    /// coordinates, just like QMouseEvent::pos().
    /// 
    /// **See also:** [`GraphicsScene::items`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// items(QPoint( *x,* *y)).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *rect.* *rect* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *rect* are returned.
    /// 
    /// The items are sorted in descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// This convenience function is equivalent to calling items(QRectF( *x,* *y,* *w,* *h),* *mode).*
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *polygon.* *polygon* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *polygon* are returned.
    /// 
    /// The items are sorted by descending stacking order (i.e., the first item in
    /// the returned list is the uppermost item).
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// Returns a list of all the items that, depending on *mode,* are either
    /// contained by or intersect with *path.* *path* is in viewport
    /// coordinates.
    /// 
    /// The default value for *mode* is Qt::IntersectsItemShape; all items whose
    /// exact shape intersects with or is contained by *path* are returned.
    /// 
    /// **See also:** [`item_at()`]
    /// [`items()`]
    /// [`map_to_scene()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    [org_name(items)]
    items_7(path: &PainterPathType, mode: Rute::ItemSelectionMode) -> [GraphicsItem?],
    /// 
    /// Returns the item at position *pos,* which is in viewport coordinates.
    /// If there are several items at this position, this function returns
    /// the topmost item.
    /// 
    /// Example:
    /// 
    /// **See also:** [`items()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to
    /// calling itemAt(QPoint( *x,* *y)).*
    item_at(pos: &PointType) -> GraphicsItem?,
    /// 
    /// Returns the item at position *pos,* which is in viewport coordinates.
    /// If there are several items at this position, this function returns
    /// the topmost item.
    /// 
    /// Example:
    /// 
    /// **See also:** [`items()`]
    /// {QGraphicsItem#Sorting}{Sorting}
    /// 
    /// **Overloads**
    /// This function is provided for convenience. It's equivalent to
    /// calling itemAt(QPoint( *x,* *y)).*
    [org_name(itemAt)]
    item_at_2(x: i32, y: i32) -> GraphicsItem?,
    /// 
    /// Returns the viewport coordinate *point* mapped to scene coordinates.
    /// 
    /// Note: It can be useful to map the whole rectangle covered by the pixel at
    /// *point* instead of the point itself. To do this, you can call
    /// mapToScene(QRect( *point,* QSize(2, 2))).
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QPoint( *x,* *y)).*
    /// 
    /// Returns the viewport rectangle *rect* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QRect( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the viewport polygon *polygon* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// Returns the viewport painter path *path* mapped to a scene coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_from_scene()`]
    map_to_scene(point: &PointType) -> PointF,
    /// 
    /// Returns the viewport coordinate *point* mapped to scene coordinates.
    /// 
    /// Note: It can be useful to map the whole rectangle covered by the pixel at
    /// *point* instead of the point itself. To do this, you can call
    /// mapToScene(QRect( *point,* QSize(2, 2))).
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QPoint( *x,* *y)).*
    /// 
    /// Returns the viewport rectangle *rect* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QRect( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the viewport polygon *polygon* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// Returns the viewport painter path *path* mapped to a scene coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_from_scene()`]
    [org_name(mapToScene)]
    map_to_scene_2(rect: &RectType) -> PolygonF,
    /// 
    /// Returns the viewport coordinate *point* mapped to scene coordinates.
    /// 
    /// Note: It can be useful to map the whole rectangle covered by the pixel at
    /// *point* instead of the point itself. To do this, you can call
    /// mapToScene(QRect( *point,* QSize(2, 2))).
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QPoint( *x,* *y)).*
    /// 
    /// Returns the viewport rectangle *rect* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QRect( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the viewport polygon *polygon* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// Returns the viewport painter path *path* mapped to a scene coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_from_scene()`]
    [org_name(mapToScene)]
    map_to_scene_3(polygon: &PolygonType) -> PolygonF,
    /// 
    /// Returns the viewport coordinate *point* mapped to scene coordinates.
    /// 
    /// Note: It can be useful to map the whole rectangle covered by the pixel at
    /// *point* instead of the point itself. To do this, you can call
    /// mapToScene(QRect( *point,* QSize(2, 2))).
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QPoint( *x,* *y)).*
    /// 
    /// Returns the viewport rectangle *rect* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QRect( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the viewport polygon *polygon* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// Returns the viewport painter path *path* mapped to a scene coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_from_scene()`]
    [org_name(mapToScene)]
    map_to_scene_4(path: &PainterPathType) -> PainterPath,
    /// 
    /// Returns the scene coordinate *point* to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QPointF( *x,* *y)).*
    /// 
    /// Returns the scene rectangle *rect* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QRectF( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the scene coordinate polygon *polygon* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// Returns the scene coordinate painter path *path* to a viewport coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_to_scene()`]
    map_from_scene(point: &PointFType) -> Point,
    /// 
    /// Returns the scene coordinate *point* to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QPointF( *x,* *y)).*
    /// 
    /// Returns the scene rectangle *rect* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QRectF( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the scene coordinate polygon *polygon* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// Returns the scene coordinate painter path *path* to a viewport coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_to_scene()`]
    [org_name(mapFromScene)]
    map_from_scene_2(rect: &RectFType) -> Polygon,
    /// 
    /// Returns the scene coordinate *point* to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QPointF( *x,* *y)).*
    /// 
    /// Returns the scene rectangle *rect* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QRectF( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the scene coordinate polygon *polygon* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// Returns the scene coordinate painter path *path* to a viewport coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_to_scene()`]
    [org_name(mapFromScene)]
    map_from_scene_3(polygon: &PolygonFType) -> Polygon,
    /// 
    /// Returns the scene coordinate *point* to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QPointF( *x,* *y)).*
    /// 
    /// Returns the scene rectangle *rect* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QRectF( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the scene coordinate polygon *polygon* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// Returns the scene coordinate painter path *path* to a viewport coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_to_scene()`]
    [org_name(mapFromScene)]
    map_from_scene_4(path: &PainterPathType) -> PainterPath,
    /// 
    /// Returns the viewport coordinate *point* mapped to scene coordinates.
    /// 
    /// Note: It can be useful to map the whole rectangle covered by the pixel at
    /// *point* instead of the point itself. To do this, you can call
    /// mapToScene(QRect( *point,* QSize(2, 2))).
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QPoint( *x,* *y)).*
    /// 
    /// Returns the viewport rectangle *rect* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QRect( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the viewport polygon *polygon* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// Returns the viewport painter path *path* mapped to a scene coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_from_scene()`]
    [org_name(mapToScene)]
    map_to_scene_5(x: i32, y: i32) -> PointF,
    /// 
    /// Returns the viewport coordinate *point* mapped to scene coordinates.
    /// 
    /// Note: It can be useful to map the whole rectangle covered by the pixel at
    /// *point* instead of the point itself. To do this, you can call
    /// mapToScene(QRect( *point,* QSize(2, 2))).
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QPoint( *x,* *y)).*
    /// 
    /// Returns the viewport rectangle *rect* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to calling
    /// mapToScene(QRect( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the viewport polygon *polygon* mapped to a scene coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_from_scene()`]
    /// 
    /// Returns the viewport painter path *path* mapped to a scene coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_from_scene()`]
    [org_name(mapToScene)]
    map_to_scene_6(x: i32, y: i32, w: i32, h: i32) -> PolygonF,
    /// 
    /// Returns the scene coordinate *point* to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QPointF( *x,* *y)).*
    /// 
    /// Returns the scene rectangle *rect* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QRectF( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the scene coordinate polygon *polygon* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// Returns the scene coordinate painter path *path* to a viewport coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_to_scene()`]
    [org_name(mapFromScene)]
    map_from_scene_5(x: f32, y: f32) -> Point,
    /// 
    /// Returns the scene coordinate *point* to viewport coordinates.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QPointF( *x,* *y)).*
    /// 
    /// Returns the scene rectangle *rect* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// This function is provided for convenience. It's equivalent to
    /// calling mapFromScene(QRectF( *x,* *y,* *w,* *h)).*
    /// 
    /// Returns the scene coordinate polygon *polygon* to a viewport coordinate
    /// polygon.
    /// 
    /// **See also:** [`map_to_scene()`]
    /// 
    /// Returns the scene coordinate painter path *path* to a viewport coordinate
    /// painter path.
    /// 
    /// **See also:** [`map_to_scene()`]
    [org_name(mapFromScene)]
    map_from_scene_6(x: f32, y: f32, w: f32, h: f32) -> Polygon,
    /// 
    [event] input_method_query(query: Rute::InputMethodQuery) -> Variant,
    /// 
    /// This property sets the background brush for the scene in this view. It is
    /// used to override the scene's own background, and defines the behavior of
    /// drawBackground(). To provide custom background drawing for this view, you
    /// can reimplement drawBackground() instead.
    /// 
    /// By default, this property contains a brush with the Qt::NoBrush pattern.
    /// 
    /// **See also:** [`GraphicsScene::background_brush()`]
    /// foregroundBrush
    background_brush() -> Brush,
    set_background_brush(brush: &BrushType),
    /// 
    /// This property sets the foreground brush for the scene in this view. It is
    /// used to override the scene's own foreground, and defines the behavior of
    /// drawForeground(). To provide custom foreground drawing for this view, you
    /// can reimplement drawForeground() instead.
    /// 
    /// By default, this property contains a brush with the Qt::NoBrush pattern.
    /// 
    /// **See also:** [`GraphicsScene::foreground_brush()`]
    /// backgroundBrush
    foreground_brush() -> Brush,
    set_foreground_brush(brush: &BrushType),
    /// 
    /// Schedules an update of the scene rectangles *rects.*
    /// 
    /// **See also:** [`GraphicsScene::changed`]
    /// 
    /// Notifies QGraphicsView that the scene's scene rect has changed. *rect*
    /// is the new scene rect. If the view already has an explicitly set scene
    /// rect, this function does nothing.
    /// 
    /// **See also:** sceneRect
    /// [`GraphicsScene::scene_rect_changed`]
    update_scene(rects: [RectFType]),
    /// 
    /// Invalidates and schedules a redraw of *layers* inside *rect.* *rect* is
    /// in scene coordinates. Any cached content for *layers* inside *rect* is
    /// unconditionally invalidated and redrawn.
    /// 
    /// You can call this function to notify QGraphicsView of changes to the
    /// background or the foreground of the scene. It is commonly used for scenes
    /// with tile-based backgrounds to notify changes when QGraphicsView has
    /// enabled background caching.
    /// 
    /// Note that QGraphicsView currently supports background caching only (see
    /// QGraphicsView::CacheBackground). This function is equivalent to calling update() if any
    /// layer but QGraphicsScene::BackgroundLayer is passed.
    /// 
    /// **See also:** [`GraphicsScene::invalidate`]
    /// [`update()`]
    invalidate_scene(rect: &RectFType, layers: GraphicsScene::SceneLayers),
    /// 
    /// Notifies QGraphicsView that the scene's scene rect has changed. *rect*
    /// is the new scene rect. If the view already has an explicitly set scene
    /// rect, this function does nothing.
    /// 
    /// **See also:** sceneRect
    /// [`GraphicsScene::scene_rect_changed`]
    update_scene_rect(rect: &RectFType),
    /// 
    /// This signal is emitted when the rubber band rect is changed. The viewport Rect is specified by *rubberBandRect.*
    /// The drag start position and drag end position are provided in scene points with *fromScenePoint* and *toScenePoint.*
    /// 
    /// When rubberband selection ends this signal will be emitted with null vales.
    /// 
    /// **See also:** [`rubber_band_rect()`]
    [signal] rubber_band_changed(viewport_rect: RectType, from_scene_point: PointFType, to_scene_point: PointFType),
    /// 
    /// This slot is called by QAbstractScrollArea after setViewport() has been
    /// called. Reimplement this function in a subclass of QGraphicsView to
    /// initialize the new viewport *widget* before it is used.
    /// 
    /// **See also:** [`set_viewport()`]
    [event] setup_viewport(widget: *WidgetType),
    /// 
    [event] event(event: *EventType) -> bool,
    /// 
    [event] viewport_event(event: *EventType) -> bool,
    /// 
    [event] context_menu_event(event: *ContextMenuEventType),
    /// 
    [event] drag_enter_event(event: *DragEnterEventType),
    /// 
    [event] drag_leave_event(event: *DragLeaveEventType),
    /// 
    [event] drag_move_event(event: *DragMoveEventType),
    /// 
    [event] drop_event(event: *DropEventType),
    /// 
    [event] focus_in_event(event: *FocusEventType),
    /// 
    [event] focus_next_prev_child(next: bool) -> bool,
    /// 
    [event] focus_out_event(event: *FocusEventType),
    /// 
    [event] key_press_event(event: *KeyEventType),
    /// 
    [event] key_release_event(event: *KeyEventType),
    /// 
    [event] mouse_double_click_event(event: *MouseEventType),
    /// 
    [event] mouse_press_event(event: *MouseEventType),
    /// 
    [event] mouse_move_event(event: *MouseEventType),
    /// 
    [event] mouse_release_event(event: *MouseEventType),
    /// 
    [event] wheel_event(event: *WheelEventType),
    /// 
    [event] paint_event(event: *PaintEventType),
    /// 
    [event] resize_event(event: *ResizeEventType),
    /// 
    [event] scroll_contents_by(dx: i32, dy: i32),
    /// 
    [event] show_event(event: *ShowEventType),
    /// 
    [event] input_method_event(event: *InputMethodEventType),
    /// 
    /// Draws the background of the scene using *painter,* before any items and
    /// the foreground are drawn. Reimplement this function to provide a custom
    /// background for this view.
    /// 
    /// If all you want is to define a color, texture or gradient for the
    /// background, you can call setBackgroundBrush() instead.
    /// 
    /// All painting is done in *scene* coordinates. *rect* is the exposed
    /// rectangle.
    /// 
    /// The default implementation fills *rect* using the view's backgroundBrush.
    /// If no such brush is defined (the default), the scene's drawBackground()
    /// function is called instead.
    /// 
    /// **See also:** [`draw_foreground()`]
    /// [`GraphicsScene::draw_background`]
    [event] draw_background(painter: *PainterType, rect: &RectFType),
    /// 
    /// Draws the foreground of the scene using *painter,* after the background
    /// and all items are drawn. Reimplement this function to provide a custom
    /// foreground for this view.
    /// 
    /// If all you want is to define a color, texture or gradient for the
    /// foreground, you can call setForegroundBrush() instead.
    /// 
    /// All painting is done in *scene* coordinates. *rect* is the exposed
    /// rectangle.
    /// 
    /// The default implementation fills *rect* using the view's foregroundBrush.
    /// If no such brush is defined (the default), the scene's drawForeground()
    /// function is called instead.
    /// 
    /// **See also:** [`draw_background()`]
    /// [`GraphicsScene::draw_foreground`]
    [event] draw_foreground(painter: *PainterType, rect: &RectFType),
    /// 
    /// Draws the items *items* in the scene using *painter,* after the
    /// background and before the foreground are drawn. *numItems* is the number
    /// of items in *items* and options in *options.* *options* is a list of
    /// styleoptions; one for each item. Reimplement this function to provide
    /// custom item drawing for this view.
    /// 
    /// The default implementation calls the scene's drawItems() function.
    /// 
    /// Since Qt 4.6, this function is not called anymore unless
    /// the QGraphicsView::IndirectPainting flag is given as an Optimization
    /// flag.
    /// 
    /// **See also:** [`draw_foreground()`]
    /// [`draw_background()`]
    /// [`GraphicsScene::draw_items`]
    [event] draw_items(painter: *PainterType, num_items: i32, items: *GraphicsItemType, options: StyleOptionGraphicsItemType),
}

[org_name(QGraphicsView)]
enum ViewportAnchor {
    NoAnchor,
    AnchorViewCenter,
    AnchorUnderMouse,
}

[org_name(QGraphicsView)]
enum CacheModeFlag {
    CacheNone,
    CacheBackground,
}

[org_name(QGraphicsView)]
enum DragMode {
    NoDrag,
    ScrollHandDrag,
    RubberBandDrag,
}

[org_name(QGraphicsView)]
enum ViewportUpdateMode {
    FullViewportUpdate,
    MinimalViewportUpdate,
    SmartViewportUpdate,
    NoViewportUpdate,
    BoundingRectViewportUpdate,
}

[org_name(QGraphicsView)]
enum OptimizationFlag {
    DontClipPainter,
    DontSavePainterState,
    DontAdjustForAntialiasing,
    IndirectPainting,
}

// vim: syntax=rust expandtab ts=4 sw=4
