///     \class QImage
/// 
///     \inmodule QtGui
///     \ingroup painting
///     \ingroup shared
/// 
///     \reentrant
/// 
///     \brief The QImage class provides a hardware-independent image
///     representation that allows direct access to the pixel data, and
///     can be used as a paint device.
/// 
///     Qt provides four classes for handling image data: QImage, QPixmap,
///     QBitmap and QPicture.  QImage is designed and optimized for I/O,
///     and for direct pixel access and manipulation, while QPixmap is
///     designed and optimized for showing images on screen. QBitmap is
///     only a convenience class that inherits QPixmap, ensuring a
///     depth of 1. Finally, the QPicture class is a paint device that
///     records and replays QPainter commands.
/// 
///     Because QImage is a QPaintDevice subclass, QPainter can be used to
///     draw directly onto images.  When using QPainter on a QImage, the
///     painting can be performed in another thread than the current GUI
///     thread.
/// 
///     The QImage class supports several image formats described by the
///     \l Format enum. These include monochrome, 8-bit, 32-bit and
///     alpha-blended images which are available in all versions of Qt
///     4.x.
/// 
///     QImage provides a collection of functions that can be used to
///     obtain a variety of information about the image. There are also
///     several functions that enables transformation of the image.
/// 
///     QImage objects can be passed around by value since the QImage
///     class uses \l{Implicit Data Sharing}{implicit data
///     sharing}. QImage objects can also be streamed and compared.
/// 
///     \note If you would like to load QImage objects in a static build of Qt,
///     refer to the \l{How to Create Qt Plugins}{Plugin HowTo}.
/// 
///     \warning Painting on a QImage with the format
///     QImage::Format_Indexed8 is not supported.
/// 
///     \tableofcontents
/// 
///     \section1 Reading and Writing Image Files
/// 
///     QImage provides several ways of loading an image file: The file
///     can be loaded when constructing the QImage object, or by using the
///     load() or loadFromData() functions later on. QImage also provides
///     the static fromData() function, constructing a QImage from the
///     given data.  When loading an image, the file name can either refer
///     to an actual file on disk or to one of the application's embedded
///     resources. See \l{The Qt Resource System} overview for details
///     on how to embed images and other resource files in the
///     application's executable.
/// 
///     Simply call the save() function to save a QImage object.
/// 
///     The complete list of supported file formats are available through
///     the QImageReader::supportedImageFormats() and
///     QImageWriter::supportedImageFormats() functions. New file formats
///     can be added as plugins. By default, Qt supports the following
///     formats:
/// 
///     \table
///     \header \li Format \li Description                      \li Qt's support
///     \row    \li BMP    \li Windows Bitmap                   \li Read/write
///     \row    \li GIF    \li Graphic Interchange Format (optional) \li Read
///     \row    \li JPG    \li Joint Photographic Experts Group \li Read/write
///     \row    \li JPEG   \li Joint Photographic Experts Group \li Read/write
///     \row    \li PNG    \li Portable Network Graphics        \li Read/write
///     \row    \li PBM    \li Portable Bitmap                  \li Read
///     \row    \li PGM    \li Portable Graymap                 \li Read
///     \row    \li PPM    \li Portable Pixmap                  \li Read/write
///     \row    \li XBM    \li X11 Bitmap                       \li Read/write
///     \row    \li XPM    \li X11 Pixmap                       \li Read/write
///     \endtable
/// 
///     \section1 Image Information
/// 
///     QImage provides a collection of functions that can be used to
///     obtain a variety of information about the image:
/// 
///     \table
///     \header
///     \li \li Available Functions
/// 
///     \row
///     \li Geometry
///     \li
/// 
///     The size(), width(), height(), dotsPerMeterX(), and
///     dotsPerMeterY() functions provide information about the image size
///     and aspect ratio.
/// 
///     The rect() function returns the image's enclosing rectangle. The
///     valid() function tells if a given pair of coordinates is within
///     this rectangle. The offset() function returns the number of pixels
///     by which the image is intended to be offset by when positioned
///     relative to other images, which also can be manipulated using the
///     setOffset() function.
/// 
///     \row
///     \li Colors
///     \li
/// 
///     The color of a pixel can be retrieved by passing its coordinates
///     to the pixel() function.  The pixel() function returns the color
///     as a QRgb value indepedent of the image's format.
/// 
///     In case of monochrome and 8-bit images, the colorCount() and
///     colorTable() functions provide information about the color
///     components used to store the image data: The colorTable() function
///     returns the image's entire color table. To obtain a single entry,
///     use the pixelIndex() function to retrieve the pixel index for a
///     given pair of coordinates, then use the color() function to
///     retrieve the color. Note that if you create an 8-bit image
///     manually, you have to set a valid color table on the image as
///     well.
/// 
///     The hasAlphaChannel() function tells if the image's format
///     respects the alpha channel, or not. The allGray() and
///     isGrayscale() functions tell whether an image's colors are all
///     shades of gray.
/// 
///     See also the \l {QImage#Pixel Manipulation}{Pixel Manipulation}
///     and \l {QImage#Image Transformations}{Image Transformations}
///     sections.
/// 
///     \row
///     \li Text
///     \li
/// 
///     The text() function returns the image text associated with the
///     given text key. An image's text keys can be retrieved using the
///     textKeys() function. Use the setText() function to alter an
///     image's text.
/// 
///     \row
///     \li Low-level information
///     \li
/// 
///     The depth() function returns the depth of the image. The supported
///     depths are 1 (monochrome), 8, 16, 24 and 32 bits. The
///     bitPlaneCount() function tells how many of those bits that are
///     used. For more information see the
///     \l {QImage#Image Formats}{Image Formats} section.
/// 
///     The format(), bytesPerLine(), and sizeInBytes() functions provide
///     low-level information about the data stored in the image.
/// 
///     The cacheKey() function returns a number that uniquely
///     identifies the contents of this QImage object.
///     \endtable
/// 
///     \section1 Pixel Manipulation
/// 
///     The functions used to manipulate an image's pixels depend on the
///     image format. The reason is that monochrome and 8-bit images are
///     index-based and use a color lookup table, while 32-bit images
///     store ARGB values directly. For more information on image formats,
///     see the \l {Image Formats} section.
/// 
///     In case of a 32-bit image, the setPixel() function can be used to
///     alter the color of the pixel at the given coordinates to any other
///     color specified as an ARGB quadruplet. To make a suitable QRgb
///     value, use the qRgb() (adding a default alpha component to the
///     given RGB values, i.e. creating an opaque color) or qRgba()
///     function. For example:
/// 
///     \table
///     \header
///     \li {2,1}32-bit
///     \row
///     \li \inlineimage qimage-32bit_scaled.png
///     \li
///     \snippet code/src_gui_image_qimage.cpp 0
///     \endtable
/// 
///     In case of a 8-bit and monchrome images, the pixel value is only
///     an index from the image's color table. So the setPixel() function
///     can only be used to alter the color of the pixel at the given
///     coordinates to a predefined color from the image's color table,
///     i.e. it can only change the pixel's index value. To alter or add a
///     color to an image's color table, use the setColor() function.
/// 
///     An entry in the color table is an ARGB quadruplet encoded as an
///     QRgb value. Use the qRgb() and qRgba() functions to make a
///     suitable QRgb value for use with the setColor() function. For
///     example:
/// 
///     \table
///     \header
///     \li {2,1} 8-bit
///     \row
///     \li \inlineimage qimage-8bit_scaled.png
///     \li
///     \snippet code/src_gui_image_qimage.cpp 1
///     \endtable
/// 
///     For images with more than 8-bit per color-channel. The methods
///     setPixelColor() and pixelColor() can be used to set and get
///     with QColor values.
/// 
///     QImage also provide the scanLine() function which returns a
///     pointer to the pixel data at the scanline with the given index,
///     and the bits() function which returns a pointer to the first pixel
///     data (this is equivalent to \c scanLine(0)).
/// 
///     \section1 Image Formats
/// 
///     Each pixel stored in a QImage is represented by an integer. The
///     size of the integer varies depending on the format. QImage
///     supports several image formats described by the \l Format
///     enum.
/// 
///     Monochrome images are stored using 1-bit indexes into a color table
///     with at most two colors. There are two different types of
///     monochrome images: big endian (MSB first) or little endian (LSB
///     first) bit order.
/// 
///     8-bit images are stored using 8-bit indexes into a color table,
///     i.e.  they have a single byte per pixel. The color table is a
///     QVector<QRgb>, and the QRgb typedef is equivalent to an unsigned
///     int containing an ARGB quadruplet on the format 0xAARRGGBB.
/// 
///     32-bit images have no color table; instead, each pixel contains an
///     QRgb value. There are three different types of 32-bit images
///     storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB
///     values respectively. In the premultiplied format the red, green,
///     and blue channels are multiplied by the alpha component divided by
///     255.
/// 
///     An image's format can be retrieved using the format()
///     function. Use the convertToFormat() functions to convert an image
///     into another format. The allGray() and isGrayscale() functions
///     tell whether a color image can safely be converted to a grayscale
///     image.
/// 
///     \section1 Image Transformations
/// 
///     QImage supports a number of functions for creating a new image
///     that is a transformed version of the original: The
///     createAlphaMask() function builds and returns a 1-bpp mask from
///     the alpha buffer in this image, and the createHeuristicMask()
///     function creates and returns a 1-bpp heuristic mask for this
///     image. The latter function works by selecting a color from one of
///     the corners, then chipping away pixels of that color starting at
///     all the edges.
/// 
///     The mirrored() function returns a mirror of the image in the
///     desired direction, the scaled() returns a copy of the image scaled
///     to a rectangle of the desired measures, and the rgbSwapped() function
///     constructs a BGR image from a RGB image.
/// 
///     The scaledToWidth() and scaledToHeight() functions return scaled
///     copies of the image.
/// 
///     The transformed() function returns a copy of the image that is
///     transformed with the given transformation matrix and
///     transformation mode: Internally, the transformation matrix is
///     adjusted to compensate for unwanted translation,
///     i.e. transformed() returns the smallest image containing all
///     transformed points of the original image. The static trueMatrix()
///     function returns the actual matrix used for transforming the
///     image.
/// 
///     There are also functions for changing attributes of an image
///     in-place:
/// 
///     \table
///     \header \li Function \li Description
///     \row
///     \li setDotsPerMeterX()
///     \li Defines the aspect ratio by setting the number of pixels that fit
///     horizontally in a physical meter.
///     \row
///     \li setDotsPerMeterY()
///     \li Defines the aspect ratio by setting the number of pixels that fit
///     vertically in a physical meter.
///     \row
///     \li fill()
///     \li Fills the entire image with the given pixel value.
///     \row
///     \li invertPixels()
///     \li Inverts all pixel values in the image using the given InvertMode value.
///     \row
///     \li setColorTable()
///     \li Sets the color table used to translate color indexes. Only
///     monochrome and 8-bit formats.
///     \row
///     \li setColorCount()
///     \li Resizes the color table. Only monochrome and 8-bit formats.
/// 
///     \endtable
/// 
///     \sa QImageReader, QImageWriter, QPixmap, QSvgRenderer, {Image Composition Example},
///         {Image Viewer Example}, {Scribble Example}, {Pixelator Example}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QImage)]
enum InvertMode {
    InvertRgb,
    InvertRgba,
}

[org_name(QImage)]
enum Format {
    Format_Invalid,
    Format_Mono,
    Format_MonoLSB,
    Format_Indexed8,
    Format_RGB32,
    Format_ARGB32,
    Format_ARGB32_Premultiplied,
    Format_RGB16,
    Format_ARGB8565_Premultiplied,
    Format_RGB666,
    Format_ARGB6666_Premultiplied,
    Format_RGB555,
    Format_ARGB8555_Premultiplied,
    Format_RGB888,
    Format_RGB444,
    Format_ARGB4444_Premultiplied,
    Format_RGBX8888,
    Format_RGBA8888,
    Format_RGBA8888_Premultiplied,
    Format_BGR30,
    Format_A2BGR30_Premultiplied,
    Format_RGB30,
    Format_A2RGB30_Premultiplied,
    Format_Alpha8,
    Format_Grayscale8,
    NImageFormats,
}

struct Image : PaintDevice {
    swap(other: &ImageType),
    ///     \fn bool QImage::isNull() const
    /// 
    ///     Returns \c true if it is a null image, otherwise returns \c false.
    /// 
    ///     A null image has all parameters set to zero and no allocated data.
    is_null() -> bool,
    ///   \internal
    [event] dev_type() -> i32,
    ///     \internal
    /// 
    ///     If multiple images share common data, this image makes a copy of
    ///     the data and detaches itself from the sharing mechanism, making
    ///     sure that this image is the only one referring to the data.
    /// 
    ///     Nothing is done if there is just a single reference.
    /// 
    ///     \sa copy(), {QImage::isDetached()}{isDetached()}, {Implicit Data Sharing}
    detach(),
    ///     \internal
    /// 
    ///     Returns \c true if the image is detached; otherwise returns \c false.
    /// 
    ///     \sa detach(), {Implicit Data Sharing}
    is_detached() -> bool,
    ///     \fn QImage QImage::copy(const QRect& rectangle) const
    /// 
    ///     Returns a sub-area of the image as a new image.
    /// 
    ///     The returned image is copied from the position (\a
    ///     {rectangle}.x(), \a{rectangle}.y()) in this image, and will always
    ///     have the size of the given \a rectangle.
    /// 
    ///     In areas beyond this image, pixels are set to 0. For 32-bit RGB
    ///     images, this means black; for 32-bit ARGB images, this means
    ///     transparent black; for 8-bit images, this means the color with
    ///     index 0 in the color table which can be anything; for 1-bit
    ///     images, this means Qt::color0.
    /// 
    ///     If the given \a rectangle is a null rectangle the entire image is
    ///     copied.
    /// 
    ///     \sa QImage()
    copy(rect: &RectType) -> Image,
    ///     \fn QImage QImage::copy(const QRect& rectangle) const
    /// 
    ///     Returns a sub-area of the image as a new image.
    /// 
    ///     The returned image is copied from the position (\a
    ///     {rectangle}.x(), \a{rectangle}.y()) in this image, and will always
    ///     have the size of the given \a rectangle.
    /// 
    ///     In areas beyond this image, pixels are set to 0. For 32-bit RGB
    ///     images, this means black; for 32-bit ARGB images, this means
    ///     transparent black; for 8-bit images, this means the color with
    ///     index 0 in the color table which can be anything; for 1-bit
    ///     images, this means Qt::color0.
    /// 
    ///     If the given \a rectangle is a null rectangle the entire image is
    ///     copied.
    /// 
    ///     \sa QImage()
    copy(x: i32, y: i32, w: i32, h: i32) -> Image,
    ///     Returns the format of the image.
    /// 
    ///     \sa {QImage#Image Formats}{Image Formats}
    format() -> Image::Format,
    ///     \overload
    /// 
    ///     Returns a copy of the image converted to the given \a format,
    ///     using the specified \a colorTable.
    /// 
    ///     Conversion from RGB formats to indexed formats is a slow operation
    ///     and will use a straightforward nearest color approach, with no
    ///     dithering.
    convert_to_format(f: Image::Format, flags: Rute::ImageConversionFlags) -> Image,
    ///     \overload
    /// 
    ///     Returns a copy of the image converted to the given \a format,
    ///     using the specified \a colorTable.
    /// 
    ///     Conversion from RGB formats to indexed formats is a slow operation
    ///     and will use a straightforward nearest color approach, with no
    ///     dithering.
    convert_to_format(f: Image::Format, flags: Rute::ImageConversionFlags) -> Image,
    ///     \overload
    /// 
    ///     Returns a copy of the image converted to the given \a format,
    ///     using the specified \a colorTable.
    /// 
    ///     Conversion from RGB formats to indexed formats is a slow operation
    ///     and will use a straightforward nearest color approach, with no
    ///     dithering.
    convert_to_format(f: Image::Format, color_table: [RgbType], flags: Rute::ImageConversionFlags) -> Image,
    ///     \since 5.9
    /// 
    ///     Changes the format of the image to \a format without changing the
    ///     data. Only works between formats of the same depth.
    /// 
    ///     Returns \c true if successful.
    /// 
    ///     This function can be used to change images with alpha-channels to
    ///     their corresponding opaque formats if the data is known to be opaque-only,
    ///     or to change the format of a given image buffer before overwriting
    ///     it with new data.
    /// 
    ///     \warning The function does not check if the image data is valid in the
    ///     new format and will still return \c true if the depths are compatible.
    ///     Operations on an image with invalid data are undefined.
    /// 
    ///     \warning If the image is not detached, this will cause the data to be
    ///     copied.
    /// 
    ///     \sa hasAlphaChannel(), convertToFormat()
    reinterpret_as_format(f: Image::Format) -> bool,
    ///     \fn int QImage::width() const
    /// 
    ///     Returns the width of the image.
    /// 
    ///     \sa {QImage#Image Information}{Image Information}
    width() -> i32,
    ///     \fn int QImage::height() const
    /// 
    ///     Returns the height of the image.
    /// 
    ///     \sa {QImage#Image Information}{Image Information}
    height() -> i32,
    ///     \fn QSize QImage::size() const
    /// 
    ///     Returns the size of the image, i.e. its width() and height().
    /// 
    ///     \sa {QImage#Image Information}{Image Information}
    size() -> Size,
    ///     \fn QRect QImage::rect() const
    /// 
    ///     Returns the enclosing rectangle (0, 0, width(), height()) of the
    ///     image.
    /// 
    ///     \sa {QImage#Image Information}{Image Information}
    rect() -> Rect,
    ///     Returns the depth of the image.
    /// 
    ///     The image depth is the number of bits used to store a single
    ///     pixel, also called bits per pixel (bpp).
    /// 
    ///     The supported depths are 1, 8, 16, 24 and 32.
    /// 
    ///     \sa bitPlaneCount(), convertToFormat(), {QImage#Image Formats}{Image Formats},
    ///     {QImage#Image Information}{Image Information}
    /// 
    depth() -> i32,
    ///     \since 4.6
    ///     \fn int QImage::colorCount() const
    /// 
    ///     Returns the size of the color table for the image.
    /// 
    ///     Notice that colorCount() returns 0 for 32-bpp images because these
    ///     images do not use color tables, but instead encode pixel values as
    ///     ARGB quadruplets.
    /// 
    ///     \sa setColorCount(), {QImage#Image Information}{Image Information}
    color_count() -> i32,
    ///     \since 4.7
    ///     Returns the number of bit planes in the image.
    /// 
    ///     The number of bit planes is the number of bits of color and
    ///     transparency information for each pixel. This is different from
    ///     (i.e. smaller than) the depth when the image format contains
    ///     unused bits.
    /// 
    ///     \sa depth(), format(), {QImage#Image Formats}{Image Formats}
    bit_plane_count() -> i32,
    ///     Returns the color in the color table at index \a i. The first
    ///     color is at index 0.
    /// 
    ///     The colors in an image's color table are specified as ARGB
    ///     quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and
    ///     qBlue() functions to get the color value components.
    /// 
    ///     \sa setColor(), pixelIndex(), {QImage#Pixel Manipulation}{Pixel
    ///     Manipulation}
    color(i: i32) -> Rgb,
    ///     \fn void QImage::setColor(int index, QRgb colorValue)
    /// 
    ///     Sets the color at the given \a index in the color table, to the
    ///     given to \a colorValue. The color value is an ARGB quadruplet.
    /// 
    ///     If \a index is outside the current size of the color table, it is
    ///     expanded with setColorCount().
    /// 
    ///     \sa color(), colorCount(), setColorTable(), {QImage#Pixel Manipulation}{Pixel
    ///     Manipulation}
    set_color(i: i32, c: RgbType),
    ///     \since 4.6
    ///     Resizes the color table to contain \a colorCount entries.
    /// 
    ///     If the color table is expanded, all the extra colors will be set to
    ///     transparent (i.e qRgba(0, 0, 0, 0)).
    /// 
    ///     When the image is used, the color table must be large enough to
    ///     have entries for all the pixel/index values present in the image,
    ///     otherwise the results are undefined.
    /// 
    ///     \sa colorCount(), colorTable(), setColor(), {QImage#Image
    ///     Transformations}{Image Transformations}
    set_color_count(arg0: i32),
    ///     Returns \c true if all the colors in the image are shades of gray
    ///     (i.e. their red, green and blue components are equal); otherwise
    ///     false.
    /// 
    ///     Note that this function is slow for images without color table.
    /// 
    ///     \sa isGrayscale()
    all_gray() -> bool,
    ///     For 32-bit images, this function is equivalent to allGray().
    /// 
    ///     For color indexed images, this function returns \c true if
    ///     color(i) is QRgb(i, i, i) for all indexes of the color table;
    ///     otherwise returns \c false.
    /// 
    ///     \sa allGray(), {QImage#Image Formats}{Image Formats}
    is_grayscale() -> bool,
    ///     \overload
    /// 
    ///     Note that QImage uses \l{Implicit Data Sharing} {implicit data
    ///     sharing}, but this function does \e not perform a deep copy of the
    ///     shared pixel data, because the returned data is const.
    bits() -> uchar?,
    ///     \overload
    /// 
    ///     Note that QImage uses \l{Implicit Data Sharing} {implicit data
    ///     sharing}, but this function does \e not perform a deep copy of the
    ///     shared pixel data, because the returned data is const.
    bits() -> uchar?,
    ///     Returns a pointer to the first pixel data.
    /// 
    ///     Note that QImage uses \l{Implicit Data Sharing} {implicit data
    ///     sharing}, but this function does \e not perform a deep copy of the
    ///     shared pixel data, because the returned data is const.
    /// 
    ///     \sa bits(), constScanLine()
    ///     \since 4.7
    const_bits() -> uchar?,
    ///     \since 4.6
    ///     \obsolete
    ///     Returns the number of bytes occupied by the image data.
    /// 
    ///     Note this method should never be called on an image larger than 2 gigabytes.
    ///     Instead use sizeInBytes().
    /// 
    ///     \sa sizeInBytes(), bytesPerLine(), bits(), {QImage#Image Information}{Image
    ///     Information}
    byte_count() -> i32,
    ///     \since 5.10
    ///     Returns the image data size in bytes.
    /// 
    ///     \sa byteCount(), bytesPerLine(), bits(), {QImage#Image Information}{Image
    ///     Information}
    size_in_bytes() -> i32,
    ///     \overload
    scan_line(arg0: i32) -> uchar?,
    ///     \overload
    scan_line(arg0: i32) -> uchar?,
    ///     Returns a pointer to the pixel data at the scanline with index \a
    ///     i. The first scanline is at index 0.
    /// 
    ///     The scanline data is aligned on a 32-bit boundary.
    /// 
    ///     Note that QImage uses \l{Implicit Data Sharing} {implicit data
    ///     sharing}, but this function does \e not perform a deep copy of the
    ///     shared pixel data, because the returned data is const.
    /// 
    ///     \sa scanLine(), constBits()
    ///     \since 4.7
    const_scan_line(arg0: i32) -> uchar?,
    ///     Returns the number of bytes per image scanline.
    /// 
    ///     This is equivalent to sizeInBytes() / height() if height() is non-zero.
    /// 
    ///     \sa scanLine()
    bytes_per_line() -> i32,
    ///     \overload
    /// 
    ///     Returns \c true if QPoint(\a x, \a y) is a valid coordinate pair
    ///     within the image; otherwise returns \c false.
    valid(x: i32, y: i32) -> bool,
    ///     \overload
    /// 
    ///     Returns \c true if QPoint(\a x, \a y) is a valid coordinate pair
    ///     within the image; otherwise returns \c false.
    valid(pt: &PointType) -> bool,
    ///     \overload
    /// 
    ///     Returns the pixel index at (\a x, \a y).
    pixel_index(x: i32, y: i32) -> i32,
    ///     \overload
    /// 
    ///     Returns the pixel index at (\a x, \a y).
    pixel_index(pt: &PointType) -> i32,
    ///     \overload
    /// 
    ///     Returns the color of the pixel at coordinates (\a x, \a y).
    pixel(x: i32, y: i32) -> Rgb,
    ///     \overload
    /// 
    ///     Returns the color of the pixel at coordinates (\a x, \a y).
    pixel(pt: &PointType) -> Rgb,
    ///     \overload
    /// 
    ///     Sets the pixel index or color at (\a x, \a y) to \a index_or_rgb.
    set_pixel(x: i32, y: i32, index_or_rgb: uint),
    ///     \overload
    /// 
    ///     Sets the pixel index or color at (\a x, \a y) to \a index_or_rgb.
    set_pixel(pt: &PointType, index_or_rgb: uint),
    ///     \overload
    ///     \since 5.6
    /// 
    ///     Returns the color of the pixel at coordinates (\a x, \a y) as a QColor.
    pixel_color(x: i32, y: i32) -> Color,
    ///     \overload
    ///     \since 5.6
    /// 
    ///     Returns the color of the pixel at coordinates (\a x, \a y) as a QColor.
    pixel_color(pt: &PointType) -> Color,
    ///     \overload
    ///     \since 5.6
    /// 
    ///     Sets the pixel color at (\a x, \a y) to \a color.
    set_pixel_color(x: i32, y: i32, c: &ColorType),
    ///     \overload
    ///     \since 5.6
    /// 
    ///     Sets the pixel color at (\a x, \a y) to \a color.
    set_pixel_color(pt: &PointType, c: &ColorType),
    ///     Returns a list of the colors contained in the image's color table,
    ///     or an empty list if the image does not have a color table
    /// 
    ///     \sa setColorTable(), colorCount(), color()
    color_table() -> [Rgb],
    ///     Sets the color table used to translate color indexes to QRgb
    ///     values, to the specified \a colors.
    /// 
    ///     When the image is used, the color table must be large enough to
    ///     have entries for all the pixel/index values present in the image,
    ///     otherwise the results are undefined.
    /// 
    ///     \sa colorTable(), setColor(), {QImage#Image Transformations}{Image
    ///     Transformations}
    set_color_table(colors: [RgbType]),
    ///     Returns the device pixel ratio for the image. This is the
    ///     ratio between \e{device pixels} and \e{device independent pixels}.
    /// 
    ///     Use this function when calculating layout geometry based on
    ///     the image size: QSize layoutSize = image.size() / image.devicePixelRatio()
    /// 
    ///     The default value is 1.0.
    /// 
    ///     \sa setDevicePixelRatio(), QImageReader
    device_pixel_ratio() -> f32,
    ///     Sets the device pixel ratio for the image. This is the
    ///     ratio between image pixels and device-independent pixels.
    /// 
    ///     The default \a scaleFactor is 1.0. Setting it to something else has
    ///     two effects:
    /// 
    ///     QPainters that are opened on the image will be scaled. For
    ///     example, painting on a 200x200 image if with a ratio of 2.0
    ///     will result in effective (device-independent) painting bounds
    ///     of 100x100.
    /// 
    ///     Code paths in Qt that calculate layout geometry based on the
    ///     image size will take the ratio into account:
    ///     QSize layoutSize = image.size() / image.devicePixelRatio()
    ///     The net effect of this is that the image is displayed as
    ///     high-DPI image rather than a large image
    ///     (see \l{Drawing High Resolution Versions of Pixmaps and Images}).
    /// 
    ///     \sa devicePixelRatio()
    set_device_pixel_ratio(scale_factor: f32),
    ///     \fn void QImage::fill(const QColor &color)
    /// 
    ///     \overload
    /// 
    ///     Fills the entire image with the given \a color.
    /// 
    ///     If the depth of the image is 1, the image will be filled with 1 if
    ///     \a color equals Qt::color1; it will otherwise be filled with 0.
    /// 
    ///     If the depth of the image is 8, the image will be filled with the
    ///     index corresponding the \a color in the color table if present; it
    ///     will otherwise be filled with 0.
    /// 
    ///     \since 4.8
    fill(pixel: uint),
    ///     \fn void QImage::fill(const QColor &color)
    /// 
    ///     \overload
    /// 
    ///     Fills the entire image with the given \a color.
    /// 
    ///     If the depth of the image is 1, the image will be filled with 1 if
    ///     \a color equals Qt::color1; it will otherwise be filled with 0.
    /// 
    ///     If the depth of the image is 8, the image will be filled with the
    ///     index corresponding the \a color in the color table if present; it
    ///     will otherwise be filled with 0.
    /// 
    ///     \since 4.8
    fill(color: &ColorType),
    ///     \fn void QImage::fill(const QColor &color)
    /// 
    ///     \overload
    /// 
    ///     Fills the entire image with the given \a color.
    /// 
    ///     If the depth of the image is 1, the image will be filled with 1 if
    ///     \a color equals Qt::color1; it will otherwise be filled with 0.
    /// 
    ///     If the depth of the image is 8, the image will be filled with the
    ///     index corresponding the \a color in the color table if present; it
    ///     will otherwise be filled with 0.
    /// 
    ///     \since 4.8
    fill(color: Rute::GlobalColor),
    ///     Returns \c true if the image has a format that respects the alpha
    ///     channel, otherwise returns \c false.
    /// 
    ///     \sa {QImage#Image Information}{Image Information}
    has_alpha_channel() -> bool,
    ///     \obsolete
    ///     Sets the alpha channel of this image to the given \a alphaChannel.
    /// 
    ///     If \a alphaChannel is an 8 bit grayscale image, the intensity values are
    ///     written into this buffer directly. Otherwise, \a alphaChannel is converted
    ///     to 32 bit and the intensity of the RGB pixel values is used.
    /// 
    ///     Note that the image will be converted to the Format_ARGB32_Premultiplied
    ///     format if the function succeeds.
    /// 
    ///     Use one of the composition modes in QPainter::CompositionMode instead.
    /// 
    ///     \warning This function is expensive.
    /// 
    ///     \sa alphaChannel(), {QImage#Image Transformations}{Image
    ///     Transformations}, {QImage#Image Formats}{Image Formats}
    set_alpha_channel(alpha_channel: &ImageType),
    ///     \obsolete
    /// 
    ///     Returns the alpha channel of the image as a new grayscale QImage in which
    ///     each pixel's red, green, and blue values are given the alpha value of the
    ///     original image. The color depth of the returned image is 8-bit.
    /// 
    ///     You can see an example of use of this function in QPixmap's
    ///     \l{QPixmap::}{alphaChannel()}, which works in the same way as
    ///     this function on QPixmaps.
    /// 
    ///     Most usecases for this function can be replaced with QPainter and
    ///     using composition modes.
    /// 
    ///     Note this returns a color-indexed image if you want the alpha channel in
    ///     the alpha8 format instead use convertToFormat(Format_Alpha8) on the source
    ///     image.
    /// 
    ///     \warning This is an expensive function.
    /// 
    ///     \sa setAlphaChannel(), hasAlphaChannel(), convertToFormat(),
    ///     {QPixmap#Pixmap Information}{Pixmap},
    ///     {QImage#Image Transformations}{Image Transformations}
    alpha_channel() -> Image,
    ///     Builds and returns a 1-bpp mask from the alpha buffer in this
    ///     image. Returns a null image if the image's format is
    ///     QImage::Format_RGB32.
    /// 
    ///     The \a flags argument is a bitwise-OR of the
    ///     Qt::ImageConversionFlags, and controls the conversion
    ///     process. Passing 0 for flags sets all the default options.
    /// 
    ///     The returned image has little-endian bit order (i.e. the image's
    ///     format is QImage::Format_MonoLSB), which you can convert to
    ///     big-endian (QImage::Format_Mono) using the convertToFormat()
    ///     function.
    /// 
    ///     \sa createHeuristicMask(), {QImage#Image Transformations}{Image
    ///     Transformations}
    create_alpha_mask(flags: Rute::ImageConversionFlags) -> Image,
    ///     Creates and returns a 1-bpp heuristic mask for this image.
    /// 
    ///     The function works by selecting a color from one of the corners,
    ///     then chipping away pixels of that color starting at all the edges.
    ///     The four corners vote for which color is to be masked away. In
    ///     case of a draw (this generally means that this function is not
    ///     applicable to the image), the result is arbitrary.
    /// 
    ///     The returned image has little-endian bit order (i.e. the image's
    ///     format is QImage::Format_MonoLSB), which you can convert to
    ///     big-endian (QImage::Format_Mono) using the convertToFormat()
    ///     function.
    /// 
    ///     If \a clipTight is true (the default) the mask is just large
    ///     enough to cover the pixels; otherwise, the mask is larger than the
    ///     data pixels.
    /// 
    ///     Note that this function disregards the alpha buffer.
    /// 
    ///     \sa createAlphaMask(), {QImage#Image Transformations}{Image
    ///     Transformations}
    create_heuristic_mask(clip_tight: bool) -> Image,
    ///     Creates and returns a mask for this image based on the given \a
    ///     color value. If the \a mode is MaskInColor (the default value),
    ///     all pixels matching \a color will be opaque pixels in the mask. If
    ///     \a mode is MaskOutColor, all pixels matching the given color will
    ///     be transparent.
    /// 
    ///     \sa createAlphaMask(), createHeuristicMask()
    create_mask_from_color(color: RgbType, mode: Rute::MaskMode) -> Image,
    ///     \fn QImage QImage::scaled(const QSize &size, Qt::AspectRatioMode aspectRatioMode,
    ///                              Qt::TransformationMode transformMode) const
    /// 
    ///     Returns a copy of the image scaled to a rectangle defined by the
    ///     given \a size according to the given \a aspectRatioMode and \a
    ///     transformMode.
    /// 
    ///     \image qimage-scaling.png
    /// 
    ///     \list
    ///     \li If \a aspectRatioMode is Qt::IgnoreAspectRatio, the image
    ///        is scaled to \a size.
    ///     \li If \a aspectRatioMode is Qt::KeepAspectRatio, the image is
    ///        scaled to a rectangle as large as possible inside \a size, preserving the aspect ratio.
    ///     \li If \a aspectRatioMode is Qt::KeepAspectRatioByExpanding,
    ///        the image is scaled to a rectangle as small as possible
    ///        outside \a size, preserving the aspect ratio.
    ///     \endlist
    /// 
    ///     If the given \a size is empty, this function returns a null image.
    /// 
    ///     \sa isNull(), {QImage#Image Transformations}{Image
    ///     Transformations}
    scaled(w: i32, h: i32, aspect_mode: Rute::AspectRatioMode, mode: Rute::TransformationMode) -> Image,
    ///     \fn QImage QImage::scaled(const QSize &size, Qt::AspectRatioMode aspectRatioMode,
    ///                              Qt::TransformationMode transformMode) const
    /// 
    ///     Returns a copy of the image scaled to a rectangle defined by the
    ///     given \a size according to the given \a aspectRatioMode and \a
    ///     transformMode.
    /// 
    ///     \image qimage-scaling.png
    /// 
    ///     \list
    ///     \li If \a aspectRatioMode is Qt::IgnoreAspectRatio, the image
    ///        is scaled to \a size.
    ///     \li If \a aspectRatioMode is Qt::KeepAspectRatio, the image is
    ///        scaled to a rectangle as large as possible inside \a size, preserving the aspect ratio.
    ///     \li If \a aspectRatioMode is Qt::KeepAspectRatioByExpanding,
    ///        the image is scaled to a rectangle as small as possible
    ///        outside \a size, preserving the aspect ratio.
    ///     \endlist
    /// 
    ///     If the given \a size is empty, this function returns a null image.
    /// 
    ///     \sa isNull(), {QImage#Image Transformations}{Image
    ///     Transformations}
    scaled(s: &SizeType, aspect_mode: Rute::AspectRatioMode, mode: Rute::TransformationMode) -> Image,
    ///     \fn QImage QImage::scaledToWidth(int width, Qt::TransformationMode mode) const
    /// 
    ///     Returns a scaled copy of the image. The returned image is scaled
    ///     to the given \a width using the specified transformation \a
    ///     mode.
    /// 
    ///     This function automatically calculates the height of the image so
    ///     that its aspect ratio is preserved.
    /// 
    ///     If the given \a width is 0 or negative, a null image is returned.
    /// 
    ///     \sa {QImage#Image Transformations}{Image Transformations}
    scaled_to_width(w: i32, mode: Rute::TransformationMode) -> Image,
    ///     \fn QImage QImage::scaledToHeight(int height, Qt::TransformationMode mode) const
    /// 
    ///     Returns a scaled copy of the image. The returned image is scaled
    ///     to the given \a height using the specified transformation \a
    ///     mode.
    /// 
    ///     This function automatically calculates the width of the image so that
    ///     the ratio of the image is preserved.
    /// 
    ///     If the given \a height is 0 or negative, a null image is returned.
    /// 
    ///     \sa {QImage#Image Transformations}{Image Transformations}
    scaled_to_height(h: i32, mode: Rute::TransformationMode) -> Image,
    mirrored(horizontally: bool, vertically: bool) -> Image,
    mirrored(horizontally: bool, vertically: bool) -> Image?,
    rgb_swapped() -> Image,
    rgb_swapped() -> Image?,
    ///     Inverts all pixel values in the image.
    /// 
    ///     The given invert \a mode only have a meaning when the image's
    ///     depth is 32. The default \a mode is InvertRgb, which leaves the
    ///     alpha channel unchanged. If the \a mode is InvertRgba, the alpha
    ///     bits are also inverted.
    /// 
    ///     Inverting an 8-bit image means to replace all pixels using color
    ///     index \e i with a pixel using color index 255 minus \e i. The same
    ///     is the case for a 1-bit image. Note that the color table is \e not
    ///     changed.
    /// 
    ///     If the image has a premultiplied alpha channel, the image is first
    ///     converted to ARGB32 to be inverted and then converted back.
    /// 
    ///     \sa {QImage#Image Transformations}{Image Transformations}
    invert_pixels(arg0: Image::InvertMode),
    ///     \overload
    /// 
    ///     This function reads a QImage from the given \a device. This can,
    ///     for example, be used to load an image directly into a QByteArray.
    load(device: *IODeviceType, format: *char) -> bool,
    ///     \overload
    /// 
    ///     This function reads a QImage from the given \a device. This can,
    ///     for example, be used to load an image directly into a QByteArray.
    load(file_name: String, format: *char) -> bool,
    ///     \fn bool QImage::loadFromData(const uchar *data, int len, const char *format)
    /// 
    ///     Loads an image from the first \a len bytes of the given binary \a
    ///     data. Returns \c true if the image was successfully loaded; otherwise
    ///     invalidates the image and returns \c false.
    /// 
    ///     The loader attempts to read the image using the specified \a format, e.g.,
    ///     PNG or JPG. If \a format is not specified (which is the default), the
    ///     loader probes the file for a header to guess the file format.
    /// 
    ///     \sa {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    load_from_data(buf: *uchar, len: i32, format: *char) -> bool,
    ///     \fn bool QImage::loadFromData(const uchar *data, int len, const char *format)
    /// 
    ///     Loads an image from the first \a len bytes of the given binary \a
    ///     data. Returns \c true if the image was successfully loaded; otherwise
    ///     invalidates the image and returns \c false.
    /// 
    ///     The loader attempts to read the image using the specified \a format, e.g.,
    ///     PNG or JPG. If \a format is not specified (which is the default), the
    ///     loader probes the file for a header to guess the file format.
    /// 
    ///     \sa {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    load_from_data(data: &ByteArrayType, aformat: *char) -> bool,
    ///     \overload
    /// 
    ///     This function writes a QImage to the given \a device.
    /// 
    ///     This can, for example, be used to save an image directly into a
    ///     QByteArray:
    /// 
    ///     \snippet image/image.cpp 0
    save(file_name: String, format: *char, quality: i32) -> bool,
    ///     \overload
    /// 
    ///     This function writes a QImage to the given \a device.
    /// 
    ///     This can, for example, be used to save an image directly into a
    ///     QByteArray:
    /// 
    ///     \snippet image/image.cpp 0
    save(device: *IODeviceType, format: *char, quality: i32) -> bool,
    [static] from_data(data: *uchar, size: i32, format: *char) -> Image,
    [static] from_data(data: &ByteArrayType, format: *char) -> Image,
    ///     Returns a number that identifies the contents of this QImage
    ///     object. Distinct QImage objects can only have the same key if they
    ///     refer to the same contents.
    /// 
    ///     The key will change when the image is altered.
    cache_key() -> i64,
    ///     \internal
    /// 
    ///     Used by QPainter to retrieve a paint engine for the image.
    [event] paint_engine() -> PaintEngine?,
    ///     Returns the number of pixels that fit horizontally in a physical
    ///     meter. Together with dotsPerMeterY(), this number defines the
    ///     intended scale and aspect ratio of the image.
    /// 
    ///     \sa setDotsPerMeterX(), {QImage#Image Information}{Image
    ///     Information}
    dots_per_meter_x() -> i32,
    ///     Returns the number of pixels that fit vertically in a physical
    ///     meter. Together with dotsPerMeterX(), this number defines the
    ///     intended scale and aspect ratio of the image.
    /// 
    ///     \sa setDotsPerMeterY(), {QImage#Image Information}{Image
    ///     Information}
    dots_per_meter_y() -> i32,
    ///     Sets the number of pixels that fit horizontally in a physical
    ///     meter, to \a x.
    /// 
    ///     Together with dotsPerMeterY(), this number defines the intended
    ///     scale and aspect ratio of the image, and determines the scale
    ///     at which QPainter will draw graphics on the image. It does not
    ///     change the scale or aspect ratio of the image when it is rendered
    ///     on other paint devices.
    /// 
    ///     \sa dotsPerMeterX(), {QImage#Image Information}{Image Information}
    set_dots_per_meter_x(arg0: i32),
    ///     Sets the number of pixels that fit vertically in a physical meter,
    ///     to \a y.
    /// 
    ///     Together with dotsPerMeterX(), this number defines the intended
    ///     scale and aspect ratio of the image, and determines the scale
    ///     at which QPainter will draw graphics on the image. It does not
    ///     change the scale or aspect ratio of the image when it is rendered
    ///     on other paint devices.
    /// 
    ///     \sa dotsPerMeterY(), {QImage#Image Information}{Image Information}
    set_dots_per_meter_y(arg0: i32),
    ///     \fn QPoint QImage::offset() const
    /// 
    ///     Returns the number of pixels by which the image is intended to be
    ///     offset by when positioning relative to other images.
    /// 
    ///     \sa setOffset(), {QImage#Image Information}{Image Information}
    offset() -> Point,
    ///     \fn void QImage::setOffset(const QPoint& offset)
    /// 
    ///     Sets the number of pixels by which the image is intended to be
    ///     offset by when positioning relative to other images, to \a offset.
    /// 
    ///     \sa offset(), {QImage#Image Information}{Image Information}
    set_offset(arg0: &PointType),
    ///     Returns the text keys for this image.
    /// 
    ///     You can use these keys with text() to list the image text for a
    ///     certain key.
    /// 
    ///     \sa text()
    text_keys() -> [String],
    ///     Returns the image text associated with the given \a key. If the
    ///     specified \a key is an empty string, the whole image text is
    ///     returned, with each key-text pair separated by a newline.
    /// 
    ///     \sa setText(), textKeys()
    text(key: String) -> String,
    ///     \fn void QImage::setText(const QString &key, const QString &text)
    /// 
    ///     Sets the image text to the given \a text and associate it with the
    ///     given \a key.
    /// 
    ///     If you just want to store a single text block (i.e., a "comment"
    ///     or just a description), you can either pass an empty key, or use a
    ///     generic key like "Description".
    /// 
    ///     The image text is embedded into the image data when you
    ///     call save() or QImageWriter::write().
    /// 
    ///     Not all image formats support embedded text. You can find out
    ///     if a specific image or format supports embedding text
    ///     by using QImageWriter::supportsOption(). We give an example:
    /// 
    ///     \snippet image/supportedformat.cpp 0
    /// 
    ///     You can use QImageWriter::supportedImageFormats() to find out
    ///     which image formats are available to you.
    /// 
    ///     \sa text(), textKeys()
    set_text(key: String, value: String),
    ///     Returns the QImage::Format as a QPixelFormat
    pixel_format() -> PixelFormat,
    ///     Converts \a format into a QPixelFormat
    [static] to_pixel_format(format: Image::Format) -> PixelFormat,
    ///     Converts \a format into a QImage::Format
    [static] to_image_format(format: PixelFormatType) -> Image::Format,
    ///     \internal
    mirrored_helper(horizontal: bool, vertical: bool) -> Image,
    ///     \internal
    rgb_swapped_helper() -> Image,
    ///     \internal
    mirrored_inplace(horizontal: bool, vertical: bool),
    ///     \internal
    rgb_swapped_inplace(),
    ///     \internal
    convert_to_format_helper(format: Image::Format, flags: Rute::ImageConversionFlags) -> Image,
    ///     \internal
    convert_to_format_inplace(format: Image::Format, flags: Rute::ImageConversionFlags) -> bool,
    ///    Returns a smoothly scaled copy of the image. The returned image has a size
    ///    of width \a w by height \a h pixels.
    smooth_scaled(w: i32, h: i32) -> Image,
}

// vim: syntax=rust expandtab ts=4 sw=4
