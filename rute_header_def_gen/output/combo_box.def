///     \class QComboBox
///     \brief The QComboBox widget is a combined button and popup list.
/// 
///     \ingroup basicwidgets
///     \inmodule QtWidgets
/// 
///     \image windows-combobox.png
/// 
///     A QComboBox provides a means of presenting a list of options to the user
///     in a way that takes up the minimum amount of screen space.
/// 
///     A combobox is a selection widget that displays the current item,
///     and can pop up a list of selectable items. A combobox may be editable,
///     allowing the user to modify each item in the list.
/// 
///     Comboboxes can contain pixmaps as well as strings; the
///     insertItem() and setItemText() functions are suitably overloaded.
///     For editable comboboxes, the function clearEditText() is provided,
///     to clear the displayed string without changing the combobox's
///     contents.
/// 
///     There are two signals emitted if the current item of a combobox
///     changes, currentIndexChanged() and activated().
///     currentIndexChanged() is always emitted regardless if the change
///     was done programmatically or by user interaction, while
///     activated() is only emitted when the change is caused by user
///     interaction. The highlighted() signal is emitted when the user
///     highlights an item in the combobox popup list. All three signals
///     exist in two versions, one with a QString argument and one with an
///     \c int argument. If the user selects or highlights a pixmap, only
///     the \c int signals are emitted. Whenever the text of an editable
///     combobox is changed the editTextChanged() signal is emitted.
/// 
///     When the user enters a new string in an editable combobox, the
///     widget may or may not insert it, and it can insert it in several
///     locations. The default policy is \l InsertAtBottom but you can change
///     this using setInsertPolicy().
/// 
///     It is possible to constrain the input to an editable combobox
///     using QValidator; see setValidator(). By default, any input is
///     accepted.
/// 
///     A combobox can be populated using the insert functions,
///     insertItem() and insertItems() for example. Items can be
///     changed with setItemText(). An item can be removed with
///     removeItem() and all items can be removed with clear(). The text
///     of the current item is returned by currentText(), and the text of
///     a numbered item is returned with text(). The current item can be
///     set with setCurrentIndex(). The number of items in the combobox is
///     returned by count(); the maximum number of items can be set with
///     setMaxCount(). You can allow editing using setEditable(). For
///     editable comboboxes you can set auto-completion using
///     setCompleter() and whether or not the user can add duplicates
///     is set with setDuplicatesEnabled().
/// 
///     QComboBox uses the \l{Model/View Programming}{model/view
///     framework} for its popup list and to store its items.  By default
///     a QStandardItemModel stores the items and a QListView subclass
///     displays the popuplist. You can access the model and view directly
///     (with model() and view()), but QComboBox also provides functions
///     to set and get item data (e.g., setItemData() and itemText()). You
///     can also set a new model and view (with setModel() and setView()).
///     For the text and icon in the combobox label, the data in the model
///     that has the Qt::DisplayRole and Qt::DecorationRole is used.  Note
///     that you cannot alter the \l{QAbstractItemView::}{SelectionMode}
///     of the view(), e.g., by using
///     \l{QAbstractItemView::}{setSelectionMode()}.
/// 
///     \sa QLineEdit, QSpinBox, QRadioButton, QButtonGroup,
///         {fowler}{GUI Design Handbook: Combo Box, Drop-Down List Box}
[org_name(QComboBox)]
enum InsertPolicy {
    NoInsert,
    InsertAtTop,
    InsertAtCurrent,
    InsertAtBottom,
    InsertAfterCurrent,
    InsertBeforeCurrent,
    InsertAlphabetically,
}

[org_name(QComboBox)]
enum SizeAdjustPolicy {
    AdjustToContents,
    AdjustToContentsOnFirstShow,
    AdjustToMinimumContentsLength,
    AdjustToMinimumContentsLengthWithIcon,
}

struct ComboBox : Widget {
    max_visible_items() -> i32,
    set_max_visible_items(max_items: i32),
    count() -> i32,
    set_max_count(max: i32),
    max_count() -> i32,
    auto_completion() -> bool,
    set_auto_completion(enable: bool),
    auto_completion_case_sensitivity() -> Rute::CaseSensitivity,
    set_auto_completion_case_sensitivity(sensitivity: Rute::CaseSensitivity),
    duplicates_enabled() -> bool,
    set_duplicates_enabled(enable: bool),
    set_frame(arg0: bool),
    has_frame() -> bool,
    find_text(text: String, flags: Rute::MatchFlags) -> i32,
    find_data(data: &VariantType, role: i32, flags: Rute::MatchFlags) -> i32,
    insert_policy() -> ComboBox::InsertPolicy,
    set_insert_policy(policy: ComboBox::InsertPolicy),
    size_adjust_policy() -> ComboBox::SizeAdjustPolicy,
    set_size_adjust_policy(policy: ComboBox::SizeAdjustPolicy),
    minimum_contents_length() -> i32,
    set_minimum_contents_length(characters: i32),
    icon_size() -> Size,
    set_icon_size(size: &SizeType),
    is_editable() -> bool,
    set_editable(editable: bool),
    set_line_edit(edit: *LineEditType),
    line_edit() -> LineEdit?,
    set_validator(v: *ValidatorType),
    validator() -> Validator?,
    set_completer(c: *CompleterType),
    completer() -> Completer?,
    item_delegate() -> AbstractItemDelegate?,
    set_item_delegate(delegate: *AbstractItemDelegateType),
    model() -> AbstractItemModel?,
    set_model(model: *AbstractItemModelType),
    root_model_index() -> ModelIndex,
    set_root_model_index(index: &ModelIndexType),
    model_column() -> i32,
    set_model_column(visible_column: i32),
    current_index() -> i32,
    current_text() -> String,
    current_data(role: i32) -> Variant,
    item_text(index: i32) -> String,
    item_icon(index: i32) -> Icon,
    item_data(index: i32, role: i32) -> Variant,
    add_item(text: String, user_data: &VariantType),
    add_item(icon: &IconType, text: String, user_data: &VariantType),
    add_items(texts: &[String]),
    insert_item(index: i32, text: String, user_data: &VariantType),
    insert_item(index: i32, icon: &IconType, text: String, user_data: &VariantType),
    insert_items(index: i32, texts: &[String]),
    insert_separator(index: i32),
    remove_item(index: i32),
    set_item_text(index: i32, text: String),
    set_item_icon(index: i32, icon: &IconType),
    set_item_data(index: i32, value: &VariantType, role: i32),
    view() -> AbstractItemView?,
    set_view(item_view: *AbstractItemViewType),
    [event] size_hint() -> Size,
    [event] minimum_size_hint() -> Size,
    [event] show_popup(),
    [event] hide_popup(),
    [event] event(event: *EventType) -> bool,
    [event] input_method_query(arg0: Rute::InputMethodQuery) -> Variant,
    input_method_query(query: Rute::InputMethodQuery, argument: &VariantType) -> Variant,
    clear(),
    clear_edit_text(),
    set_edit_text(text: String),
    set_current_index(index: i32),
    set_current_text(text: String),
    [signal] edit_text_changed(arg0: String),
    [signal] activated(index: i32),
    [signal] activated(arg0: String),
    [signal] highlighted(index: i32),
    [signal] highlighted(arg0: String),
    [signal] current_index_changed(index: i32),
    [signal] current_index_changed(arg0: String),
    [signal] current_text_changed(arg0: String),
    [event] focus_in_event(e: *FocusEventType),
    [event] focus_out_event(e: *FocusEventType),
    [event] change_event(e: *EventType),
    [event] resize_event(e: *ResizeEventType),
    [event] paint_event(e: *PaintEventType),
    [event] show_event(e: *ShowEventType),
    [event] hide_event(e: *HideEventType),
    [event] mouse_press_event(e: *MouseEventType),
    [event] mouse_release_event(e: *MouseEventType),
    [event] key_press_event(e: *KeyEventType),
    [event] key_release_event(e: *KeyEventType),
    [event] wheel_event(e: *WheelEventType),
    [event] context_menu_event(e: *ContextMenuEventType),
    [event] input_method_event(arg0: *InputMethodEventType),
    init_style_option(option: *StyleOptionComboBoxType),
}

// vim: syntax=rust expandtab ts=4 sw=4
