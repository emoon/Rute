///     \class QOpenGLShaderProgram
///     \brief The QOpenGLShaderProgram class allows OpenGL shader programs to be linked and used.
///     \since 5.0
///     \ingroup painting-3D
///     \inmodule QtGui
/// 
///     \section1 Introduction
/// 
///     This class supports shader programs written in the OpenGL Shading
///     Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).
/// 
///     QOpenGLShader and QOpenGLShaderProgram shelter the programmer from the details of
///     compiling and linking vertex and fragment shaders.
/// 
///     The following example creates a vertex shader program using the
///     supplied source \c{code}.  Once compiled and linked, the shader
///     program is activated in the current QOpenGLContext by calling
///     QOpenGLShaderProgram::bind():
/// 
///     \snippet code/src_gui_qopenglshaderprogram.cpp 0
/// 
///     \section1 Writing Portable Shaders
/// 
///     Shader programs can be difficult to reuse across OpenGL implementations
///     because of varying levels of support for standard vertex attributes and
///     uniform variables.  In particular, GLSL/ES lacks all of the
///     standard variables that are present on desktop OpenGL systems:
///     \c{gl_Vertex}, \c{gl_Normal}, \c{gl_Color}, and so on.  Desktop OpenGL
///     lacks the variable qualifiers \c{highp}, \c{mediump}, and \c{lowp}.
/// 
///     The QOpenGLShaderProgram class makes the process of writing portable shaders
///     easier by prefixing all shader programs with the following lines on
///     desktop OpenGL:
/// 
///     \code
///     #define highp
///     #define mediump
///     #define lowp
///     \endcode
/// 
///     This makes it possible to run most GLSL/ES shader programs
///     on desktop systems.  The programmer should restrict themselves
///     to just features that are present in GLSL/ES, and avoid
///     standard variable names that only work on the desktop.
/// 
///     \section1 Simple Shader Example
/// 
///     \snippet code/src_gui_qopenglshaderprogram.cpp 1
/// 
///     With the above shader program active, we can draw a green triangle
///     as follows:
/// 
///     \snippet code/src_gui_qopenglshaderprogram.cpp 2
/// 
///     \section1 Binary Shaders and Programs
/// 
///     Binary shaders may be specified using \c{glShaderBinary()} on
///     the return value from QOpenGLShader::shaderId().  The QOpenGLShader instance
///     containing the binary can then be added to the shader program with
///     addShader() and linked in the usual fashion with link().
/// 
///     Binary programs may be specified using \c{glProgramBinaryOES()}
///     on the return value from programId().  Then the application should
///     call link(), which will notice that the program has already been
///     specified and linked, allowing other operations to be performed
///     on the shader program. The shader program's id can be explicitly
///     created using the create() function.
/// 
///     \section2 Caching Program Binaries
/// 
///     As of Qt 5.9, support for caching program binaries on disk is built in. To
///     enable this, switch to using addCacheableShaderFromSourceCode() and
///     addCacheableShaderFromSourceFile(). With an OpenGL ES 3.x context or support
///     for \c{GL_ARB_get_program_binary}, this will transparently cache program
///     binaries under QStandardPaths::GenericCacheLocation or
///     QStandardPaths::CacheLocation. When support is not available, calling the
///     cacheable function variants is equivalent to the normal ones.
/// 
///     \note Some drivers do not have any binary formats available, even though
///     they advertise the extension or offer OpenGL ES 3.0. In this case program
///     binary support will be disabled.
/// 
///     \sa QOpenGLShader
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct OpenGLShaderProgram : Object {
    ///     Adds a compiled \a shader to this shader program.  Returns \c true
    ///     if the shader could be added, or false otherwise.
    /// 
    ///     Ownership of the \a shader object remains with the caller.
    ///     It will not be deleted when this QOpenGLShaderProgram instance
    ///     is deleted.  This allows the caller to add the same shader
    ///     to multiple shader programs.
    /// 
    ///     \sa addShaderFromSourceCode(), addShaderFromSourceFile()
    ///     \sa removeShader(), link(), removeAllShaders()
    add_shader(shader: *OpenGLShaderType) -> bool,
    ///     Removes \a shader from this shader program.  The object is not deleted.
    /// 
    ///     The shader program must be valid in the current QOpenGLContext.
    /// 
    ///     \sa addShader(), link(), removeAllShaders()
    remove_shader(shader: *OpenGLShaderType),
    ///     Returns a list of all shaders that have been added to this shader
    ///     program using addShader().
    /// 
    ///     \sa addShader(), removeShader()
    shaders() -> [OpenGLShader?],
    ///     \overload
    /// 
    ///     Compiles \a source as a shader of the specified \a type and
    ///     adds it to this shader program.  Returns \c true if compilation
    ///     was successful, false otherwise.  The compilation errors
    ///     and warnings will be made available via log().
    /// 
    ///     This function is intended to be a short-cut for quickly
    ///     adding vertex and fragment shaders to a shader program without
    ///     creating an instance of QOpenGLShader first.
    /// 
    ///     \sa addShader(), addShaderFromSourceFile()
    ///     \sa removeShader(), link(), log(), removeAllShaders()
    add_shader_from_source_code(type: OpenGLShader::ShaderType, source: *char) -> bool,
    ///     \overload
    /// 
    ///     Compiles \a source as a shader of the specified \a type and
    ///     adds it to this shader program.  Returns \c true if compilation
    ///     was successful, false otherwise.  The compilation errors
    ///     and warnings will be made available via log().
    /// 
    ///     This function is intended to be a short-cut for quickly
    ///     adding vertex and fragment shaders to a shader program without
    ///     creating an instance of QOpenGLShader first.
    /// 
    ///     \sa addShader(), addShaderFromSourceFile()
    ///     \sa removeShader(), link(), log(), removeAllShaders()
    add_shader_from_source_code(type: OpenGLShader::ShaderType, source: &ByteArrayType) -> bool,
    ///     \overload
    /// 
    ///     Compiles \a source as a shader of the specified \a type and
    ///     adds it to this shader program.  Returns \c true if compilation
    ///     was successful, false otherwise.  The compilation errors
    ///     and warnings will be made available via log().
    /// 
    ///     This function is intended to be a short-cut for quickly
    ///     adding vertex and fragment shaders to a shader program without
    ///     creating an instance of QOpenGLShader first.
    /// 
    ///     \sa addShader(), addShaderFromSourceFile()
    ///     \sa removeShader(), link(), log(), removeAllShaders()
    add_shader_from_source_code(type: OpenGLShader::ShaderType, source: String) -> bool,
    add_shader_from_source_file(type: OpenGLShader::ShaderType, file_name: String) -> bool,
    add_cacheable_shader_from_source_code(type: OpenGLShader::ShaderType, source: *char) -> bool,
    add_cacheable_shader_from_source_code(type: OpenGLShader::ShaderType, source: &ByteArrayType) -> bool,
    add_cacheable_shader_from_source_code(type: OpenGLShader::ShaderType, source: String) -> bool,
    add_cacheable_shader_from_source_file(type: OpenGLShader::ShaderType, file_name: String) -> bool,
    ///     Removes all of the shaders that were added to this program previously.
    ///     The QOpenGLShader objects for the shaders will not be deleted if they
    ///     were constructed externally.  QOpenGLShader objects that are constructed
    ///     internally by QOpenGLShaderProgram will be deleted.
    /// 
    ///     \sa addShader(), removeShader()
    remove_all_shaders(),
    ///     Links together the shaders that were added to this program with
    ///     addShader().  Returns \c true if the link was successful or
    ///     false otherwise.  If the link failed, the error messages can
    ///     be retrieved with log().
    /// 
    ///     Subclasses can override this function to initialize attributes
    ///     and uniform variables for use in specific shader programs.
    /// 
    ///     If the shader program was already linked, calling this
    ///     function again will force it to be re-linked.
    /// 
    ///     When shaders were added to this program via
    ///     addCacheableShaderFromSourceCode() or addCacheableShaderFromSourceFile(),
    ///     program binaries are supported, and a cached binary is available on disk,
    ///     actual compilation and linking are skipped. Instead, link() will initialize
    ///     the program with the binary blob via glProgramBinary(). If there is no
    ///     cached version of the program or it was generated with a different driver
    ///     version, the shaders will be compiled from source and the program will get
    ///     linked normally. This allows seamless upgrading of the graphics drivers,
    ///     without having to worry about potentially incompatible binary formats.
    /// 
    ///     \sa addShader(), log()
    [event] link() -> bool,
    ///     Returns \c true if this shader program has been linked; false otherwise.
    /// 
    ///     \sa link()
    is_linked() -> bool,
    ///     Returns the errors and warnings that occurred during the last link()
    ///     or addShader() with explicitly specified source code.
    /// 
    ///     \sa link()
    log() -> String,
    ///     Binds this shader program to the active QOpenGLContext and makes
    ///     it the current shader program.  Any previously bound shader program
    ///     is released.  This is equivalent to calling \c{glUseProgram()} on
    ///     programId().  Returns \c true if the program was successfully bound;
    ///     false otherwise.  If the shader program has not yet been linked,
    ///     or it needs to be re-linked, this function will call link().
    /// 
    ///     \sa link(), release()
    bind() -> bool,
    ///     Releases the active shader program from the current QOpenGLContext.
    ///     This is equivalent to calling \c{glUseProgram(0)}.
    /// 
    ///     \sa bind()
    release(),
    create() -> bool,
    ///     Returns the OpenGL identifier associated with this shader program.
    /// 
    ///     \sa QOpenGLShader::shaderId()
    program_id() -> i32,
    ///     Use this function to specify to OpenGL the number of vertices in
    ///     a patch to \a count. A patch is a custom OpenGL primitive whose interpretation
    ///     is entirely defined by the tessellation shader stages. Therefore, calling
    ///     this function only makes sense when using a QOpenGLShaderProgram
    ///     containing tessellation stage shaders. When using OpenGL tessellation,
    ///     the only primitive that can be rendered with \c{glDraw*()} functions is
    ///     \c{GL_PATCHES}.
    /// 
    ///     This is equivalent to calling glPatchParameteri(GL_PATCH_VERTICES, count).
    /// 
    ///     \note This modifies global OpenGL state and is not specific to this
    ///     QOpenGLShaderProgram instance. You should call this in your render
    ///     function when needed, as QOpenGLShaderProgram will not apply this for
    ///     you. This is purely a convenience function.
    /// 
    ///     \sa patchVertexCount()
    set_patch_vertex_count(count: i32),
    ///     Returns the number of vertices per-patch to be used when rendering.
    /// 
    ///     \note This returns the global OpenGL state value. It is not specific to
    ///     this QOpenGLShaderProgram instance.
    /// 
    ///     \sa setPatchVertexCount()
    patch_vertex_count() -> i32,
    ///     Sets the default outer tessellation levels to be used by the tessellation
    ///     primitive generator in the event that the tessellation control shader
    ///     does not output them to \a levels. For more details on OpenGL and Tessellation
    ///     shaders see \l{OpenGL Tessellation Shaders}.
    /// 
    ///     The \a levels argument should be a QVector consisting of 4 floats. Not all
    ///     of the values make sense for all tessellation modes. If you specify a vector with
    ///     fewer than 4 elements, the remaining elements will be given a default value of 1.
    /// 
    ///     \note This modifies global OpenGL state and is not specific to this
    ///     QOpenGLShaderProgram instance. You should call this in your render
    ///     function when needed, as QOpenGLShaderProgram will not apply this for
    ///     you. This is purely a convenience function.
    /// 
    ///     \sa defaultOuterTessellationLevels(), setDefaultInnerTessellationLevels()
    set_default_outer_tessellation_levels(levels: [f32]),
    ///     Returns the default outer tessellation levels to be used by the tessellation
    ///     primitive generator in the event that the tessellation control shader
    ///     does not output them. For more details on OpenGL and Tessellation shaders see
    ///     \l{OpenGL Tessellation Shaders}.
    /// 
    ///     Returns a QVector of floats describing the outer tessellation levels. The vector
    ///     will always have four elements but not all of them make sense for every mode
    ///     of tessellation.
    /// 
    ///     \note This returns the global OpenGL state value. It is not specific to
    ///     this QOpenGLShaderProgram instance.
    /// 
    ///     \sa setDefaultOuterTessellationLevels(), defaultInnerTessellationLevels()
    default_outer_tessellation_levels() -> [f32],
    ///     Sets the default outer tessellation levels to be used by the tessellation
    ///     primitive generator in the event that the tessellation control shader
    ///     does not output them to \a levels. For more details on OpenGL and Tessellation shaders see
    ///     \l{OpenGL Tessellation Shaders}.
    /// 
    ///     The \a levels argument should be a QVector consisting of 2 floats. Not all
    ///     of the values make sense for all tessellation modes. If you specify a vector with
    ///     fewer than 2 elements, the remaining elements will be given a default value of 1.
    /// 
    ///     \note This modifies global OpenGL state and is not specific to this
    ///     QOpenGLShaderProgram instance. You should call this in your render
    ///     function when needed, as QOpenGLShaderProgram will not apply this for
    ///     you. This is purely a convenience function.
    /// 
    ///     \sa defaultInnerTessellationLevels(), setDefaultOuterTessellationLevels()
    set_default_inner_tessellation_levels(levels: [f32]),
    ///     Returns the default inner tessellation levels to be used by the tessellation
    ///     primitive generator in the event that the tessellation control shader
    ///     does not output them. For more details on OpenGL and Tessellation shaders see
    ///     \l{OpenGL Tessellation Shaders}.
    /// 
    ///     Returns a QVector of floats describing the inner tessellation levels. The vector
    ///     will always have two elements but not all of them make sense for every mode
    ///     of tessellation.
    /// 
    ///     \note This returns the global OpenGL state value. It is not specific to
    ///     this QOpenGLShaderProgram instance.
    /// 
    ///     \sa setDefaultInnerTessellationLevels(), defaultOuterTessellationLevels()
    default_inner_tessellation_levels() -> [f32],
    ///     \overload
    /// 
    ///     Returns the location of the uniform variable \a name within this shader
    ///     program's parameter list.  Returns -1 if \a name is not a valid
    ///     uniform variable for this shader program.
    /// 
    ///     \sa attributeLocation()
    uniform_location(name: *char) -> i32,
    ///     \overload
    /// 
    ///     Returns the location of the uniform variable \a name within this shader
    ///     program's parameter list.  Returns -1 if \a name is not a valid
    ///     uniform variable for this shader program.
    /// 
    ///     \sa attributeLocation()
    uniform_location(name: &ByteArrayType) -> i32,
    ///     \overload
    /// 
    ///     Returns the location of the uniform variable \a name within this shader
    ///     program's parameter list.  Returns -1 if \a name is not a valid
    ///     uniform variable for this shader program.
    /// 
    ///     \sa attributeLocation()
    uniform_location(name: String) -> i32,
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: GLint),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, x: i32, y: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, x: i32, y: i32, z: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, x: i32, y: i32, z: i32, w: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Vector2DType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Vector3DType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Vector4DType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, color: &ColorType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, point: &PointType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, point: &PointFType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, size: &SizeType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, size: &SizeFType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix2x2Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix2x3Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix2x4Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix3x2Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix3x3Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix3x4Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix4x2Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix4x3Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &Matrix4x4Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(location: i32, value: &TransformType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: GLint),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, x: i32, y: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, x: i32, y: i32, z: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, x: i32, y: i32, z: i32, w: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Vector2DType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Vector3DType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Vector4DType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, color: &ColorType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, point: &PointType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, point: &PointFType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, size: &SizeType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, size: &SizeFType),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix2x2Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix2x3Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix2x4Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix3x2Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix3x3Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix3x4Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix4x2Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix4x3Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &Matrix4x4Type),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: i32),
    ///     Sets the uniform variable at \a location in the current context to a
    ///     3x3 transformation matrix \a value that is specified as a QTransform value.
    /// 
    ///     To set a QTransform value as a 4x4 matrix in a shader, use
    ///     \c{setUniformValue(location, QMatrix4x4(value))}.
    set_uniform_value(name: *char, value: &TransformType),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *i32, count: i32, tuple_size: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *GLint, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *i32, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Vector2DType, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Vector3DType, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Vector4DType, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix2x2Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix2x3Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix2x4Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix3x2Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix3x3Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix3x4Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix4x2Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix4x3Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(location: i32, values: *Matrix4x4Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *i32, count: i32, tuple_size: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *GLint, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *i32, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Vector2DType, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Vector3DType, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Vector4DType, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix2x2Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix2x3Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix2x4Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix3x2Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix3x3Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix3x4Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix4x2Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix4x3Type, count: i32),
    ///     \overload
    /// 
    ///     Sets the uniform variable array called \a name in the current
    ///     context to the \a count 4x4 matrix elements of \a values.
    /// 
    ///     \sa setAttributeValue()
    set_uniform_value_array(name: *char, values: *Matrix4x4Type, count: i32),
    ///     Returns \c true if shader programs written in the OpenGL Shading
    ///     Language (GLSL) are supported on this system; false otherwise.
    /// 
    ///     The \a context is used to resolve the GLSL extensions.
    ///     If \a context is null, then QOpenGLContext::currentContext() is used.
    [static] has_open_gl_shader_programs(context: *OpenGLContextType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
