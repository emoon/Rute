///     \class QIODevice
///     \inmodule QtCore
///     \reentrant
/// 
///     \brief The QIODevice class is the base interface class of all I/O
///     devices in Qt.
/// 
///     \ingroup io
/// 
///     QIODevice provides both a common implementation and an abstract
///     interface for devices that support reading and writing of blocks
///     of data, such as QFile, QBuffer and QTcpSocket. QIODevice is
///     abstract and can not be instantiated, but it is common to use the
///     interface it defines to provide device-independent I/O features.
///     For example, Qt's XML classes operate on a QIODevice pointer,
///     allowing them to be used with various devices (such as files and
///     buffers).
/// 
///     Before accessing the device, open() must be called to set the
///     correct OpenMode (such as ReadOnly or ReadWrite). You can then
///     write to the device with write() or putChar(), and read by calling
///     either read(), readLine(), or readAll(). Call close() when you are
///     done with the device.
/// 
///     QIODevice distinguishes between two types of devices:
///     random-access devices and sequential devices.
/// 
///     \list
///     \li Random-access devices support seeking to arbitrary
///     positions using seek(). The current position in the file is
///     available by calling pos(). QFile and QBuffer are examples of
///     random-access devices.
/// 
///     \li Sequential devices don't support seeking to arbitrary
///     positions. The data must be read in one pass. The functions
///     pos() and size() don't work for sequential devices.
///     QTcpSocket and QProcess are examples of sequential devices.
///     \endlist
/// 
///     You can use isSequential() to determine the type of device.
/// 
///     QIODevice emits readyRead() when new data is available for
///     reading; for example, if new data has arrived on the network or if
///     additional data is appended to a file that you are reading
///     from. You can call bytesAvailable() to determine the number of
///     bytes that are currently available for reading. It's common to use
///     bytesAvailable() together with the readyRead() signal when
///     programming with asynchronous devices such as QTcpSocket, where
///     fragments of data can arrive at arbitrary points in
///     time. QIODevice emits the bytesWritten() signal every time a
///     payload of data has been written to the device. Use bytesToWrite()
///     to determine the current amount of data waiting to be written.
/// 
///     Certain subclasses of QIODevice, such as QTcpSocket and QProcess,
///     are asynchronous. This means that I/O functions such as write()
///     or read() always return immediately, while communication with the
///     device itself may happen when control goes back to the event loop.
///     QIODevice provides functions that allow you to force these
///     operations to be performed immediately, while blocking the
///     calling thread and without entering the event loop. This allows
///     QIODevice subclasses to be used without an event loop, or in
///     a separate thread:
/// 
///     \list
///     \li waitForReadyRead() - This function suspends operation in the
///     calling thread until new data is available for reading.
/// 
///     \li waitForBytesWritten() - This function suspends operation in the
///     calling thread until one payload of data has been written to the
///     device.
/// 
///     \li waitFor....() - Subclasses of QIODevice implement blocking
///     functions for device-specific operations. For example, QProcess
///     has a function called \l {QProcess::}{waitForStarted()} which suspends operation in
///     the calling thread until the process has started.
///     \endlist
/// 
///     Calling these functions from the main, GUI thread, may cause your
///     user interface to freeze. Example:
/// 
///     \snippet code/src_corelib_io_qiodevice.cpp 0
/// 
///     By subclassing QIODevice, you can provide the same interface to
///     your own I/O devices. Subclasses of QIODevice are only required to
///     implement the protected readData() and writeData() functions.
///     QIODevice uses these functions to implement all its convenience
///     functions, such as getChar(), readLine() and write(). QIODevice
///     also handles access control for you, so you can safely assume that
///     the device is opened in write mode if writeData() is called.
/// 
///     Some subclasses, such as QFile and QTcpSocket, are implemented
///     using a memory buffer for intermediate storing of data. This
///     reduces the number of required device accessing calls, which are
///     often very slow. Buffering makes functions like getChar() and
///     putChar() fast, as they can operate on the memory buffer instead
///     of directly on the device itself. Certain I/O operations, however,
///     don't work well with a buffer. For example, if several users open
///     the same device and read it character by character, they may end
///     up reading the same data when they meant to read a separate chunk
///     each. For this reason, QIODevice allows you to bypass any
///     buffering by passing the Unbuffered flag to open(). When
///     subclassing QIODevice, remember to bypass any buffer you may use
///     when the device is open in Unbuffered mode.
/// 
///     Usually, the incoming data stream from an asynchronous device is
///     fragmented, and chunks of data can arrive at arbitrary points in time.
///     To handle incomplete reads of data structures, use the transaction
///     mechanism implemented by QIODevice. See startTransaction() and related
///     functions for more details.
/// 
///     Some sequential devices support communicating via multiple channels. These
///     channels represent separate streams of data that have the property of
///     independently sequenced delivery. Once the device is opened, you can
///     determine the number of channels by calling the readChannelCount() and
///     writeChannelCount() functions. To switch between channels, call
///     setCurrentReadChannel() and setCurrentWriteChannel(), respectively.
///     QIODevice also provides additional signals to handle asynchronous
///     communication on a per-channel basis.
/// 
///     \sa QBuffer, QFile, QTcpSocket
[org_name(QIODevice)]
enum OpenModeFlag {
    NotOpen,
    ReadOnly,
    WriteOnly,
    ReadWrite,
    Append,
    Truncate,
    Text,
    Unbuffered,
    NewOnly,
    ExistingOnly,
}

struct IODevice : Object {
    ///     Returns the mode in which the device has been opened;
    ///     i.e. ReadOnly or WriteOnly.
    /// 
    ///     \sa OpenMode
    open_mode() -> IODevice::OpenMode,
    set_text_mode_enabled(enabled: bool),
    ///     Returns \c true if the \l Text flag is enabled; otherwise returns \c false.
    /// 
    ///     \sa setTextModeEnabled()
    is_text_mode_enabled() -> bool,
    ///     Returns \c true if the device is open; otherwise returns \c false. A
    ///     device is open if it can be read from and/or written to. By
    ///     default, this function returns \c false if openMode() returns
    ///     \c NotOpen.
    /// 
    ///     \sa openMode(), OpenMode
    is_open() -> bool,
    ///     Returns \c true if data can be read from the device; otherwise returns
    ///     false. Use bytesAvailable() to determine how many bytes can be read.
    /// 
    ///     This is a convenience function which checks if the OpenMode of the
    ///     device contains the ReadOnly flag.
    /// 
    ///     \sa openMode(), OpenMode
    is_readable() -> bool,
    ///     Returns \c true if data can be written to the device; otherwise returns
    ///     false.
    /// 
    ///     This is a convenience function which checks if the OpenMode of the
    ///     device contains the WriteOnly flag.
    /// 
    ///     \sa openMode(), OpenMode
    is_writable() -> bool,
    ///     Returns \c true if this device is sequential; otherwise returns
    ///     false.
    /// 
    ///     Sequential devices, as opposed to a random-access devices, have no
    ///     concept of a start, an end, a size, or a current position, and they
    ///     do not support seeking. You can only read from the device when it
    ///     reports that data is available. The most common example of a
    ///     sequential device is a network socket. On Unix, special files such
    ///     as /dev/zero and fifo pipes are sequential.
    /// 
    ///     Regular files, on the other hand, do support random access. They
    ///     have both a size and a current position, and they also support
    ///     seeking backwards and forwards in the data stream. Regular files
    ///     are non-sequential.
    /// 
    ///     \sa bytesAvailable()
    [event] is_sequential() -> bool,
    ///     \since 5.7
    /// 
    ///     Returns the number of available read channels if the device is open;
    ///     otherwise returns 0.
    /// 
    ///     \sa writeChannelCount(), QProcess
    read_channel_count() -> i32,
    ///     \since 5.7
    /// 
    ///     Returns the number of available write channels if the device is open;
    ///     otherwise returns 0.
    /// 
    ///     \sa readChannelCount()
    write_channel_count() -> i32,
    ///     \since 5.7
    /// 
    ///     Returns the index of the current read channel.
    /// 
    ///     \sa setCurrentReadChannel(), readChannelCount(), QProcess
    current_read_channel() -> i32,
    ///     \since 5.7
    /// 
    ///     Sets the current read channel of the QIODevice to the given \a
    ///     channel. The current input channel is used by the functions
    ///     read(), readAll(), readLine(), and getChar(). It also determines
    ///     which channel triggers QIODevice to emit readyRead().
    /// 
    ///     \sa currentReadChannel(), readChannelCount(), QProcess
    set_current_read_channel(channel: i32),
    ///     \since 5.7
    /// 
    ///     Returns the the index of the current write channel.
    /// 
    ///     \sa setCurrentWriteChannel(), writeChannelCount()
    current_write_channel() -> i32,
    ///     \since 5.7
    /// 
    ///     Sets the current write channel of the QIODevice to the given \a
    ///     channel. The current output channel is used by the functions
    ///     write(), putChar(). It also determines  which channel triggers
    ///     QIODevice to emit bytesWritten().
    /// 
    ///     \sa currentWriteChannel(), writeChannelCount()
    set_current_write_channel(channel: i32),
    ///     Opens the device and sets its OpenMode to \a mode. Returns \c true if successful;
    ///     otherwise returns \c false. This function should be called from any
    ///     reimplementations of open() or other functions that open the device.
    /// 
    ///     \sa openMode(), OpenMode
    [event] open(mode: IODevice::OpenMode) -> bool,
    ///     First emits aboutToClose(), then closes the device and sets its
    ///     OpenMode to NotOpen. The error string is also reset.
    /// 
    ///     \sa setOpenMode(), OpenMode
    [event] close(),
    ///     For random-access devices, this function returns the position that
    ///     data is written to or read from. For sequential devices or closed
    ///     devices, where there is no concept of a "current position", 0 is
    ///     returned.
    /// 
    ///     The current read/write position of the device is maintained internally by
    ///     QIODevice, so reimplementing this function is not necessary. When
    ///     subclassing QIODevice, use QIODevice::seek() to notify QIODevice about
    ///     changes in the device position.
    /// 
    ///     \sa isSequential(), seek()
    [event] pos() -> i64,
    ///     For open random-access devices, this function returns the size of the
    ///     device. For open sequential devices, bytesAvailable() is returned.
    /// 
    ///     If the device is closed, the size returned will not reflect the actual
    ///     size of the device.
    /// 
    ///     \sa isSequential(), pos()
    [event] size() -> i64,
    ///     For random-access devices, this function sets the current position
    ///     to \a pos, returning true on success, or false if an error occurred.
    ///     For sequential devices, the default behavior is to produce a warning
    ///     and return false.
    /// 
    ///     When subclassing QIODevice, you must call QIODevice::seek() at the
    ///     start of your function to ensure integrity with QIODevice's
    ///     built-in buffer.
    /// 
    ///     \sa pos(), isSequential()
    [event] seek(pos: i64) -> bool,
    ///     Returns \c true if the current read and write position is at the end
    ///     of the device (i.e. there is no more data available for reading on
    ///     the device); otherwise returns \c false.
    /// 
    ///     For some devices, atEnd() can return true even though there is more data
    ///     to read. This special case only applies to devices that generate data in
    ///     direct response to you calling read() (e.g., \c /dev or \c /proc files on
    ///     Unix and \macos, or console input / \c stdin on all platforms).
    /// 
    ///     \sa bytesAvailable(), read(), isSequential()
    [event] at_end() -> bool,
    ///     Seeks to the start of input for random-access devices. Returns
    ///     true on success; otherwise returns \c false (for example, if the
    ///     device is not open).
    /// 
    ///     Note that when using a QTextStream on a QFile, calling reset() on
    ///     the QFile will not have the expected result because QTextStream
    ///     buffers the file. Use the QTextStream::seek() function instead.
    /// 
    ///     \sa seek()
    [event] reset() -> bool,
    ///     Returns the number of bytes that are available for reading. This
    ///     function is commonly used with sequential devices to determine the
    ///     number of bytes to allocate in a buffer before reading.
    /// 
    ///     Subclasses that reimplement this function must call the base
    ///     implementation in order to include the size of the buffer of QIODevice. Example:
    /// 
    ///     \snippet code/src_corelib_io_qiodevice.cpp 1
    /// 
    ///     \sa bytesToWrite(), readyRead(), isSequential()
    [event] bytes_available() -> i64,
    [event] bytes_to_write() -> i64,
    ///     \overload
    /// 
    ///     Reads at most \a maxSize bytes from the device, and returns the
    ///     data read as a QByteArray.
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for reading, or that an error occurred.
    read(data: *char, maxlen: i64) -> i64,
    ///     \overload
    /// 
    ///     Reads at most \a maxSize bytes from the device, and returns the
    ///     data read as a QByteArray.
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for reading, or that an error occurred.
    read(maxlen: i64) -> ByteArray,
    ///     Reads all remaining data from the device, and returns it as a
    ///     byte array.
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for reading, or that an error occurred.
    read_all() -> ByteArray,
    ///     \overload
    /// 
    ///     Reads a line from the device, but no more than \a maxSize characters,
    ///     and returns the result as a byte array.
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for reading, or that an error occurred.
    read_line(data: *char, maxlen: i64) -> i64,
    ///     \overload
    /// 
    ///     Reads a line from the device, but no more than \a maxSize characters,
    ///     and returns the result as a byte array.
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for reading, or that an error occurred.
    read_line(maxlen: i64) -> ByteArray,
    ///     Returns \c true if a complete line of data can be read from the device;
    ///     otherwise returns \c false.
    /// 
    ///     Note that unbuffered devices, which have no way of determining what
    ///     can be read, always return false.
    /// 
    ///     This function is often called in conjunction with the readyRead()
    ///     signal.
    /// 
    ///     Subclasses that reimplement this function must call the base
    ///     implementation in order to include the contents of the QIODevice's buffer. Example:
    /// 
    ///     \snippet code/src_corelib_io_qiodevice.cpp 3
    /// 
    ///     \sa readyRead(), readLine()
    [event] can_read_line() -> bool,
    ///     \since 5.7
    /// 
    ///     Starts a new read transaction on the device.
    /// 
    ///     Defines a restorable point within the sequence of read operations. For
    ///     sequential devices, read data will be duplicated internally to allow
    ///     recovery in case of incomplete reads. For random-access devices,
    ///     this function saves the current position. Call commitTransaction() or
    ///     rollbackTransaction() to finish the transaction.
    /// 
    ///     \note Nesting transactions is not supported.
    /// 
    ///     \sa commitTransaction(), rollbackTransaction()
    start_transaction(),
    ///     \since 5.7
    /// 
    ///     Completes a read transaction.
    /// 
    ///     For sequential devices, all data recorded in the internal buffer during
    ///     the transaction will be discarded.
    /// 
    ///     \sa startTransaction(), rollbackTransaction()
    commit_transaction(),
    ///     \since 5.7
    /// 
    ///     Rolls back a read transaction.
    /// 
    ///     Restores the input stream to the point of the startTransaction() call.
    ///     This function is commonly used to rollback the transaction when an
    ///     incomplete read was detected prior to committing the transaction.
    /// 
    ///     \sa startTransaction(), commitTransaction()
    rollback_transaction(),
    ///     \since 5.7
    /// 
    ///     Returns \c true if a transaction is in progress on the device, otherwise
    ///     \c false.
    /// 
    ///     \sa startTransaction()
    is_transaction_started() -> bool,
    ///     \since 4.5
    /// 
    ///     \overload
    /// 
    ///     Writes data from a zero-terminated string of 8-bit characters to the
    ///     device. Returns the number of bytes that were actually written, or
    ///     -1 if an error occurred. This is equivalent to
    ///     \code
    ///     ...
    ///     QIODevice::write(data, qstrlen(data));
    ///     ...
    ///     \endcode
    /// 
    ///     \sa read(), writeData()
    write(data: *char, len: i64) -> i64,
    ///     \since 4.5
    /// 
    ///     \overload
    /// 
    ///     Writes data from a zero-terminated string of 8-bit characters to the
    ///     device. Returns the number of bytes that were actually written, or
    ///     -1 if an error occurred. This is equivalent to
    ///     \code
    ///     ...
    ///     QIODevice::write(data, qstrlen(data));
    ///     ...
    ///     \endcode
    /// 
    ///     \sa read(), writeData()
    write(data: *char) -> i64,
    ///     \since 4.5
    /// 
    ///     \overload
    /// 
    ///     Writes data from a zero-terminated string of 8-bit characters to the
    ///     device. Returns the number of bytes that were actually written, or
    ///     -1 if an error occurred. This is equivalent to
    ///     \code
    ///     ...
    ///     QIODevice::write(data, qstrlen(data));
    ///     ...
    ///     \endcode
    /// 
    ///     \sa read(), writeData()
    write(data: &ByteArrayType) -> i64,
    ///     \since 4.1
    ///     \overload
    /// 
    ///     Peeks at most \a maxSize bytes from the device, returning the data peeked
    ///     as a QByteArray.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_io_qiodevice.cpp 5
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for peeking, or that an error occurred.
    /// 
    ///     \sa read()
    peek(data: *char, maxlen: i64) -> i64,
    ///     \since 4.1
    ///     \overload
    /// 
    ///     Peeks at most \a maxSize bytes from the device, returning the data peeked
    ///     as a QByteArray.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_io_qiodevice.cpp 5
    /// 
    ///     This function has no way of reporting errors; returning an empty
    ///     QByteArray can mean either that no data was currently available
    ///     for peeking, or that an error occurred.
    /// 
    ///     \sa read()
    peek(maxlen: i64) -> ByteArray,
    ///     \since 5.10
    /// 
    ///     Skips up to \a maxSize bytes from the device. Returns the number of bytes
    ///     actually skipped, or -1 on error.
    /// 
    ///     This function does not wait and only discards the data that is already
    ///     available for reading.
    /// 
    ///     If the device is opened in text mode, end-of-line terminators are
    ///     translated to '\n' symbols and count as a single byte identically to the
    ///     read() and peek() behavior.
    /// 
    ///     This function works for all devices, including sequential ones that cannot
    ///     seek(). It is optimized to skip unwanted data after a peek() call.
    /// 
    ///     For random-access devices, skip() can be used to seek forward from the
    ///     current position. Negative \a maxSize values are not allowed.
    /// 
    ///     \sa peek(), seek(), read()
    skip(max_size: i64) -> i64,
    ///     Blocks until new data is available for reading and the readyRead()
    ///     signal has been emitted, or until \a msecs milliseconds have
    ///     passed. If msecs is -1, this function will not time out.
    /// 
    ///     Returns \c true if new data is available for reading; otherwise returns
    ///     false (if the operation timed out or if an error occurred).
    /// 
    ///     This function can operate without an event loop. It is
    ///     useful when writing non-GUI applications and when performing
    ///     I/O operations in a non-GUI thread.
    /// 
    ///     If called from within a slot connected to the readyRead() signal,
    ///     readyRead() will not be reemitted.
    /// 
    ///     Reimplement this function to provide a blocking API for a custom
    ///     device. The default implementation does nothing, and returns \c false.
    /// 
    ///     \warning Calling this function from the main (GUI) thread
    ///     might cause your user interface to freeze.
    /// 
    ///     \sa waitForBytesWritten()
    [event] wait_for_ready_read(msecs: i32) -> bool,
    ///     For buffered devices, this function waits until a payload of
    ///     buffered written data has been written to the device and the
    ///     bytesWritten() signal has been emitted, or until \a msecs
    ///     milliseconds have passed. If msecs is -1, this function will
    ///     not time out. For unbuffered devices, it returns immediately.
    /// 
    ///     Returns \c true if a payload of data was written to the device;
    ///     otherwise returns \c false (i.e. if the operation timed out, or if an
    ///     error occurred).
    /// 
    ///     This function can operate without an event loop. It is
    ///     useful when writing non-GUI applications and when performing
    ///     I/O operations in a non-GUI thread.
    /// 
    ///     If called from within a slot connected to the bytesWritten() signal,
    ///     bytesWritten() will not be reemitted.
    /// 
    ///     Reimplement this function to provide a blocking API for a custom
    ///     device. The default implementation does nothing, and returns \c false.
    /// 
    ///     \warning Calling this function from the main (GUI) thread
    ///     might cause your user interface to freeze.
    /// 
    ///     \sa waitForReadyRead()
    [event] wait_for_bytes_written(msecs: i32) -> bool,
    ///     Puts the character \a c back into the device, and decrements the
    ///     current position unless the position is 0. This function is
    ///     usually called to "undo" a getChar() operation, such as when
    ///     writing a backtracking parser.
    /// 
    ///     If \a c was not previously read from the device, the behavior is
    ///     undefined.
    /// 
    ///     \note This function is not available while a transaction is in progress.
    unget_char(c: char),
    put_char(c: char) -> bool,
    get_char(c: *char) -> bool,
    [signal] ready_read(),
    [signal] channel_ready_read(channel: i32),
    ///     \enum QIODevice::OpenModeFlag
    /// 
    ///     This enum is used with open() to describe the mode in which a device
    ///     is opened. It is also returned by openMode().
    /// 
    ///     \value NotOpen   The device is not open.
    ///     \value ReadOnly  The device is open for reading.
    ///     \value WriteOnly The device is open for writing. Note that this mode implies
    ///                      Truncate.
    ///     \value ReadWrite The device is open for reading and writing.
    ///     \value Append    The device is opened in append mode so that all data is
    ///                      written to the end of the file.
    ///     \value Truncate  If possible, the device is truncated before it is opened.
    ///                      All earlier contents of the device are lost.
    ///     \value Text      When reading, the end-of-line terminators are
    ///                      translated to '\\n'. When writing, the end-of-line
    ///                      terminators are translated to the local encoding, for
    ///                      example '\\r\\n' for Win32.
    ///     \value Unbuffered Any buffer in the device is bypassed.
    ///     \value NewOnly   Fail if the file to be opened already exists. Create and
    ///                      open the file only if it does not exist. There is a
    ///                      guarantee from the operating system that you are the only
    ///                      one creating and opening the file. Note that this mode
    ///                      implies WriteOnly, and combining it with ReadWrite is
    ///                      allowed. This flag currently only affects QFile. Other
    ///                      classes might use this flag in the future, but until then
    ///                      using this flag with any classes other than QFile may
    ///                      result in undefined behavior.
    ///     \value ExistingOnly Fail if the file to be opened does not exist. This flag
    ///                      must be specified alongside ReadOnly, WriteOnly, or
    ///                      ReadWrite. Note that using this flag with ReadOnly alone
    ///                      is redundant, as ReadOnly already fails when the file does
    ///                      not exist. This flag currently only affects QFile. Other
    ///                      classes might use this flag in the future, but until then
    ///                      using this flag with any classes other than QFile may
    ///                      result in undefined behavior.
    /// 
    ///     Certain flags, such as \c Unbuffered and \c Truncate, are
    ///     meaningless when used with some subclasses. Some of these
    ///     restrictions are implied by the type of device that is represented
    ///     by a subclass. In other cases, the restriction may be due to the
    ///     implementation, or may be imposed by the underlying platform; for
    ///     example, QTcpSocket does not support \c Unbuffered mode, and
    ///     limitations in the native API prevent QFile from supporting \c
    ///     Unbuffered on Windows.
    [signal] bytes_written(bytes: i64),
    [signal] channel_bytes_written(channel: i32, bytes: i64),
    ///     \fn QIODevice::channelReadyRead(int channel)
    ///     \since 5.7
    /// 
    ///     This signal is emitted when new data is available for reading from the
    ///     device. The \a channel argument is set to the index of the read channel on
    ///     which the data has arrived. Unlike readyRead(), it is emitted regardless of
    ///     the \l{currentReadChannel()}{current read channel}.
    /// 
    ///     channelReadyRead() can be emitted recursively - even for the same channel.
    /// 
    ///     \sa readyRead(), channelBytesWritten()
    [signal] about_to_close(),
    [signal] read_channel_finished(),
    [event] read_data(data: *char, maxlen: i64) -> i64,
    ///     Reads up to \a maxSize characters into \a data and returns the
    ///     number of characters read.
    /// 
    ///     This function is called by readLine(), and provides its base
    ///     implementation, using getChar(). Buffered devices can improve the
    ///     performance of readLine() by reimplementing this function.
    /// 
    ///     readLine() appends a '\\0' byte to \a data; readLineData() does not
    ///     need to do this.
    /// 
    ///     If you reimplement this function, be careful to return the correct
    ///     value: it should return the number of bytes read in this line,
    ///     including the terminating newline, or 0 if there is no line to be
    ///     read at this point. If an error occurs, it should return -1 if and
    ///     only if no bytes were read. Reading past EOF is considered an error.
    [event] read_line_data(data: *char, maxlen: i64) -> i64,
    [event] write_data(data: *char, len: i64) -> i64,
    ///     Sets the OpenMode of the device to \a openMode. Call this
    ///     function to set the open mode if the flags change after the device
    ///     has been opened.
    /// 
    ///     \sa openMode(), OpenMode
    set_open_mode(open_mode: IODevice::OpenMode),
}

// vim: syntax=rust expandtab ts=4 sw=4
