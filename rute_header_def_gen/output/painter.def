///     \class QPainter
///     \brief The QPainter class performs low-level painting on widgets and
///     other paint devices.
/// 
///     \inmodule QtGui
///     \ingroup painting
/// 
///     \reentrant
/// 
///     QPainter provides highly optimized functions to do most of the
///     drawing GUI programs require. It can draw everything from simple
///     lines to complex shapes like pies and chords. It can also draw
///     aligned text and pixmaps. Normally, it draws in a "natural"
///     coordinate system, but it can also do view and world
///     transformation. QPainter can operate on any object that inherits
///     the QPaintDevice class.
/// 
///     The common use of QPainter is inside a widget's paint event:
///     Construct and customize (e.g. set the pen or the brush) the
///     painter. Then draw. Remember to destroy the QPainter object after
///     drawing. For example:
/// 
///     \snippet code/src_gui_painting_qpainter.cpp 0
/// 
///     The core functionality of QPainter is drawing, but the class also
///     provide several functions that allows you to customize QPainter's
///     settings and its rendering quality, and others that enable
///     clipping. In addition you can control how different shapes are
///     merged together by specifying the painter's composition mode.
/// 
///     The isActive() function indicates whether the painter is active. A
///     painter is activated by the begin() function and the constructor
///     that takes a QPaintDevice argument. The end() function, and the
///     destructor, deactivates it.
/// 
///     Together with the QPaintDevice and QPaintEngine classes, QPainter
///     form the basis for Qt's paint system. QPainter is the class used
///     to perform drawing operations. QPaintDevice represents a device
///     that can be painted on using a QPainter. QPaintEngine provides the
///     interface that the painter uses to draw onto different types of
///     devices. If the painter is active, device() returns the paint
///     device on which the painter paints, and paintEngine() returns the
///     paint engine that the painter is currently operating on. For more
///     information, see the \l {Paint System}.
/// 
///     Sometimes it is desirable to make someone else paint on an unusual
///     QPaintDevice. QPainter supports a static function to do this,
///     setRedirected().
/// 
///     \warning When the paintdevice is a widget, QPainter can only be
///     used inside a paintEvent() function or in a function called by
///     paintEvent().
/// 
///     \tableofcontents
/// 
///     \section1 Settings
/// 
///     There are several settings that you can customize to make QPainter
///     draw according to your preferences:
/// 
///     \list
/// 
///     \li font() is the font used for drawing text. If the painter
///         isActive(), you can retrieve information about the currently set
///         font, and its metrics, using the fontInfo() and fontMetrics()
///         functions respectively.
/// 
///     \li brush() defines the color or pattern that is used for filling
///        shapes.
/// 
///     \li pen() defines the color or stipple that is used for drawing
///        lines or boundaries.
/// 
///     \li backgroundMode() defines whether there is a background() or
///        not, i.e it is either Qt::OpaqueMode or Qt::TransparentMode.
/// 
///     \li background() only applies when backgroundMode() is \l
///        Qt::OpaqueMode and pen() is a stipple. In that case, it
///        describes the color of the background pixels in the stipple.
/// 
///     \li brushOrigin() defines the origin of the tiled brushes, normally
///        the origin of widget's background.
/// 
///     \li viewport(), window(), worldTransform() make up the painter's coordinate
///         transformation system. For more information, see the \l
///         {Coordinate Transformations} section and the \l {Coordinate
///         System} documentation.
/// 
///     \li hasClipping() tells whether the painter clips at all. (The paint
///        device clips, too.) If the painter clips, it clips to clipRegion().
/// 
///     \li layoutDirection() defines the layout direction used by the
///        painter when drawing text.
/// 
///     \li worldMatrixEnabled() tells whether world transformation is enabled.
/// 
///     \li viewTransformEnabled() tells whether view transformation is
///         enabled.
/// 
///     \endlist
/// 
///     Note that some of these settings mirror settings in some paint
///     devices, e.g.  QWidget::font(). The QPainter::begin() function (or
///     equivalently the QPainter constructor) copies these attributes
///     from the paint device.
/// 
///     You can at any time save the QPainter's state by calling the
///     save() function which saves all the available settings on an
///     internal stack. The restore() function pops them back.
/// 
///     \section1 Drawing
/// 
///     QPainter provides functions to draw most primitives: drawPoint(),
///     drawPoints(), drawLine(), drawRect(), drawRoundedRect(),
///     drawEllipse(), drawArc(), drawPie(), drawChord(), drawPolyline(),
///     drawPolygon(), drawConvexPolygon() and drawCubicBezier().  The two
///     convenience functions, drawRects() and drawLines(), draw the given
///     number of rectangles or lines in the given array of \l
///     {QRect}{QRects} or \l {QLine}{QLines} using the current pen and
///     brush.
/// 
///     The QPainter class also provides the fillRect() function which
///     fills the given QRect, with the given QBrush, and the eraseRect()
///     function that erases the area inside the given rectangle.
/// 
///     All of these functions have both integer and floating point
///     versions.
/// 
///     \table 100%
///     \row
///     \li \inlineimage qpainter-basicdrawing.png
///     \li
///     \b {Basic Drawing Example}
/// 
///     The \l {painting/basicdrawing}{Basic Drawing} example shows how to
///     display basic graphics primitives in a variety of styles using the
///     QPainter class.
/// 
///     \endtable
/// 
///     If you need to draw a complex shape, especially if you need to do
///     so repeatedly, consider creating a QPainterPath and drawing it
///     using drawPath().
/// 
///     \table 100%
///     \row
///     \li
///     \b {Painter Paths example}
/// 
///     The QPainterPath class provides a container for painting
///     operations, enabling graphical shapes to be constructed and
///     reused.
/// 
///     The \l {painting/painterpaths}{Painter Paths} example shows how
///     painter paths can be used to build complex shapes for rendering.
/// 
///     \li \inlineimage qpainter-painterpaths.png
///     \endtable
/// 
///     QPainter also provides the fillPath() function which fills the
///     given QPainterPath with the given QBrush, and the strokePath()
///     function that draws the outline of the given path (i.e. strokes
///     the path).
/// 
///     See also the \l {painting/deform}{Vector Deformation} example which
///     shows how to use advanced vector techniques to draw text using a
///     QPainterPath, the \l {painting/gradients}{Gradients} example which shows
///     the different types of gradients that are available in Qt, and the \l
///     {painting/pathstroke}{Path Stroking} example which shows Qt's built-in
///     dash patterns and shows how custom patterns can be used to extend
///     the range of available patterns.
/// 
///     \table
///     \header
///     \li \l {painting/deform}{Vector Deformation}
///     \li \l {painting/gradients}{Gradients}
///     \li \l {painting/pathstroke}{Path Stroking}
///     \row
///     \li \inlineimage qpainter-vectordeformation.png
///     \li \inlineimage qpainter-gradients.png
///     \li \inlineimage qpainter-pathstroking.png
///     \endtable
/// 
///     Text drawing is done using drawText(). When you need
///     fine-grained positioning, boundingRect() tells you where a given
///     drawText() command will draw.
/// 
///     \section1 Drawing Pixmaps and Images
/// 
///     There are functions to draw pixmaps/images, namely drawPixmap(),
///     drawImage() and drawTiledPixmap(). Both drawPixmap() and drawImage()
///     produce the same result, except that drawPixmap() is faster
///     on-screen while drawImage() may be faster on a QPrinter or other
///     devices.
/// 
///     There is a drawPicture() function that draws the contents of an
///     entire QPicture. The drawPicture() function is the only function
///     that disregards all the painter's settings as QPicture has its own
///     settings.
/// 
///     \section2 Drawing High Resolution Versions of Pixmaps and Images
/// 
///     High resolution versions of pixmaps have a \e{device pixel ratio} value larger
///     than 1 (see QImageReader, QPixmap::devicePixelRatio()). Should it match the value
///     of the underlying QPaintDevice, it is drawn directly onto the device with no
///     additional transformation applied.
/// 
///     This is for example the case when drawing a QPixmap of 64x64 pixels size with
///     a device pixel ratio of 2 onto a high DPI screen which also has
///     a device pixel ratio of 2. Note that the pixmap is then effectively 32x32
///     pixels in \e{user space}. Code paths in Qt that calculate layout geometry
///     based on the pixmap size will use this size. The net effect of this is that
///     the pixmap is displayed as high DPI pixmap rather than a large pixmap.
/// 
///     \section1 Rendering Quality
/// 
///     To get the optimal rendering result using QPainter, you should use
///     the platform independent QImage as paint device; i.e. using QImage
///     will ensure that the result has an identical pixel representation
///     on any platform.
/// 
///     The QPainter class also provides a means of controlling the
///     rendering quality through its RenderHint enum and the support for
///     floating point precision: All the functions for drawing primitives
///     has a floating point version. These are often used in combination
///     with the \l {RenderHint}{QPainter::Antialiasing} render hint.
/// 
///     \table 100%
///     \row
///     \li \inlineimage qpainter-concentriccircles.png
///     \li
///     \b {Concentric Circles Example}
/// 
///     The \l {painting/concentriccircles}{Concentric Circles} example
///     shows the improved rendering quality that can be obtained using
///     floating point precision and anti-aliasing when drawing custom
///     widgets.
/// 
///     The application's main window displays several widgets which are
///     drawn using the various combinations of precision and
///     anti-aliasing.
/// 
///     \endtable
/// 
///     The RenderHint enum specifies flags to QPainter that may or may
///     not be respected by any given engine.  \l
///     {RenderHint}{QPainter::Antialiasing} indicates that the engine
///     should antialias edges of primitives if possible, \l
///     {RenderHint}{QPainter::TextAntialiasing} indicates that the engine
///     should antialias text if possible, and the \l
///     {RenderHint}{QPainter::SmoothPixmapTransform} indicates that the
///     engine should use a smooth pixmap transformation algorithm.
/// 
///     The renderHints() function returns a flag that specifies the
///     rendering hints that are set for this painter.  Use the
///     setRenderHint() function to set or clear the currently set
///     RenderHints.
/// 
///     \section1 Coordinate Transformations
/// 
///     Normally, the QPainter operates on the device's own coordinate
///     system (usually pixels), but QPainter has good support for
///     coordinate transformations.
/// 
///     \table
///     \header
///     \li  nop \li rotate() \li scale() \li translate()
///     \row
///     \li \inlineimage qpainter-clock.png
///     \li \inlineimage qpainter-rotation.png
///     \li \inlineimage qpainter-scale.png
///     \li \inlineimage qpainter-translation.png
///     \endtable
/// 
///     The most commonly used transformations are scaling, rotation,
///     translation and shearing. Use the scale() function to scale the
///     coordinate system by a given offset, the rotate() function to
///     rotate it clockwise and translate() to translate it (i.e. adding a
///     given offset to the points). You can also twist the coordinate
///     system around the origin using the shear() function. See the \l
///     {painting/affine}{Affine Transformations} example for a visualization of
///     a sheared coordinate system.
/// 
///     See also the \l {painting/transformations}{Transformations}
///     example which shows how transformations influence the way that
///     QPainter renders graphics primitives. In particular it shows how
///     the order of transformations affects the result.
/// 
///     \table 100%
///     \row
///     \li
///     \b {Affine Transformations Example}
/// 
///     The \l {painting/affine}{Affine Transformations} example shows Qt's
///     ability to perform affine transformations on painting
///     operations. The demo also allows the user to experiment with the
///     transformation operations and see the results immediately.
/// 
///     \li \inlineimage qpainter-affinetransformations.png
///     \endtable
/// 
///     All the tranformation operations operate on the transformation
///     worldTransform(). A matrix transforms a point in the plane to another
///     point. For more information about the transformation matrix, see
///     the \l {Coordinate System} and QTransform documentation.
/// 
///     The setWorldTransform() function can replace or add to the currently
///     set worldTransform(). The resetTransform() function resets any
///     transformations that were made using translate(), scale(),
///     shear(), rotate(), setWorldTransform(), setViewport() and setWindow()
///     functions. The deviceTransform() returns the matrix that transforms
///     from logical coordinates to device coordinates of the platform
///     dependent paint device. The latter function is only needed when
///     using platform painting commands on the platform dependent handle,
///     and the platform does not do transformations nativly.
/// 
///     When drawing with QPainter, we specify points using logical
///     coordinates which then are converted into the physical coordinates
///     of the paint device. The mapping of the logical coordinates to the
///     physical coordinates are handled by QPainter's combinedTransform(), a
///     combination of viewport() and window() and worldTransform(). The
///     viewport() represents the physical coordinates specifying an
///     arbitrary rectangle, the window() describes the same rectangle in
///     logical coordinates, and the worldTransform() is identical with the
///     transformation matrix.
/// 
///     See also \l {Coordinate System}
/// 
///     \section1 Clipping
/// 
///     QPainter can clip any drawing operation to a rectangle, a region,
///     or a vector path. The current clip is available using the
///     functions clipRegion() and clipPath(). Whether paths or regions are
///     preferred (faster) depends on the underlying paintEngine(). For
///     example, the QImage paint engine prefers paths while the X11 paint
///     engine prefers regions. Setting a clip is done in the painters
///     logical coordinates.
/// 
///     After QPainter's clipping, the paint device may also clip. For
///     example, most widgets clip away the pixels used by child widgets,
///     and most printers clip away an area near the edges of the paper.
///     This additional clipping is not reflected by the return value of
///     clipRegion() or hasClipping().
/// 
///     \section1 Composition Modes
///     \target Composition Modes
/// 
///     QPainter provides the CompositionMode enum which defines the
///     Porter-Duff rules for digital image compositing; it describes a
///     model for combining the pixels in one image, the source, with the
///     pixels in another image, the destination.
/// 
///     The two most common forms of composition are \l
///     {QPainter::CompositionMode}{Source} and \l
///     {QPainter::CompositionMode}{SourceOver}.  \l
///     {QPainter::CompositionMode}{Source} is used to draw opaque objects
///     onto a paint device. In this mode, each pixel in the source
///     replaces the corresponding pixel in the destination. In \l
///     {QPainter::CompositionMode}{SourceOver} composition mode, the
///     source object is transparent and is drawn on top of the
///     destination.
/// 
///     Note that composition transformation operates pixelwise. For that
///     reason, there is a difference between using the graphic primitive
///     itself and its bounding rectangle: The bounding rect contains
///     pixels with alpha == 0 (i.e the pixels surrounding the
///     primitive). These pixels will overwrite the other image's pixels,
///     affectively clearing those, while the primitive only overwrites
///     its own area.
/// 
///     \table 100%
///     \row
///     \li \inlineimage qpainter-compositiondemo.png
/// 
///     \li
///     \b {Composition Modes Example}
/// 
///     The \l {painting/composition}{Composition Modes} example, available in
///     Qt's examples directory, allows you to experiment with the various
///     composition modes and see the results immediately.
/// 
///     \endtable
/// 
///     \section1 Limitations
///     \target Limitations
/// 
///     If you are using coordinates with Qt's raster-based paint engine, it is
///     important to note that, while coordinates greater than +/- 2\sup 15 can
///     be used, any painting performed with coordinates outside this range is not
///     guaranteed to be shown; the drawing may be clipped. This is due to the
///     use of \c{short int} in the implementation.
/// 
///     The outlines generated by Qt's stroker are only an approximation when dealing
///     with curved shapes. It is in most cases impossible to represent the outline of
///     a bezier curve segment using another bezier curve segment, and so Qt approximates
///     the curve outlines by using several smaller curves. For performance reasons there
///     is a limit to how many curves Qt uses for these outlines, and thus when using
///     large pen widths or scales the outline error increases. To generate outlines with
///     smaller errors it is possible to use the QPainterPathStroker class, which has the
///     setCurveThreshold member function which let's the user specify the error tolerance.
///     Another workaround is to convert the paths to polygons first and then draw the
///     polygons instead.
/// 
///     \section1 Performance
/// 
///     QPainter is a rich framework that allows developers to do a great
///     variety of graphical operations, such as gradients, composition
///     modes and vector graphics. And QPainter can do this across a
///     variety of different hardware and software stacks. Naturally the
///     underlying combination of hardware and software has some
///     implications for performance, and ensuring that every single
///     operation is fast in combination with all the various combinations
///     of composition modes, brushes, clipping, transformation, etc, is
///     close to an impossible task because of the number of
///     permutations. As a compromise we have selected a subset of the
///     QPainter API and backends, where performance is guaranteed to be as
///     good as we can sensibly get it for the given combination of
///     hardware and software.
/// 
///     The backends we focus on as high-performance engines are:
/// 
///     \list
/// 
///     \li Raster - This backend implements all rendering in pure software
///     and is always used to render into QImages. For optimal performance
///     only use the format types QImage::Format_ARGB32_Premultiplied,
///     QImage::Format_RGB32 or QImage::Format_RGB16. Any other format,
///     including QImage::Format_ARGB32, has significantly worse
///     performance. This engine is used by default for QWidget and QPixmap.
/// 
///     \li OpenGL 2.0 (ES) - This backend is the primary backend for
///     hardware accelerated graphics. It can be run on desktop machines
///     and embedded devices supporting the OpenGL 2.0 or OpenGL/ES 2.0
///     specification. This includes most graphics chips produced in the
///     last couple of years. The engine can be enabled by using QPainter
///     onto a QOpenGLWidget.
/// 
///     \endlist
/// 
///     These operations are:
/// 
///     \list
/// 
///     \li Simple transformations, meaning translation and scaling, pluss
///     0, 90, 180, 270 degree rotations.
/// 
///     \li \c drawPixmap() in combination with simple transformations and
///     opacity with non-smooth transformation mode
///     (\c QPainter::SmoothPixmapTransform not enabled as a render hint).
/// 
///     \li Rectangle fills with solid color, two-color linear gradients
///     and simple transforms.
/// 
///     \li Rectangular clipping with simple transformations and intersect
///     clip.
/// 
///     \li Composition Modes \c QPainter::CompositionMode_Source and
///     QPainter::CompositionMode_SourceOver
/// 
///     \li Rounded rectangle filling using solid color and two-color
///     linear gradients fills.
/// 
///     \li 3x3 patched pixmaps, via qDrawBorderPixmap.
/// 
///     \endlist
/// 
///     This list gives an indication of which features to safely use in
///     an application where performance is critical. For certain setups,
///     other operations may be fast too, but before making extensive use
///     of them, it is recommended to benchmark and verify them on the
///     system where the software will run in the end. There are also
///     cases where expensive operations are ok to use, for instance when
///     the result is cached in a QPixmap.
/// 
///     \sa QPaintDevice, QPaintEngine, {Qt SVG}, {Basic Drawing Example},
///         {Drawing Utility Functions}
[org_name(QPainter)]
enum RenderHint {
    Antialiasing,
    TextAntialiasing,
    SmoothPixmapTransform,
    HighQualityAntialiasing,
    NonCosmeticDefaultPen,
    Qt4CompatiblePainting,
}

[org_name(QPainter)]
enum PixmapFragmentHint {
    OpaqueHint,
}

[org_name(QPainter)]
enum CompositionMode {
    CompositionMode_SourceOver,
    CompositionMode_DestinationOver,
    CompositionMode_Clear,
    CompositionMode_Source,
    CompositionMode_Destination,
    CompositionMode_SourceIn,
    CompositionMode_DestinationIn,
    CompositionMode_SourceOut,
    CompositionMode_DestinationOut,
    CompositionMode_SourceAtop,
    CompositionMode_DestinationAtop,
    CompositionMode_Xor,
    CompositionMode_Plus,
    CompositionMode_Multiply,
    CompositionMode_Screen,
    CompositionMode_Overlay,
    CompositionMode_Darken,
    CompositionMode_Lighten,
    CompositionMode_ColorDodge,
    CompositionMode_ColorBurn,
    CompositionMode_HardLight,
    CompositionMode_SoftLight,
    CompositionMode_Difference,
    CompositionMode_Exclusion,
    RasterOp_SourceOrDestination,
    RasterOp_SourceAndDestination,
    RasterOp_SourceXorDestination,
    RasterOp_NotSourceAndNotDestination,
    RasterOp_NotSourceOrNotDestination,
    RasterOp_NotSourceXorDestination,
    RasterOp_NotSource,
    RasterOp_NotSourceAndDestination,
    RasterOp_SourceAndNotDestination,
    RasterOp_NotSourceOrDestination,
    RasterOp_SourceOrNotDestination,
    RasterOp_ClearDestination,
    RasterOp_SetDestination,
    RasterOp_NotDestination,
}


struct Painter {
    qt_check_for_qgadget_macro(),
    ///     Returns the paint device on which this painter is currently
    ///     painting, or 0 if the painter is not active.
    /// 
    ///     \sa isActive()
    device() -> PaintDevice?,
    begin(arg0: *PaintDeviceType) -> bool,
    ///     Ends painting. Any resources used while painting are released. You
    ///     don't normally need to call this since it is called by the
    ///     destructor.
    /// 
    ///     Returns \c true if the painter is no longer active; otherwise returns \c false.
    /// 
    ///     \sa begin(), isActive()
    end() -> bool,
    ///     Returns \c true if begin() has been called and end() has not yet been
    ///     called; otherwise returns \c false.
    /// 
    ///     \sa begin(), QPaintDevice::paintingActive()
    is_active() -> bool,
    ///     Initializes the painters pen, background and font to the same as
    ///     the given \a device.
    /// 
    ///     \obsolete
    /// 
    ///     \sa begin(), {QPainter#Settings}{Settings}
    init_from(device: *PaintDeviceType),
    ///     Sets the composition mode to the given \a mode.
    /// 
    ///     \warning Only a QPainter operating on a QImage fully supports all
    ///     composition modes. The RasterOp modes are supported for X11 as
    ///     described in compositionMode().
    /// 
    ///     \sa compositionMode()
    set_composition_mode(mode: Painter::CompositionMode),
    ///   Returns the current composition mode.
    /// 
    ///   \sa CompositionMode, setCompositionMode()
    composition_mode() -> Painter::CompositionMode,
    font() -> Font?,
    ///     Sets the painter's font to the given \a font.
    /// 
    ///     This font is used by subsequent drawText() functions. The text
    ///     color is the same as the pen color.
    /// 
    ///     If you set a font that isn't available, Qt finds a close match.
    ///     font() will return what you set using setFont() and fontInfo() returns the
    ///     font actually being used (which may be the same).
    /// 
    ///     \sa font(), drawText(), {QPainter#Settings}{Settings}
    set_font(f: &FontType),
    ///     Returns the font info for the painter if the painter is
    ///     active. Otherwise, the return value is undefined.
    /// 
    ///     \sa font(), isActive(), {QPainter#Settings}{Settings}
    font_info() -> FontInfo,
    ///     \overload
    /// 
    ///     Sets the painter's pen to have the given \a style, width 1 and
    ///     black color.
    set_pen(color: &ColorType),
    ///     \overload
    /// 
    ///     Sets the painter's pen to have the given \a style, width 1 and
    ///     black color.
    set_pen(pen: &PenType),
    ///     \overload
    /// 
    ///     Sets the painter's pen to have the given \a style, width 1 and
    ///     black color.
    set_pen(style: Rute::PenStyle),
    pen() -> Pen?,
    ///     \overload
    /// 
    ///     Sets the painter's brush to black color and the specified \a
    ///     style.
    set_brush(brush: &BrushType),
    ///     \overload
    /// 
    ///     Sets the painter's brush to black color and the specified \a
    ///     style.
    set_brush(style: Rute::BrushStyle),
    brush() -> Brush?,
    ///     Sets the background mode of the painter to the given \a mode
    /// 
    ///     Qt::TransparentMode (the default) draws stippled lines and text
    ///     without setting the background pixels.  Qt::OpaqueMode fills these
    ///     space with the current background color.
    /// 
    ///     Note that in order to draw a bitmap or pixmap transparently, you
    ///     must use QPixmap::setMask().
    /// 
    ///     \sa backgroundMode(), setBackground(),
    ///     {QPainter#Settings}{Settings}
    set_background_mode(mode: Rute::BGMode),
    ///     Returns the current background mode.
    /// 
    ///     \sa setBackgroundMode(), {QPainter#Settings}{Settings}
    background_mode() -> Rute::BGMode,
    ///     Returns the currently set brush origin.
    /// 
    ///     \sa setBrushOrigin(), {QPainter#Settings}{Settings}
    brush_origin() -> Point,
    ///     \fn void QPainter::setBrushOrigin(const QPointF &position)
    /// 
    ///     Sets the brush origin to \a position.
    /// 
    ///     The brush origin specifies the (0, 0) coordinate of the painter's
    ///     brush.
    /// 
    ///     Note that while the brushOrigin() was necessary to adopt the
    ///     parent's background for a widget in Qt 3, this is no longer the
    ///     case since the Qt 4 painter doesn't paint the background unless
    ///     you explicitly tell it to do so by setting the widget's \l
    ///     {QWidget::autoFillBackground}{autoFillBackground} property to
    ///     true.
    /// 
    ///     \sa brushOrigin(), {QPainter#Settings}{Settings}
    set_brush_origin(x: i32, y: i32),
    ///     \fn void QPainter::setBrushOrigin(const QPointF &position)
    /// 
    ///     Sets the brush origin to \a position.
    /// 
    ///     The brush origin specifies the (0, 0) coordinate of the painter's
    ///     brush.
    /// 
    ///     Note that while the brushOrigin() was necessary to adopt the
    ///     parent's background for a widget in Qt 3, this is no longer the
    ///     case since the Qt 4 painter doesn't paint the background unless
    ///     you explicitly tell it to do so by setting the widget's \l
    ///     {QWidget::autoFillBackground}{autoFillBackground} property to
    ///     true.
    /// 
    ///     \sa brushOrigin(), {QPainter#Settings}{Settings}
    set_brush_origin(arg0: &PointType),
    ///     \fn void QPainter::setBrushOrigin(const QPointF &position)
    /// 
    ///     Sets the brush origin to \a position.
    /// 
    ///     The brush origin specifies the (0, 0) coordinate of the painter's
    ///     brush.
    /// 
    ///     Note that while the brushOrigin() was necessary to adopt the
    ///     parent's background for a widget in Qt 3, this is no longer the
    ///     case since the Qt 4 painter doesn't paint the background unless
    ///     you explicitly tell it to do so by setting the widget's \l
    ///     {QWidget::autoFillBackground}{autoFillBackground} property to
    ///     true.
    /// 
    ///     \sa brushOrigin(), {QPainter#Settings}{Settings}
    set_brush_origin(arg0: &PointFType),
    ///     \fn void QPainter::setBackground(const QBrush &brush)
    /// 
    ///     Sets the background brush of the painter to the given \a brush.
    /// 
    ///     The background brush is the brush that is filled in when drawing
    ///     opaque text, stippled lines and bitmaps. The background brush has
    ///     no effect in transparent background mode (which is the default).
    /// 
    ///     \sa background(), setBackgroundMode(),
    ///     {QPainter#Settings}{Settings}
    set_background(bg: &BrushType),
    background() -> Brush?,
    ///     \since 4.2
    /// 
    ///     Returns the opacity of the painter. The default value is
    ///     1.
    opacity() -> f32,
    ///     \since 4.2
    /// 
    ///     Sets the opacity of the painter to \a opacity. The value should
    ///     be in the range 0.0 to 1.0, where 0.0 is fully transparent and
    ///     1.0 is fully opaque.
    /// 
    ///     Opacity set on the painter will apply to all drawing operations
    ///     individually.
    set_opacity(opacity: f32),
    ///     Returns the currently set clip region. Note that the clip region
    ///     is given in logical coordinates.
    /// 
    ///     \warning QPainter does not store the combined clip explicitly as
    ///     this is handled by the underlying QPaintEngine, so the path is
    ///     recreated on demand and transformed to the current logical
    ///     coordinate system. This is potentially an expensive operation.
    /// 
    ///     \sa setClipRegion(), clipPath(), setClipping()
    clip_region() -> Region,
    ///     Returns the current clip path in logical coordinates.
    /// 
    ///     \warning QPainter does not store the combined clip explicitly as
    ///     this is handled by the underlying QPaintEngine, so the path is
    ///     recreated on demand and transformed to the current logical
    ///     coordinate system. This is potentially an expensive operation.
    /// 
    ///     \sa setClipPath(), clipRegion(), setClipping()
    clip_path() -> PainterPath,
    ///     \fn void QPainter::setClipRect(const QRect &rectangle, Qt::ClipOperation operation)
    ///     \overload
    /// 
    ///     Enables clipping, and sets the clip region to the given \a rectangle using the given
    ///     clip \a operation.
    set_clip_rect(arg0: &RectFType, op: Rute::ClipOperation),
    ///     \fn void QPainter::setClipRect(const QRect &rectangle, Qt::ClipOperation operation)
    ///     \overload
    /// 
    ///     Enables clipping, and sets the clip region to the given \a rectangle using the given
    ///     clip \a operation.
    set_clip_rect(arg0: &RectType, op: Rute::ClipOperation),
    ///     \fn void QPainter::setClipRect(const QRect &rectangle, Qt::ClipOperation operation)
    ///     \overload
    /// 
    ///     Enables clipping, and sets the clip region to the given \a rectangle using the given
    ///     clip \a operation.
    set_clip_rect(x: i32, y: i32, w: i32, h: i32, op: Rute::ClipOperation),
    ///     \fn void QPainter::setClipRegion(const QRegion &region, Qt::ClipOperation operation)
    /// 
    ///     Sets the clip region to the given \a region using the specified clip
    ///     \a operation. The default clip operation is to replace the current
    ///     clip region.
    /// 
    ///     Note that the clip region is given in logical coordinates.
    /// 
    ///     \sa clipRegion(), setClipRect(), {QPainter#Clipping}{Clipping}
    set_clip_region(arg0: &RegionType, op: Rute::ClipOperation),
    ///     \fn void QPainter::setClipPath(const QPainterPath &path, Qt::ClipOperation operation)
    /// 
    ///     Enables clipping, and sets the clip path for the painter to the
    ///     given \a path, with the clip \a operation.
    /// 
    ///     Note that the clip path is specified in logical (painter)
    ///     coordinates.
    /// 
    ///     \sa clipPath(), clipRegion(), {QPainter#Clipping}{Clipping}
    /// 
    set_clip_path(path: &PainterPathType, op: Rute::ClipOperation),
    ///     Enables clipping if  \a enable is true, or disables clipping if  \a
    ///     enable is false.
    /// 
    ///     \sa hasClipping(), {QPainter#Clipping}{Clipping}
    set_clipping(enable: bool),
    ///     Returns \c true if clipping has been set; otherwise returns \c false.
    /// 
    ///     \sa setClipping(), {QPainter#Clipping}{Clipping}
    has_clipping() -> bool,
    clip_bounding_rect() -> RectF,
    ///     Saves the current painter state (pushes the state onto a stack). A
    ///     save() must be followed by a corresponding restore(); the end()
    ///     function unwinds the stack.
    /// 
    ///     \sa restore()
    save(),
    ///     Restores the current painter state (pops a saved state off the
    ///     stack).
    /// 
    ///     \sa save()
    restore(),
    ///     \since 4.3
    /// 
    ///     Sets the world transformation matrix.
    ///     If \a combine is true, the specified \a transform is combined with
    ///     the current matrix; otherwise it replaces the current matrix.
    /// 
    ///     \sa transform(), setWorldTransform()
    set_transform(transform: &TransformType, combine: bool),
    ///     Returns the matrix that transforms from logical coordinates to
    ///     device coordinates of the platform dependent paint device.
    /// 
    ///     This function is \e only needed when using platform painting
    ///     commands on the platform dependent handle (Qt::HANDLE), and the
    ///     platform does not do transformations nativly.
    /// 
    ///     The QPaintEngine::PaintEngineFeature enum can be queried to
    ///     determine whether the platform performs the transformations or
    ///     not.
    /// 
    ///     \sa worldTransform(), QPaintEngine::hasFeature(),
    device_transform() -> Transform?,
    ///     Resets any transformations that were made using translate(),
    ///     scale(), shear(), rotate(), setWorldTransform(), setViewport()
    ///     and setWindow().
    /// 
    ///     \sa {Coordinate Transformations}
    reset_transform(),
    ///     Sets the world transformation matrix.
    ///     If \a combine is true, the specified \a matrix is combined with the current matrix;
    ///     otherwise it replaces the current matrix.
    /// 
    ///     \sa transform(), setTransform()
    set_world_transform(matrix: &TransformType, combine: bool),
    ///     Returns the world transformation matrix.
    world_transform() -> Transform?,
    ///     Returns the transformation matrix combining the current
    ///     window/viewport and world transformation.
    /// 
    ///     \sa setWorldTransform(), setWindow(), setViewport()
    combined_transform() -> Transform,
    ///     Scales the coordinate system by (\a{sx}, \a{sy}).
    /// 
    ///     \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations}
    scale(sx: f32, sy: f32),
    ///     Shears the coordinate system by (\a{sh}, \a{sv}).
    /// 
    ///     \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations}
    shear(sh: f32, sv: f32),
    ///     \fn void QPainter::rotate(qreal angle)
    /// 
    ///     Rotates the coordinate system clockwise. The given \a angle parameter is in degrees.
    /// 
    ///     \sa setWorldTransform(), {QPainter#Coordinate Transformations}{Coordinate Transformations}
    rotate(a: f32),
    ///     Returns the window rectangle.
    /// 
    ///     \sa setWindow(), setViewTransformEnabled()
    window() -> Rect,
    ///     \fn void QPainter::setWindow(int x, int y, int width, int height)
    ///     \overload
    /// 
    ///     Sets the painter's window to the rectangle beginning at (\a x, \a
    ///     y) and the given \a width and \a height.
    set_window(window: &RectType),
    ///     \fn void QPainter::setWindow(int x, int y, int width, int height)
    ///     \overload
    /// 
    ///     Sets the painter's window to the rectangle beginning at (\a x, \a
    ///     y) and the given \a width and \a height.
    set_window(x: i32, y: i32, w: i32, h: i32),
    ///     Returns the viewport rectangle.
    /// 
    ///     \sa setViewport(), setViewTransformEnabled()
    viewport() -> Rect,
    ///     \fn void QPainter::setViewport(int x, int y, int width, int height)
    ///     \overload
    /// 
    ///     Sets the painter's viewport rectangle to be the rectangle
    ///     beginning at (\a x, \a y) with the given \a width and \a height.
    set_viewport(viewport: &RectType),
    ///     \fn void QPainter::setViewport(int x, int y, int width, int height)
    ///     \overload
    /// 
    ///     Sets the painter's viewport rectangle to be the rectangle
    ///     beginning at (\a x, \a y) with the given \a width and \a height.
    set_viewport(x: i32, y: i32, w: i32, h: i32),
    ///     Enables view transformations if \a enable is true, or disables
    ///     view transformations if \a enable is false.
    /// 
    ///     \sa viewTransformEnabled(), {Coordinate System#Window-Viewport
    ///     Conversion}{Window-Viewport Conversion}
    set_view_transform_enabled(enable: bool),
    ///     Returns \c true if view transformation is enabled; otherwise returns
    ///     false.
    /// 
    ///     \sa setViewTransformEnabled(), worldTransform()
    view_transform_enabled() -> bool,
    ///     Fills the given \a path using the given \a brush. The outline is
    ///     not drawn.
    /// 
    ///     Alternatively, you can specify a QColor instead of a QBrush; the
    ///     QBrush constructor (taking a QColor argument) will automatically
    ///     create a solid pattern brush.
    /// 
    ///     \sa drawPath()
    fill_path(path: &PainterPathType, brush: &BrushType),
    ///     Draws the given painter \a path using the current pen for outline
    ///     and the current brush for filling.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-path.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 5
    ///     \endtable
    /// 
    ///     \sa {painting/painterpaths}{the Painter Paths
    ///     example},{painting/deform}{the Vector Deformation example}
    draw_path(path: &PainterPathType),
    ///     \fn void QPainter::drawPoint(const QPoint &position)
    ///     \overload
    /// 
    ///     Draws a single point at the given \a position using the current
    ///     pen's color.
    draw_point(pt: &PointFType),
    ///     \fn void QPainter::drawPoint(const QPoint &position)
    ///     \overload
    /// 
    ///     Draws a single point at the given \a position using the current
    ///     pen's color.
    draw_point(p: &PointType),
    ///     \fn void QPainter::drawPoint(const QPoint &position)
    ///     \overload
    /// 
    ///     Draws a single point at the given \a position using the current
    ///     pen's color.
    draw_point(x: i32, y: i32),
    ///     \overload
    /// 
    ///     Draws the first \a pointCount points in the array \a points using
    ///     the current pen's color.
    draw_points(points: *PointFType, point_count: i32),
    ///     \overload
    /// 
    ///     Draws the first \a pointCount points in the array \a points using
    ///     the current pen's color.
    draw_points(points: &PolygonFType),
    ///     \overload
    /// 
    ///     Draws the first \a pointCount points in the array \a points using
    ///     the current pen's color.
    draw_points(points: *PointType, point_count: i32),
    ///     \overload
    /// 
    ///     Draws the first \a pointCount points in the array \a points using
    ///     the current pen's color.
    draw_points(points: &PolygonType),
    draw_line(line: &LineFType),
    draw_line(line: &LineType),
    draw_line(x1: i32, y1: i32, x2: i32, y2: i32),
    draw_line(p1: &PointType, p2: &PointType),
    draw_line(p1: &PointFType, p2: &PointFType),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(lines: *LineFType, line_count: i32),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(lines: [LineFType]),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(point_pairs: *PointFType, line_count: i32),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(point_pairs: [PointFType]),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(lines: *LineType, line_count: i32),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(lines: [LineType]),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(point_pairs: *PointType, line_count: i32),
    ///     \overload
    /// 
    ///     Draws the first \a lineCount lines in the array \a pointPairs
    ///     using the current pen.
    draw_lines(point_pairs: [PointType]),
    draw_rect(rect: &RectFType),
    draw_rect(x1: i32, y1: i32, w: i32, h: i32),
    draw_rect(rect: &RectType),
    ///     \fn void QPainter::drawRects(const QRect *rectangles, int rectCount)
    ///     \overload
    /// 
    ///     Draws the first \a rectCount of the given \a rectangles using the
    ///     current pen and brush.
    draw_rects(rects: *RectFType, rect_count: i32),
    ///     \fn void QPainter::drawRects(const QRect *rectangles, int rectCount)
    ///     \overload
    /// 
    ///     Draws the first \a rectCount of the given \a rectangles using the
    ///     current pen and brush.
    draw_rects(rectangles: [RectFType]),
    ///     \fn void QPainter::drawRects(const QRect *rectangles, int rectCount)
    ///     \overload
    /// 
    ///     Draws the first \a rectCount of the given \a rectangles using the
    ///     current pen and brush.
    draw_rects(rects: *RectType, rect_count: i32),
    ///     \fn void QPainter::drawRects(const QRect *rectangles, int rectCount)
    ///     \overload
    /// 
    ///     Draws the first \a rectCount of the given \a rectangles using the
    ///     current pen and brush.
    draw_rects(rectangles: [RectType]),
    ///     \fn void QPainter::drawEllipse(const QRect &rectangle)
    /// 
    ///     \overload
    /// 
    ///     Draws the ellipse defined by the given \a rectangle.
    draw_ellipse(r: &RectFType),
    ///     \fn void QPainter::drawEllipse(const QRect &rectangle)
    /// 
    ///     \overload
    /// 
    ///     Draws the ellipse defined by the given \a rectangle.
    draw_ellipse(r: &RectType),
    ///     \fn void QPainter::drawEllipse(const QRect &rectangle)
    /// 
    ///     \overload
    /// 
    ///     Draws the ellipse defined by the given \a rectangle.
    draw_ellipse(x: i32, y: i32, w: i32, h: i32),
    ///     \fn void QPainter::drawEllipse(const QRect &rectangle)
    /// 
    ///     \overload
    /// 
    ///     Draws the ellipse defined by the given \a rectangle.
    draw_ellipse(center: &PointFType, rx: f32, ry: f32),
    ///     \fn void QPainter::drawEllipse(const QRect &rectangle)
    /// 
    ///     \overload
    /// 
    ///     Draws the ellipse defined by the given \a rectangle.
    draw_ellipse(center: &PointType, rx: i32, ry: i32),
    ///     Draws the polyline defined by the first \a pointCount points in \a
    ///     points using the current pen.
    /// 
    ///     Note that unlike the drawPolygon() function the last point is \e
    ///     not connected to the first, neither is the polyline filled.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 13
    ///     \endtable
    /// 
    ///     \sa drawLines(), drawPolygon(), {Coordinate System}
    draw_polyline(points: *PointFType, point_count: i32),
    ///     Draws the polyline defined by the first \a pointCount points in \a
    ///     points using the current pen.
    /// 
    ///     Note that unlike the drawPolygon() function the last point is \e
    ///     not connected to the first, neither is the polyline filled.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 13
    ///     \endtable
    /// 
    ///     \sa drawLines(), drawPolygon(), {Coordinate System}
    draw_polyline(polyline: &PolygonFType),
    ///     Draws the polyline defined by the first \a pointCount points in \a
    ///     points using the current pen.
    /// 
    ///     Note that unlike the drawPolygon() function the last point is \e
    ///     not connected to the first, neither is the polyline filled.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 13
    ///     \endtable
    /// 
    ///     \sa drawLines(), drawPolygon(), {Coordinate System}
    draw_polyline(points: *PointType, point_count: i32),
    ///     Draws the polyline defined by the first \a pointCount points in \a
    ///     points using the current pen.
    /// 
    ///     Note that unlike the drawPolygon() function the last point is \e
    ///     not connected to the first, neither is the polyline filled.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 13
    ///     \endtable
    /// 
    ///     \sa drawLines(), drawPolygon(), {Coordinate System}
    draw_polyline(polygon: &PolygonType),
    ///     Draws the polygon defined by the first \a pointCount points in the
    ///     array \a points using the current pen and brush.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-polygon.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 14
    ///     \endtable
    /// 
    ///     The first point is implicitly connected to the last point, and the
    ///     polygon is filled with the current brush().
    /// 
    ///     If \a fillRule is Qt::WindingFill, the polygon is filled using the
    ///     winding fill algorithm.  If \a fillRule is Qt::OddEvenFill, the
    ///     polygon is filled using the odd-even fill algorithm. See
    ///     \l{Qt::FillRule} for a more detailed description of these fill
    ///     rules.
    /// 
    ///     \sa drawConvexPolygon(), drawPolyline(), {Coordinate System}
    draw_polygon(points: *PointFType, point_count: i32, fill_rule: Rute::FillRule),
    ///     Draws the polygon defined by the first \a pointCount points in the
    ///     array \a points using the current pen and brush.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-polygon.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 14
    ///     \endtable
    /// 
    ///     The first point is implicitly connected to the last point, and the
    ///     polygon is filled with the current brush().
    /// 
    ///     If \a fillRule is Qt::WindingFill, the polygon is filled using the
    ///     winding fill algorithm.  If \a fillRule is Qt::OddEvenFill, the
    ///     polygon is filled using the odd-even fill algorithm. See
    ///     \l{Qt::FillRule} for a more detailed description of these fill
    ///     rules.
    /// 
    ///     \sa drawConvexPolygon(), drawPolyline(), {Coordinate System}
    draw_polygon(polygon: &PolygonFType, fill_rule: Rute::FillRule),
    ///     Draws the polygon defined by the first \a pointCount points in the
    ///     array \a points using the current pen and brush.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-polygon.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 14
    ///     \endtable
    /// 
    ///     The first point is implicitly connected to the last point, and the
    ///     polygon is filled with the current brush().
    /// 
    ///     If \a fillRule is Qt::WindingFill, the polygon is filled using the
    ///     winding fill algorithm.  If \a fillRule is Qt::OddEvenFill, the
    ///     polygon is filled using the odd-even fill algorithm. See
    ///     \l{Qt::FillRule} for a more detailed description of these fill
    ///     rules.
    /// 
    ///     \sa drawConvexPolygon(), drawPolyline(), {Coordinate System}
    draw_polygon(points: *PointType, point_count: i32, fill_rule: Rute::FillRule),
    ///     Draws the polygon defined by the first \a pointCount points in the
    ///     array \a points using the current pen and brush.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-polygon.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 14
    ///     \endtable
    /// 
    ///     The first point is implicitly connected to the last point, and the
    ///     polygon is filled with the current brush().
    /// 
    ///     If \a fillRule is Qt::WindingFill, the polygon is filled using the
    ///     winding fill algorithm.  If \a fillRule is Qt::OddEvenFill, the
    ///     polygon is filled using the odd-even fill algorithm. See
    ///     \l{Qt::FillRule} for a more detailed description of these fill
    ///     rules.
    /// 
    ///     \sa drawConvexPolygon(), drawPolyline(), {Coordinate System}
    draw_polygon(polygon: &PolygonType, fill_rule: Rute::FillRule),
    ///     \fn void QPainter::drawConvexPolygon(const QPolygon &polygon)
    ///     \overload
    /// 
    ///     Draws the convex polygon defined by \a polygon using the current
    ///     pen and brush.
    draw_convex_polygon(points: *PointFType, point_count: i32),
    ///     \fn void QPainter::drawConvexPolygon(const QPolygon &polygon)
    ///     \overload
    /// 
    ///     Draws the convex polygon defined by \a polygon using the current
    ///     pen and brush.
    draw_convex_polygon(polygon: &PolygonFType),
    ///     \fn void QPainter::drawConvexPolygon(const QPolygon &polygon)
    ///     \overload
    /// 
    ///     Draws the convex polygon defined by \a polygon using the current
    ///     pen and brush.
    draw_convex_polygon(points: *PointType, point_count: i32),
    ///     \fn void QPainter::drawConvexPolygon(const QPolygon &polygon)
    ///     \overload
    /// 
    ///     Draws the convex polygon defined by \a polygon using the current
    ///     pen and brush.
    draw_convex_polygon(polygon: &PolygonType),
    ///     \fn void QPainter::drawArc(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws the arc defined by the given \a rectangle, \a startAngle and
    ///     \a spanAngle.
    /// 
    ///     The \a startAngle and \a spanAngle must be specified in 1/16th of
    ///     a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    ///     values for the angles mean counter-clockwise while negative values
    ///     mean the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-arc.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 10
    ///     \endtable
    /// 
    ///     \sa drawPie(), drawChord(), {Coordinate System}
    draw_arc(rect: &RectFType, a: i32, alen: i32),
    ///     \fn void QPainter::drawArc(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws the arc defined by the given \a rectangle, \a startAngle and
    ///     \a spanAngle.
    /// 
    ///     The \a startAngle and \a spanAngle must be specified in 1/16th of
    ///     a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    ///     values for the angles mean counter-clockwise while negative values
    ///     mean the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-arc.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 10
    ///     \endtable
    /// 
    ///     \sa drawPie(), drawChord(), {Coordinate System}
    draw_arc(arg0: &RectType, a: i32, alen: i32),
    ///     \fn void QPainter::drawArc(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws the arc defined by the given \a rectangle, \a startAngle and
    ///     \a spanAngle.
    /// 
    ///     The \a startAngle and \a spanAngle must be specified in 1/16th of
    ///     a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    ///     values for the angles mean counter-clockwise while negative values
    ///     mean the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-arc.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 10
    ///     \endtable
    /// 
    ///     \sa drawPie(), drawChord(), {Coordinate System}
    draw_arc(x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32),
    ///     \fn void QPainter::drawPie(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws a pie defined by the given \a rectangle, \a startAngle and \a spanAngle.
    /// 
    ///     The pie is filled with the current brush().
    /// 
    ///     The startAngle and spanAngle must be specified in 1/16th of a
    ///     degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    ///     for the angles mean counter-clockwise while negative values mean
    ///     the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-pie.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 11
    ///     \endtable
    /// 
    ///     \sa drawEllipse(), drawChord(), {Coordinate System}
    draw_pie(rect: &RectFType, a: i32, alen: i32),
    ///     \fn void QPainter::drawPie(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws a pie defined by the given \a rectangle, \a startAngle and \a spanAngle.
    /// 
    ///     The pie is filled with the current brush().
    /// 
    ///     The startAngle and spanAngle must be specified in 1/16th of a
    ///     degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    ///     for the angles mean counter-clockwise while negative values mean
    ///     the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-pie.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 11
    ///     \endtable
    /// 
    ///     \sa drawEllipse(), drawChord(), {Coordinate System}
    draw_pie(x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32),
    ///     \fn void QPainter::drawPie(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws a pie defined by the given \a rectangle, \a startAngle and \a spanAngle.
    /// 
    ///     The pie is filled with the current brush().
    /// 
    ///     The startAngle and spanAngle must be specified in 1/16th of a
    ///     degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    ///     for the angles mean counter-clockwise while negative values mean
    ///     the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-pie.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 11
    ///     \endtable
    /// 
    ///     \sa drawEllipse(), drawChord(), {Coordinate System}
    draw_pie(arg0: &RectType, a: i32, alen: i32),
    ///     \fn void QPainter::drawChord(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws the chord defined by the given \a rectangle, \a startAngle and
    ///     \a spanAngle.  The chord is filled with the current brush().
    /// 
    ///     The startAngle and spanAngle must be specified in 1/16th of a
    ///     degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    ///     for the angles mean counter-clockwise while negative values mean
    ///     the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-chord.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 12
    ///     \endtable
    /// 
    ///     \sa drawArc(), drawPie(), {Coordinate System}
    draw_chord(rect: &RectFType, a: i32, alen: i32),
    ///     \fn void QPainter::drawChord(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws the chord defined by the given \a rectangle, \a startAngle and
    ///     \a spanAngle.  The chord is filled with the current brush().
    /// 
    ///     The startAngle and spanAngle must be specified in 1/16th of a
    ///     degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    ///     for the angles mean counter-clockwise while negative values mean
    ///     the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-chord.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 12
    ///     \endtable
    /// 
    ///     \sa drawArc(), drawPie(), {Coordinate System}
    draw_chord(x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32),
    ///     \fn void QPainter::drawChord(const QRectF &rectangle, int startAngle, int spanAngle)
    /// 
    ///     Draws the chord defined by the given \a rectangle, \a startAngle and
    ///     \a spanAngle.  The chord is filled with the current brush().
    /// 
    ///     The startAngle and spanAngle must be specified in 1/16th of a
    ///     degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    ///     for the angles mean counter-clockwise while negative values mean
    ///     the clockwise direction. Zero degrees is at the 3 o'clock
    ///     position.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-chord.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 12
    ///     \endtable
    /// 
    ///     \sa drawArc(), drawPie(), {Coordinate System}
    draw_chord(arg0: &RectType, a: i32, alen: i32),
    ///     \since 4.4
    /// 
    ///     Draws the given rectangle \a rect with rounded corners.
    /// 
    ///     The \a xRadius and \a yRadius arguments specify the radii
    ///     of the ellipses defining the corners of the rounded rectangle.
    ///     When \a mode is Qt::RelativeSize, \a xRadius and
    ///     \a yRadius are specified in percentage of half the rectangle's
    ///     width and height respectively, and should be in the range
    ///     0.0 to 100.0.
    /// 
    ///     A filled rectangle has a size of rect.size(). A stroked rectangle
    ///     has a size of rect.size() plus the pen width.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-roundrect.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 8
    ///     \endtable
    /// 
    ///     \sa drawRect(), QPen
    draw_rounded_rect(rect: &RectFType, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    ///     \since 4.4
    /// 
    ///     Draws the given rectangle \a rect with rounded corners.
    /// 
    ///     The \a xRadius and \a yRadius arguments specify the radii
    ///     of the ellipses defining the corners of the rounded rectangle.
    ///     When \a mode is Qt::RelativeSize, \a xRadius and
    ///     \a yRadius are specified in percentage of half the rectangle's
    ///     width and height respectively, and should be in the range
    ///     0.0 to 100.0.
    /// 
    ///     A filled rectangle has a size of rect.size(). A stroked rectangle
    ///     has a size of rect.size() plus the pen width.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-roundrect.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 8
    ///     \endtable
    /// 
    ///     \sa drawRect(), QPen
    draw_rounded_rect(x: i32, y: i32, w: i32, h: i32, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    ///     \since 4.4
    /// 
    ///     Draws the given rectangle \a rect with rounded corners.
    /// 
    ///     The \a xRadius and \a yRadius arguments specify the radii
    ///     of the ellipses defining the corners of the rounded rectangle.
    ///     When \a mode is Qt::RelativeSize, \a xRadius and
    ///     \a yRadius are specified in percentage of half the rectangle's
    ///     width and height respectively, and should be in the range
    ///     0.0 to 100.0.
    /// 
    ///     A filled rectangle has a size of rect.size(). A stroked rectangle
    ///     has a size of rect.size() plus the pen width.
    /// 
    ///     \table 100%
    ///     \row
    ///     \li \inlineimage qpainter-roundrect.png
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 8
    ///     \endtable
    /// 
    ///     \sa drawRect(), QPen
    draw_rounded_rect(rect: &RectType, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    ///     \obsolete
    /// 
    ///     Draws a rectangle \a r with rounded corners.
    /// 
    ///     The \a xRnd and \a yRnd arguments specify how rounded the corners
    ///     should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    ///     A filled rectangle has a size of r.size(). A stroked rectangle
    ///     has a size of r.size() plus the pen width.
    /// 
    ///     \sa drawRoundedRect()
    draw_round_rect(r: &RectFType, xround: i32, yround: i32),
    ///     \obsolete
    /// 
    ///     Draws a rectangle \a r with rounded corners.
    /// 
    ///     The \a xRnd and \a yRnd arguments specify how rounded the corners
    ///     should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    ///     A filled rectangle has a size of r.size(). A stroked rectangle
    ///     has a size of r.size() plus the pen width.
    /// 
    ///     \sa drawRoundedRect()
    draw_round_rect(x: i32, y: i32, w: i32, h: i32, arg0: i32, arg1: i32),
    ///     \obsolete
    /// 
    ///     Draws a rectangle \a r with rounded corners.
    /// 
    ///     The \a xRnd and \a yRnd arguments specify how rounded the corners
    ///     should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    ///     A filled rectangle has a size of r.size(). A stroked rectangle
    ///     has a size of r.size() plus the pen width.
    /// 
    ///     \sa drawRoundedRect()
    draw_round_rect(r: &RectType, xround: i32, yround: i32),
    ///     \fn void QPainter::drawTiledPixmap(const QRectF &rectangle, const QPixmap &pixmap, const QPointF &position)
    /// 
    ///     Draws a tiled \a pixmap, inside the given \a rectangle with its
    ///     origin at the given \a position.
    /// 
    ///     Calling drawTiledPixmap() is similar to calling drawPixmap()
    ///     several times to fill (tile) an area with a pixmap, but is
    ///     potentially much more efficient depending on the underlying window
    ///     system.
    /// 
    ///     \sa drawPixmap()
    draw_tiled_pixmap(rect: &RectFType, pm: &PixmapType, offset: &PointFType),
    ///     \fn void QPainter::drawTiledPixmap(const QRectF &rectangle, const QPixmap &pixmap, const QPointF &position)
    /// 
    ///     Draws a tiled \a pixmap, inside the given \a rectangle with its
    ///     origin at the given \a position.
    /// 
    ///     Calling drawTiledPixmap() is similar to calling drawPixmap()
    ///     several times to fill (tile) an area with a pixmap, but is
    ///     potentially much more efficient depending on the underlying window
    ///     system.
    /// 
    ///     \sa drawPixmap()
    draw_tiled_pixmap(x: i32, y: i32, w: i32, h: i32, arg0: &PixmapType, sx: i32, sy: i32),
    ///     \fn void QPainter::drawTiledPixmap(const QRectF &rectangle, const QPixmap &pixmap, const QPointF &position)
    /// 
    ///     Draws a tiled \a pixmap, inside the given \a rectangle with its
    ///     origin at the given \a position.
    /// 
    ///     Calling drawTiledPixmap() is similar to calling drawPixmap()
    ///     several times to fill (tile) an area with a pixmap, but is
    ///     potentially much more efficient depending on the underlying window
    ///     system.
    /// 
    ///     \sa drawPixmap()
    draw_tiled_pixmap(arg0: &RectType, arg1: &PixmapType, arg2: &PointType),
    ///     \fn void QPainter::drawPicture(const QPointF &point, const QPicture &picture)
    /// 
    ///     Replays the given \a picture at the given \a point.
    /// 
    ///     The QPicture class is a paint device that records and replays
    ///     QPainter commands. A picture serializes the painter commands to an
    ///     IO device in a platform-independent format. Everything that can be
    ///     painted on a widget or pixmap can also be stored in a picture.
    /// 
    ///     This function does exactly the same as QPicture::play() when
    ///     called with \a point = QPoint(0, 0).
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 18
    ///     \endtable
    /// 
    ///     \sa QPicture::play()
    draw_picture(p: &PointFType, picture: &PictureType),
    ///     \fn void QPainter::drawPicture(const QPointF &point, const QPicture &picture)
    /// 
    ///     Replays the given \a picture at the given \a point.
    /// 
    ///     The QPicture class is a paint device that records and replays
    ///     QPainter commands. A picture serializes the painter commands to an
    ///     IO device in a platform-independent format. Everything that can be
    ///     painted on a widget or pixmap can also be stored in a picture.
    /// 
    ///     This function does exactly the same as QPicture::play() when
    ///     called with \a point = QPoint(0, 0).
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 18
    ///     \endtable
    /// 
    ///     \sa QPicture::play()
    draw_picture(x: i32, y: i32, picture: &PictureType),
    ///     \fn void QPainter::drawPicture(const QPointF &point, const QPicture &picture)
    /// 
    ///     Replays the given \a picture at the given \a point.
    /// 
    ///     The QPicture class is a paint device that records and replays
    ///     QPainter commands. A picture serializes the painter commands to an
    ///     IO device in a platform-independent format. Everything that can be
    ///     painted on a widget or pixmap can also be stored in a picture.
    /// 
    ///     This function does exactly the same as QPicture::play() when
    ///     called with \a point = QPoint(0, 0).
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 18
    ///     \endtable
    /// 
    ///     \sa QPicture::play()
    draw_picture(p: &PointType, picture: &PictureType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(target_rect: &RectFType, pixmap: &PixmapType, source_rect: &RectFType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(target_rect: &RectType, pixmap: &PixmapType, source_rect: &RectType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(x: i32, y: i32, w: i32, h: i32, pm: &PixmapType, sx: i32, sy: i32, sw: i32, sh: i32),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(x: i32, y: i32, pm: &PixmapType, sx: i32, sy: i32, sw: i32, sh: i32),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(p: &PointFType, pm: &PixmapType, sr: &RectFType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(p: &PointType, pm: &PixmapType, sr: &RectType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(p: &PointFType, pm: &PixmapType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(p: &PointType, pm: &PixmapType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(x: i32, y: i32, pm: &PixmapType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(r: &RectType, pm: &PixmapType),
    ///     \fn void QPainter::drawPixmap(const QRectF &target, const QPixmap &pixmap, const QRectF &source)
    /// 
    ///     Draws the rectangular portion \a source of the given \a pixmap
    ///     into the given \a target in the paint device.
    /// 
    ///     \note The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///     \note See \l{Drawing High Resolution Versions of Pixmaps and Images} on how this is affected
    ///     by QPixmap::devicePixelRatio().
    /// 
    ///     \table 100%
    ///     \row
    ///     \li
    ///     \snippet code/src_gui_painting_qpainter.cpp 16
    ///     \endtable
    /// 
    ///     If \a pixmap is a QBitmap it is drawn with the bits that are "set"
    ///     using the pens color. If backgroundMode is Qt::OpaqueMode, the
    ///     "unset" bits are drawn using the color of the background brush; if
    ///     backgroundMode is Qt::TransparentMode, the "unset" bits are
    ///     transparent. Drawing bitmaps with gradient or texture colors is
    ///     not supported.
    /// 
    ///     \sa drawImage(), QPixmap::devicePixelRatio()
    draw_pixmap(x: i32, y: i32, w: i32, h: i32, pm: &PixmapType),
    draw_pixmap_fragments(fragments: onst QPainter::PixmapFragment *, fragment_count: i32, pixmap: &PixmapType, hints: Painter::PixmapFragmentHints),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(target_rect: &RectFType, image: &ImageType, source_rect: &RectFType, flags: Rute::ImageConversionFlags),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(target_rect: &RectType, image: &ImageType, source_rect: &RectType, flags: Rute::ImageConversionFlags),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(p: &PointFType, image: &ImageType, sr: &RectFType, flags: Rute::ImageConversionFlags),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(p: &PointType, image: &ImageType, sr: &RectType, flags: Rute::ImageConversionFlags),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(r: &RectFType, image: &ImageType),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(r: &RectType, image: &ImageType),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(p: &PointFType, image: &ImageType),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(p: &PointType, image: &ImageType),
    ///     \fn void QPainter::drawPixmap(int x, int y, const QPixmap &pixmap,
    ///                                   int sx, int sy, int sw, int sh)
    /// 
    ///     \overload
    /// 
    ///     Draws a pixmap at (\a{x}, \a{y}) by copying a part of the given \a
    ///     pixmap into the paint device.
    /// 
    ///     (\a{x}, \a{y}) specifies the top-left point in the paint device that is
    ///     to be drawn onto. (\a{sx}, \a{sy}) specifies the top-left point in \a
    ///     pixmap that is to be drawn. The default is (0, 0).
    /// 
    ///     (\a{sw}, \a{sh}) specifies the size of the pixmap that is to be drawn.
    ///     The default, (0, 0) (and negative) means all the way to the
    ///     bottom-right of the pixmap.
    draw_image(x: i32, y: i32, image: &ImageType, sx: i32, sy: i32, sw: i32, sh: i32, flags: Rute::ImageConversionFlags),
    ///     Sets the layout direction used by the painter when drawing text,
    ///     to the specified \a direction.
    /// 
    ///     The default is Qt::LayoutDirectionAuto, which will implicitly determine the
    ///     direction from the text drawn.
    /// 
    ///     \sa QTextOption::setTextDirection(), layoutDirection(), drawText(), {QPainter#Settings}{Settings}
    set_layout_direction(direction: Rute::LayoutDirection),
    ///     Returns the layout direction used by the painter when drawing text.
    /// 
    ///     \sa QTextOption::textDirection(), setLayoutDirection(), drawText(), {QPainter#Settings}{Settings}
    layout_direction() -> Rute::LayoutDirection,
    ///     \fn void QPainter::drawGlyphRun(const QPointF &position, const QGlyphRun &glyphs)
    /// 
    ///     Draws the glyphs represented by \a glyphs at \a position. The \a position gives the
    ///     edge of the baseline for the string of glyphs. The glyphs will be retrieved from the font
    ///     selected on \a glyphs and at offsets given by the positions in \a glyphs.
    /// 
    ///     \since 4.8
    /// 
    ///     \sa QGlyphRun::setRawFont(), QGlyphRun::setPositions(), QGlyphRun::setGlyphIndexes()
    draw_glyph_run(position: &PointFType, glyph_run: &GlyphRunType),
    ///     \since 4.7
    /// 
    ///     Draws the given \a staticText at the given \a topLeftPosition.
    /// 
    ///     The text will be drawn using the font and the transformation set on the painter. If the
    ///     font and/or transformation set on the painter are different from the ones used to initialize
    ///     the layout of the QStaticText, then the layout will have to be recalculated. Use
    ///     QStaticText::prepare() to initialize \a staticText with the font and transformation with which
    ///     it will later be drawn.
    /// 
    ///     If \a topLeftPosition is not the same as when \a staticText was initialized, or when it was
    ///     last drawn, then there will be a slight overhead when translating the text to its new position.
    /// 
    ///     \note If the painter's transformation is not affine, then \a staticText will be drawn using
    ///     regular calls to drawText(), losing any potential for performance improvement.
    /// 
    ///     \note The y-position is used as the top of the font.
    /// 
    ///     \sa QStaticText
    draw_static_text(top_left_position: &PointFType, static_text: &StaticTextType),
    ///     \since 4.7
    /// 
    ///     Draws the given \a staticText at the given \a topLeftPosition.
    /// 
    ///     The text will be drawn using the font and the transformation set on the painter. If the
    ///     font and/or transformation set on the painter are different from the ones used to initialize
    ///     the layout of the QStaticText, then the layout will have to be recalculated. Use
    ///     QStaticText::prepare() to initialize \a staticText with the font and transformation with which
    ///     it will later be drawn.
    /// 
    ///     If \a topLeftPosition is not the same as when \a staticText was initialized, or when it was
    ///     last drawn, then there will be a slight overhead when translating the text to its new position.
    /// 
    ///     \note If the painter's transformation is not affine, then \a staticText will be drawn using
    ///     regular calls to drawText(), losing any potential for performance improvement.
    /// 
    ///     \note The y-position is used as the top of the font.
    /// 
    ///     \sa QStaticText
    draw_static_text(top_left_position: &PointType, static_text: &StaticTextType),
    ///     \since 4.7
    /// 
    ///     Draws the given \a staticText at the given \a topLeftPosition.
    /// 
    ///     The text will be drawn using the font and the transformation set on the painter. If the
    ///     font and/or transformation set on the painter are different from the ones used to initialize
    ///     the layout of the QStaticText, then the layout will have to be recalculated. Use
    ///     QStaticText::prepare() to initialize \a staticText with the font and transformation with which
    ///     it will later be drawn.
    /// 
    ///     If \a topLeftPosition is not the same as when \a staticText was initialized, or when it was
    ///     last drawn, then there will be a slight overhead when translating the text to its new position.
    /// 
    ///     \note If the painter's transformation is not affine, then \a staticText will be drawn using
    ///     regular calls to drawText(), losing any potential for performance improvement.
    /// 
    ///     \note The y-position is used as the top of the font.
    /// 
    ///     \sa QStaticText
    draw_static_text(left: i32, top: i32, static_text: &StaticTextType),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(p: &PointFType, s: String),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(p: &PointType, s: String),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(x: i32, y: i32, s: String),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(p: &PointFType, str: String, tf: i32, justification_padding: i32),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(r: &RectFType, flags: i32, text: String, br: *RectFType),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(r: &RectType, flags: i32, text: String, br: *RectType),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(x: i32, y: i32, w: i32, h: i32, flags: i32, text: String, br: *RectType),
    ///     \fn void QPainter::drawText(const QRectF &rectangle, const QString &text,
    ///         const QTextOption &option)
    ///     \overload
    /// 
    ///     Draws the given \a text in the \a rectangle specified using the \a option
    ///     to control its positioning and orientation.
    /// 
    ///     By default, QPainter draws text anti-aliased.
    /// 
    ///     \note The y-coordinate of \a rectangle is used as the top of the font.
    /// 
    ///     \sa setFont(), setPen()
    draw_text(r: &RectFType, text: String, o: &TextOptionType),
    ///     \fn QRectF QPainter::boundingRect(const QRectF &rectangle,
    ///         const QString &text, const QTextOption &option)
    /// 
    ///     \overload
    /// 
    ///     Instead of specifying flags as a bitwise OR of the
    ///     Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    ///     an \a option argument. The QTextOption class provides a
    ///     description of general rich text properties.
    /// 
    ///     \sa QTextOption
    bounding_rect(rect: &RectFType, flags: i32, text: String) -> RectF,
    ///     \fn QRectF QPainter::boundingRect(const QRectF &rectangle,
    ///         const QString &text, const QTextOption &option)
    /// 
    ///     \overload
    /// 
    ///     Instead of specifying flags as a bitwise OR of the
    ///     Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    ///     an \a option argument. The QTextOption class provides a
    ///     description of general rich text properties.
    /// 
    ///     \sa QTextOption
    bounding_rect(rect: &RectType, flags: i32, text: String) -> Rect,
    ///     \fn QRectF QPainter::boundingRect(const QRectF &rectangle,
    ///         const QString &text, const QTextOption &option)
    /// 
    ///     \overload
    /// 
    ///     Instead of specifying flags as a bitwise OR of the
    ///     Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    ///     an \a option argument. The QTextOption class provides a
    ///     description of general rich text properties.
    /// 
    ///     \sa QTextOption
    bounding_rect(x: i32, y: i32, w: i32, h: i32, flags: i32, text: String) -> Rect,
    ///     \fn QRectF QPainter::boundingRect(const QRectF &rectangle,
    ///         const QString &text, const QTextOption &option)
    /// 
    ///     \overload
    /// 
    ///     Instead of specifying flags as a bitwise OR of the
    ///     Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    ///     an \a option argument. The QTextOption class provides a
    ///     description of general rich text properties.
    /// 
    ///     \sa QTextOption
    bounding_rect(rect: &RectFType, text: String, o: &TextOptionType) -> RectF,
    draw_text_item(p: &PointFType, ti: &TextItemType),
    draw_text_item(x: i32, y: i32, ti: &TextItemType),
    draw_text_item(p: &PointType, ti: &TextItemType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(arg0: &RectFType, arg1: &BrushType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(x: i32, y: i32, w: i32, h: i32, arg0: &BrushType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(arg0: &RectType, arg1: &BrushType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(arg0: &RectFType, color: &ColorType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(x: i32, y: i32, w: i32, h: i32, color: &ColorType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(arg0: &RectType, color: &ColorType),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(x: i32, y: i32, w: i32, h: i32, c: Rute::GlobalColor),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(r: &RectType, c: Rute::GlobalColor),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(r: &RectFType, c: Rute::GlobalColor),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(x: i32, y: i32, w: i32, h: i32, style: Rute::BrushStyle),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(r: &RectType, style: Rute::BrushStyle),
    ///     \fn void QPainter::fillRect(const QRectF &rectangle, const QColor &color)
    ///     \overload
    /// 
    ///     Fills the given \a rectangle with the \a color specified.
    /// 
    ///     \since 4.5
    fill_rect(r: &RectFType, style: Rute::BrushStyle),
    ///     \fn void QPainter::eraseRect(const QRectF &rectangle)
    /// 
    ///     Erases the area inside the given \a rectangle. Equivalent to
    ///     calling
    ///     \snippet code/src_gui_painting_qpainter.cpp 19
    /// 
    ///     \sa fillRect()
    erase_rect(arg0: &RectFType),
    ///     \fn void QPainter::eraseRect(const QRectF &rectangle)
    /// 
    ///     Erases the area inside the given \a rectangle. Equivalent to
    ///     calling
    ///     \snippet code/src_gui_painting_qpainter.cpp 19
    /// 
    ///     \sa fillRect()
    erase_rect(x: i32, y: i32, w: i32, h: i32),
    ///     \fn void QPainter::eraseRect(const QRectF &rectangle)
    /// 
    ///     Erases the area inside the given \a rectangle. Equivalent to
    ///     calling
    ///     \snippet code/src_gui_painting_qpainter.cpp 19
    /// 
    ///     \sa fillRect()
    erase_rect(arg0: &RectType),
    ///     Sets the given render \a hint on the painter if \a on is true;
    ///     otherwise clears the render hint.
    /// 
    ///     \sa setRenderHints(), renderHints(), {QPainter#Rendering
    ///     Quality}{Rendering Quality}
    set_render_hint(hint: Painter::RenderHint, on: bool),
    ///     \since 4.2
    /// 
    ///     Sets the given render \a hints on the painter if \a on is true;
    ///     otherwise clears the render hints.
    /// 
    ///     \sa setRenderHint(), renderHints(), {QPainter#Rendering
    ///     Quality}{Rendering Quality}
    set_render_hints(hints: Painter::RenderHints, on: bool),
    ///     Returns a flag that specifies the rendering hints that are set for
    ///     this painter.
    /// 
    ///     \sa testRenderHint(), {QPainter#Rendering Quality}{Rendering Quality}
    render_hints() -> Painter::RenderHints,
    test_render_hint(hint: Painter::RenderHint) -> bool,
    ///     Returns the paint engine that the painter is currently operating
    ///     on if the painter is active; otherwise 0.
    /// 
    ///     \sa isActive()
    paint_engine() -> PaintEngine?,
    [static] set_redirected(device: *PaintDeviceType, replacement: *PaintDeviceType, offset: &PointType),
    ///     \threadsafe
    /// 
    ///     \obsolete
    /// 
    ///     Using QWidget::render() obsoletes the use of this function.
    /// 
    ///     Returns the replacement for given \a device. The optional out
    ///     parameter \a offset returns the offset within the replaced device.
    /// 
    ///     \warning Making use of redirections in the QPainter API implies
    ///     that QPainter::begin() and QPaintDevice destructors need to hold
    ///     a mutex for a short period. This can impact performance. Use of
    ///     QWidget::render is strongly encouraged.
    /// 
    ///     \sa setRedirected(), restoreRedirected()
    [static] redirected(device: *PaintDeviceType, offset: *PointType) -> PaintDevice?,
    [static] restore_redirected(device: *PaintDeviceType),
    ///     \since 4.6
    /// 
    ///     Flushes the painting pipeline and prepares for the user issuing commands
    ///     directly to the underlying graphics context. Must be followed by a call to
    ///     endNativePainting().
    /// 
    ///     Note that only the states the underlying paint engine changes will be reset
    ///     to their respective default states. The states we reset may change from
    ///     release to release. The following states are currently reset in the OpenGL
    ///     2 engine:
    /// 
    ///     \list
    ///     \li blending is disabled
    ///     \li the depth, stencil and scissor tests are disabled
    ///     \li the active texture unit is reset to 0
    ///     \li the depth mask, depth function and the clear depth are reset to their
    ///     default values
    ///     \li the stencil mask, stencil operation and stencil function are reset to
    ///     their default values
    ///      \li the current color is reset to solid white
    ///     \endlist
    /// 
    ///     If, for example, the OpenGL polygon mode is changed by the user inside a
    ///     beginNativePaint()/endNativePainting() block, it will not be reset to the
    ///     default state by endNativePainting(). Here is an example that shows
    ///     intermixing of painter commands and raw OpenGL commands:
    /// 
    ///     \snippet code/src_gui_painting_qpainter.cpp 21
    /// 
    ///     \sa endNativePainting()
    begin_native_painting(),
    ///     \since 4.6
    /// 
    ///     Restores the painter after manually issuing native painting commands. Lets
    ///     the painter restore any native state that it relies on before calling any
    ///     other painter commands.
    /// 
    ///     \sa beginNativePainting()
    end_native_painting(),
}

// vim: syntax=rust expandtab ts=4 sw=4
