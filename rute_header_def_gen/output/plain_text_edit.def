///     \class QPlainTextEdit
///     \since 4.4
///     \brief The QPlainTextEdit class provides a widget that is used to edit and display
///     plain text.
/// 
///     \ingroup richtext-processing
///     \inmodule QtWidgets
/// 
///     \tableofcontents
/// 
///     \section1 Introduction and Concepts
/// 
///     QPlainTextEdit is an advanced viewer/editor supporting plain
///     text. It is optimized to handle large documents and to respond
///     quickly to user input.
/// 
///     QPlainText uses very much the same technology and concepts as
///     QTextEdit, but is optimized for plain text handling.
/// 
///     QPlainTextEdit works on paragraphs and characters. A paragraph is
///     a formatted string which is word-wrapped to fit into the width of
///     the widget. By default when reading plain text, one newline
///     signifies a paragraph. A document consists of zero or more
///     paragraphs. Paragraphs are separated by hard line breaks. Each
///     character within a paragraph has its own attributes, for example,
///     font and color.
/// 
///     The shape of the mouse cursor on a QPlainTextEdit is
///     Qt::IBeamCursor by default.  It can be changed through the
///     viewport()'s cursor property.
/// 
///     \section1 Using QPlainTextEdit as a Display Widget
/// 
///     The text is set or replaced using setPlainText() which deletes the
///     existing text and replaces it with the text passed to setPlainText().
/// 
///     Text can be inserted using the QTextCursor class or using the
///     convenience functions insertPlainText(), appendPlainText() or
///     paste().
/// 
///     By default, the text edit wraps words at whitespace to fit within
///     the text edit widget. The setLineWrapMode() function is used to
///     specify the kind of line wrap you want, \l WidgetWidth or \l
///     NoWrap if you don't want any wrapping.  If you use word wrap to
///     the widget's width \l WidgetWidth, you can specify whether to
///     break on whitespace or anywhere with setWordWrapMode().
/// 
///     The find() function can be used to find and select a given string
///     within the text.
/// 
///     If you want to limit the total number of paragraphs in a
///     QPlainTextEdit, as it is for example useful in a log viewer, then
///     you can use the maximumBlockCount property. The combination of
///     setMaximumBlockCount() and appendPlainText() turns QPlainTextEdit
///     into an efficient viewer for log text. The scrolling can be
///     reduced with the centerOnScroll() property, making the log viewer
///     even faster. Text can be formatted in a limited way, either using
///     a syntax highlighter (see below), or by appending html-formatted
///     text with appendHtml(). While QPlainTextEdit does not support
///     complex rich text rendering with tables and floats, it does
///     support limited paragraph-based formatting that you may need in a
///     log viewer.
/// 
///     \section2 Read-only Key Bindings
/// 
///     When QPlainTextEdit is used read-only the key bindings are limited to
///     navigation, and text may only be selected with the mouse:
///     \table
///     \header \li Keypresses \li Action
///     \row \li Qt::UpArrow        \li Moves one line up.
///     \row \li Qt::DownArrow        \li Moves one line down.
///     \row \li Qt::LeftArrow        \li Moves one character to the left.
///     \row \li Qt::RightArrow        \li Moves one character to the right.
///     \row \li PageUp        \li Moves one (viewport) page up.
///     \row \li PageDown        \li Moves one (viewport) page down.
///     \row \li Home        \li Moves to the beginning of the text.
///     \row \li End                \li Moves to the end of the text.
///     \row \li Alt+Wheel
///          \li Scrolls the page horizontally (the Wheel is the mouse wheel).
///     \row \li Ctrl+Wheel        \li Zooms the text.
///     \row \li Ctrl+A            \li Selects all text.
///     \endtable
/// 
/// 
///     \section1 Using QPlainTextEdit as an Editor
/// 
///     All the information about using QPlainTextEdit as a display widget also
///     applies here.
/// 
///     Selection of text is handled by the QTextCursor class, which provides
///     functionality for creating selections, retrieving the text contents or
///     deleting selections. You can retrieve the object that corresponds with
///     the user-visible cursor using the textCursor() method. If you want to set
///     a selection in QPlainTextEdit just create one on a QTextCursor object and
///     then make that cursor the visible cursor using setCursor(). The selection
///     can be copied to the clipboard with copy(), or cut to the clipboard with
///     cut(). The entire text can be selected using selectAll().
/// 
///     QPlainTextEdit holds a QTextDocument object which can be retrieved using the
///     document() method. You can also set your own document object using setDocument().
///     QTextDocument emits a textChanged() signal if the text changes and it also
///     provides a isModified() function which will return true if the text has been
///     modified since it was either loaded or since the last call to setModified
///     with false as argument. In addition it provides methods for undo and redo.
/// 
///     \section2 Syntax Highlighting
/// 
///     Just like QTextEdit, QPlainTextEdit works together with
///     QSyntaxHighlighter.
/// 
///     \section2 Editing Key Bindings
/// 
///     The list of key bindings which are implemented for editing:
///     \table
///     \header \li Keypresses \li Action
///     \row \li Backspace \li Deletes the character to the left of the cursor.
///     \row \li Delete \li Deletes the character to the right of the cursor.
///     \row \li Ctrl+C \li Copy the selected text to the clipboard.
///     \row \li Ctrl+Insert \li Copy the selected text to the clipboard.
///     \row \li Ctrl+K \li Deletes to the end of the line.
///     \row \li Ctrl+V \li Pastes the clipboard text into text edit.
///     \row \li Shift+Insert \li Pastes the clipboard text into text edit.
///     \row \li Ctrl+X \li Deletes the selected text and copies it to the clipboard.
///     \row \li Shift+Delete \li Deletes the selected text and copies it to the clipboard.
///     \row \li Ctrl+Z \li Undoes the last operation.
///     \row \li Ctrl+Y \li Redoes the last operation.
///     \row \li LeftArrow \li Moves the cursor one character to the left.
///     \row \li Ctrl+LeftArrow \li Moves the cursor one word to the left.
///     \row \li RightArrow \li Moves the cursor one character to the right.
///     \row \li Ctrl+RightArrow \li Moves the cursor one word to the right.
///     \row \li UpArrow \li Moves the cursor one line up.
///     \row \li Ctrl+UpArrow \li Moves the cursor one word up.
///     \row \li DownArrow \li Moves the cursor one line down.
///     \row \li Ctrl+Down Arrow \li Moves the cursor one word down.
///     \row \li PageUp \li Moves the cursor one page up.
///     \row \li PageDown \li Moves the cursor one page down.
///     \row \li Home \li Moves the cursor to the beginning of the line.
///     \row \li Ctrl+Home \li Moves the cursor to the beginning of the text.
///     \row \li End \li Moves the cursor to the end of the line.
///     \row \li Ctrl+End \li Moves the cursor to the end of the text.
///     \row \li Alt+Wheel \li Scrolls the page horizontally (the Wheel is the mouse wheel).
///     \row \li Ctrl+Wheel \li Zooms the text.
///     \endtable
/// 
///     To select (mark) text hold down the Shift key whilst pressing one
///     of the movement keystrokes, for example, \e{Shift+Right Arrow}
///     will select the character to the right, and \e{Shift+Ctrl+Right
///     Arrow} will select the word to the right, etc.
/// 
///    \section1 Differences to QTextEdit
/// 
///    QPlainTextEdit is a thin class, implemented by using most of the
///    technology that is behind QTextEdit and QTextDocument. Its
///    performance benefits over QTextEdit stem mostly from using a
///    different and simplified text layout called
///    QPlainTextDocumentLayout on the text document (see
///    QTextDocument::setDocumentLayout()). The plain text document layout
///    does not support tables nor embedded frames, and \e{replaces a
///    pixel-exact height calculation with a line-by-line respectively
///    paragraph-by-paragraph scrolling approach}. This makes it possible
///    to handle significantly larger documents, and still resize the
///    editor with line wrap enabled in real time. It also makes for a
///    fast log viewer (see setMaximumBlockCount()).
/// 
/// 
///     \sa QTextDocument, QTextCursor, {Application Example},
///         {Code Editor Example}, {Syntax Highlighter Example},
///         {Rich Text Processing}
/// 
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QPlainTextEdit)]
enum LineWrapMode {
    NoWrap,
    WidgetWidth,
}

struct PlainTextEdit : AbstractScrollArea {
    ///     Makes \a document the new document of the text editor.
    /// 
    ///     The parent QObject of the provided document remains the owner
    ///     of the object. If the current document is a child of the text
    ///     editor, then it is deleted.
    /// 
    ///     The document must have a document layout that inherits
    ///     QPlainTextDocumentLayout (see QTextDocument::setDocumentLayout()).
    /// 
    ///     \sa document()
    set_document(document: *TextDocumentType),
    ///     Returns a pointer to the underlying document.
    /// 
    ///     \sa setDocument()
    document() -> TextDocument?,
    ///     \since 5.3
    /// 
    ///     \property QPlainTextEdit::placeholderText
    ///     \brief the editor placeholder text
    /// 
    ///     Setting this property makes the editor display a grayed-out
    ///     placeholder text as long as the document() is empty.
    /// 
    ///     By default, this property contains an empty string.
    /// 
    ///     \sa document()
    set_placeholder_text(placeholder_text: String),
    placeholder_text() -> String,
    ///     Sets the visible \a cursor.
    set_text_cursor(cursor: &TextCursorType),
    text_cursor() -> TextCursor,
    ///     \property QPlainTextEdit::readOnly
    ///     \brief whether the text edit is read-only
    /// 
    ///     In a read-only text edit the user can only navigate through the
    ///     text and select text; modifying the text is not possible.
    /// 
    ///     This property's default is false.
    is_read_only() -> bool,
    set_read_only(ro: bool),
    ///     \property QPlainTextEdit::textInteractionFlags
    /// 
    ///     Specifies how the label should interact with user input if it displays text.
    /// 
    ///     If the flags contain either Qt::LinksAccessibleByKeyboard or Qt::TextSelectableByKeyboard
    ///     then the focus policy is also automatically set to Qt::ClickFocus.
    /// 
    ///     The default value depends on whether the QPlainTextEdit is read-only
    ///     or editable.
    set_text_interaction_flags(flags: Rute::TextInteractionFlags),
    text_interaction_flags() -> Rute::TextInteractionFlags,
    merge_current_char_format(modifier: &TextCharFormatType),
    set_current_char_format(format: &TextCharFormatType),
    current_char_format() -> TextCharFormat,
    tab_changes_focus() -> bool,
    set_tab_changes_focus(b: bool),
    set_document_title(title: String),
    document_title() -> String,
    is_undo_redo_enabled() -> bool,
    set_undo_redo_enabled(enable: bool),
    set_maximum_block_count(maximum: i32),
    maximum_block_count() -> i32,
    ///     \property QPlainTextEdit::lineWrapMode
    ///     \brief the line wrap mode
    /// 
    ///     The default mode is WidgetWidth which causes words to be
    ///     wrapped at the right edge of the text edit. Wrapping occurs at
    ///     whitespace, keeping whole words intact. If you want wrapping to
    ///     occur within words use setWordWrapMode().
    line_wrap_mode() -> PlainTextEdit::LineWrapMode,
    set_line_wrap_mode(mode: PlainTextEdit::LineWrapMode),
    ///     \property QPlainTextEdit::wordWrapMode
    ///     \brief the mode QPlainTextEdit will use when wrapping text by words
    /// 
    ///     By default, this property is set to QTextOption::WrapAtWordBoundaryOrAnywhere.
    /// 
    ///     \sa QTextOption::WrapMode
    word_wrap_mode() -> TextOption::WrapMode,
    set_word_wrap_mode(policy: TextOption::WrapMode),
    set_background_visible(visible: bool),
    ///     \property QPlainTextEdit::backgroundVisible
    ///     \brief whether the palette background is visible outside the document area
    /// 
    ///     If set to true, the plain text edit paints the palette background
    ///     on the viewport area not covered by the text document. Otherwise,
    ///     if set to false, it won't. The feature makes it possible for
    ///     the user to visually distinguish between the area of the document,
    ///     painted with the base color of the palette, and the empty
    ///     area not covered by any document.
    /// 
    ///     The default is false.
    background_visible() -> bool,
    set_center_on_scroll(enabled: bool),
    ///     \property QPlainTextEdit::centerOnScroll
    ///     \brief whether the cursor should be centered on screen
    /// 
    ///     If set to true, the plain text edit scrolls the document
    ///     vertically to make the cursor visible at the center of the
    ///     viewport. This also allows the text edit to scroll below the end
    ///     of the document. Otherwise, if set to false, the plain text edit
    ///     scrolls the smallest amount possible to ensure the cursor is
    ///     visible.  The same algorithm is applied to any new line appended
    ///     through appendPlainText().
    /// 
    ///     The default is false.
    /// 
    ///     \sa centerCursor(), ensureCursorVisible()
    center_on_scroll() -> bool,
    ///     \fn bool QPlainTextEdit::find(const QRegExp &exp, QTextDocument::FindFlags options)
    /// 
    ///     \since 5.3
    ///     \overload
    /// 
    ///     Finds the next occurrence, matching the regular expression, \a exp, using the given
    ///     \a options. The QTextDocument::FindCaseSensitively option is ignored for this overload,
    ///     use QRegExp::caseSensitivity instead.
    /// 
    ///     Returns \c true if a match was found and changes the cursor to select the match;
    ///     otherwise returns \c false.
    find(exp: String, options: TextDocument::FindFlags) -> bool,
    ///     \fn bool QPlainTextEdit::find(const QRegExp &exp, QTextDocument::FindFlags options)
    /// 
    ///     \since 5.3
    ///     \overload
    /// 
    ///     Finds the next occurrence, matching the regular expression, \a exp, using the given
    ///     \a options. The QTextDocument::FindCaseSensitively option is ignored for this overload,
    ///     use QRegExp::caseSensitivity instead.
    /// 
    ///     Returns \c true if a match was found and changes the cursor to select the match;
    ///     otherwise returns \c false.
    find(exp: &RegExpType, options: TextDocument::FindFlags) -> bool,
    to_plain_text() -> String,
    ///     Ensures that the cursor is visible by scrolling the text edit if
    ///     necessary.
    /// 
    ///     \sa centerCursor(), centerOnScroll
    ensure_cursor_visible(),
    ///     Loads the resource specified by the given \a type and \a name.
    /// 
    ///     This function is an extension of QTextDocument::loadResource().
    /// 
    ///     \sa QTextDocument::loadResource()
    [event] load_resource(type: i32, name: &UrlType) -> Variant,
    ///   \since 5.5
    ///   This function creates the standard context menu which is shown
    ///   when the user clicks on the text edit with the right mouse
    ///   button. It is called from the default contextMenuEvent() handler
    ///   and it takes the \a position in document coordinates where the mouse click was.
    ///   This can enable actions that are sensitive to the position where the user clicked.
    ///   The popup menu's ownership is transferred to the caller.
    create_standard_context_menu() -> Menu?,
    ///   \since 5.5
    ///   This function creates the standard context menu which is shown
    ///   when the user clicks on the text edit with the right mouse
    ///   button. It is called from the default contextMenuEvent() handler
    ///   and it takes the \a position in document coordinates where the mouse click was.
    ///   This can enable actions that are sensitive to the position where the user clicked.
    ///   The popup menu's ownership is transferred to the caller.
    create_standard_context_menu(position: &PointType) -> Menu?,
    ///   returns a QTextCursor at position \a pos (in viewport coordinates).
    cursor_for_position(pos: &PointType) -> TextCursor,
    cursor_rect(cursor: &TextCursorType) -> Rect,
    cursor_rect() -> Rect,
    anchor_at(pos: &PointType) -> String,
    ///    \property QPlainTextEdit::overwriteMode
    ///    \brief whether text entered by the user will overwrite existing text
    /// 
    ///    As with many text editors, the plain text editor widget can be configured
    ///    to insert or overwrite existing text with new text entered by the user.
    /// 
    ///    If this property is \c true, existing text is overwritten, character-for-character
    ///    by new text; otherwise, text is inserted at the cursor position, displacing
    ///    existing text.
    /// 
    ///    By default, this property is \c false (new text does not overwrite existing text).
    overwrite_mode() -> bool,
    set_overwrite_mode(overwrite: bool),
    ///     \property QPlainTextEdit::tabStopWidth
    ///     \brief the tab stop width in pixels
    ///     \deprecated in Qt 5.10. Use tabStopDistance instead.
    /// 
    ///     By default, this property contains a value of 80.
    tab_stop_width() -> i32,
    set_tab_stop_width(width: i32),
    ///     \property QPlainTextEdit::tabStopDistance
    ///     \brief the tab stop distance in pixels
    ///     \since 5.10
    /// 
    ///     By default, this property contains a value of 80.
    tab_stop_distance() -> f32,
    set_tab_stop_distance(distance: f32),
    ///     \property QPlainTextEdit::cursorWidth
    /// 
    ///     This property specifies the width of the cursor in pixels. The default value is 1.
    cursor_width() -> i32,
    set_cursor_width(width: i32),
    ///     Moves the cursor by performing the given \a operation.
    /// 
    ///     If \a mode is QTextCursor::KeepAnchor, the cursor selects the text it moves over.
    ///     This is the same effect that the user achieves when they hold down the Shift key
    ///     and move the cursor with the cursor keys.
    /// 
    ///     \sa QTextCursor::movePosition()
    move_cursor(operation: TextCursor::MoveOperation, mode: TextCursor::MoveMode),
    ///     Returns whether text can be pasted from the clipboard into the textedit.
    can_paste() -> bool,
    ///     Convenience function to print the text edit's document to the given \a printer. This
    ///     is equivalent to calling the print method on the document directly except that this
    ///     function also supports QPrinter::Selection as print range.
    /// 
    ///     \sa QTextDocument::print()
    print(printer: *PagedPaintDeviceType),
    ///     \property QPlainTextEdit::blockCount
    ///     \brief the number of text blocks in the document.
    /// 
    ///     By default, in an empty document, this property contains a value of 1.
    block_count() -> i32,
    [event] input_method_query(property: Rute::InputMethodQuery) -> Variant,
    input_method_query(query: Rute::InputMethodQuery, argument: VariantType) -> Variant,
    ///     Changes the text of the text edit to the string \a text.
    ///     Any previous text is removed.
    /// 
    ///     \a text is interpreted as plain text.
    /// 
    ///     Note that the undo/redo history is cleared by this function.
    /// 
    ///     \sa toPlainText()
    set_plain_text(text: String),
    ///     Copies the selected text to the clipboard and deletes it from
    ///     the text edit.
    /// 
    ///     If there is no selected text nothing happens.
    /// 
    ///     \sa copy(), paste()
    cut(),
    ///     Copies any selected text to the clipboard.
    /// 
    ///     \sa copyAvailable()
    copy(),
    ///     Pastes the text from the clipboard into the text edit at the
    ///     current cursor position.
    /// 
    ///     If there is no text in the clipboard nothing happens.
    /// 
    ///     To change the behavior of this function, i.e. to modify what
    ///     QPlainTextEdit can paste and how it is being pasted, reimplement the
    ///     virtual canInsertFromMimeData() and insertFromMimeData()
    ///     functions.
    /// 
    ///     \sa cut(), copy()
    paste(),
    ///     Undoes the last operation.
    /// 
    ///     If there is no operation to undo, i.e. there is no undo step in
    ///     the undo/redo history, nothing happens.
    /// 
    ///     \sa redo()
    undo(),
    redo(),
    ///     Deletes all the text in the text edit.
    /// 
    ///     Note that the undo/redo history is cleared by this function.
    /// 
    ///     \sa cut(), setPlainText()
    clear(),
    select_all(),
    insert_plain_text(text: String),
    ///     Appends a new paragraph with \a text to the end of the text edit.
    /// 
    ///     \sa appendHtml()
    append_plain_text(text: String),
    ///     Appends a new paragraph with \a html to the end of the text edit.
    /// 
    ///     appendPlainText()
    append_html(html: String),
    center_cursor(),
    ///     \fn QPlainTextEdit::zoomIn(int range)
    /// 
    ///     Zooms in on the text by making the base font size \a range
    ///     points larger and recalculating all font sizes to be the new size.
    ///     This does not change the size of any images.
    /// 
    ///     \sa zoomOut()
    zoom_in(range: i32),
    ///     \fn QPlainTextEdit::zoomOut(int range)
    /// 
    ///     \overload
    /// 
    ///     Zooms out on the text by making the base font size \a range points
    ///     smaller and recalculating all font sizes to be the new size. This
    ///     does not change the size of any images.
    /// 
    ///     \sa zoomIn()
    zoom_out(range: i32),
    [signal] text_changed(),
    [signal] undo_available(b: bool),
    [signal] redo_available(b: bool),
    [signal] copy_available(b: bool),
    [signal] selection_changed(),
    [signal] cursor_position_changed(),
    [signal] update_request(rect: &RectType, dy: i32),
    ///     \fn void QPlainTextEdit::updateRequest(const QRect &rect, int dy)
    /// 
    ///     This signal is emitted when the text document needs an update of
    ///     the specified \a rect. If the text is scrolled, \a rect will cover
    ///     the entire viewport area. If the text is scrolled vertically, \a
    ///     dy carries the amount of pixels the viewport was scrolled.
    /// 
    ///     The purpose of the signal is to support extra widgets in plain
    ///     text edit subclasses that e.g. show line numbers, breakpoints, or
    ///     other extra information.
    [signal] block_count_changed(new_block_count: i32),
    [signal] modification_changed(arg0: bool),
    ///     Selects all text.
    /// 
    ///     \sa copy(), cut(), textCursor()
    ///  */
    /// void QPlainTextEdit::selectAll()
    /// {
    ///     Q_D(QPlainTextEdit);
    ///     d->control->selectAll();
    /// }
    /// 
    [event] event(e: *EventType) -> bool,
    [event] timer_event(e: *TimerEventType),
    ///     \fn QString QPlainTextEdit::toPlainText() const
    /// 
    ///     Returns the text of the text edit as plain text.
    /// 
    ///     \sa QPlainTextEdit::setPlainText()
    ///  */
    /// 
    [event] key_press_event(e: *KeyEventType),
    [event] key_release_event(e: *KeyEventType),
    [event] resize_event(e: *ResizeEventType),
    [event] paint_event(e: *PaintEventType),
    [event] mouse_press_event(e: *MouseEventType),
    [event] mouse_move_event(e: *MouseEventType),
    [event] mouse_release_event(e: *MouseEventType),
    [event] mouse_double_click_event(e: *MouseEventType),
    [event] focus_next_prev_child(next: bool) -> bool,
    ///   \fn void QPlainTextEdit::contextMenuEvent(QContextMenuEvent *event)
    /// 
    ///   Shows the standard context menu created with createStandardContextMenu().
    /// 
    ///   If you do not want the text edit to have a context menu, you can set
    ///   its \l contextMenuPolicy to Qt::NoContextMenu. If you want to
    ///   customize the context menu, reimplement this function. If you want
    ///   to extend the standard context menu, reimplement this function, call
    ///   createStandardContextMenu() and extend the menu returned.
    /// 
    ///   Information about the event is passed in the \a event object.
    /// 
    ///   \snippet code/src_gui_widgets_qplaintextedit.cpp 0
    [event] context_menu_event(e: *ContextMenuEventType),
    [event] drag_enter_event(e: *DragEnterEventType),
    [event] drag_leave_event(e: *DragLeaveEventType),
    [event] drag_move_event(e: *DragMoveEventType),
    [event] drop_event(e: *DropEventType),
    [event] focus_in_event(e: *FocusEventType),
    [event] focus_out_event(e: *FocusEventType),
    [event] show_event(arg0: *ShowEventType),
    [event] change_event(e: *EventType),
    [event] wheel_event(e: *WheelEventType),
    ///     This function returns a new MIME data object to represent the contents
    ///     of the text edit's current selection. It is called when the selection needs
    ///     to be encapsulated into a new QMimeData object; for example, when a drag
    ///     and drop operation is started, or when data is copied to the clipboard.
    /// 
    ///     If you reimplement this function, note that the ownership of the returned
    ///     QMimeData object is passed to the caller. The selection can be retrieved
    ///     by using the textCursor() function.
    [event] create_mime_data_from_selection() -> MimeData?,
    [event] can_insert_from_mime_data(source: *MimeDataType) -> bool,
    ///     This function inserts the contents of the MIME data object, specified
    ///     by \a source, into the text edit at the current cursor position. It is
    ///     called whenever text is inserted as the result of a clipboard paste
    ///     operation, or when the text edit accepts data from a drag and drop
    ///     operation.
    [event] insert_from_mime_data(source: *MimeDataType),
    [event] input_method_event(arg0: *InputMethodEventType),
    [event] scroll_contents_by(dx: i32, dy: i32),
    ///     \internal
    /// 
    ///      This provides a hook for subclasses to intercept cursor changes.
    [event] do_set_text_cursor(cursor: &TextCursorType),
    first_visible_block() -> TextBlock,
    content_offset() -> PointF,
    block_bounding_rect(block: &TextBlockType) -> RectF,
    get_paint_context() -> AbstractTextDocumentLayout::PaintContext,
    ///     \internal
    zoom_in_f(range: f32),
}

// vim: syntax=rust expandtab ts=4 sw=4
