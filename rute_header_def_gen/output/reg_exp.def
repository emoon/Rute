///     \class QRegExp
///     \inmodule QtCore
///     \reentrant
///     \brief The QRegExp class provides pattern matching using regular expressions.
/// 
///     \ingroup tools
///     \ingroup shared
/// 
///     \keyword regular expression
/// 
///     A regular expression, or "regexp", is a pattern for matching
///     substrings in a text. This is useful in many contexts, e.g.,
/// 
///     \table
///     \row \li Validation
///          \li A regexp can test whether a substring meets some criteria,
///          e.g. is an integer or contains no whitespace.
///     \row \li Searching
///          \li A regexp provides more powerful pattern matching than
///          simple substring matching, e.g., match one of the words
///          \e{mail}, \e{letter} or \e{correspondence}, but none of the
///          words \e{email}, \e{mailman}, \e{mailer}, \e{letterbox}, etc.
///      \row \li Search and Replace
///          \li A regexp can replace all occurrences of a substring with a
///          different substring, e.g., replace all occurrences of \e{&}
///          with \e{\&amp;} except where the \e{&} is already followed by
///          an \e{amp;}.
///     \row \li String Splitting
///          \li A regexp can be used to identify where a string should be
///          split apart, e.g. splitting tab-delimited strings.
///     \endtable
/// 
///     A brief introduction to regexps is presented, a description of
///     Qt's regexp language, some examples, and the function
///     documentation itself. QRegExp is modeled on Perl's regexp
///     language. It fully supports Unicode. QRegExp can also be used in a
///     simpler, \e{wildcard mode} that is similar to the functionality
///     found in command shells. The syntax rules used by QRegExp can be
///     changed with setPatternSyntax(). In particular, the pattern syntax
///     can be set to QRegExp::FixedString, which means the pattern to be
///     matched is interpreted as a plain string, i.e., special characters
///     (e.g., backslash) are not escaped.
/// 
///     A good text on regexps is \e {Mastering Regular Expressions}
///     (Third Edition) by Jeffrey E. F.  Friedl, ISBN 0-596-52812-4.
/// 
///     \note In Qt 5, the new QRegularExpression class provides a Perl
///     compatible implementation of regular expressions and is recommended
///     in place of QRegExp.
/// 
///     \tableofcontents
/// 
///     \section1 Introduction
/// 
///     Regexps are built up from expressions, quantifiers, and
///     assertions. The simplest expression is a character, e.g. \b{x}
///     or \b{5}. An expression can also be a set of characters
///     enclosed in square brackets. \b{[ABCD]} will match an \b{A}
///     or a \b{B} or a \b{C} or a \b{D}. We can write this same
///     expression as \b{[A-D]}, and an expression to match any
///     capital letter in the English alphabet is written as
///     \b{[A-Z]}.
/// 
///     A quantifier specifies the number of occurrences of an expression
///     that must be matched. \b{x{1,1}} means match one and only one
///     \b{x}. \b{x{1,5}} means match a sequence of \b{x}
///     characters that contains at least one \b{x} but no more than
///     five.
/// 
///     Note that in general regexps cannot be used to check for balanced
///     brackets or tags. For example, a regexp can be written to match an
///     opening html \c{<b>} and its closing \c{</b>}, if the \c{<b>} tags
///     are not nested, but if the \c{<b>} tags are nested, that same
///     regexp will match an opening \c{<b>} tag with the wrong closing
///     \c{</b>}.  For the fragment \c{<b>bold <b>bolder</b></b>}, the
///     first \c{<b>} would be matched with the first \c{</b>}, which is
///     not correct. However, it is possible to write a regexp that will
///     match nested brackets or tags correctly, but only if the number of
///     nesting levels is fixed and known. If the number of nesting levels
///     is not fixed and known, it is impossible to write a regexp that
///     will not fail.
/// 
///     Suppose we want a regexp to match integers in the range 0 to 99.
///     At least one digit is required, so we start with the expression
///     \b{[0-9]{1,1}}, which matches a single digit exactly once. This
///     regexp matches integers in the range 0 to 9. To match integers up
///     to 99, increase the maximum number of occurrences to 2, so the
///     regexp becomes \b{[0-9]{1,2}}. This regexp satisfies the
///     original requirement to match integers from 0 to 99, but it will
///     also match integers that occur in the middle of strings. If we
///     want the matched integer to be the whole string, we must use the
///     anchor assertions, \b{^} (caret) and \b{$} (dollar). When
///     \b{^} is the first character in a regexp, it means the regexp
///     must match from the beginning of the string. When \b{$} is the
///     last character of the regexp, it means the regexp must match to
///     the end of the string. The regexp becomes \b{^[0-9]{1,2}$}.
///     Note that assertions, e.g. \b{^} and \b{$}, do not match
///     characters but locations in the string.
/// 
///     If you have seen regexps described elsewhere, they may have looked
///     different from the ones shown here. This is because some sets of
///     characters and some quantifiers are so common that they have been
///     given special symbols to represent them. \b{[0-9]} can be
///     replaced with the symbol \b{\\d}. The quantifier to match
///     exactly one occurrence, \b{{1,1}}, can be replaced with the
///     expression itself, i.e. \b{x{1,1}} is the same as \b{x}. So
///     our 0 to 99 matcher could be written as \b{^\\d{1,2}$}. It can
///     also be written \b{^\\d\\d{0,1}$}, i.e. \e{From the start of
///     the string, match a digit, followed immediately by 0 or 1 digits}.
///     In practice, it would be written as \b{^\\d\\d?$}. The \b{?}
///     is shorthand for the quantifier \b{{0,1}}, i.e. 0 or 1
///     occurrences. \b{?} makes an expression optional. The regexp
///     \b{^\\d\\d?$} means \e{From the beginning of the string, match
///     one digit, followed immediately by 0 or 1 more digit, followed
///     immediately by end of string}.
/// 
///     To write a regexp that matches one of the words 'mail' \e or
///     'letter' \e or 'correspondence' but does not match words that
///     contain these words, e.g., 'email', 'mailman', 'mailer', and
///     'letterbox', start with a regexp that matches 'mail'. Expressed
///     fully, the regexp is \b{m{1,1}a{1,1}i{1,1}l{1,1}}, but because
///     a character expression is automatically quantified by
///     \b{{1,1}}, we can simplify the regexp to \b{mail}, i.e., an
///     'm' followed by an 'a' followed by an 'i' followed by an 'l'. Now
///     we can use the vertical bar \b{|}, which means \b{or}, to
///     include the other two words, so our regexp for matching any of the
///     three words becomes \b{mail|letter|correspondence}. Match
///     'mail' \b{or} 'letter' \b{or} 'correspondence'. While this
///     regexp will match one of the three words we want to match, it will
///     also match words we don't want to match, e.g., 'email'.  To
///     prevent the regexp from matching unwanted words, we must tell it
///     to begin and end the match at word boundaries. First we enclose
///     our regexp in parentheses, \b{(mail|letter|correspondence)}.
///     Parentheses group expressions together, and they identify a part
///     of the regexp that we wish to \l{capturing text}{capture}.
///     Enclosing the expression in parentheses allows us to use it as a
///     component in more complex regexps. It also allows us to examine
///     which of the three words was actually matched. To force the match
///     to begin and end on word boundaries, we enclose the regexp in
///     \b{\\b} \e{word boundary} assertions:
///     \b{\\b(mail|letter|correspondence)\\b}.  Now the regexp means:
///     \e{Match a word boundary, followed by the regexp in parentheses,
///     followed by a word boundary}. The \b{\\b} assertion matches a
///     \e position in the regexp, not a \e character. A word boundary is
///     any non-word character, e.g., a space, newline, or the beginning
///     or ending of a string.
/// 
///     If we want to replace ampersand characters with the HTML entity
///     \b{\&amp;}, the regexp to match is simply \b{\&}. But this
///     regexp will also match ampersands that have already been converted
///     to HTML entities. We want to replace only ampersands that are not
///     already followed by \b{amp;}. For this, we need the negative
///     lookahead assertion, \b{(?!}__\b{)}. The regexp can then be
///     written as \b{\&(?!amp;)}, i.e. \e{Match an ampersand that is}
///     \b{not} \e{followed by} \b{amp;}.
/// 
///     If we want to count all the occurrences of 'Eric' and 'Eirik' in a
///     string, two valid solutions are \b{\\b(Eric|Eirik)\\b} and
///     \b{\\bEi?ri[ck]\\b}. The word boundary assertion '\\b' is
///     required to avoid matching words that contain either name,
///     e.g. 'Ericsson'. Note that the second regexp matches more
///     spellings than we want: 'Eric', 'Erik', 'Eiric' and 'Eirik'.
/// 
///     Some of the examples discussed above are implemented in the
///     \l{#code-examples}{code examples} section.
/// 
///     \target characters-and-abbreviations-for-sets-of-characters
///     \section1 Characters and Abbreviations for Sets of Characters
/// 
///     \table
///     \header \li Element \li Meaning
///     \row \li \b{c}
///          \li A character represents itself unless it has a special
///          regexp meaning. e.g. \b{c} matches the character \e c.
///     \row \li \b{\\c}
///          \li A character that follows a backslash matches the character
///          itself, except as specified below. e.g., To match a literal
///          caret at the beginning of a string, write \b{\\^}.
///     \row \li \b{\\a}
///          \li Matches the ASCII bell (BEL, 0x07).
///     \row \li \b{\\f}
///          \li Matches the ASCII form feed (FF, 0x0C).
///     \row \li \b{\\n}
///          \li Matches the ASCII line feed (LF, 0x0A, Unix newline).
///     \row \li \b{\\r}
///          \li Matches the ASCII carriage return (CR, 0x0D).
///     \row \li \b{\\t}
///          \li Matches the ASCII horizontal tab (HT, 0x09).
///     \row \li \b{\\v}
///          \li Matches the ASCII vertical tab (VT, 0x0B).
///     \row \li \b{\\x\e{hhhh}}
///          \li Matches the Unicode character corresponding to the
///          hexadecimal number \e{hhhh} (between 0x0000 and 0xFFFF).
///     \row \li \b{\\0\e{ooo}} (i.e., \\zero \e{ooo})
///          \li matches the ASCII/Latin1 character for the octal number
///          \e{ooo} (between 0 and 0377).
///     \row \li \b{. (dot)}
///          \li Matches any character (including newline).
///     \row \li \b{\\d}
///          \li Matches a digit (QChar::isDigit()).
///     \row \li \b{\\D}
///          \li Matches a non-digit.
///     \row \li \b{\\s}
///          \li Matches a whitespace character (QChar::isSpace()).
///     \row \li \b{\\S}
///          \li Matches a non-whitespace character.
///     \row \li \b{\\w}
///          \li Matches a word character (QChar::isLetterOrNumber(), QChar::isMark(), or '_').
///     \row \li \b{\\W}
///          \li Matches a non-word character.
///     \row \li \b{\\\e{n}}
///          \li The \e{n}-th backreference, e.g. \\1, \\2, etc.
///     \endtable
/// 
///     \b{Note:} The C++ compiler transforms backslashes in strings.
///     To include a \b{\\} in a regexp, enter it twice, i.e. \c{\\}.
///     To match the backslash character itself, enter it four times, i.e.
///     \c{\\\\}.
/// 
///     \target sets-of-characters
///     \section1 Sets of Characters
/// 
///     Square brackets mean match any character contained in the square
///     brackets. The character set abbreviations described above can
///     appear in a character set in square brackets. Except for the
///     character set abbreviations and the following two exceptions,
///     characters do not have special meanings in square brackets.
/// 
///     \table
///     \row \li \b{^}
/// 
///          \li The caret negates the character set if it occurs as the
///          first character (i.e. immediately after the opening square
///          bracket). \b{[abc]} matches 'a' or 'b' or 'c', but
///          \b{[^abc]} matches anything \e but 'a' or 'b' or 'c'.
/// 
///     \row \li \b{-}
/// 
///          \li The dash indicates a range of characters. \b{[W-Z]}
///          matches 'W' or 'X' or 'Y' or 'Z'.
/// 
///     \endtable
/// 
///     Using the predefined character set abbreviations is more portable
///     than using character ranges across platforms and languages. For
///     example, \b{[0-9]} matches a digit in Western alphabets but
///     \b{\\d} matches a digit in \e any alphabet.
/// 
///     Note: In other regexp documentation, sets of characters are often
///     called "character classes".
/// 
///     \target quantifiers
///     \section1 Quantifiers
/// 
///     By default, an expression is automatically quantified by
///     \b{{1,1}}, i.e. it should occur exactly once. In the following
///     list, \b{\e {E}} stands for expression. An expression is a
///     character, or an abbreviation for a set of characters, or a set of
///     characters in square brackets, or an expression in parentheses.
/// 
///     \table
///     \row \li \b{\e {E}?}
/// 
///          \li Matches zero or one occurrences of \e E. This quantifier
///          means \e{The previous expression is optional}, because it
///          will match whether or not the expression is found. \b{\e
///          {E}?} is the same as \b{\e {E}{0,1}}. e.g., \b{dents?}
///          matches 'dent' or 'dents'.
/// 
///     \row \li \b{\e {E}+}
/// 
///          \li Matches one or more occurrences of \e E. \b{\e {E}+} is
///          the same as \b{\e {E}{1,}}. e.g., \b{0+} matches '0',
///          '00', '000', etc.
/// 
///     \row \li \b{\e {E}*}
/// 
///          \li Matches zero or more occurrences of \e E. It is the same
///          as \b{\e {E}{0,}}. The \b{*} quantifier is often used
///          in error where \b{+} should be used. For example, if
///          \b{\\s*$} is used in an expression to match strings that
///          end in whitespace, it will match every string because
///          \b{\\s*$} means \e{Match zero or more whitespaces followed
///          by end of string}. The correct regexp to match strings that
///          have at least one trailing whitespace character is
///          \b{\\s+$}.
/// 
///     \row \li \b{\e {E}{n}}
/// 
///          \li Matches exactly \e n occurrences of \e E. \b{\e {E}{n}}
///          is the same as repeating \e E \e n times. For example,
///          \b{x{5}} is the same as \b{xxxxx}. It is also the same
///          as \b{\e {E}{n,n}}, e.g. \b{x{5,5}}.
/// 
///     \row \li \b{\e {E}{n,}}
///          \li Matches at least \e n occurrences of \e E.
/// 
///     \row \li \b{\e {E}{,m}}
///          \li Matches at most \e m occurrences of \e E. \b{\e {E}{,m}}
///          is the same as \b{\e {E}{0,m}}.
/// 
///     \row \li \b{\e {E}{n,m}}
///          \li Matches at least \e n and at most \e m occurrences of \e E.
///     \endtable
/// 
///     To apply a quantifier to more than just the preceding character,
///     use parentheses to group characters together in an expression. For
///     example, \b{tag+} matches a 't' followed by an 'a' followed by
///     at least one 'g', whereas \b{(tag)+} matches at least one
///     occurrence of 'tag'.
/// 
///     Note: Quantifiers are normally "greedy". They always match as much
///     text as they can. For example, \b{0+} matches the first zero it
///     finds and all the consecutive zeros after the first zero. Applied
///     to '20005', it matches '2\underline{000}5'. Quantifiers can be made
///     non-greedy, see setMinimal().
/// 
///     \target capturing parentheses
///     \target backreferences
///     \section1 Capturing Text
/// 
///     Parentheses allow us to group elements together so that we can
///     quantify and capture them. For example if we have the expression
///     \b{mail|letter|correspondence} that matches a string we know
///     that \e one of the words matched but not which one. Using
///     parentheses allows us to "capture" whatever is matched within
///     their bounds, so if we used \b{(mail|letter|correspondence)}
///     and matched this regexp against the string "I sent you some email"
///     we can use the cap() or capturedTexts() functions to extract the
///     matched characters, in this case 'mail'.
/// 
///     We can use captured text within the regexp itself. To refer to the
///     captured text we use \e backreferences which are indexed from 1,
///     the same as for cap(). For example we could search for duplicate
///     words in a string using \b{\\b(\\w+)\\W+\\1\\b} which means match a
///     word boundary followed by one or more word characters followed by
///     one or more non-word characters followed by the same text as the
///     first parenthesized expression followed by a word boundary.
/// 
///     If we want to use parentheses purely for grouping and not for
///     capturing we can use the non-capturing syntax, e.g.
///     \b{(?:green|blue)}. Non-capturing parentheses begin '(?:' and
///     end ')'. In this example we match either 'green' or 'blue' but we
///     do not capture the match so we only know whether or not we matched
///     but not which color we actually found. Using non-capturing
///     parentheses is more efficient than using capturing parentheses
///     since the regexp engine has to do less book-keeping.
/// 
///     Both capturing and non-capturing parentheses may be nested.
/// 
///     \target greedy quantifiers
/// 
///     For historical reasons, quantifiers (e.g. \b{*}) that apply to
///     capturing parentheses are more "greedy" than other quantifiers.
///     For example, \b{a*(a*)} will match "aaa" with cap(1) == "aaa".
///     This behavior is different from what other regexp engines do
///     (notably, Perl). To obtain a more intuitive capturing behavior,
///     specify QRegExp::RegExp2 to the QRegExp constructor or call
///     setPatternSyntax(QRegExp::RegExp2).
/// 
///     \target cap_in_a_loop
/// 
///     When the number of matches cannot be determined in advance, a
///     common idiom is to use cap() in a loop. For example:
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 0
/// 
///     \target assertions
///     \section1 Assertions
/// 
///     Assertions make some statement about the text at the point where
///     they occur in the regexp but they do not match any characters. In
///     the following list \b{\e {E}} stands for any expression.
/// 
///     \table
///     \row \li \b{^}
///          \li The caret signifies the beginning of the string. If you
///          wish to match a literal \c{^} you must escape it by
///          writing \c{\\^}. For example, \b{^#include} will only
///          match strings which \e begin with the characters '#include'.
///          (When the caret is the first character of a character set it
///          has a special meaning, see \l{#sets-of-characters}{Sets of Characters}.)
/// 
///     \row \li \b{$}
///          \li The dollar signifies the end of the string. For example
///          \b{\\d\\s*$} will match strings which end with a digit
///          optionally followed by whitespace. If you wish to match a
///          literal \c{$} you must escape it by writing
///          \c{\\$}.
/// 
///     \row \li \b{\\b}
///          \li A word boundary. For example the regexp
///          \b{\\bOK\\b} means match immediately after a word
///          boundary (e.g. start of string or whitespace) the letter 'O'
///          then the letter 'K' immediately before another word boundary
///          (e.g. end of string or whitespace). But note that the
///          assertion does not actually match any whitespace so if we
///          write \b{(\\bOK\\b)} and we have a match it will only
///          contain 'OK' even if the string is "It's \underline{OK} now".
/// 
///     \row \li \b{\\B}
///          \li A non-word boundary. This assertion is true wherever
///          \b{\\b} is false. For example if we searched for
///          \b{\\Bon\\B} in "Left on" the match would fail (space
///          and end of string aren't non-word boundaries), but it would
///          match in "t\underline{on}ne".
/// 
///     \row \li \b{(?=\e E)}
///          \li Positive lookahead. This assertion is true if the
///          expression matches at this point in the regexp. For example,
///          \b{const(?=\\s+char)} matches 'const' whenever it is
///          followed by 'char', as in 'static \underline{const} char *'.
///          (Compare with \b{const\\s+char}, which matches 'static
///          \underline{const char} *'.)
/// 
///     \row \li \b{(?!\e E)}
///          \li Negative lookahead. This assertion is true if the
///          expression does not match at this point in the regexp. For
///          example, \b{const(?!\\s+char)} matches 'const' \e except
///          when it is followed by 'char'.
///     \endtable
/// 
///     \target QRegExp wildcard matching
///     \section1 Wildcard Matching
/// 
///     Most command shells such as \e bash or \e cmd.exe support "file
///     globbing", the ability to identify a group of files by using
///     wildcards. The setPatternSyntax() function is used to switch
///     between regexp and wildcard mode. Wildcard matching is much
///     simpler than full regexps and has only four features:
/// 
///     \table
///     \row \li \b{c}
///          \li Any character represents itself apart from those mentioned
///          below. Thus \b{c} matches the character \e c.
///     \row \li \b{?}
///          \li Matches any single character. It is the same as
///          \b{.} in full regexps.
///     \row \li \b{*}
///          \li Matches zero or more of any characters. It is the
///          same as \b{.*} in full regexps.
///     \row \li \b{[...]}
///          \li Sets of characters can be represented in square brackets,
///          similar to full regexps. Within the character class, like
///          outside, backslash has no special meaning.
///     \endtable
/// 
///     In the mode Wildcard, the wildcard characters cannot be
///     escaped. In the mode WildcardUnix, the character '\\' escapes the
///     wildcard.
/// 
///     For example if we are in wildcard mode and have strings which
///     contain filenames we could identify HTML files with \b{*.html}.
///     This will match zero or more characters followed by a dot followed
///     by 'h', 't', 'm' and 'l'.
/// 
///     To test a string against a wildcard expression, use exactMatch().
///     For example:
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 1
/// 
///     \target perl-users
///     \section1 Notes for Perl Users
/// 
///     Most of the character class abbreviations supported by Perl are
///     supported by QRegExp, see \l{#characters-and-abbreviations-for-sets-of-characters}
///     {characters and abbreviations for sets of characters}.
/// 
///     In QRegExp, apart from within character classes, \c{^} always
///     signifies the start of the string, so carets must always be
///     escaped unless used for that purpose. In Perl the meaning of caret
///     varies automagically depending on where it occurs so escaping it
///     is rarely necessary. The same applies to \c{$} which in
///     QRegExp always signifies the end of the string.
/// 
///     QRegExp's quantifiers are the same as Perl's greedy quantifiers
///     (but see the \l{greedy quantifiers}{note above}). Non-greedy
///     matching cannot be applied to individual quantifiers, but can be
///     applied to all the quantifiers in the pattern. For example, to
///     match the Perl regexp \b{ro+?m} requires:
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 2
/// 
///     The equivalent of Perl's \c{/i} option is
///     setCaseSensitivity(Qt::CaseInsensitive).
/// 
///     Perl's \c{/g} option can be emulated using a \l{#cap_in_a_loop}{loop}.
/// 
///     In QRegExp \b{.} matches any character, therefore all QRegExp
///     regexps have the equivalent of Perl's \c{/s} option. QRegExp
///     does not have an equivalent to Perl's \c{/m} option, but this
///     can be emulated in various ways for example by splitting the input
///     into lines or by looping with a regexp that searches for newlines.
/// 
///     Because QRegExp is string oriented, there are no \\A, \\Z, or \\z
///     assertions. The \\G assertion is not supported but can be emulated
///     in a loop.
/// 
///     Perl's $& is cap(0) or capturedTexts()[0]. There are no QRegExp
///     equivalents for $`, $' or $+. Perl's capturing variables, $1, $2,
///     ... correspond to cap(1) or capturedTexts()[1], cap(2) or
///     capturedTexts()[2], etc.
/// 
///     To substitute a pattern use QString::replace().
/// 
///     Perl's extended \c{/x} syntax is not supported, nor are
///     directives, e.g. (?i), or regexp comments, e.g. (?#comment). On
///     the other hand, C++'s rules for literal strings can be used to
///     achieve the same:
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 3
/// 
///     Both zero-width positive and zero-width negative lookahead
///     assertions (?=pattern) and (?!pattern) are supported with the same
///     syntax as Perl. Perl's lookbehind assertions, "independent"
///     subexpressions and conditional expressions are not supported.
/// 
///     Non-capturing parentheses are also supported, with the same
///     (?:pattern) syntax.
/// 
///     See QString::split() and QStringList::join() for equivalents
///     to Perl's split and join functions.
/// 
///     Note: because C++ transforms \\'s they must be written \e twice in
///     code, e.g. \b{\\b} must be written \b{\\\\b}.
/// 
///     \target code-examples
///     \section1 Code Examples
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 4
/// 
///     The third string matches '\underline{6}'. This is a simple validation
///     regexp for integers in the range 0 to 99.
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 5
/// 
///     The second string matches '\underline{This_is-OK}'. We've used the
///     character set abbreviation '\\S' (non-whitespace) and the anchors
///     to match strings which contain no whitespace.
/// 
///     In the following example we match strings containing 'mail' or
///     'letter' or 'correspondence' but only match whole words i.e. not
///     'email'
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 6
/// 
///     The second string matches "Please write the \underline{letter}". The
///     word 'letter' is also captured (because of the parentheses). We
///     can see what text we've captured like this:
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 7
/// 
///     This will capture the text from the first set of capturing
///     parentheses (counting capturing left parentheses from left to
///     right). The parentheses are counted from 1 since cap(0) is the
///     whole matched regexp (equivalent to '&' in most regexp engines).
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 8
/// 
///     Here we've passed the QRegExp to QString's replace() function to
///     replace the matched text with new text.
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 9
/// 
///     We've used the indexIn() function to repeatedly match the regexp in
///     the string. Note that instead of moving forward by one character
///     at a time \c pos++ we could have written \c {pos +=
///     rx.matchedLength()} to skip over the already matched string. The
///     count will equal 3, matching 'One \underline{Eric} another
///     \underline{Eirik}, and an Ericsson. How many Eiriks, \underline{Eric}?'; it
///     doesn't match 'Ericsson' or 'Eiriks' because they are not bounded
///     by non-word boundaries.
/// 
///     One common use of regexps is to split lines of delimited data into
///     their component fields.
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 10
/// 
///     In this example our input lines have the format company name, web
///     address and country. Unfortunately the regexp is rather long and
///     not very versatile -- the code will break if we add any more
///     fields. A simpler and better solution is to look for the
///     separator, '\\t' in this case, and take the surrounding text. The
///     QString::split() function can take a separator string or regexp
///     as an argument and split a string accordingly.
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 11
/// 
///     Here field[0] is the company, field[1] the web address and so on.
/// 
///     To imitate the matching of a shell we can use wildcard mode.
/// 
///     \snippet code/src_corelib_tools_qregexp.cpp 12
/// 
///     Wildcard matching can be convenient because of its simplicity, but
///     any wildcard regexp can be defined using full regexps, e.g.
///     \b{.*\\.html$}. Notice that we can't match both \c .html and \c
///     .htm files with a wildcard unless we use \b{*.htm*} which will
///     also match 'test.html.bak'. A full regexp gives us the precision
///     we need, \b{.*\\.html?$}.
/// 
///     QRegExp can match case insensitively using setCaseSensitivity(),
///     and can use non-greedy matching, see setMinimal(). By
///     default QRegExp uses full regexps but this can be changed with
///     setPatternSyntax(). Searching can be done forward with indexIn() or backward
///     with lastIndexIn(). Captured text can be accessed using
///     capturedTexts() which returns a string list of all captured
///     strings, or using cap() which returns the captured string for the
///     given index. The pos() function takes a match index and returns
///     the position in the string where the match was made (or -1 if
///     there was no match).
/// 
///     \sa QString, QStringList, QRegExpValidator, QSortFilterProxyModel,
///         {tools/regexp}{Regular Expression Example}
[org_name(QRegExp)]
enum PatternSyntax {
    RegExp,
    Wildcard,
    FixedString,
    RegExp2,
    WildcardUnix,
    W3CXmlSchema11,
}

[org_name(QRegExp)]
enum CaretMode {
    CaretAtZero,
    CaretAtOffset,
    CaretWontMatch,
}


struct RegExp {
    swap(other: &RegExpType),
    ///     Returns \c true if the pattern string is empty; otherwise returns
    ///     false.
    /// 
    ///     If you call exactMatch() with an empty pattern on an empty string
    ///     it will return true; otherwise it returns \c false since it operates
    ///     over the whole string. If you call indexIn() with an empty pattern
    ///     on \e any string it will return the start offset (0 by default)
    ///     because the empty pattern matches the 'emptiness' at the start of
    ///     the string. In this case the length of the match returned by
    ///     matchedLength() will be 0.
    /// 
    ///     See QString::isEmpty().
    is_empty() -> bool,
    ///     Returns \c true if the regular expression is valid; otherwise returns
    ///     false. An invalid regular expression never matches.
    /// 
    ///     The pattern \b{[a-z} is an example of an invalid pattern, since
    ///     it lacks a closing square bracket.
    /// 
    ///     Note that the validity of a regexp may also depend on the setting
    ///     of the wildcard flag, for example \b{*.html} is a valid
    ///     wildcard regexp but an invalid full regexp.
    /// 
    ///     \sa errorString()
    is_valid() -> bool,
    ///     Returns the pattern string of the regular expression. The pattern
    ///     has either regular expression syntax or wildcard syntax, depending
    ///     on patternSyntax().
    /// 
    ///     \sa patternSyntax(), caseSensitivity()
    pattern() -> String,
    ///     Sets the pattern string to \a pattern. The case sensitivity,
    ///     wildcard, and minimal matching options are not changed.
    /// 
    ///     \sa setPatternSyntax(), setCaseSensitivity()
    set_pattern(pattern: String),
    ///     Returns Qt::CaseSensitive if the regexp is matched case
    ///     sensitively; otherwise returns Qt::CaseInsensitive.
    /// 
    ///     \sa patternSyntax(), pattern(), isMinimal()
    case_sensitivity() -> Rute::CaseSensitivity,
    ///     Sets case sensitive matching to \a cs.
    /// 
    ///     If \a cs is Qt::CaseSensitive, \b{\\.txt$} matches
    ///     \c{readme.txt} but not \c{README.TXT}.
    /// 
    ///     \sa setPatternSyntax(), setPattern(), setMinimal()
    set_case_sensitivity(cs: Rute::CaseSensitivity),
    ///     Returns the syntax used by the regular expression. The default is
    ///     QRegExp::RegExp.
    /// 
    ///     \sa pattern(), caseSensitivity()
    pattern_syntax() -> RegExp::PatternSyntax,
    ///     Sets the syntax mode for the regular expression. The default is
    ///     QRegExp::RegExp.
    /// 
    ///     Setting \a syntax to QRegExp::Wildcard enables simple shell-like
    ///     \l{QRegExp wildcard matching}. For example, \b{r*.txt} matches the
    ///     string \c{readme.txt} in wildcard mode, but does not match
    ///     \c{readme}.
    /// 
    ///     Setting \a syntax to QRegExp::FixedString means that the pattern
    ///     is interpreted as a plain string. Special characters (e.g.,
    ///     backslash) don't need to be escaped then.
    /// 
    ///     \sa setPattern(), setCaseSensitivity(), escape()
    set_pattern_syntax(syntax: RegExp::PatternSyntax),
    ///     Returns \c true if minimal (non-greedy) matching is enabled;
    ///     otherwise returns \c false.
    /// 
    ///     \sa caseSensitivity(), setMinimal()
    is_minimal() -> bool,
    ///     Enables or disables minimal matching. If \a minimal is false,
    ///     matching is greedy (maximal) which is the default.
    /// 
    ///     For example, suppose we have the input string "We must be
    ///     <b>bold</b>, very <b>bold</b>!" and the pattern
    ///     \b{<b>.*</b>}. With the default greedy (maximal) matching,
    ///     the match is "We must be \underline{<b>bold</b>, very
    ///     <b>bold</b>}!". But with minimal (non-greedy) matching, the
    ///     first match is: "We must be \underline{<b>bold</b>}, very
    ///     <b>bold</b>!" and the second match is "We must be <b>bold</b>,
    ///     very \underline{<b>bold</b>}!". In practice we might use the pattern
    ///     \b{<b>[^<]*\</b>} instead, although this will still fail for
    ///     nested tags.
    /// 
    ///     \sa setCaseSensitivity()
    set_minimal(minimal: bool),
    ///     Returns \c true if \a str is matched exactly by this regular
    ///     expression; otherwise returns \c false. You can determine how much of
    ///     the string was matched by calling matchedLength().
    /// 
    ///     For a given regexp string R, exactMatch("R") is the equivalent of
    ///     indexIn("^R$") since exactMatch() effectively encloses the regexp
    ///     in the start of string and end of string anchors, except that it
    ///     sets matchedLength() differently.
    /// 
    ///     For example, if the regular expression is \b{blue}, then
    ///     exactMatch() returns \c true only for input \c blue. For inputs \c
    ///     bluebell, \c blutak and \c lightblue, exactMatch() returns \c false
    ///     and matchedLength() will return 4, 3 and 0 respectively.
    /// 
    ///     Although const, this function sets matchedLength(),
    ///     capturedTexts(), and pos().
    /// 
    ///     \sa indexIn(), lastIndexIn()
    exact_match(str: String) -> bool,
    ///     Attempts to find a match in \a str from position \a offset (0 by
    ///     default). If \a offset is -1, the search starts at the last
    ///     character; if -2, at the next to last character; etc.
    /// 
    ///     Returns the position of the first match, or -1 if there was no
    ///     match.
    /// 
    ///     The \a caretMode parameter can be used to instruct whether \b{^}
    ///     should match at index 0 or at \a offset.
    /// 
    ///     You might prefer to use QString::indexOf(), QString::contains(),
    ///     or even QStringList::filter(). To replace matches use
    ///     QString::replace().
    /// 
    ///     Example:
    ///     \snippet code/src_corelib_tools_qregexp.cpp 13
    /// 
    ///     Although const, this function sets matchedLength(),
    ///     capturedTexts() and pos().
    /// 
    ///     If the QRegExp is a wildcard expression (see setPatternSyntax())
    ///     and want to test a string against the whole wildcard expression,
    ///     use exactMatch() instead of this function.
    /// 
    ///     \sa lastIndexIn(), exactMatch()
    index_in(str: String, offset: i32, caret_mode: RegExp::CaretMode) -> i32,
    ///     Attempts to find a match backwards in \a str from position \a
    ///     offset. If \a offset is -1 (the default), the search starts at the
    ///     last character; if -2, at the next to last character; etc.
    /// 
    ///     Returns the position of the first match, or -1 if there was no
    ///     match.
    /// 
    ///     The \a caretMode parameter can be used to instruct whether \b{^}
    ///     should match at index 0 or at \a offset.
    /// 
    ///     Although const, this function sets matchedLength(),
    ///     capturedTexts() and pos().
    /// 
    ///     \warning Searching backwards is much slower than searching
    ///     forwards.
    /// 
    ///     \sa indexIn(), exactMatch()
    last_index_in(str: String, offset: i32, caret_mode: RegExp::CaretMode) -> i32,
    ///     Returns the length of the last matched string, or -1 if there was
    ///     no match.
    /// 
    ///     \sa exactMatch(), indexIn(), lastIndexIn()
    matched_length() -> i32,
    capture_count() -> i32,
    ///     \internal
    captured_texts() -> [String],
    ///     \internal
    captured_texts() -> [String],
    ///     \internal
    cap(nth: i32) -> String,
    ///     \internal
    cap(nth: i32) -> String,
    ///     \internal
    pos(nth: i32) -> i32,
    ///     \internal
    pos(nth: i32) -> i32,
    ///     Returns the string \a str with every regexp special character
    ///     escaped with a backslash. The special characters are $, (,), *, +,
    ///     ., ?, [, \,], ^, {, | and }.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_tools_qregexp.cpp 19
    /// 
    ///     This function is useful to construct regexp patterns dynamically:
    /// 
    ///     \snippet code/src_corelib_tools_qregexp.cpp 20
    /// 
    ///     \sa setPatternSyntax()
    [static] escape(str: String) -> String,
}

// vim: syntax=rust expandtab ts=4 sw=4
