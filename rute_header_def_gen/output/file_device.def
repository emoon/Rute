[org_name(QFileDevice)]
enum FileError {
    NoError,
    ReadError,
    WriteError,
    FatalError,
    ResourceError,
    OpenError,
    AbortError,
    TimeOutError,
    UnspecifiedError,
    RemoveError,
    RenameError,
    PositionError,
    ResizeError,
    PermissionsError,
    CopyError,
}

[org_name(QFileDevice)]
enum FileTime {
    FileAccessTime,
    FileBirthTime,
    FileMetadataChangeTime,
    FileModificationTime,
}

[org_name(QFileDevice)]
enum Permission {
    ReadOwner,
    WriteOwner,
    ExeOwner,
    ReadUser,
    WriteUser,
    ExeUser,
    ReadGroup,
    WriteGroup,
    ExeGroup,
    ReadOther,
    WriteOther,
    ExeOther,
}

[org_name(QFileDevice)]
enum FileHandleFlag {
    AutoCloseHandle,
    DontCloseHandle,
}

[org_name(QFileDevice)]
enum MemoryMapFlags {
    NoOptions,
    MapPrivateOption,
}

struct FileDevice : IODevice {
    error() -> FileDevice::FileError,
    unset_error(),
    [event] close(),
    [event] is_sequential() -> bool,
    handle() -> i32,
    [event] file_name() -> String,
    [event] pos() -> i64,
    [event] seek(offset: i64) -> bool,
    [event] at_end() -> bool,
    flush() -> bool,
    [event] size() -> i64,
    [event] resize(sz: i64) -> bool,
    [event] permissions() -> FileDevice::Permissions,
    [event] set_permissions(permission_spec: FileDevice::Permissions) -> bool,
    map(offset: i64, size: i64, flags: FileDevice::MemoryMapFlags) -> uchar?,
    unmap(address: *uchar) -> bool,
    file_time(time: FileDevice::FileTime) -> DateTime,
    set_file_time(new_date: &DateTimeType, file_time: FileDevice::FileTime) -> bool,
    [event] read_data(data: *char, maxlen: i64) -> i64,
    [event] write_data(data: *char, len: i64) -> i64,
    [event] read_line_data(data: *char, maxlen: i64) -> i64,
}

// vim: syntax=rust expandtab ts=4 sw=4
