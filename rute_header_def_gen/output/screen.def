///     \class QScreen
///     \since 5.0
///     \brief The QScreen class is used to query screen properties.
///     \inmodule QtGui
/// 
///     A note on logical vs physical dots per inch: physical DPI is based on the
///     actual physical pixel sizes when available, and is useful for print preview
///     and other cases where it's desirable to know the exact physical dimensions
///     of screen displayed contents.
/// 
///     Logical dots per inch are used to convert font and user interface elements
///     from point sizes to pixel sizes, and might be different from the physical
///     dots per inch. The logical dots per inch are sometimes user-settable in the
///     desktop environment's settings panel, to let the user globally control UI
///     and font sizes in different applications.
/// 
///     \inmodule QtGui
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct Screen : Object {
    ///   Get the platform screen handle.
    handle() -> PlatformScreen?,
    ///   \property QScreen::name
    ///   \brief a user presentable string representing the screen
    /// 
    ///   For example, on X11 these correspond to the XRandr screen names,
    ///   typically "VGA1", "HDMI1", etc.
    name() -> String,
    ///   \property QScreen::manufacturer
    ///   \brief the manufacturer of the screen
    /// 
    ///   \since 5.9
    manufacturer() -> String,
    ///   \property QScreen::model
    ///   \brief the model of the screen
    /// 
    ///   \since 5.9
    model() -> String,
    ///   \property QScreen::serialNumber
    ///   \brief the serial number of the screen
    /// 
    ///   \since 5.9
    serial_number() -> String,
    ///   \property QScreen::depth
    ///   \brief the color depth of the screen
    depth() -> i32,
    ///   \property QScreen::size
    ///   \brief the pixel resolution of the screen
    size() -> Size,
    ///   \property QScreen::physicalSize
    ///   \brief the screen's physical size (in millimeters)
    /// 
    ///   The physical size represents the actual physical dimensions of the
    ///   screen's display.
    /// 
    ///   Depending on what information the underlying system provides the value
    ///   might not be entirely accurate.
    physical_size() -> SizeF,
    ///   \property QScreen::physicalDotsPerInchX
    ///   \brief the number of physical dots or pixels per inch in the horizontal direction
    /// 
    ///   This value represents the actual horizontal pixel density on the screen's display.
    ///   Depending on what information the underlying system provides the value might not be
    ///   entirely accurate.
    /// 
    ///   \sa physicalDotsPerInchY()
    physical_dots_per_inch_x() -> f32,
    ///   \property QScreen::physicalDotsPerInchY
    ///   \brief the number of physical dots or pixels per inch in the vertical direction
    /// 
    ///   This value represents the actual vertical pixel density on the screen's display.
    ///   Depending on what information the underlying system provides the value might not be
    ///   entirely accurate.
    /// 
    ///   \sa physicalDotsPerInchX()
    physical_dots_per_inch_y() -> f32,
    ///   \property QScreen::physicalDotsPerInch
    ///   \brief the number of physical dots or pixels per inch
    /// 
    ///   This value represents the pixel density on the screen's display.
    ///   Depending on what information the underlying system provides the value might not be
    ///   entirely accurate.
    /// 
    ///   This is a convenience property that's simply the average of the physicalDotsPerInchX
    ///   and physicalDotsPerInchY properties.
    /// 
    ///   \sa physicalDotsPerInchX()
    ///   \sa physicalDotsPerInchY()
    physical_dots_per_inch() -> f32,
    ///   \property QScreen::logicalDotsPerInchX
    ///   \brief the number of logical dots or pixels per inch in the horizontal direction
    /// 
    ///   This value is used to convert font point sizes to pixel sizes.
    /// 
    ///   \sa logicalDotsPerInchY()
    logical_dots_per_inch_x() -> f32,
    ///   \property QScreen::logicalDotsPerInchY
    ///   \brief the number of logical dots or pixels per inch in the vertical direction
    /// 
    ///   This value is used to convert font point sizes to pixel sizes.
    /// 
    ///   \sa logicalDotsPerInchX()
    logical_dots_per_inch_y() -> f32,
    ///   \property QScreen::logicalDotsPerInch
    ///   \brief the number of logical dots or pixels per inch
    /// 
    ///   This value can be used to convert font point sizes to pixel sizes.
    /// 
    ///   This is a convenience property that's simply the average of the logicalDotsPerInchX
    ///   and logicalDotsPerInchY properties.
    /// 
    ///   \sa logicalDotsPerInchX()
    ///   \sa logicalDotsPerInchY()
    logical_dots_per_inch() -> f32,
    ///     \property QScreen::devicePixelRatio
    ///     \brief the screen's ratio between physical pixels and device-independent pixels
    ///     \since 5.5
    /// 
    ///     Returns the ratio between physical pixels and device-independent pixels for the screen.
    /// 
    ///     Common values are 1.0 on normal displays and 2.0 on "retina" displays.
    ///     Higher values are also possible.
    /// 
    ///     \sa QWindow::devicePixelRatio(), QGuiApplication::devicePixelRatio()
    device_pixel_ratio() -> f32,
    ///   \property QScreen::availableSize
    ///   \brief the screen's available size in pixels
    /// 
    ///   The available size is the size excluding window manager reserved areas
    ///   such as task bars and system menus.
    available_size() -> Size,
    ///   Get the screen's virtual siblings.
    /// 
    ///   The virtual siblings are the screen instances sharing the same virtual desktop.
    ///   They share a common coordinate system, and windows can freely be moved or
    ///   positioned across them without having to be re-created.
    virtual_siblings() -> [Screen?],
    ///     \property QScreen::virtualSize
    ///     \brief the pixel size of the virtual desktop to which this screen belongs
    /// 
    ///   Returns the pixel size of the virtual desktop corresponding to this screen.
    /// 
    ///   This is the combined size of the virtual siblings' individual geometries.
    /// 
    ///   \sa virtualSiblings()
    virtual_size() -> Size,
    ///     \property QScreen::availableVirtualSize
    ///     \brief the available size of the virtual desktop to which this screen belongs
    /// 
    ///   Returns the available pixel size of the virtual desktop corresponding to this screen.
    /// 
    ///   This is the combined size of the virtual siblings' individual available geometries.
    /// 
    ///   \sa availableSize(), virtualSiblings()
    available_virtual_size() -> Size,
    ///     \property QScreen::primaryOrientation
    ///     \brief the primary screen orientation
    /// 
    ///     The primary screen orientation is Qt::LandscapeOrientation
    ///     if the screen geometry's width is greater than or equal to its
    ///     height, or Qt::PortraitOrientation otherwise. This property might
    ///     change when the screen orientation was changed (i.e. when the
    ///     display is rotated).
    ///     The behavior is however platform dependent and can often be specified in
    ///     an application manifest file.
    /// 
    primary_orientation() -> Rute::ScreenOrientation,
    ///     \property QScreen::orientation
    ///     \brief the screen orientation
    /// 
    ///     The screen orientation represents the physical orientation
    ///     of the display. For example, the screen orientation of a mobile device
    ///     will change based on how it is being held. A change to the orientation
    ///     might or might not trigger a change to the primary orientation of the screen.
    /// 
    ///     Changes to this property will be filtered by orientationUpdateMask(),
    ///     so in order to receive orientation updates the application must first
    ///     call setOrientationUpdateMask() with a mask of the orientations it wants
    ///     to receive.
    /// 
    ///     Qt::PrimaryOrientation is never returned.
    /// 
    ///     \sa primaryOrientation()
    orientation() -> Rute::ScreenOrientation,
    ///     \property QScreen::nativeOrientation
    ///     \brief the native screen orientation
    ///     \since 5.2
    /// 
    ///     The native orientation of the screen is the orientation where the logo
    ///     sticker of the device appears the right way up, or Qt::PrimaryOrientation
    ///     if the platform does not support this functionality.
    /// 
    ///     The native orientation is a property of the hardware, and does not change.
    native_orientation() -> Rute::ScreenOrientation,
    ///     Returns the currently set orientation update mask.
    /// 
    ///     \sa setOrientationUpdateMask()
    orientation_update_mask() -> Rute::ScreenOrientations,
    ///     Sets the orientations that the application is interested in receiving
    ///     updates for in conjunction with this screen.
    /// 
    ///     For example, to receive orientation() updates and thus have
    ///     orientationChanged() signals being emitted for LandscapeOrientation and
    ///     InvertedLandscapeOrientation, call setOrientationUpdateMask() with
    ///     \a{mask} set to Qt::LandscapeOrientation | Qt::InvertedLandscapeOrientation.
    /// 
    ///     The default, 0, means no orientationChanged() signals are fired.
    set_orientation_update_mask(mask: Rute::ScreenOrientations),
    ///     Convenience function to compute the angle of rotation to get from
    ///     rotation \a a to rotation \a b.
    /// 
    ///     The result will be 0, 90, 180, or 270.
    /// 
    ///     Qt::PrimaryOrientation is interpreted as the screen's primaryOrientation().
    angle_between(a: Rute::ScreenOrientation, b: Rute::ScreenOrientation) -> i32,
    ///     Maps the rect between two screen orientations.
    /// 
    ///     This will flip the x and y dimensions of the rectangle \a{rect} if the orientation \a{a} is
    ///     Qt::PortraitOrientation or Qt::InvertedPortraitOrientation and orientation \a{b} is
    ///     Qt::LandscapeOrientation or Qt::InvertedLandscapeOrientation, or vice versa.
    /// 
    ///     Qt::PrimaryOrientation is interpreted as the screen's primaryOrientation().
    map_between(a: Rute::ScreenOrientation, b: Rute::ScreenOrientation, rect: &RectType) -> Rect,
    ///     Convenience function that returns \c true if \a o is either landscape or inverted landscape;
    ///     otherwise returns \c false.
    /// 
    ///     Qt::PrimaryOrientation is interpreted as the screen's primaryOrientation().
    is_landscape(orientation: Rute::ScreenOrientation) -> bool,
    ///     Creates and returns a pixmap constructed by grabbing the contents
    ///     of the given \a window restricted by QRect(\a x, \a y, \a width,
    ///     \a height).
    /// 
    ///     The arguments (\a{x}, \a{y}) specify the offset in the window,
    ///     whereas (\a{width}, \a{height}) specify the area to be copied.  If
    ///     \a width is negative, the function copies everything to the right
    ///     border of the window. If \a height is negative, the function
    ///     copies everything to the bottom of the window.
    /// 
    ///     The window system identifier (\c WId) can be retrieved using the
    ///     QWidget::winId() function. The rationale for using a window
    ///     identifier and not a QWidget, is to enable grabbing of windows
    ///     that are not part of the application, window system frames, and so
    ///     on.
    /// 
    ///     \warning Grabbing windows that are not part of the application is
    ///     not supported on systems such as iOS, where sandboxing/security
    ///     prevents reading pixels of windows not owned by the application.
    /// 
    ///     The grabWindow() function grabs pixels from the screen, not from
    ///     the window, i.e. if there is another window partially or entirely
    ///     over the one you grab, you get pixels from the overlying window,
    ///     too. The mouse cursor is generally not grabbed.
    /// 
    ///     Note on X11 that if the given \a window doesn't have the same depth
    ///     as the root window, and another window partially or entirely
    ///     obscures the one you grab, you will \e not get pixels from the
    ///     overlying window.  The contents of the obscured areas in the
    ///     pixmap will be undefined and uninitialized.
    /// 
    ///     On Windows Vista and above grabbing a layered window, which is
    ///     created by setting the Qt::WA_TranslucentBackground attribute, will
    ///     not work. Instead grabbing the desktop widget should work.
    /// 
    ///     \warning In general, grabbing an area outside the screen is not
    ///     safe. This depends on the underlying window system.
    grab_window(window: WId, x: i32, y: i32, w: i32, h: i32) -> Pixmap,
    ///   \property QScreen::refreshRate
    ///   \brief the approximate vertical refresh rate of the screen in Hz
    refresh_rate() -> f32,
    [signal] physical_size_changed(size: &SizeFType),
    [signal] physical_dots_per_inch_changed(dpi: f32),
    [signal] logical_dots_per_inch_changed(dpi: f32),
    [signal] primary_orientation_changed(orientation: Rute::ScreenOrientation),
    [signal] orientation_changed(orientation: Rute::ScreenOrientation),
    [signal] refresh_rate_changed(refresh_rate: f32),
}

// vim: syntax=rust expandtab ts=4 sw=4
