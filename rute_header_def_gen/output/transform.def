///     \class QTransform
///     \brief The QTransform class specifies 2D transformations of a coordinate system.
///     \since 4.3
///     \ingroup painting
///     \inmodule QtGui
/// 
///     A transformation specifies how to translate, scale, shear, rotate
///     or project the coordinate system, and is typically used when
///     rendering graphics.
/// 
///     QTransform differs from QMatrix in that it is a true 3x3 matrix,
///     allowing perspective transformations. QTransform's toAffine()
///     method allows casting QTransform to QMatrix. If a perspective
///     transformation has been specified on the matrix, then the
///     conversion will cause loss of data.
/// 
///     QTransform is the recommended transformation class in Qt.
/// 
///     A QTransform object can be built using the setMatrix(), scale(),
///     rotate(), translate() and shear() functions.  Alternatively, it
///     can be built by applying \l {QTransform#Basic Matrix
///     Operations}{basic matrix operations}. The matrix can also be
///     defined when constructed, and it can be reset to the identity
///     matrix (the default) using the reset() function.
/// 
///     The QTransform class supports mapping of graphic primitives: A given
///     point, line, polygon, region, or painter path can be mapped to the
///     coordinate system defined by \e this matrix using the map()
///     function. In case of a rectangle, its coordinates can be
///     transformed using the mapRect() function. A rectangle can also be
///     transformed into a \e polygon (mapped to the coordinate system
///     defined by \e this matrix), using the mapToPolygon() function.
/// 
///     QTransform provides the isIdentity() function which returns \c true if
///     the matrix is the identity matrix, and the isInvertible() function
///     which returns \c true if the matrix is non-singular (i.e. AB = BA =
///     I). The inverted() function returns an inverted copy of \e this
///     matrix if it is invertible (otherwise it returns the identity
///     matrix), and adjoint() returns the matrix's classical adjoint.
///     In addition, QTransform provides the determinant() function which
///     returns the matrix's determinant.
/// 
///     Finally, the QTransform class supports matrix multiplication, addition
///     and subtraction, and objects of the class can be streamed as well
///     as compared.
/// 
///     \tableofcontents
/// 
///     \section1 Rendering Graphics
/// 
///     When rendering graphics, the matrix defines the transformations
///     but the actual transformation is performed by the drawing routines
///     in QPainter.
/// 
///     By default, QPainter operates on the associated device's own
///     coordinate system.  The standard coordinate system of a
///     QPaintDevice has its origin located at the top-left position. The
///     \e x values increase to the right; \e y values increase
///     downward. For a complete description, see the \l {Coordinate
///     System} {coordinate system} documentation.
/// 
///     QPainter has functions to translate, scale, shear and rotate the
///     coordinate system without using a QTransform. For example:
/// 
///     \table 100%
///     \row
///     \li \inlineimage qtransform-simpletransformation.png
///     \li
///     \snippet transform/main.cpp 0
///     \endtable
/// 
///     Although these functions are very convenient, it can be more
///     efficient to build a QTransform and call QPainter::setTransform() if you
///     want to perform more than a single transform operation. For
///     example:
/// 
///     \table 100%
///     \row
///     \li \inlineimage qtransform-combinedtransformation.png
///     \li
///     \snippet transform/main.cpp 1
///     \endtable
/// 
///     \section1 Basic Matrix Operations
/// 
///     \image qtransform-representation.png
/// 
///     A QTransform object contains a 3 x 3 matrix.  The \c m31 (\c dx) and
///     \c m32 (\c dy) elements specify horizontal and vertical translation.
///     The \c m11 and \c m22 elements specify horizontal and vertical scaling.
///     The \c m21 and \c m12 elements specify horizontal and vertical \e shearing.
///     And finally, the \c m13 and \c m23 elements specify horizontal and vertical
///     projection, with \c m33 as an additional projection factor.
/// 
///     QTransform transforms a point in the plane to another point using the
///     following formulas:
/// 
///     \snippet code/src_gui_painting_qtransform.cpp 0
/// 
///     The point \e (x, y) is the original point, and \e (x', y') is the
///     transformed point. \e (x', y') can be transformed back to \e (x,
///     y) by performing the same operation on the inverted() matrix.
/// 
///     The various matrix elements can be set when constructing the
///     matrix, or by using the setMatrix() function later on. They can also
///     be manipulated using the translate(), rotate(), scale() and
///     shear() convenience functions. The currently set values can be
///     retrieved using the m11(), m12(), m13(), m21(), m22(), m23(),
///     m31(), m32(), m33(), dx() and dy() functions.
/// 
///     Translation is the simplest transformation. Setting \c dx and \c
///     dy will move the coordinate system \c dx units along the X axis
///     and \c dy units along the Y axis.  Scaling can be done by setting
///     \c m11 and \c m22. For example, setting \c m11 to 2 and \c m22 to
///     1.5 will double the height and increase the width by 50%.  The
///     identity matrix has \c m11, \c m22, and \c m33 set to 1 (all others are set
///     to 0) mapping a point to itself. Shearing is controlled by \c m12
///     and \c m21. Setting these elements to values different from zero
///     will twist the coordinate system. Rotation is achieved by
///     setting both the shearing factors and the scaling factors. Perspective
///     transformation is achieved by setting both the projection factors and
///     the scaling factors.
/// 
///     Here's the combined transformations example using basic matrix
///     operations:
/// 
///     \table 100%
///     \row
///     \li \inlineimage qtransform-combinedtransformation2.png
///     \li
///     \snippet transform/main.cpp 2
///     \endtable
/// 
///     \sa QPainter, {Coordinate System}, {painting/affine}{Affine
///     Transformations Example}, {Transformations Example}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QTransform)]
enum TransformationType {
    TxNone,
    TxTranslate,
    TxScale,
    TxRotate,
    TxShear,
    TxProject,
}


struct Transform {
    is_affine() -> bool,
    is_identity() -> bool,
    is_invertible() -> bool,
    is_scaling() -> bool,
    is_rotating() -> bool,
    is_translating() -> bool,
    type() -> Transform::TransformationType,
    determinant() -> f32,
    det() -> f32,
    m11() -> f32,
    m12() -> f32,
    m13() -> f32,
    m21() -> f32,
    m22() -> f32,
    m23() -> f32,
    m31() -> f32,
    m32() -> f32,
    m33() -> f32,
    dx() -> f32,
    dy() -> f32,
    ///     Returns an inverted copy of this matrix.
    /// 
    ///     If the matrix is singular (not invertible), the returned matrix is
    ///     the identity matrix. If \a invertible is valid (i.e. not 0), its
    ///     value is set to true if the matrix is invertible, otherwise it is
    ///     set to false.
    /// 
    ///     \sa isInvertible()
    inverted(invertible: *bool) -> Transform,
    ///     Returns the adjoint of this matrix.
    adjoint() -> Transform,
    ///     Scales the coordinate system by \a sx horizontally and \a sy
    ///     vertically, and returns a reference to the matrix.
    /// 
    ///     \sa setMatrix()
    scale(sx: f32, sy: f32) -> Transform?,
    ///     Shears the coordinate system by \a sh horizontally and \a sv
    ///     vertically, and returns a reference to the matrix.
    /// 
    ///     \sa setMatrix()
    shear(sh: f32, sv: f32) -> Transform?,
    ///     \fn QTransform &QTransform::rotate(qreal angle, Qt::Axis axis)
    /// 
    ///     Rotates the coordinate system counterclockwise by the given \a angle
    ///     about the specified \a axis and returns a reference to the matrix.
    /// 
    ///     Note that if you apply a QTransform to a point defined in widget
    ///     coordinates, the direction of the rotation will be clockwise
    ///     because the y-axis points downwards.
    /// 
    ///     The angle is specified in degrees.
    /// 
    ///     \sa setMatrix()
    rotate(a: f32, axis: Rute::Axis) -> Transform?,
    ///     \fn QTransform & QTransform::rotateRadians(qreal angle, Qt::Axis axis)
    /// 
    ///     Rotates the coordinate system counterclockwise by the given \a angle
    ///     about the specified \a axis and returns a reference to the matrix.
    /// 
    ///     Note that if you apply a QTransform to a point defined in widget
    ///     coordinates, the direction of the rotation will be clockwise
    ///     because the y-axis points downwards.
    /// 
    ///     The angle is specified in radians.
    /// 
    ///     \sa setMatrix()
    rotate_radians(a: f32, axis: Rute::Axis) -> Transform?,
    ///     Creates a transformation matrix, \a trans, that maps a unit square
    ///     to a four-sided polygon, \a quad. Returns \c true if the transformation
    ///     is constructed or false if such a transformation does not exist.
    /// 
    ///     \sa quadToSquare(), quadToQuad()
    [static] square_to_quad(square: &PolygonFType, result: &TransformType) -> bool,
    ///     \fn bool QTransform::quadToSquare(const QPolygonF &quad, QTransform &trans)
    /// 
    ///     Creates a transformation matrix, \a trans, that maps a four-sided polygon,
    ///     \a quad, to a unit square. Returns \c true if the transformation is constructed
    ///     or false if such a transformation does not exist.
    /// 
    ///     \sa squareToQuad(), quadToQuad()
    [static] quad_to_square(quad: &PolygonFType, result: &TransformType) -> bool,
    [static] quad_to_quad(one: &PolygonFType, two: &PolygonFType, result: &TransformType) -> bool,
    ///     Resets the matrix to an identity matrix, i.e. all elements are set
    ///     to zero, except \c m11 and \c m22 (specifying the scale) and \c m33
    ///     which are set to 1.
    /// 
    ///     \sa QTransform(), isIdentity(), {QTransform#Basic Matrix
    ///     Operations}{Basic Matrix Operations}
    reset(),
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(p: &PointType) -> Point,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(p: &PointFType) -> PointF,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(l: &LineType) -> Line,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(l: &LineFType) -> LineF,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(a: &PolygonFType) -> PolygonF,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(a: &PolygonType) -> Polygon,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(r: &RegionType) -> Region,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(p: &PainterPathType) -> PainterPath,
    ///     \fn QPolygon QTransform::mapToPolygon(const QRect &rectangle) const
    /// 
    ///     Creates and returns a QPolygon representation of the given \a
    ///     rectangle, mapped into the coordinate system defined by this
    ///     matrix.
    /// 
    ///     The rectangle's coordinates are transformed using the following
    ///     formulas:
    /// 
    ///     \snippet code/src_gui_painting_qtransform.cpp 1
    /// 
    ///     Polygons and rectangles behave slightly differently when
    ///     transformed (due to integer rounding), so
    ///     \c{matrix.map(QPolygon(rectangle))} is not always the same as
    ///     \c{matrix.mapToPolygon(rectangle)}.
    /// 
    ///     \sa mapRect(), {QTransform#Basic Matrix Operations}{Basic Matrix
    ///     Operations}
    map_to_polygon(r: &RectType) -> Polygon,
    ///     \fn QRectF QTransform::mapRect(const QRectF &rectangle) const
    /// 
    ///     Creates and returns a QRectF object that is a copy of the given \a
    ///     rectangle, mapped into the coordinate system defined by this
    ///     matrix.
    /// 
    ///     The rectangle's coordinates are transformed using the following
    ///     formulas:
    /// 
    ///     \snippet code/src_gui_painting_qtransform.cpp 2
    /// 
    ///     If rotation or shearing has been specified, this function returns
    ///     the \e bounding rectangle. To retrieve the exact region the given
    ///     \a rectangle maps to, use the mapToPolygon() function instead.
    /// 
    ///     \sa mapToPolygon(), {QTransform#Basic Matrix Operations}{Basic Matrix
    ///     Operations}
    map_rect(arg0: &RectType) -> Rect,
    ///     \fn QRectF QTransform::mapRect(const QRectF &rectangle) const
    /// 
    ///     Creates and returns a QRectF object that is a copy of the given \a
    ///     rectangle, mapped into the coordinate system defined by this
    ///     matrix.
    /// 
    ///     The rectangle's coordinates are transformed using the following
    ///     formulas:
    /// 
    ///     \snippet code/src_gui_painting_qtransform.cpp 2
    /// 
    ///     If rotation or shearing has been specified, this function returns
    ///     the \e bounding rectangle. To retrieve the exact region the given
    ///     \a rectangle maps to, use the mapToPolygon() function instead.
    /// 
    ///     \sa mapToPolygon(), {QTransform#Basic Matrix Operations}{Basic Matrix
    ///     Operations}
    map_rect(arg0: &RectFType) -> RectF,
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(x: i32, y: i32, tx: *i32, ty: *i32),
    ///     \overload
    /// 
    ///     Maps the given coordinates \a x and \a y into the coordinate
    ///     system defined by this matrix. The resulting values are put in *\a
    ///     tx and *\a ty, respectively. Note that the transformed coordinates
    ///     are rounded to the nearest integer.
    map(x: f32, y: f32, tx: *f32, ty: *f32),
    to_affine() -> Matrix?,
    ///     Creates a matrix which corresponds to a translation of \a dx along
    ///     the x axis and \a dy along the y axis. This is the same as
    ///     QTransform().translate(dx, dy) but slightly faster.
    /// 
    ///     \since 4.5
    [static] from_translate(dx: f32, dy: f32) -> Transform,
    ///     Creates a matrix which corresponds to a scaling of
    ///     \a sx horizontally and \a sy vertically.
    ///     This is the same as QTransform().scale(sx, sy) but slightly faster.
    /// 
    ///     \since 4.5
    [static] from_scale(dx: f32, dy: f32) -> Transform,
}

// vim: syntax=rust expandtab ts=4 sw=4
