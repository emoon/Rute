///     \class QMetaType
///     \inmodule QtCore
///     \brief The QMetaType class manages named types in the meta-object system.
/// 
///     \ingroup objectmodel
///     \threadsafe
/// 
///     The class is used as a helper to marshall types in QVariant and
///     in queued signals and slots connections. It associates a type
///     name to a type so that it can be created and destructed
///     dynamically at run-time. Declare new types with Q_DECLARE_METATYPE()
///     to make them available to QVariant and other template-based functions.
///     Call qRegisterMetaType() to make types available to non-template based
///     functions, such as the queued signal and slot connections.
/// 
///     Any class or struct that has a public default
///     constructor, a public copy constructor, and a public destructor
///     can be registered.
/// 
///     The following code allocates and destructs an instance of
///     \c{MyClass}:
/// 
///     \snippet code/src_corelib_kernel_qmetatype.cpp 3
/// 
///     If we want the stream operators \c operator<<() and \c
///     operator>>() to work on QVariant objects that store custom types,
///     the custom type must provide \c operator<<() and \c operator>>()
///     operators.
/// 
///     \sa Q_DECLARE_METATYPE(), QVariant::setValue(), QVariant::value(), QVariant::fromValue()
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QMetaType)]
enum ExtensionFlag {
    NoExtensionFlags,
    CreateEx,
    DestroyEx,
    ConstructEx,
    DestructEx,
    NameEx,
    SizeEx,
    CtorEx,
    DtorEx,
    FlagsEx,
    MetaObjectEx,
}

[org_name(QMetaType)]
enum Type {
    Void,
    Bool,
    Int,
    UInt,
    LongLong,
    ULongLong,
    Double,
    Long,
    Short,
    Char,
    ULong,
    UShort,
    UChar,
    Float,
    SChar,
    Nullptr,
    VoidStar,
    QChar,
    QString,
    QStringList,
    QByteArray,
    QBitArray,
    QDate,
    QTime,
    QDateTime,
    QUrl,
    QLocale,
    QRect,
    QRectF,
    QSize,
    QSizeF,
    QLine,
    QLineF,
    QPoint,
    QPointF,
    QRegExp,
    QEasingCurve,
    QUuid,
    QVariant,
    QRegularExpression,
    QJsonValue,
    QJsonObject,
    QJsonArray,
    QJsonDocument,
    QModelIndex,
    QPersistentModelIndex,
    QObjectStar,
    QVariantMap,
    QVariantList,
    QVariantHash,
    QByteArrayList,
    QFont,
    QPixmap,
    QBrush,
    QColor,
    QPalette,
    QIcon,
    QImage,
    QPolygon,
    QRegion,
    QBitmap,
    QCursor,
    QKeySequence,
    QPen,
    QTextLength,
    QTextFormat,
    QMatrix,
    QTransform,
    QMatrix4x4,
    QVector2D,
    QVector3D,
    QVector4D,
    QQuaternion,
    QPolygonF,
    QSizePolicy,
    FirstCoreType,
    LastCoreType,
    FirstGuiType,
    LastGuiType,
    FirstWidgetsType,
    LastWidgetsType,
    HighestInternalId,
    QReal,
    UnknownType,
    User,
}

[org_name(QMetaType)]
enum TypeFlag {
    NeedsConstruction,
    NeedsDestruction,
    MovableType,
    PointerToQObject,
    IsEnumeration,
    SharedPointerToQObject,
    WeakPointerToQObject,
    TrackingPointerToQObject,
    WasDeclaredAsMetaType,
    IsGadget,
    PointerToGadget,
}


struct MetaType {
    [static] register_type(type_name: *char, deleter: MetaType::Deleter, creator: MetaType::Creator) -> i32,
    [static] register_type(type_name: *char, deleter: MetaType::Deleter, creator: MetaType::Creator, destructor: MetaType::Destructor, constructor: MetaType::Constructor, size: i32, flags: MetaType::TypeFlags, meta_object: *MetaObjectType) -> i32,
    [static] unregister_type(type: i32) -> bool,
    ///   \internal
    ///   \since 5.0
    ///   \overload
    ///   Don't use, kept for binary compatibility
    /// 
    ///   ### TODO Qt6: remove me
    [static] register_normalized_type(normalized_type_name: onst ::QByteArray &, deleter: MetaType::Deleter, creator: MetaType::Creator, destructor: MetaType::Destructor, constructor: MetaType::Constructor, size: i32, flags: MetaType::TypeFlags, meta_object: *MetaObjectType) -> i32,
    ///   \internal
    ///   \since 5.0
    ///   \overload
    ///   Don't use, kept for binary compatibility
    /// 
    ///   ### TODO Qt6: remove me
    [static] register_normalized_type(normalized_type_name: onst ::QByteArray &, destructor: MetaType::Destructor, constructor: MetaType::Constructor, size: i32, flags: MetaType::TypeFlags, meta_object: *MetaObjectType) -> i32,
    ///     \internal
    ///     \since 4.7
    /// 
    ///     Registers a user type for marshalling, as an alias of another type (typedef)
    [static] register_typedef(type_name: *char, alias_id: i32) -> i32,
    ///     \internal
    ///     \since 5.0
    /// 
    ///     Registers a user type for marshalling, as an alias of another type (typedef).
    ///     Note that normalizedTypeName is not checked for conformance with Qt's normalized format,
    ///     so it must already conform.
    [static] register_normalized_typedef(normalized_type_name: onst ::QByteArray &, alias_id: i32) -> i32,
    ///     \since 5.5
    ///     \overload
    /// 
    ///     Returns a handle to the type called \a typeName, or 0 if there is
    ///     no such type.
    /// 
    ///     \sa isRegistered(), typeName()
    [static] type(type_name: *char) -> i32,
    ///     \since 5.5
    ///     \overload
    /// 
    ///     Returns a handle to the type called \a typeName, or 0 if there is
    ///     no such type.
    /// 
    ///     \sa isRegistered(), typeName()
    [static] type(type_name: onst ::QByteArray &) -> i32,
    ///     Returns the type name associated with the given \a typeId, or a null
    ///     pointer if no matching type was found. The returned pointer must not be
    ///     deleted.
    /// 
    ///     \sa type(), isRegistered(), Type
    [static] type_name(type: i32) -> char?,
    ///     \since 5.0
    /// 
    ///     Returns the size of the given \a type in bytes (i.e. sizeof(T),
    ///     where T is the actual type identified by the \a type argument).
    /// 
    ///     This function is typically used together with construct()
    ///     to perform low-level management of the memory used by a type.
    /// 
    ///     \sa construct()
    [static] size_of(type: i32) -> i32,
    ///     \since 5.0
    /// 
    ///     Returns flags of the given \a type.
    /// 
    ///     \sa QMetaType::TypeFlags
    [static] type_flags(type: i32) -> MetaType::TypeFlags,
    ///     Returns \c true if the datatype with ID \a type is registered;
    ///     otherwise returns \c false.
    /// 
    ///     \sa type(), typeName(), Type
    [static] is_registered(type: i32) -> bool,
    ///     Returns a copy of \a copy, assuming it is of type \a type. If \a
    ///     copy is zero, creates a default constructed instance.
    /// 
    ///     \sa destroy(), isRegistered(), Type
    [static] create(type: i32, copy: *void),
    ///     Writes the object pointed to by \a data with the ID \a type to
    ///     the given \a stream. Returns \c true if the object is saved
    ///     successfully; otherwise returns \c false.
    /// 
    ///     The type must have been registered with qRegisterMetaType() and
    ///     qRegisterMetaTypeStreamOperators() beforehand.
    /// 
    ///     Normally, you should not need to call this function directly.
    ///     Instead, use QVariant's \c operator<<(), which relies on save()
    ///     to stream custom types.
    /// 
    ///     \sa load(), qRegisterMetaTypeStreamOperators()
    [static] save(stream: &DataStreamType, type: i32, data: *void) -> bool,
    ///     Reads the object of the specified \a type from the given \a
    ///     stream into \a data. Returns \c true if the object is loaded
    ///     successfully; otherwise returns \c false.
    /// 
    ///     The type must have been registered with qRegisterMetaType() and
    ///     qRegisterMetaTypeStreamOperators() beforehand.
    /// 
    ///     Normally, you should not need to call this function directly.
    ///     Instead, use QVariant's \c operator>>(), which relies on load()
    ///     to stream custom types.
    /// 
    ///     \sa save(), qRegisterMetaTypeStreamOperators()
    [static] load(stream: &DataStreamType, type: i32, data: *void) -> bool,
    is_valid() -> bool,
    ///     Returns \c true if the datatype with ID \a type is registered;
    ///     otherwise returns \c false.
    /// 
    ///     \sa type(), typeName(), Type
    is_registered() -> bool,
    ///     \since 5.0
    /// 
    ///     Returns the size of the given \a type in bytes (i.e. sizeof(T),
    ///     where T is the actual type identified by the \a type argument).
    /// 
    ///     This function is typically used together with construct()
    ///     to perform low-level management of the memory used by a type.
    /// 
    ///     \sa construct()
    size_of() -> i32,
    flags() -> MetaType::TypeFlags,
    ///     Returns a copy of \a copy, assuming it is of type \a type. If \a
    ///     copy is zero, creates a default constructed instance.
    /// 
    ///     \sa destroy(), isRegistered(), Type
    create(copy: *void),
    [static] has_registered_comparators(type_id: i32) -> bool,
    ///     Converts the object at \a from from \a fromTypeId to the preallocated space at \a to
    ///     typed \a toTypeId. Returns \c true, if the conversion succeeded, otherwise false.
    ///     \since 5.2
    [static] convert(from: *void, from_type_id: i32, to: *void, to_type_id: i32) -> bool,
    ///     Compares the objects at \a lhs and \a rhs. Both objects need to be of type \a typeId.
    ///     \a result is set to less than, equal to or greater than zero, if \a lhs is less than, equal to
    ///     or greater than \a rhs. Returns \c true, if the comparison succeeded, otherwise \c false.
    ///     \since 5.2
    [static] compare(lhs: *void, rhs: *void, type_id: i32, result: *i32) -> bool,
    ///     Compares the objects at \a lhs and \a rhs. Both objects need to be of type \a typeId.
    ///     \a result is set to zero, if \a lhs equals to rhs. Returns \c true, if the comparison
    ///     succeeded, otherwise \c false.
    ///     \since 5.5
    [static] equals(lhs: *void, rhs: *void, type_id: i32, result: *i32) -> bool,
    ///     Returns \c true, if the meta type system has a registered conversion from meta type id \a fromTypeId
    ///     to \a toTypeId
    ///     \since 5.2
    [static] has_registered_converter_function(from_type_id: i32, to_type_id: i32) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
