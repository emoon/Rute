///     \class QPlatformInputContext
///     \since 5.0
///     \internal
///     \preliminary
///     \ingroup qpa
///     \brief The QPlatformInputContext class abstracts the input method dependent data and composing state.
/// 
///     An input method is responsible for inputting complex text that cannot
///     be inputted via simple keymap. It converts a sequence of input
///     events (typically key events) into a text string through the input
///     method specific converting process. The class of the processes are
///     widely ranging from simple finite state machine to complex text
///     translator that pools a whole paragraph of a text with text
///     editing capability to perform grammar and semantic analysis.
/// 
///     To abstract such different input method specific intermediate
///     information, Qt offers the QPlatformInputContext as base class. The
///     concept is well known as 'input context' in the input method
///     domain. An input context is created for a text widget in response
///     to a demand. It is ensured that an input context is prepared for
///     an input method before input to a text widget.
/// 
///     QPlatformInputContext provides an interface the actual input methods
///     can derive from by reimplementing methods.
/// 
///     \sa QInputMethod
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QPlatformInputContext)]
enum Capability {
    HiddenTextCapability,
}

struct PlatformInputContext : Object {
    [event] is_valid() -> bool,
    [event] has_capability(capability: PlatformInputContext::Capability) -> bool,
    [event] reset(),
    [event] commit(),
    [event] update(arg0: Rute::InputMethodQueries),
    [event] invoke_action(arg0: InputMethod::Action, cursor_position: i32),
    ///     This function can be reimplemented to filter input events.
    ///     Return true if the event has been consumed. Otherwise, the unfiltered event will
    ///     be forwarded to widgets as ordinary way. Although the input events have accept()
    ///     and ignore() methods, leave it untouched.
    [event] filter_event(event: *EventType) -> bool,
    [event] keyboard_rect() -> RectF,
    emit_keyboard_rect_changed(),
    [event] is_animating() -> bool,
    emit_animating_changed(),
    [event] show_input_panel(),
    [event] hide_input_panel(),
    [event] is_input_panel_visible() -> bool,
    emit_input_panel_visible_changed(),
    [event] locale() -> Locale,
    emit_locale_changed(),
    [event] input_direction() -> Rute::LayoutDirection,
    emit_input_direction_changed(new_direction: Rute::LayoutDirection),
    [event] set_focus_object(object: *ObjectType),
    input_method_accepted() -> bool,
    [static] set_selection_on_focus_object(anchor_pos: &PointFType, cursor_pos: &PointFType),
}

// vim: syntax=rust expandtab ts=4 sw=4
