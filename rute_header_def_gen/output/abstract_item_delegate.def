///     \class QAbstractItemDelegate
/// 
///     \brief The QAbstractItemDelegate class is used to display and edit
///     data items from a model.
/// 
///     \ingroup model-view
///     \inmodule QtWidgets
/// 
///     A QAbstractItemDelegate provides the interface and common functionality
///     for delegates in the model/view architecture. Delegates display
///     individual items in views, and handle the editing of model data.
/// 
///     The QAbstractItemDelegate class is one of the \l{Model/View Classes}
///     and is part of Qt's \l{Model/View Programming}{model/view framework}.
/// 
///     To render an item in a custom way, you must implement paint() and
///     sizeHint(). The QItemDelegate class provides default implementations for
///     these functions; if you do not need custom rendering, subclass that
///     class instead.
/// 
///     We give an example of drawing a progress bar in items; in our case
///     for a package management program.
/// 
///     \image widgetdelegate.png
/// 
///     We create the \c WidgetDelegate class, which inherits from
///     QStyledItemDelegate. We do the drawing in the paint() function:
/// 
///     \snippet widgetdelegate.cpp 0
/// 
///     Notice that we use a QStyleOptionProgressBar and initialize its
///     members. We can then use the current QStyle to draw it.
/// 
///     To provide custom editing, there are two approaches that can be
///     used. The first approach is to create an editor widget and display
///     it directly on top of the item. To do this you must reimplement
///     createEditor() to provide an editor widget, setEditorData() to populate
///     the editor with the data from the model, and setModelData() so that the
///     delegate can update the model with data from the editor.
/// 
///     The second approach is to handle user events directly by reimplementing
///     editorEvent().
/// 
///     \sa {model-view-programming}{Model/View Programming}, QItemDelegate,
///         {Pixelator Example}, QStyledItemDelegate, QStyle
[org_name(QAbstractItemDelegate)]
enum EndEditHint {
    NoHint,
    EditNextItem,
    EditPreviousItem,
    SubmitModelCache,
    RevertModelCache,
}

struct AbstractItemDelegate : Object {
    [event] paint(painter: *PainterType, option: &StyleOptionViewItemType, index: &ModelIndexType),
    [event] size_hint(option: &StyleOptionViewItemType, index: &ModelIndexType) -> Size,
    [event] create_editor(parent: *WidgetType, option: &StyleOptionViewItemType, index: &ModelIndexType) -> Widget?,
    [event] set_editor_data(editor: *WidgetType, index: &ModelIndexType),
    [event] set_model_data(editor: *WidgetType, model: *AbstractItemModelType, index: &ModelIndexType),
    [event] editor_event(event: *EventType, model: *AbstractItemModelType, option: &StyleOptionViewItemType, index: &ModelIndexType) -> bool,
    [static] elided_text(font_metrics: &FontMetricsType, width: i32, mode: Rute::TextElideMode, text: String) -> String,
    [event] help_event(event: *HelpEventType, view: *AbstractItemViewType, option: &StyleOptionViewItemType, index: &ModelIndexType) -> bool,
    ///     \internal
    /// 
    ///     This virtual method is reserved and will be used in Qt 5.1.
    [event] painting_roles() -> [i32],
    [signal] commit_data(editor: *WidgetType),
    [signal] close_editor(editor: *WidgetType, hint: AbstractItemDelegate::EndEditHint),
    [signal] size_hint_changed(arg0: &ModelIndexType),
}

// vim: syntax=rust expandtab ts=4 sw=4
