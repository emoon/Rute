///    \class QRawFont
///    \brief The QRawFont class provides access to a single physical instance of a font.
///    \since 4.8
///    \inmodule QtGui
/// 
///    \ingroup text
///    \ingroup shared
/// 
///    \note QRawFont is a low level class. For most purposes QFont is a more appropriate class.
/// 
///    Most commonly, when presenting text in a user interface, the exact fonts used
///    to render the characters is to some extent unknown. This can be the case for several
///    reasons: For instance, the actual, physical fonts present on the target system could be
///    unexpected to the developers, or the text could contain user selected styles, sizes or
///    writing systems that are not supported by font chosen in the code.
/// 
///    Therefore, Qt's QFont class really represents a query for fonts. When text is interpreted,
///    Qt will do its best to match the text to the query, but depending on the support, different
///    fonts can be used behind the scenes.
/// 
///    For most use cases, this is both expected and necessary, as it minimizes the possibility of
///    text in the user interface being undisplayable. In some cases, however, more direct control
///    over the process might be useful. It is for these use cases the QRawFont class exists.
/// 
///    A QRawFont object represents a single, physical instance of a given font in a given pixel size.
///    I.e. in the typical case it represents a set of TrueType or OpenType font tables and uses a
///    user specified pixel size to convert metrics into logical pixel units. It can be used in
///    combination with the QGlyphRun class to draw specific glyph indexes at specific positions, and
///    also have accessors to some relevant data in the physical font.
/// 
///    QRawFont only provides support for the main font technologies: GDI and DirectWrite on Windows
///    platforms, FreeType on Linux platforms and CoreText on \macos. For other
///    font back-ends, the APIs will be disabled.
/// 
///    QRawFont can be constructed in a number of ways:
///    \list
///    \li It can be constructed by calling QTextLayout::glyphs() or QTextFragment::glyphs(). The
///       returned QGlyphs objects will contain QRawFont objects which represent the actual fonts
///       used to render each portion of the text.
///    \li It can be constructed by passing a QFont object to QRawFont::fromFont(). The function
///       will return a QRawFont object representing the font that will be selected as response to
///       the QFont query and the selected writing system.
///    \li It can be constructed by passing a file name or QByteArray directly to the QRawFont
///       constructor, or by calling loadFromFile() or loadFromData(). In this case, the
///       font will not be registered in QFontDatabase, and it will not be available as part of
///       regular font selection.
///    \endlist
/// 
///    QRawFont is considered local to the thread in which it is constructed (either using a
///    constructor, or by calling loadFromData() or loadFromFile()). The QRawFont cannot be moved to a
///    different thread, but will have to be recreated in the thread in question.
/// 
///    \note For the requirement of caching glyph indexes and font selections for static text to avoid
///    reshaping and relayouting in the inner loop of an application, a better choice is the QStaticText
///    class, since it optimizes the memory cost of the cache and also provides the possibility of paint
///    engine specific caches for an additional speed-up.
[org_name(QRawFont)]
enum AntialiasingType {
    PixelAntialiasing,
    SubPixelAntialiasing,
}

[org_name(QRawFont)]
enum LayoutFlag {
    SeparateAdvances,
    KernedAdvances,
    UseDesignMetrics,
}


struct RawFont {
    swap(other: &RawFontType),
    ///    Returns \c true if the QRawFont is valid and false otherwise.
    is_valid() -> bool,
    ///    Returns the family name of this QRawFont.
    family_name() -> String,
    ///    Returns the style name of this QRawFont.
    /// 
    ///    \sa QFont::styleName()
    style_name() -> String,
    ///    Returns the style of this QRawFont.
    /// 
    ///    \sa QFont::style()
    style() -> Font::Style,
    ///    Returns the weight of this QRawFont.
    /// 
    ///    \sa QFont::weight()
    weight() -> i32,
    ///    \overload
    /// 
    ///    Returns the QRawFont's advances for each of the \a glyphIndexes in pixel units. The advances
    ///    give the distance from the position of a given glyph to where the next glyph should be drawn
    ///    to make it appear as if the two glyphs are unspaced. The glyph indexes are given with the
    ///    array \a glyphIndexes while the results are returned through \a advances, both of them must
    ///    have \a numGlyphs elements. The advance of each glyph is calculated separately
    /// 
    ///    \sa QTextLine::horizontalAdvance(), QFontMetricsF::width()
    advances_for_glyph_indexes(glyph_indexes: [u32]) -> [PointF],
    ///    \overload
    /// 
    ///    Returns the QRawFont's advances for each of the \a glyphIndexes in pixel units. The advances
    ///    give the distance from the position of a given glyph to where the next glyph should be drawn
    ///    to make it appear as if the two glyphs are unspaced. The glyph indexes are given with the
    ///    array \a glyphIndexes while the results are returned through \a advances, both of them must
    ///    have \a numGlyphs elements. The advance of each glyph is calculated separately
    /// 
    ///    \sa QTextLine::horizontalAdvance(), QFontMetricsF::width()
    advances_for_glyph_indexes(glyph_indexes: [u32], layout_flags: RawFont::LayoutFlags) -> [PointF],
    ///    Converts a string of unicode points to glyph indexes using the CMAP table in the
    ///    underlying font. The function works like glyphIndexesForString() except it take
    ///    an array (\a chars), the results will be returned though \a glyphIndexes array
    ///    and number of glyphs will be set in \a numGlyphs. The size of \a glyphIndexes array
    ///    must be at least \a numChars, if that's still not enough, this function will return
    ///    false, then you can resize \a glyphIndexes from the size returned in \a numGlyphs.
    /// 
    ///    \sa glyphIndexesForString(), advancesForGlyphIndexes(), QGlyphRun, QTextLayout::glyphRuns(), QTextFragment::glyphRuns()
    glyph_indexes_for_chars(chars: *CharType, num_chars: i32, glyph_indexes: *u32, num_glyphs: *i32) -> bool,
    ///    \overload
    /// 
    ///    Returns the QRawFont's advances for each of the \a glyphIndexes in pixel units. The advances
    ///    give the distance from the position of a given glyph to where the next glyph should be drawn
    ///    to make it appear as if the two glyphs are unspaced. The glyph indexes are given with the
    ///    array \a glyphIndexes while the results are returned through \a advances, both of them must
    ///    have \a numGlyphs elements. The advance of each glyph is calculated separately
    /// 
    ///    \sa QTextLine::horizontalAdvance(), QFontMetricsF::width()
    advances_for_glyph_indexes(glyph_indexes: *u32, advances: *PointFType, num_glyphs: i32) -> bool,
    ///    \overload
    /// 
    ///    Returns the QRawFont's advances for each of the \a glyphIndexes in pixel units. The advances
    ///    give the distance from the position of a given glyph to where the next glyph should be drawn
    ///    to make it appear as if the two glyphs are unspaced. The glyph indexes are given with the
    ///    array \a glyphIndexes while the results are returned through \a advances, both of them must
    ///    have \a numGlyphs elements. The advance of each glyph is calculated separately
    /// 
    ///    \sa QTextLine::horizontalAdvance(), QFontMetricsF::width()
    advances_for_glyph_indexes(glyph_indexes: *u32, advances: *PointFType, num_glyphs: i32, layout_flags: RawFont::LayoutFlags) -> bool,
    alpha_map_for_glyph(glyph_index: u32, antialiasing_type: RawFont::AntialiasingType, transform: &TransformType) -> Image,
    ///    This function returns the shape of the glyph at a given \a glyphIndex in the underlying font
    ///    if the QRawFont is valid. Otherwise, it returns an empty QPainterPath.
    /// 
    ///    The returned glyph will always be unhinted.
    /// 
    ///    \sa alphaMapForGlyph(), QPainterPath::addText()
    path_for_glyph(glyph_index: u32) -> PainterPath,
    ///   Returns the smallest rectangle containing the glyph with the given \a glyphIndex.
    /// 
    ///   \since 5.0
    bounding_rect(glyph_index: u32) -> RectF,
    ///    Sets the pixel size with which this font should be rendered to \a pixelSize.
    set_pixel_size(pixel_size: f32),
    ///    Returns the pixel size set for this QRawFont. The pixel size affects how glyphs are
    ///    rasterized, the size of glyphs returned by pathForGlyph(), and is used to convert
    ///    internal metrics from design units to logical pixel units.
    /// 
    ///    \sa setPixelSize()
    pixel_size() -> f32,
    ///    Returns the hinting preference used to construct this QRawFont.
    /// 
    ///    \sa QFont::hintingPreference()
    hinting_preference() -> Font::HintingPreference,
    ///    Returns the ascent of this QRawFont in pixel units.
    /// 
    ///    The ascent of a font is the distance from the baseline to the
    ///    highest position characters extend to. In practice, some font
    ///    designers break this rule, e.g. when they put more than one accent
    ///    on top of a character, or to accommodate an unusual character in
    ///    an exotic language, so it is possible (though rare) that this
    ///    value will be too small.
    /// 
    ///    \sa QFontMetricsF::ascent()
    ascent() -> f32,
    ///    Returns the cap height of this QRawFont in pixel units.
    /// 
    ///    \since 5.8
    /// 
    ///    The cap height of a font is the height of a capital letter above
    ///    the baseline. It specifically is the height of capital letters
    ///    that are flat - such as H or I - as opposed to round letters such
    ///    as O, or pointed letters like A, both of which may display overshoot.
    /// 
    ///    \sa QFontMetricsF::capHeight()
    cap_height() -> f32,
    ///    Returns the descent of this QRawFont in pixel units.
    /// 
    ///    The descent is the distance from the base line to the lowest point
    ///    characters extend to. In practice, some font designers break this rule,
    ///    e.g. to accommodate an unusual character in an exotic language, so
    ///    it is possible (though rare) that this value will be too small.
    /// 
    ///    \sa QFontMetricsF::descent()
    descent() -> f32,
    ///    Returns the leading of this QRawFont in pixel units.
    /// 
    ///    This is the natural inter-line spacing.
    /// 
    ///    \sa QFontMetricsF::leading()
    leading() -> f32,
    ///    Returns the xHeight of this QRawFont in pixel units.
    /// 
    ///    This is often but not always the same as the height of the character 'x'.
    /// 
    ///    \sa QFontMetricsF::xHeight()
    x_height() -> f32,
    ///    Returns the average character width of this QRawFont in pixel units.
    /// 
    ///    \sa QFontMetricsF::averageCharWidth()
    average_char_width() -> f32,
    ///    Returns the width of the widest character in the font.
    /// 
    ///    \sa QFontMetricsF::maxWidth()
    max_char_width() -> f32,
    line_thickness() -> f32,
    underline_position() -> f32,
    ///    Returns the number of design units define the width and height of the em square
    ///    for this QRawFont. This value is used together with the pixel size when converting design metrics
    ///    to pixel units, as the internal metrics are specified in design units and the pixel size gives
    ///    the size of 1 em in pixels.
    /// 
    ///    \sa pixelSize(), setPixelSize()
    units_per_em() -> f32,
    load_from_file(file_name: String, pixel_size: f32, hinting_preference: Font::HintingPreference),
    load_from_data(font_data: &ByteArrayType, pixel_size: f32, hinting_preference: Font::HintingPreference),
    ///     \overload
    /// 
    ///    Returns \c true if the font has a glyph that corresponds to the UCS-4 encoded character \a ucs4.
    /// 
    ///    \sa supportedWritingSystems()
    supports_character(ucs4: uint) -> bool,
    ///     \overload
    /// 
    ///    Returns \c true if the font has a glyph that corresponds to the UCS-4 encoded character \a ucs4.
    /// 
    ///    \sa supportedWritingSystems()
    supports_character(character: CharType) -> bool,
    ///    Returns a list of writing systems supported by the font according to designer supplied
    ///    information in the font file. Please note that this does not guarantee support for a
    ///    specific unicode point in the font. You can use the supportsCharacter() to check support
    ///    for a single, specific character.
    /// 
    ///    \note The list is determined based on the unicode ranges and codepage ranges set in the font's
    ///    OS/2 table and requires such a table to be present in the underlying font file.
    /// 
    ///    \sa supportsCharacter()
    supported_writing_systems() -> List<QFontDatabase::WritingSystem>,
    ///    Retrieves the sfnt table named \a tagName from the underlying physical font, or an empty
    ///    byte array if no such table was found. The returned font table's byte order is Big Endian, like
    ///    the sfnt format specifies. The \a tagName must be four characters long and should be formatted
    ///    in the default endianness of the current platform.
    font_table(tag_name: *char) -> ByteArray,
    ///    Fetches the physical representation based on a \a font query. The physical font returned is
    ///    the font that will be preferred by Qt in order to display text in the selected \a writingSystem.
    /// 
    ///    \warning This function is potentially expensive and should not be called in performance
    ///    sensitive code.
    [static] from_font(font: &FontType, writing_system: FontDatabase::WritingSystem) -> RawFont,
}

// vim: syntax=rust expandtab ts=4 sw=4
