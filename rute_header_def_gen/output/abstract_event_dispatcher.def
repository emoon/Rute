///     \class QAbstractEventDispatcher
///     \inmodule QtCore
///     \brief The QAbstractEventDispatcher class provides an interface to manage Qt's event queue.
/// 
///     \ingroup events
/// 
///     An event dispatcher receives events from the window system and other
///     sources. It then sends them to the QCoreApplication or QApplication
///     instance for processing and delivery. QAbstractEventDispatcher provides
///     fine-grained control over event delivery.
/// 
///     For simple control of event processing use
///     QCoreApplication::processEvents().
/// 
///     For finer control of the application's event loop, call
///     instance() and call functions on the QAbstractEventDispatcher
///     object that is returned. If you want to use your own instance of
///     QAbstractEventDispatcher or of a QAbstractEventDispatcher
///     subclass, you must install it with QCoreApplication::setEventDispatcher()
///     or QThread::setEventDispatcher() \e before a default event dispatcher has
///     been installed.
/// 
///     The main event loop is started by calling
///     QCoreApplication::exec(), and stopped by calling
///     QCoreApplication::exit(). Local event loops can be created using
///     QEventLoop.
/// 
///     Programs that perform long operations can call processEvents()
///     with a bitwise OR combination of various QEventLoop::ProcessEventsFlag
///     values to control which events should be delivered.
/// 
///     QAbstractEventDispatcher also allows the integration of an
///     external event loop with the Qt event loop.
/// 
///     \sa QEventLoop, QCoreApplication, QThread
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct AbstractEventDispatcher : Object {
    [static] instance(thread: *ThreadType) -> AbstractEventDispatcher?,
    [event] process_events(flags: EventLoop::ProcessEventsFlags) -> bool,
    ///     \fn bool QAbstractEventDispatcher::processEvents(QEventLoop::ProcessEventsFlags flags)
    /// 
    ///     Processes pending events that match \a flags until there are no
    ///     more events to process. Returns \c true if an event was processed;
    ///     otherwise returns \c false.
    /// 
    ///     This function is especially useful if you have a long running
    ///     operation, and want to show its progress without allowing user
    ///     input by using the QEventLoop::ExcludeUserInputEvents flag.
    /// 
    ///     If the QEventLoop::WaitForMoreEvents flag is set in \a flags, the
    ///     behavior of this function is as follows:
    /// 
    ///     \list
    /// 
    ///     \li If events are available, this function returns after processing
    ///     them.
    /// 
    ///     \li If no events are available, this function will wait until more
    ///     are available and return after processing newly available events.
    /// 
    ///     \endlist
    /// 
    ///     If the QEventLoop::WaitForMoreEvents flag is not set in \a flags,
    ///     and no events are available, this function will return
    ///     immediately.
    /// 
    ///     \b{Note:} This function does not process events continuously; it
    ///     returns after all available events are processed.
    /// 
    ///     \sa hasPendingEvents()
    [event] has_pending_events() -> bool,
    [event] register_socket_notifier(notifier: *SocketNotifierType),
    ///     \fn void QAbstractEventDispatcher::registerSocketNotifier(QSocketNotifier *notifier)
    /// 
    ///     Registers \a notifier with the event loop. Subclasses must
    ///     implement this method to tie a socket notifier into another
    ///     event loop.
    [event] unregister_socket_notifier(notifier: *SocketNotifierType),
    ///     Registers a timer with the specified \a interval and \a timerType for the
    ///     given \a object and returns the timer id.
    register_timer(interval: i32, timer_type: Rute::TimerType, object: *ObjectType) -> i32,
    ///     Registers a timer with the specified \a interval and \a timerType for the
    ///     given \a object and returns the timer id.
    [event] register_timer(timer_id: i32, interval: i32, timer_type: Rute::TimerType, object: *ObjectType),
    [event] unregister_timer(timer_id: i32) -> bool,
    [event] unregister_timers(object: *ObjectType) -> bool,
    [event] registered_timers(object: *ObjectType) -> List<QAbstractEventDispatcher::TimerInfo>,
    [event] remaining_time(timer_id: i32) -> i32,
    ///     \fn int QAbstractEventDispatcher::remainingTime(int timerId)
    /// 
    ///     Returns the remaining time in milliseconds with the given \a timerId.
    ///     If the timer is inactive, the returned value will be -1. If the timer is
    ///     overdue, the returned value will be 0.
    /// 
    ///     \sa Qt::TimerType
    [event] wake_up(),
    [event] interrupt(),
    ///     \fn void QAbstractEventDispatcher::interrupt()
    /// 
    ///     Interrupts event dispatching.  The event dispatcher will
    ///     return from processEvents() as soon as possible.
    [event] flush(),
    ///     \internal
    [event] starting_up(),
    ///     \internal
    [event] closing_down(),
    ///     Installs an event filter \a filterObj for all native events received by the application.
    /// 
    ///     The event filter \a filterObj receives events via its \l {QAbstractNativeEventFilter::}{nativeEventFilter()}
    ///     function, which is called for all events received by all threads.
    /// 
    ///     The  \l {QAbstractNativeEventFilter::}{nativeEventFilter()} function should return true
    ///     if the event should be filtered, (in this case, stopped). It should return false to allow
    ///     normal Qt processing to continue: the native event can then be translated
    ///     into a QEvent and handled by the standard Qt \l{QEvent} {event} filtering,
    ///     e.g. QObject::installEventFilter().
    /// 
    ///     If multiple event filters are installed, the filter that was installed last
    ///     is activated first.
    /// 
    ///     \note The filter function set here receives native messages,
    ///     that is, MSG or XEvent structs.
    /// 
    ///     For maximum portability, you should always try to use QEvent objects
    ///     and QObject::installEventFilter() whenever possible.
    /// 
    ///     \sa QObject::installEventFilter()
    /// 
    ///     \since 5.0
    install_native_event_filter(filter_obj: *AbstractNativeEventFilterType),
    ///     Removes the event filter \a filter from this object. The
    ///     request is ignored if such an event filter has not been installed.
    /// 
    ///     All event filters for this object are automatically removed when
    ///     this object is destroyed.
    /// 
    ///     It is always safe to remove an event filter, even during event filter
    ///     filter activation (that is, even from within the \l {QAbstractNativeEventFilter::}{nativeEventFilter()} function).
    /// 
    ///     \sa installNativeEventFilter(), QAbstractNativeEventFilter
    ///     \since 5.0
    remove_native_event_filter(filter_obj: *AbstractNativeEventFilterType),
    ///     Sends \a message through the event filters that were set by
    ///     installNativeEventFilter().  This function returns \c true as soon as an
    ///     event filter returns \c true, and false otherwise to indicate that
    ///     the processing of the event should continue.
    /// 
    ///     Subclasses of QAbstractEventDispatcher \e must call this function
    ///     for \e all messages received from the system to ensure
    ///     compatibility with any extensions that may be used in the
    ///     application. The type of event \a eventType is specific to the platform
    ///     plugin chosen at run-time, and can be used to cast message to the right type.
    ///     The \a result pointer is only used on Windows, and corresponds to the LRESULT pointer.
    /// 
    ///     Note that the type of \a message is platform dependent. See
    ///     QAbstractNativeEventFilter for details.
    /// 
    ///     \sa installNativeEventFilter(), QAbstractNativeEventFilter::nativeEventFilter()
    ///     \since 5.0
    filter_native_event(event_type: &ByteArrayType, message: *void, result: *long) -> bool,
    [signal] about_to_block(),
    [signal] awake(),
}

// vim: syntax=rust expandtab ts=4 sw=4
