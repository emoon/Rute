///     \class QTextEdit
///     \brief The QTextEdit class provides a widget that is used to edit and display
///     both plain and rich text.
/// 
///     \ingroup richtext-processing
///     \inmodule QtWidgets
/// 
///     \tableofcontents
/// 
///     \section1 Introduction and Concepts
/// 
///     QTextEdit is an advanced WYSIWYG viewer/editor supporting rich
///     text formatting using HTML-style tags. It is optimized to handle
///     large documents and to respond quickly to user input.
/// 
///     QTextEdit works on paragraphs and characters. A paragraph is a
///     formatted string which is word-wrapped to fit into the width of
///     the widget. By default when reading plain text, one newline
///     signifies a paragraph. A document consists of zero or more
///     paragraphs. The words in the paragraph are aligned in accordance
///     with the paragraph's alignment. Paragraphs are separated by hard
///     line breaks. Each character within a paragraph has its own
///     attributes, for example, font and color.
/// 
///     QTextEdit can display images, lists and tables. If the text is
///     too large to view within the text edit's viewport, scroll bars will
///     appear. The text edit can load both plain text and rich text files.
///     Rich text is described using a subset of HTML 4 markup, refer to the
///     \l {Supported HTML Subset} page for more information.
/// 
///     If you just need to display a small piece of rich text use QLabel.
/// 
///     The rich text support in Qt is designed to provide a fast, portable and
///     efficient way to add reasonable online help facilities to
///     applications, and to provide a basis for rich text editors. If
///     you find the HTML support insufficient for your needs you may consider
///     the use of Qt WebKit, which provides a full-featured web browser
///     widget.
/// 
///     The shape of the mouse cursor on a QTextEdit is Qt::IBeamCursor by default.
///     It can be changed through the viewport()'s cursor property.
/// 
///     \section1 Using QTextEdit as a Display Widget
/// 
///     QTextEdit can display a large HTML subset, including tables and
///     images.
/// 
///     The text is set or replaced using setHtml() which deletes any
///     existing text and replaces it with the text passed in the
///     setHtml() call. If you call setHtml() with legacy HTML, and then
///     call toHtml(), the text that is returned may have different markup,
///     but will render the same. The entire text can be deleted with clear().
/// 
///     Text itself can be inserted using the QTextCursor class or using the
///     convenience functions insertHtml(), insertPlainText(), append() or
///     paste(). QTextCursor is also able to insert complex objects like tables
///     or lists into the document, and it deals with creating selections
///     and applying changes to selected text.
/// 
///     By default the text edit wraps words at whitespace to fit within
///     the text edit widget. The setLineWrapMode() function is used to
///     specify the kind of line wrap you want, or \l NoWrap if you don't
///     want any wrapping. Call setLineWrapMode() to set a fixed pixel width
///     \l FixedPixelWidth, or character column (e.g. 80 column) \l
///     FixedColumnWidth with the pixels or columns specified with
///     setLineWrapColumnOrWidth(). If you use word wrap to the widget's width
///     \l WidgetWidth, you can specify whether to break on whitespace or
///     anywhere with setWordWrapMode().
/// 
///     The find() function can be used to find and select a given string
///     within the text.
/// 
///     If you want to limit the total number of paragraphs in a QTextEdit,
///     as for example it is often useful in a log viewer, then you can use
///     QTextDocument's maximumBlockCount property for that.
/// 
///     \section2 Read-only Key Bindings
/// 
///     When QTextEdit is used read-only the key bindings are limited to
///     navigation, and text may only be selected with the mouse:
///     \table
///     \header \li Keypresses \li Action
///     \row \li Up        \li Moves one line up.
///     \row \li Down        \li Moves one line down.
///     \row \li Left        \li Moves one character to the left.
///     \row \li Right        \li Moves one character to the right.
///     \row \li PageUp        \li Moves one (viewport) page up.
///     \row \li PageDown        \li Moves one (viewport) page down.
///     \row \li Home        \li Moves to the beginning of the text.
///     \row \li End                \li Moves to the end of the text.
///     \row \li Alt+Wheel
///          \li Scrolls the page horizontally (the Wheel is the mouse wheel).
///     \row \li Ctrl+Wheel        \li Zooms the text.
///     \row \li Ctrl+A            \li Selects all text.
///     \endtable
/// 
///     The text edit may be able to provide some meta-information. For
///     example, the documentTitle() function will return the text from
///     within HTML \c{<title>} tags.
/// 
///     \note Zooming into HTML documents only works if the font-size is not set to a fixed size.
/// 
///     \section1 Using QTextEdit as an Editor
/// 
///     All the information about using QTextEdit as a display widget also
///     applies here.
/// 
///     The current char format's attributes are set with setFontItalic(),
///     setFontWeight(), setFontUnderline(), setFontFamily(),
///     setFontPointSize(), setTextColor() and setCurrentFont(). The current
///     paragraph's alignment is set with setAlignment().
/// 
///     Selection of text is handled by the QTextCursor class, which provides
///     functionality for creating selections, retrieving the text contents or
///     deleting selections. You can retrieve the object that corresponds with
///     the user-visible cursor using the textCursor() method. If you want to set
///     a selection in QTextEdit just create one on a QTextCursor object and
///     then make that cursor the visible cursor using setTextCursor(). The selection
///     can be copied to the clipboard with copy(), or cut to the clipboard with
///     cut(). The entire text can be selected using selectAll().
/// 
///     When the cursor is moved and the underlying formatting attributes change,
///     the currentCharFormatChanged() signal is emitted to reflect the new attributes
///     at the new cursor position.
/// 
///     The textChanged() signal is emitted whenever the text changes (as a result
///     of setText() or through the editor itself).
/// 
///     QTextEdit holds a QTextDocument object which can be retrieved using the
///     document() method. You can also set your own document object using setDocument().
/// 
///     QTextDocument provides an \l {QTextDocument::isModified()}{isModified()}
///     function which will return true if the text has been modified since it was
///     either loaded or since the last call to setModified with false as argument.
///     In addition it provides methods for undo and redo.
/// 
///     \section2 Drag and Drop
/// 
///     QTextEdit also supports custom drag and drop behavior. By default,
///     QTextEdit will insert plain text, HTML and rich text when the user drops
///     data of these MIME types onto a document. Reimplement
///     canInsertFromMimeData() and insertFromMimeData() to add support for
///     additional MIME types.
/// 
///     For example, to allow the user to drag and drop an image onto a QTextEdit,
///     you could the implement these functions in the following way:
/// 
///     \snippet textdocument-imagedrop/textedit.cpp 0
/// 
///     We add support for image MIME types by returning true. For all other
///     MIME types, we use the default implementation.
/// 
///     \snippet textdocument-imagedrop/textedit.cpp 1
/// 
///     We unpack the image from the QVariant held by the MIME source and insert
///     it into the document as a resource.
/// 
///     \section2 Editing Key Bindings
/// 
///     The list of key bindings which are implemented for editing:
///     \table
///     \header \li Keypresses \li Action
///     \row \li Backspace \li Deletes the character to the left of the cursor.
///     \row \li Delete \li Deletes the character to the right of the cursor.
///     \row \li Ctrl+C \li Copy the selected text to the clipboard.
///     \row \li Ctrl+Insert \li Copy the selected text to the clipboard.
///     \row \li Ctrl+K \li Deletes to the end of the line.
///     \row \li Ctrl+V \li Pastes the clipboard text into text edit.
///     \row \li Shift+Insert \li Pastes the clipboard text into text edit.
///     \row \li Ctrl+X \li Deletes the selected text and copies it to the clipboard.
///     \row \li Shift+Delete \li Deletes the selected text and copies it to the clipboard.
///     \row \li Ctrl+Z \li Undoes the last operation.
///     \row \li Ctrl+Y \li Redoes the last operation.
///     \row \li Left \li Moves the cursor one character to the left.
///     \row \li Ctrl+Left \li Moves the cursor one word to the left.
///     \row \li Right \li Moves the cursor one character to the right.
///     \row \li Ctrl+Right \li Moves the cursor one word to the right.
///     \row \li Up \li Moves the cursor one line up.
///     \row \li Down \li Moves the cursor one line down.
///     \row \li PageUp \li Moves the cursor one page up.
///     \row \li PageDown \li Moves the cursor one page down.
///     \row \li Home \li Moves the cursor to the beginning of the line.
///     \row \li Ctrl+Home \li Moves the cursor to the beginning of the text.
///     \row \li End \li Moves the cursor to the end of the line.
///     \row \li Ctrl+End \li Moves the cursor to the end of the text.
///     \row \li Alt+Wheel \li Scrolls the page horizontally (the Wheel is the mouse wheel).
///     \endtable
/// 
///     To select (mark) text hold down the Shift key whilst pressing one
///     of the movement keystrokes, for example, \e{Shift+Right}
///     will select the character to the right, and \e{Shift+Ctrl+Right} will select the word to the right, etc.
/// 
///     \sa QTextDocument, QTextCursor, {Application Example},
///         {Syntax Highlighter Example}, {Rich Text Processing}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QTextEdit)]
enum LineWrapMode {
    NoWrap,
    WidgetWidth,
    FixedPixelWidth,
    FixedColumnWidth,
}

[org_name(QTextEdit)]
enum AutoFormattingFlag {
    AutoNone,
    AutoBulletList,
    AutoAll,
}

struct TextEdit : AbstractScrollArea {
    ///     \property QTextEdit::document
    ///     \brief the underlying document of the text editor.
    /// 
    ///     \note The editor \e{does not take ownership of the document} unless it
    ///     is the document's parent object. The parent object of the provided document
    ///     remains the owner of the object. If the previously assigned document is a
    ///     child of the editor then it will be deleted.
    set_document(document: *TextDocumentType),
    document() -> TextDocument?,
    set_placeholder_text(placeholder_text: String),
    ///     \since 5.2
    /// 
    ///     \property QTextEdit::placeholderText
    ///     \brief the editor placeholder text
    /// 
    ///     Setting this property makes the editor display a grayed-out
    ///     placeholder text as long as the document() is empty.
    /// 
    ///     By default, this property contains an empty string.
    /// 
    ///     \sa document()
    placeholder_text() -> String,
    ///     Sets the visible \a cursor.
    set_text_cursor(cursor: &TextCursorType),
    text_cursor() -> TextCursor,
    ///     \property QTextEdit::readOnly
    ///     \brief whether the text edit is read-only
    /// 
    ///     In a read-only text edit the user can only navigate through the
    ///     text and select text; modifying the text is not possible.
    /// 
    ///     This property's default is false.
    is_read_only() -> bool,
    set_read_only(ro: bool),
    ///     \property QTextEdit::textInteractionFlags
    ///     \since 4.2
    /// 
    ///     Specifies how the widget should interact with user input.
    /// 
    ///     The default value depends on whether the QTextEdit is read-only
    ///     or editable, and whether it is a QTextBrowser or not.
    set_text_interaction_flags(flags: Rute::TextInteractionFlags),
    text_interaction_flags() -> Rute::TextInteractionFlags,
    ///     Returns the point size of the font of the current format.
    /// 
    ///     \sa setFontFamily(), setCurrentFont(), setFontPointSize()
    font_point_size() -> f32,
    ///     Returns the font family of the current format.
    /// 
    ///     \sa setFontFamily(), setCurrentFont(), setFontPointSize()
    font_family() -> String,
    ///     Returns the font weight of the current format.
    /// 
    ///     \sa setFontWeight(), setCurrentFont(), setFontPointSize(), QFont::Weight
    font_weight() -> i32,
    ///     Returns \c true if the font of the current format is underlined; otherwise returns
    ///     false.
    /// 
    ///     \sa setFontUnderline()
    font_underline() -> bool,
    ///     Returns \c true if the font of the current format is italic; otherwise returns
    ///     false.
    /// 
    ///     \sa setFontItalic()
    font_italic() -> bool,
    ///     Returns the text color of the current format.
    /// 
    ///     \sa setTextColor()
    text_color() -> Color,
    ///     \since 4.4
    /// 
    ///     Returns the text background color of the current format.
    /// 
    ///     \sa setTextBackgroundColor()
    text_background_color() -> Color,
    ///     Returns the font of the current format.
    /// 
    ///     \sa setCurrentFont(), setFontFamily(), setFontPointSize()
    current_font() -> Font,
    ///     Returns the alignment of the current paragraph.
    /// 
    ///     \sa setAlignment()
    alignment() -> Rute::Alignment,
    merge_current_char_format(modifier: &TextCharFormatType),
    set_current_char_format(format: &TextCharFormatType),
    current_char_format() -> TextCharFormat,
    ///     \property QTextEdit::autoFormatting
    ///     \brief the enabled set of auto formatting features
    /// 
    ///     The value can be any combination of the values in the
    ///     AutoFormattingFlag enum.  The default is AutoNone. Choose
    ///     AutoAll to enable all automatic formatting.
    /// 
    ///     Currently, the only automatic formatting feature provided is
    ///     AutoBulletList; future versions of Qt may offer more.
    auto_formatting() -> TextEdit::AutoFormatting,
    set_auto_formatting(features: TextEdit::AutoFormatting),
    tab_changes_focus() -> bool,
    set_tab_changes_focus(b: bool),
    set_document_title(title: String),
    document_title() -> String,
    is_undo_redo_enabled() -> bool,
    set_undo_redo_enabled(enable: bool),
    ///     \property QTextEdit::lineWrapMode
    ///     \brief the line wrap mode
    /// 
    ///     The default mode is WidgetWidth which causes words to be
    ///     wrapped at the right edge of the text edit. Wrapping occurs at
    ///     whitespace, keeping whole words intact. If you want wrapping to
    ///     occur within words use setWordWrapMode(). If you set a wrap mode of
    ///     FixedPixelWidth or FixedColumnWidth you should also call
    ///     setLineWrapColumnOrWidth() with the width you want.
    /// 
    ///     \sa lineWrapColumnOrWidth
    line_wrap_mode() -> TextEdit::LineWrapMode,
    set_line_wrap_mode(mode: TextEdit::LineWrapMode),
    ///     \property QTextEdit::lineWrapColumnOrWidth
    ///     \brief the position (in pixels or columns depending on the wrap mode) where text will be wrapped
    /// 
    ///     If the wrap mode is FixedPixelWidth, the value is the number of
    ///     pixels from the left edge of the text edit at which text should be
    ///     wrapped. If the wrap mode is FixedColumnWidth, the value is the
    ///     column number (in character columns) from the left edge of the
    ///     text edit at which text should be wrapped.
    /// 
    ///     By default, this property contains a value of 0.
    /// 
    ///     \sa lineWrapMode
    line_wrap_column_or_width() -> i32,
    set_line_wrap_column_or_width(w: i32),
    ///     \property QTextEdit::wordWrapMode
    ///     \brief the mode QTextEdit will use when wrapping text by words
    /// 
    ///     By default, this property is set to QTextOption::WrapAtWordBoundaryOrAnywhere.
    /// 
    ///     \sa QTextOption::WrapMode
    word_wrap_mode() -> TextOption::WrapMode,
    set_word_wrap_mode(policy: TextOption::WrapMode),
    ///     \fn bool QTextEdit::find(const QRegExp &exp, QTextDocument::FindFlags options)
    /// 
    ///     \since 5.3
    ///     \overload
    /// 
    ///     Finds the next occurrence, matching the regular expression, \a exp, using the given
    ///     \a options. The QTextDocument::FindCaseSensitively option is ignored for this overload,
    ///     use QRegExp::caseSensitivity instead.
    /// 
    ///     Returns \c true if a match was found and changes the cursor to select the match;
    ///     otherwise returns \c false.
    find(exp: String, options: TextDocument::FindFlags) -> bool,
    ///     \fn bool QTextEdit::find(const QRegExp &exp, QTextDocument::FindFlags options)
    /// 
    ///     \since 5.3
    ///     \overload
    /// 
    ///     Finds the next occurrence, matching the regular expression, \a exp, using the given
    ///     \a options. The QTextDocument::FindCaseSensitively option is ignored for this overload,
    ///     use QRegExp::caseSensitivity instead.
    /// 
    ///     Returns \c true if a match was found and changes the cursor to select the match;
    ///     otherwise returns \c false.
    find(exp: &RegExpType, options: TextDocument::FindFlags) -> bool,
    to_plain_text() -> String,
    to_html() -> String,
    ///     Ensures that the cursor is visible by scrolling the text edit if
    ///     necessary.
    ensure_cursor_visible(),
    ///     Loads the resource specified by the given \a type and \a name.
    /// 
    ///     This function is an extension of QTextDocument::loadResource().
    /// 
    ///     \sa QTextDocument::loadResource()
    [event] load_resource(type: i32, name: &UrlType) -> Variant,
    ///   \since 4.4
    ///   This function creates the standard context menu which is shown
    ///   when the user clicks on the text edit with the right mouse
    ///   button. It is called from the default contextMenuEvent() handler
    ///   and it takes the \a position in document coordinates where the mouse click was.
    ///   This can enable actions that are sensitive to the position where the user clicked.
    ///   The popup menu's ownership is transferred to the caller.
    create_standard_context_menu() -> Menu?,
    ///   \since 4.4
    ///   This function creates the standard context menu which is shown
    ///   when the user clicks on the text edit with the right mouse
    ///   button. It is called from the default contextMenuEvent() handler
    ///   and it takes the \a position in document coordinates where the mouse click was.
    ///   This can enable actions that are sensitive to the position where the user clicked.
    ///   The popup menu's ownership is transferred to the caller.
    create_standard_context_menu(position: &PointType) -> Menu?,
    ///   returns a QTextCursor at position \a pos (in viewport coordinates).
    cursor_for_position(pos: &PointType) -> TextCursor,
    cursor_rect(cursor: &TextCursorType) -> Rect,
    cursor_rect() -> Rect,
    ///     Returns the reference of the anchor at position \a pos, or an
    ///     empty string if no anchor exists at that point.
    anchor_at(pos: &PointType) -> String,
    ///    \property QTextEdit::overwriteMode
    ///    \since 4.1
    ///    \brief whether text entered by the user will overwrite existing text
    /// 
    ///    As with many text editors, the text editor widget can be configured
    ///    to insert or overwrite existing text with new text entered by the user.
    /// 
    ///    If this property is \c true, existing text is overwritten, character-for-character
    ///    by new text; otherwise, text is inserted at the cursor position, displacing
    ///    existing text.
    /// 
    ///    By default, this property is \c false (new text does not overwrite existing text).
    overwrite_mode() -> bool,
    set_overwrite_mode(overwrite: bool),
    ///     \property QTextEdit::tabStopWidth
    ///     \brief the tab stop width in pixels
    ///     \since 4.1
    ///     \deprecated in Qt 5.10. Use tabStopDistance instead.
    /// 
    ///     By default, this property contains a value of 80 pixels.
    tab_stop_width() -> i32,
    set_tab_stop_width(width: i32),
    ///     \property QTextEdit::tabStopDistance
    ///     \brief the tab stop distance in pixels
    ///     \since 5.10
    /// 
    ///     By default, this property contains a value of 80 pixels.
    tab_stop_distance() -> f32,
    set_tab_stop_distance(distance: f32),
    ///     \since 4.2
    ///     \property QTextEdit::cursorWidth
    /// 
    ///     This property specifies the width of the cursor in pixels. The default value is 1.
    cursor_width() -> i32,
    set_cursor_width(width: i32),
    ///     \property QTextEdit::acceptRichText
    ///     \brief whether the text edit accepts rich text insertions by the user
    ///     \since 4.1
    /// 
    ///     When this propery is set to false text edit will accept only
    ///     plain text input from the user. For example through clipboard or drag and drop.
    /// 
    ///     This property's default is true.
    accept_rich_text() -> bool,
    set_accept_rich_text(accept: bool),
    ///     \since 4.2
    ///     Moves the cursor by performing the given \a operation.
    /// 
    ///     If \a mode is QTextCursor::KeepAnchor, the cursor selects the text it moves over.
    ///     This is the same effect that the user achieves when they hold down the Shift key
    ///     and move the cursor with the cursor keys.
    /// 
    ///     \sa QTextCursor::movePosition()
    move_cursor(operation: TextCursor::MoveOperation, mode: TextCursor::MoveMode),
    ///     \since 4.2
    ///     Returns whether text can be pasted from the clipboard into the textedit.
    can_paste() -> bool,
    ///     \since 4.3
    ///     Convenience function to print the text edit's document to the given \a printer. This
    ///     is equivalent to calling the print method on the document directly except that this
    ///     function also supports QPrinter::Selection as print range.
    /// 
    ///     \sa QTextDocument::print()
    print(printer: *PagedPaintDeviceType),
    [event] input_method_query(property: Rute::InputMethodQuery) -> Variant,
    input_method_query(query: Rute::InputMethodQuery, argument: VariantType) -> Variant,
    ///     Sets the point size of the current format to \a s.
    /// 
    ///     Note that if \a s is zero or negative, the behavior of this
    ///     function is not defined.
    /// 
    ///     \sa fontPointSize(), setCurrentFont(), setFontFamily()
    set_font_point_size(s: f32),
    ///     Sets the font family of the current format to \a fontFamily.
    /// 
    ///     \sa fontFamily(), setCurrentFont()
    set_font_family(font_family: String),
    ///     \fn void QTextEdit::setFontWeight(int weight)
    /// 
    ///     Sets the font weight of the current format to the given \a weight,
    ///     where the value used is in the range defined by the QFont::Weight
    ///     enum.
    /// 
    ///     \sa fontWeight(), setCurrentFont(), setFontFamily()
    set_font_weight(w: i32),
    ///     If \a underline is true, sets the current format to underline;
    ///     otherwise sets the current format to non-underline.
    /// 
    ///     \sa fontUnderline()
    set_font_underline(b: bool),
    ///     If \a italic is true, sets the current format to italic;
    ///     otherwise sets the current format to non-italic.
    /// 
    ///     \sa fontItalic()
    set_font_italic(b: bool),
    ///     Sets the text color of the current format to \a c.
    /// 
    ///     \sa textColor()
    set_text_color(c: &ColorType),
    ///     \since 4.4
    /// 
    ///     Sets the text background color of the current format to \a c.
    /// 
    ///     \sa textBackgroundColor()
    set_text_background_color(c: &ColorType),
    ///     Sets the font of the current format to \a f.
    /// 
    ///     \sa currentFont(), setFontPointSize(), setFontFamily()
    set_current_font(f: &FontType),
    ///     Sets the alignment of the current paragraph to \a a. Valid
    ///     alignments are Qt::AlignLeft, Qt::AlignRight,
    ///     Qt::AlignJustify and Qt::AlignCenter (which centers
    ///     horizontally).
    set_alignment(a: Rute::Alignment),
    ///     Changes the text of the text edit to the string \a text.
    ///     Any previous text is removed.
    /// 
    ///     \a text is interpreted as plain text.
    /// 
    ///     Note that the undo/redo history is cleared by this function.
    /// 
    ///     \sa toPlainText()
    set_plain_text(text: String),
    ///     \property QTextEdit::html
    /// 
    ///     This property provides an HTML interface to the text of the text edit.
    /// 
    ///     toHtml() returns the text of the text edit as html.
    /// 
    ///     setHtml() changes the text of the text edit.  Any previous text is
    ///     removed and the undo/redo history is cleared. The input text is
    ///     interpreted as rich text in html format.
    /// 
    ///     \note It is the responsibility of the caller to make sure that the
    ///     text is correctly decoded when a QString containing HTML is created
    ///     and passed to setHtml().
    /// 
    ///     By default, for a newly-created, empty document, this property contains
    ///     text to describe an HTML 4.0 document with no body text.
    /// 
    ///     \sa {Supported HTML Subset}, plainText
    set_html(text: String),
    ///     \since 4.2
    /// 
    ///     Sets the text edit's \a text. The text can be plain text or HTML
    ///     and the text edit will try to guess the right format.
    /// 
    ///     Use setHtml() or setPlainText() directly to avoid text edit's guessing.
    /// 
    ///     \sa toPlainText(), toHtml()
    set_text(text: String),
    ///     Copies the selected text to the clipboard and deletes it from
    ///     the text edit.
    /// 
    ///     If there is no selected text nothing happens.
    /// 
    ///     \sa copy(), paste()
    cut(),
    ///     Copies any selected text to the clipboard.
    /// 
    ///     \sa copyAvailable()
    copy(),
    ///     Pastes the text from the clipboard into the text edit at the
    ///     current cursor position.
    /// 
    ///     If there is no text in the clipboard nothing happens.
    /// 
    ///     To change the behavior of this function, i.e. to modify what
    ///     QTextEdit can paste and how it is being pasted, reimplement the
    ///     virtual canInsertFromMimeData() and insertFromMimeData()
    ///     functions.
    /// 
    ///     \sa cut(), copy()
    paste(),
    ///     \since 4.2
    /// 
    ///     Undoes the last operation.
    /// 
    ///     If there is no operation to undo, i.e. there is no undo step in
    ///     the undo/redo history, nothing happens.
    /// 
    ///     \sa redo()
    undo(),
    redo(),
    ///     Deletes all the text in the text edit.
    /// 
    ///     Note that the undo/redo history is cleared by this function.
    /// 
    ///     \sa cut(), setPlainText(), setHtml()
    clear(),
    select_all(),
    insert_plain_text(text: String),
    insert_html(text: String),
    ///     Appends a new paragraph with \a text to the end of the text edit.
    /// 
    ///     \note The new paragraph appended will have the same character format and
    ///     block format as the current paragraph, determined by the position of the cursor.
    /// 
    ///     \sa currentCharFormat(), QTextCursor::blockFormat()
    append(text: String),
    ///     Scrolls the text edit so that the anchor with the given \a name is
    ///     visible; does nothing if the \a name is empty, or is already
    ///     visible, or isn't found.
    scroll_to_anchor(name: String),
    ///     \fn QTextEdit::zoomIn(int range)
    /// 
    ///     Zooms in on the text by making the base font size \a range
    ///     points larger and recalculating all font sizes to be the new size.
    ///     This does not change the size of any images.
    /// 
    ///     \sa zoomOut()
    zoom_in(range: i32),
    ///     \fn QTextEdit::zoomOut(int range)
    /// 
    ///     \overload
    /// 
    ///     Zooms out on the text by making the base font size \a range points
    ///     smaller and recalculating all font sizes to be the new size. This
    ///     does not change the size of any images.
    /// 
    ///     \sa zoomIn()
    zoom_out(range: i32),
    [signal] text_changed(),
    [signal] undo_available(b: bool),
    [signal] redo_available(b: bool),
    [signal] current_char_format_changed(format: &TextCharFormatType),
    [signal] copy_available(b: bool),
    [signal] selection_changed(),
    [signal] cursor_position_changed(),
    ///     Selects all text.
    /// 
    ///     \sa copy(), cut(), textCursor()
    ///  */
    /// void QTextEdit::selectAll()
    /// {
    ///     Q_D(QTextEdit);
    ///     d->control->selectAll();
    /// }
    /// 
    [event] event(e: *EventType) -> bool,
    [event] timer_event(e: *TimerEventType),
    [event] key_press_event(e: *KeyEventType),
    [event] key_release_event(e: *KeyEventType),
    [event] resize_event(e: *ResizeEventType),
    [event] paint_event(e: *PaintEventType),
    [event] mouse_press_event(e: *MouseEventType),
    [event] mouse_move_event(e: *MouseEventType),
    [event] mouse_release_event(e: *MouseEventType),
    [event] mouse_double_click_event(e: *MouseEventType),
    [event] focus_next_prev_child(next: bool) -> bool,
    ///   \fn void QTextEdit::contextMenuEvent(QContextMenuEvent *event)
    /// 
    ///   Shows the standard context menu created with createStandardContextMenu().
    /// 
    ///   If you do not want the text edit to have a context menu, you can set
    ///   its \l contextMenuPolicy to Qt::NoContextMenu. If you want to
    ///   customize the context menu, reimplement this function. If you want
    ///   to extend the standard context menu, reimplement this function, call
    ///   createStandardContextMenu() and extend the menu returned.
    /// 
    ///   Information about the event is passed in the \a event object.
    /// 
    ///   \snippet code/src_gui_widgets_qtextedit.cpp 0
    [event] context_menu_event(e: *ContextMenuEventType),
    [event] drag_enter_event(e: *DragEnterEventType),
    [event] drag_leave_event(e: *DragLeaveEventType),
    [event] drag_move_event(e: *DragMoveEventType),
    [event] drop_event(e: *DropEventType),
    [event] focus_in_event(e: *FocusEventType),
    [event] focus_out_event(e: *FocusEventType),
    [event] show_event(arg0: *ShowEventType),
    [event] change_event(e: *EventType),
    [event] wheel_event(e: *WheelEventType),
    ///     This function returns a new MIME data object to represent the contents
    ///     of the text edit's current selection. It is called when the selection needs
    ///     to be encapsulated into a new QMimeData object; for example, when a drag
    ///     and drop operation is started, or when data is copied to the clipboard.
    /// 
    ///     If you reimplement this function, note that the ownership of the returned
    ///     QMimeData object is passed to the caller. The selection can be retrieved
    ///     by using the textCursor() function.
    [event] create_mime_data_from_selection() -> MimeData?,
    [event] can_insert_from_mime_data(source: *MimeDataType) -> bool,
    [event] insert_from_mime_data(source: *MimeDataType),
    [event] input_method_event(arg0: *InputMethodEventType),
    [event] scroll_contents_by(dx: i32, dy: i32),
    ///     \internal
    /// 
    ///      This provides a hook for subclasses to intercept cursor changes.
    [event] do_set_text_cursor(cursor: &TextCursorType),
    ///     \internal
    zoom_in_f(range: f32),
}

// vim: syntax=rust expandtab ts=4 sw=4
