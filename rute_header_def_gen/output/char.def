/// 
/// In Qt, Unicode characters are 16-bit entities without any markup
/// or structure. This class represents such an entity. It is
/// lightweight, so it can be used everywhere. Most compilers treat
/// it like an `unsigned short` .
/// 
/// QChar provides a full complement of testing/classification
/// functions, converting to and from other formats, converting from
/// composed to decomposed Unicode, and trying to compare and
/// case-convert if you ask it to.
/// 
/// The classification functions include functions like those in the
/// standard C++ header \<cctype\> (formerly \<ctype.h\>), but
/// operating on the full range of Unicode characters, not just for the ASCII
/// range. They all return true if the character is a certain type of character;
/// otherwise they return false. These classification functions are
/// isNull() (returns `true` if the character is '\\0'), isPrint()
/// (true if the character is any sort of printable character,
/// including whitespace), isPunct() (any sort of punctation),
/// isMark() (Unicode Mark), isLetter() (a letter), isNumber() (any
/// sort of numeric character, not just 0-9), isLetterOrNumber(), and
/// isDigit() (decimal digits). All of these are wrappers around
/// category() which return the Unicode-defined category of each
/// character. Some of these also calculate the derived properties
/// (for example isSpace() returns `true` if the character is of category
/// Separator_* or an exceptional code point from Other_Control category).
/// 
/// QChar also provides direction(), which indicates the
/// writing direction of this character. The joiningType() function
/// indicates how the character joins with it's neighbors (needed
/// mostly for Arabic or Syriac) and finally hasMirrored(), which indicates
/// whether the character needs to be mirrored when it is printed in
/// it's writing direction.
/// 
/// Composed Unicode characters (like *ring)* can be converted to
/// decomposed Unicode ("a" followed by ) by using decomposition().
/// 
/// In Unicode, comparison is not necessarily possible and case
/// conversion is very difficult at best. Unicode, covering the
/// world, also includes most of the world's case and
/// sorting problems. operator==() and friends will do comparison
/// based purely on the numeric Unicode value (code point) of the
/// characters, and toUpper() and toLower() will do case changes when
/// the character has a well-defined uppercase/lowercase equivalent.
/// For locale-dependent comparisons, use QString::localeAwareCompare().
/// 
/// The conversion functions include unicode() (to a scalar),
/// toLatin1() (to scalar, but converts all non-Latin-1 characters to
/// 0), row() (gives the Unicode row), cell() (gives the Unicode
/// cell), digitValue() (gives the integer value of any of the
/// numerous digit characters), and a host of constructors.
/// 
/// QChar provides constructors and cast operators that make it easy
/// to convert to and from traditional 8-bit `char` s. If you
/// defined `QT_NO_CAST_FROM_ASCII` and `QT_NO_CAST_TO_ASCII,` as
/// explained in the QString documentation, you will need to
/// explicitly call fromLatin1(), or use QLatin1Char,
/// to construct a QChar from an 8-bit `char,` and you will need to
/// call toLatin1() to get the 8-bit value back.
/// 
/// For more information see
/// ["About the Unicode Character Database"](http://www.unicode.org/ucd/)
/// 
/// 
/// **See also:** Unicode
/// QString
/// QLatin1Char
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QChar)]
enum SpecialCharacter {
    Null,
    Tabulation,
    LineFeed,
    CarriageReturn,
    Space,
    Nbsp,
    SoftHyphen,
    ReplacementCharacter,
    ObjectReplacementCharacter,
    ByteOrderMark,
    ByteOrderSwapped,
    ParagraphSeparator,
    LineSeparator,
    LastValidCodePoint,
}

[org_name(QChar)]
enum Category {
    Mark_NonSpacing,
    Mark_SpacingCombining,
    Mark_Enclosing,
    Number_DecimalDigit,
    Number_Letter,
    Number_Other,
    Separator_Space,
    Separator_Line,
    Separator_Paragraph,
    Other_Control,
    Other_Format,
    Other_Surrogate,
    Other_PrivateUse,
    Other_NotAssigned,
    Letter_Uppercase,
    Letter_Lowercase,
    Letter_Titlecase,
    Letter_Modifier,
    Letter_Other,
    Punctuation_Connector,
    Punctuation_Dash,
    Punctuation_Open,
    Punctuation_Close,
    Punctuation_InitialQuote,
    Punctuation_FinalQuote,
    Punctuation_Other,
    Symbol_Math,
    Symbol_Currency,
    Symbol_Modifier,
    Symbol_Other,
}

[org_name(QChar)]
enum Script {
    Script_Unknown,
    Script_Inherited,
    Script_Common,
    Script_Latin,
    Script_Greek,
    Script_Cyrillic,
    Script_Armenian,
    Script_Hebrew,
    Script_Arabic,
    Script_Syriac,
    Script_Thaana,
    Script_Devanagari,
    Script_Bengali,
    Script_Gurmukhi,
    Script_Gujarati,
    Script_Oriya,
    Script_Tamil,
    Script_Telugu,
    Script_Kannada,
    Script_Malayalam,
    Script_Sinhala,
    Script_Thai,
    Script_Lao,
    Script_Tibetan,
    Script_Myanmar,
    Script_Georgian,
    Script_Hangul,
    Script_Ethiopic,
    Script_Cherokee,
    Script_CanadianAboriginal,
    Script_Ogham,
    Script_Runic,
    Script_Khmer,
    Script_Mongolian,
    Script_Hiragana,
    Script_Katakana,
    Script_Bopomofo,
    Script_Han,
    Script_Yi,
    Script_OldItalic,
    Script_Gothic,
    Script_Deseret,
    Script_Tagalog,
    Script_Hanunoo,
    Script_Buhid,
    Script_Tagbanwa,
    Script_Coptic,
    Script_Limbu,
    Script_TaiLe,
    Script_LinearB,
    Script_Ugaritic,
    Script_Shavian,
    Script_Osmanya,
    Script_Cypriot,
    Script_Braille,
    Script_Buginese,
    Script_NewTaiLue,
    Script_Glagolitic,
    Script_Tifinagh,
    Script_SylotiNagri,
    Script_OldPersian,
    Script_Kharoshthi,
    Script_Balinese,
    Script_Cuneiform,
    Script_Phoenician,
    Script_PhagsPa,
    Script_Nko,
    Script_Sundanese,
    Script_Lepcha,
    Script_OlChiki,
    Script_Vai,
    Script_Saurashtra,
    Script_KayahLi,
    Script_Rejang,
    Script_Lycian,
    Script_Carian,
    Script_Lydian,
    Script_Cham,
    Script_TaiTham,
    Script_TaiViet,
    Script_Avestan,
    Script_EgyptianHieroglyphs,
    Script_Samaritan,
    Script_Lisu,
    Script_Bamum,
    Script_Javanese,
    Script_MeeteiMayek,
    Script_ImperialAramaic,
    Script_OldSouthArabian,
    Script_InscriptionalParthian,
    Script_InscriptionalPahlavi,
    Script_OldTurkic,
    Script_Kaithi,
    Script_Batak,
    Script_Brahmi,
    Script_Mandaic,
    Script_Chakma,
    Script_MeroiticCursive,
    Script_MeroiticHieroglyphs,
    Script_Miao,
    Script_Sharada,
    Script_SoraSompeng,
    Script_Takri,
    Script_CaucasianAlbanian,
    Script_BassaVah,
    Script_Duployan,
    Script_Elbasan,
    Script_Grantha,
    Script_PahawhHmong,
    Script_Khojki,
    Script_LinearA,
    Script_Mahajani,
    Script_Manichaean,
    Script_MendeKikakui,
    Script_Modi,
    Script_Mro,
    Script_OldNorthArabian,
    Script_Nabataean,
    Script_Palmyrene,
    Script_PauCinHau,
    Script_OldPermic,
    Script_PsalterPahlavi,
    Script_Siddham,
    Script_Khudawadi,
    Script_Tirhuta,
    Script_WarangCiti,
    Script_Ahom,
    Script_AnatolianHieroglyphs,
    Script_Hatran,
    Script_Multani,
    Script_OldHungarian,
    Script_SignWriting,
    Script_Adlam,
    Script_Bhaiksuki,
    Script_Marchen,
    Script_Newa,
    Script_Osage,
    Script_Tangut,
    Script_MasaramGondi,
    Script_Nushu,
    Script_Soyombo,
    Script_ZanabazarSquare,
    ScriptCount,
}

[org_name(QChar)]
enum Direction {
    DirL,
    DirR,
    DirEN,
    DirES,
    DirET,
    DirAN,
    DirCS,
    DirB,
    DirS,
    DirWS,
    DirON,
    DirLRE,
    DirLRO,
    DirAL,
    DirRLE,
    DirRLO,
    DirPDF,
    DirNSM,
    DirBN,
    DirLRI,
    DirRLI,
    DirFSI,
    DirPDI,
}

[org_name(QChar)]
enum Decomposition {
    NoDecomposition,
    Canonical,
    Font,
    NoBreak,
    Initial,
    Medial,
    Final,
    Isolated,
    Circle,
    Super,
    Sub,
    Vertical,
    Wide,
    Narrow,
    Small,
    Square,
    Compat,
    Fraction,
}

[org_name(QChar)]
enum JoiningType {
    Joining_None,
    Joining_Causing,
    Joining_Dual,
    Joining_Right,
    Joining_Left,
    Joining_Transparent,
}

[org_name(QChar)]
enum Joining {
    OtherJoining,
    Dual,
    Right,
    Center,
}

[org_name(QChar)]
enum CombiningClass {
    Combining_BelowLeftAttached,
    Combining_BelowAttached,
    Combining_BelowRightAttached,
    Combining_LeftAttached,
    Combining_RightAttached,
    Combining_AboveLeftAttached,
    Combining_AboveAttached,
    Combining_AboveRightAttached,
    Combining_BelowLeft,
    Combining_Below,
    Combining_BelowRight,
    Combining_Left,
    Combining_Right,
    Combining_AboveLeft,
    Combining_Above,
    Combining_AboveRight,
    Combining_DoubleBelow,
    Combining_DoubleAbove,
    Combining_IotaSubscript,
}

[org_name(QChar)]
enum UnicodeVersion {
    Unicode_Unassigned,
    Unicode_1_1,
    Unicode_2_0,
    Unicode_2_1_2,
    Unicode_3_0,
    Unicode_3_1,
    Unicode_3_2,
    Unicode_4_0,
    Unicode_4_1,
    Unicode_5_0,
    Unicode_5_1,
    Unicode_5_2,
    Unicode_6_0,
    Unicode_6_1,
    Unicode_6_2,
    Unicode_6_3,
    Unicode_7_0,
    Unicode_8_0,
    Unicode_9_0,
    Unicode_10_0,
}


struct Char {
    /// 
    /// Returns the character's category.
    /// 
    /// **Overloads**  Returns the category of the UCS-4-encoded character specified by *ucs4.*
    category() -> Char::Category,
    /// 
    /// Returns the character's direction.
    /// 
    /// **Overloads**  Returns the direction of the UCS-4-encoded character specified by *ucs4.*
    direction() -> Char::Direction,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    joining_type() -> Char::JoiningType,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// Returns information about the joining properties of the character
    /// (needed for certain languages such as Arabic).
    /// 
    /// **Overloads**
    /// Returns information about the joining properties of the UCS-4-encoded
    /// character specified by *ucs4* (needed for certain languages such as Arabic).
    joining() -> Char::Joining,
    /// 
    /// Returns the combining class for the character as defined in the
    /// Unicode standard. This is mainly useful as a positioning hint for
    /// marks attached to a base character.
    /// 
    /// The Qt text rendering engine uses this information to correctly
    /// position non-spacing marks around a base character.
    /// 
    /// **Overloads**  Returns the combining class for the UCS-4-encoded character specified by
    /// *ucs4,* as defined in the Unicode standard.
    combining_class() -> unsigned,
    /// 
    /// Returns the mirrored character if this character is a mirrored
    /// character; otherwise returns the character itself.
    /// 
    /// **See also:** hasMirrored()
    /// 
    /// **Overloads**  Returns the mirrored character if the UCS-4-encoded character specified
    /// by *ucs4* is a mirrored character; otherwise returns the character itself.
    /// 
    /// **See also:** hasMirrored()
    mirrored_char() -> Char,
    /// 
    /// Returns `true` if the character should be reversed if the text
    /// direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (ch.mirroredChar() != ch).
    /// 
    /// **See also:** mirroredChar()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// should be reversed if the text direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (QChar::mirroredChar(ucs4) != ucs4).
    /// 
    /// **See also:** mirroredChar()
    has_mirrored() -> bool,
    /// 
    /// Decomposes a character into it's constituent parts. Returns an empty string
    /// if no decomposition exists.
    /// 
    /// **Overloads**  Decomposes the UCS-4-encoded character specified by *ucs4* into it's
    /// constituent parts. Returns an empty string if no decomposition exists.
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    decomposition() -> String,
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    decomposition_tag() -> Char::Decomposition,
    /// 
    /// Returns the numeric value of the digit, or -1 if the character is not a digit.
    /// 
    /// **Overloads**  Returns the numeric value of the digit specified by the UCS-4-encoded
    /// character, *ucs4,* or -1 if the character is not a digit.
    digit_value() -> i32,
    /// 
    /// Returns the lowercase equivalent if the character is uppercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the lowercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is uppercase or titlecase; otherwise returns
    /// the character itself.
    to_lower() -> Char,
    /// 
    /// Returns the uppercase equivalent if the character is lowercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the uppercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or titlecase; otherwise returns
    /// the character itself.
    to_upper() -> Char,
    /// 
    /// Returns the title case equivalent if the character is lowercase or uppercase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the title case equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or uppercase; otherwise returns
    /// the character itself.
    to_title_case() -> Char,
    /// 
    /// Returns the case folded equivalent of the character.
    /// For most Unicode characters this is the same as toLower().
    /// 
    /// **Overloads**  Returns the case folded equivalent of the UCS-4-encoded character specified
    /// by *ucs4.* For most Unicode characters this is the same as toLower().
    to_case_folded() -> Char,
    /// 
    /// Returns the Unicode script property value for this character.
    /// 
    /// **Overloads**
    /// Returns the Unicode script property value for the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    script() -> Char::Script,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    unicode_version() -> Char::UnicodeVersion,
    /// 
    /// Returns the Latin-1 character equivalent to the QChar, or 0. This
    /// is mainly useful for non-internationalized software.
    /// 
    /// **Note**: It is not possible to distinguish a non-Latin-1 character from a Latin-1 0
    /// (NUL) character. Prefer to use unicode(), which does not have this ambiguity.
    /// 
    /// **See also:** unicode()
    to_latin1() -> char,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    /// 
    /// Returns a reference to the numeric Unicode value of the QChar.
    /// 
    /// Returns the numeric Unicode value of the QChar.
    unicode() -> ushort,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    /// 
    /// Returns a reference to the numeric Unicode value of the QChar.
    /// 
    /// Returns the numeric Unicode value of the QChar.
    unicode_2() -> ushort?,
    /// 
    /// Converts the Latin-1 character *c* to its equivalent QChar. This
    /// is mainly useful for non-internationalized software.
    /// 
    /// An alternative is to use QLatin1Char.
    /// 
    /// **See also:** toLatin1()
    /// unicode()
    [static] from_latin1(c: char) -> Char,
    /// 
    /// Returns `true` if the character is the Unicode character 0x0000
    /// ('\\0'); otherwise returns `false.`
    is_null() -> bool,
    /// 
    /// Returns `true` if the character is a printable character; otherwise
    /// returns `false.` This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a printable character; otherwise returns `false.`
    /// This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    is_print() -> bool,
    /// 
    /// Returns `true` if the character is a separator character
    /// (Separator_* categories or certain code points from Other_Control category);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a separator character (Separator_* categories or certain code points
    /// from Other_Control category); otherwise returns `false.`
    is_space() -> bool,
    /// 
    /// Returns `true` if the character is a mark (Mark_* categories);
    /// otherwise returns `false.`
    /// 
    /// See QChar::Category for more information regarding marks.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a mark (Mark_* categories); otherwise returns `false.`
    is_mark() -> bool,
    /// 
    /// Returns `true` if the character is a punctuation mark (Punctuation_*
    /// categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a punctuation mark (Punctuation_* categories); otherwise returns `false.`
    is_punct() -> bool,
    /// 
    /// Returns `true` if the character is a symbol (Symbol_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a symbol (Symbol_* categories); otherwise returns `false.`
    is_symbol() -> bool,
    /// 
    /// Returns `true` if the character is a letter (Letter_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter (Letter_* categories); otherwise returns `false.`
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    is_letter() -> bool,
    /// 
    /// Returns `true` if the character is a number (Number_* categories,
    /// not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** isDigit()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a number (Number_* categories, not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** isDigit()
    is_number() -> bool,
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    is_letter_or_number() -> bool,
    /// 
    /// Returns `true` if the character is a decimal digit
    /// (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** isNumber()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a decimal digit (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** isNumber()
    is_digit() -> bool,
    /// 
    /// Returns `true` if the character is a lowercase letter, for example
    /// category() is Letter_Lowercase.
    /// 
    /// **See also:** isUpper()
    /// toLower()
    /// toUpper()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a lowercase letter, for example category() is Letter_Lowercase.
    /// 
    /// **See also:** isUpper()
    /// toLower()
    /// toUpper()
    is_lower() -> bool,
    /// 
    /// Returns `true` if the character is an uppercase letter, for example
    /// category() is Letter_Uppercase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is an uppercase letter, for example category() is Letter_Uppercase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    is_upper() -> bool,
    /// 
    /// Returns `true` if the character is a titlecase letter, for example
    /// category() is Letter_Titlecase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    /// toTitleCase()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a titlecase letter, for example category() is Letter_Titlecase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    /// toTitleCase()
    is_title_case() -> bool,
    /// 
    /// Returns `true` if the QChar is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    is_non_character() -> bool,
    /// 
    /// Returns `true` if the QChar is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    is_high_surrogate() -> bool,
    /// 
    /// Returns `true` if the QChar is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    is_low_surrogate() -> bool,
    /// 
    /// Returns `true` if the QChar contains a code point that is in either
    /// the high or the low part of the UTF-16 surrogate range
    /// (for example if its code point is in range [0xd800..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// contains a code point that is in either the high or the low part of the
    /// UTF-16 surrogate range (for example if its code point is in range [0xd800..0xdfff]);
    /// false otherwise.
    is_surrogate() -> bool,
    /// 
    /// Returns the cell (least significant byte) of the Unicode character.
    /// 
    /// **See also:** row()
    cell() -> uchar,
    /// 
    /// Returns the row (most significant byte) of the Unicode character.
    /// 
    /// **See also:** cell()
    row() -> uchar,
    set_cell(acell: uchar),
    set_row(arow: uchar),
    /// 
    /// Returns `true` if the QChar is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    [static] is_non_character_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the QChar is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    [static] is_high_surrogate_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the QChar is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    [static] is_low_surrogate_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the QChar contains a code point that is in either
    /// the high or the low part of the UTF-16 surrogate range
    /// (for example if its code point is in range [0xd800..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// contains a code point that is in either the high or the low part of the
    /// UTF-16 surrogate range (for example if its code point is in range [0xd800..0xdfff]);
    /// false otherwise.
    [static] is_surrogate_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// can be split into the high and low parts of a UTF16 surrogate
    /// (for example if its code point is greater than or equals to 0x10000);
    /// false otherwise.
    [static] requires_surrogates(ucs4: uint) -> bool,
    /// 
    /// Converts a UTF16 surrogate pair with the given *high* and *low* values
    /// to it's UCS-4-encoded code point.
    /// 
    /// **Overloads**
    /// Converts a UTF16 surrogate pair ( *high,* *low)* to it's UCS-4-encoded code point.
    [static] surrogate_to_ucs4(high: ushort, low: ushort) -> uint,
    /// 
    /// Converts a UTF16 surrogate pair with the given *high* and *low* values
    /// to it's UCS-4-encoded code point.
    /// 
    /// **Overloads**
    /// Converts a UTF16 surrogate pair ( *high,* *low)* to it's UCS-4-encoded code point.
    [static] surrogate_to_ucs4_2(high: CharType, low: CharType) -> uint,
    /// 
    /// Returns the high surrogate part of a UCS-4-encoded code point.
    /// The returned result is undefined if *ucs4* is smaller than 0x10000.
    [static] high_surrogate(ucs4: uint) -> ushort,
    /// 
    /// Returns the low surrogate part of a UCS-4-encoded code point.
    /// The returned result is undefined if *ucs4* is smaller than 0x10000.
    [static] low_surrogate(ucs4: uint) -> ushort,
    /// 
    /// Returns the character's category.
    /// 
    /// **Overloads**  Returns the category of the UCS-4-encoded character specified by *ucs4.*
    [static] category_2(ucs4: uint) -> Char::Category,
    /// 
    /// Returns the character's direction.
    /// 
    /// **Overloads**  Returns the direction of the UCS-4-encoded character specified by *ucs4.*
    [static] direction_2(ucs4: uint) -> Char::Direction,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    [static] joining_type_2(ucs4: uint) -> Char::JoiningType,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// Returns information about the joining properties of the character
    /// (needed for certain languages such as Arabic).
    /// 
    /// **Overloads**
    /// Returns information about the joining properties of the UCS-4-encoded
    /// character specified by *ucs4* (needed for certain languages such as Arabic).
    [static] joining_2(ucs4: uint) -> Char::Joining,
    /// 
    /// Returns the combining class for the character as defined in the
    /// Unicode standard. This is mainly useful as a positioning hint for
    /// marks attached to a base character.
    /// 
    /// The Qt text rendering engine uses this information to correctly
    /// position non-spacing marks around a base character.
    /// 
    /// **Overloads**  Returns the combining class for the UCS-4-encoded character specified by
    /// *ucs4,* as defined in the Unicode standard.
    [static] combining_class_2(ucs4: uint) -> unsigned,
    /// 
    /// Returns the mirrored character if this character is a mirrored
    /// character; otherwise returns the character itself.
    /// 
    /// **See also:** hasMirrored()
    /// 
    /// **Overloads**  Returns the mirrored character if the UCS-4-encoded character specified
    /// by *ucs4* is a mirrored character; otherwise returns the character itself.
    /// 
    /// **See also:** hasMirrored()
    [static] mirrored_char_2(ucs4: uint) -> uint,
    /// 
    /// Returns `true` if the character should be reversed if the text
    /// direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (ch.mirroredChar() != ch).
    /// 
    /// **See also:** mirroredChar()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// should be reversed if the text direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (QChar::mirroredChar(ucs4) != ucs4).
    /// 
    /// **See also:** mirroredChar()
    [static] has_mirrored_2(ucs4: uint) -> bool,
    /// 
    /// Decomposes a character into it's constituent parts. Returns an empty string
    /// if no decomposition exists.
    /// 
    /// **Overloads**  Decomposes the UCS-4-encoded character specified by *ucs4* into it's
    /// constituent parts. Returns an empty string if no decomposition exists.
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    [static] decomposition_2(ucs4: uint) -> String,
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    [static] decomposition_tag_2(ucs4: uint) -> Char::Decomposition,
    /// 
    /// Returns the numeric value of the digit, or -1 if the character is not a digit.
    /// 
    /// **Overloads**  Returns the numeric value of the digit specified by the UCS-4-encoded
    /// character, *ucs4,* or -1 if the character is not a digit.
    [static] digit_value_2(ucs4: uint) -> i32,
    /// 
    /// Returns the lowercase equivalent if the character is uppercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the lowercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is uppercase or titlecase; otherwise returns
    /// the character itself.
    [static] to_lower_2(ucs4: uint) -> uint,
    /// 
    /// Returns the uppercase equivalent if the character is lowercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the uppercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or titlecase; otherwise returns
    /// the character itself.
    [static] to_upper_2(ucs4: uint) -> uint,
    /// 
    /// Returns the title case equivalent if the character is lowercase or uppercase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the title case equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or uppercase; otherwise returns
    /// the character itself.
    [static] to_title_case_2(ucs4: uint) -> uint,
    /// 
    /// Returns the case folded equivalent of the character.
    /// For most Unicode characters this is the same as toLower().
    /// 
    /// **Overloads**  Returns the case folded equivalent of the UCS-4-encoded character specified
    /// by *ucs4.* For most Unicode characters this is the same as toLower().
    [static] to_case_folded_2(ucs4: uint) -> uint,
    /// 
    /// Returns the Unicode script property value for this character.
    /// 
    /// **Overloads**
    /// Returns the Unicode script property value for the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    [static] script_2(ucs4: uint) -> Char::Script,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    [static] unicode_version_2(ucs4: uint) -> Char::UnicodeVersion,
    /// 
    /// Returns the most recent supported Unicode version.
    [static] current_unicode_version() -> Char::UnicodeVersion,
    /// 
    /// Returns `true` if the character is a printable character; otherwise
    /// returns `false.` This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a printable character; otherwise returns `false.`
    /// This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    [static] is_print_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a separator character
    /// (Separator_* categories or certain code points from Other_Control category);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a separator character (Separator_* categories or certain code points
    /// from Other_Control category); otherwise returns `false.`
    [static] is_space_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a mark (Mark_* categories);
    /// otherwise returns `false.`
    /// 
    /// See QChar::Category for more information regarding marks.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a mark (Mark_* categories); otherwise returns `false.`
    [static] is_mark_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a punctuation mark (Punctuation_*
    /// categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a punctuation mark (Punctuation_* categories); otherwise returns `false.`
    [static] is_punct_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a symbol (Symbol_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a symbol (Symbol_* categories); otherwise returns `false.`
    [static] is_symbol_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a letter (Letter_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter (Letter_* categories); otherwise returns `false.`
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    [static] is_letter_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a number (Number_* categories,
    /// not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** isDigit()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a number (Number_* categories, not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** isDigit()
    [static] is_number_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    [static] is_letter_or_number_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a decimal digit
    /// (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** isNumber()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a decimal digit (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** isNumber()
    [static] is_digit_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a lowercase letter, for example
    /// category() is Letter_Lowercase.
    /// 
    /// **See also:** isUpper()
    /// toLower()
    /// toUpper()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a lowercase letter, for example category() is Letter_Lowercase.
    /// 
    /// **See also:** isUpper()
    /// toLower()
    /// toUpper()
    [static] is_lower_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is an uppercase letter, for example
    /// category() is Letter_Uppercase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is an uppercase letter, for example category() is Letter_Uppercase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    [static] is_upper_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a titlecase letter, for example
    /// category() is Letter_Titlecase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    /// toTitleCase()
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a titlecase letter, for example category() is Letter_Titlecase.
    /// 
    /// **See also:** isLower()
    /// toUpper()
    /// toLower()
    /// toTitleCase()
    [static] is_title_case_2(ucs4: uint) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
