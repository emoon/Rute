/// 
/// In Qt, Unicode characters are 16-bit entities without any markup
/// or structure. This class represents such an entity. It is
/// lightweight, so it can be used everywhere. Most compilers treat
/// it like an `unsigned short` .
/// 
/// QChar provides a full complement of testing/classification
/// functions, converting to and from other formats, converting from
/// composed to decomposed Unicode, and trying to compare and
/// case-convert if you ask it to.
/// 
/// The classification functions include functions like those in the
/// standard C++ header \<cctype\> (formerly \<ctype.h\>), but
/// operating on the full range of Unicode characters, not just for the ASCII
/// range. They all return true if the character is a certain type of character;
/// otherwise they return false. These classification functions are
/// isNull() (returns `true` if the character is '\\0'), isPrint()
/// (true if the character is any sort of printable character,
/// including whitespace), isPunct() (any sort of punctation),
/// isMark() (Unicode Mark), isLetter() (a letter), isNumber() (any
/// sort of numeric character, not just 0-9), isLetterOrNumber(), and
/// isDigit() (decimal digits). All of these are wrappers around
/// category() which return the Unicode-defined category of each
/// character. Some of these also calculate the derived properties
/// (for example isSpace() returns `true` if the character is of category
/// Separator_* or an exceptional code point from Other_Control category).
/// 
/// QChar also provides direction(), which indicates the
/// writing direction of this character. The joiningType() function
/// indicates how the character joins with it's neighbors (needed
/// mostly for Arabic or Syriac) and finally hasMirrored(), which indicates
/// whether the character needs to be mirrored when it is printed in
/// it's writing direction.
/// 
/// Composed Unicode characters (like *ring)* can be converted to
/// decomposed Unicode ("a" followed by ) by using decomposition().
/// 
/// In Unicode, comparison is not necessarily possible and case
/// conversion is very difficult at best. Unicode, covering the
/// world, also includes most of the world's case and
/// sorting problems. operator==() and friends will do comparison
/// based purely on the numeric Unicode value (code point) of the
/// characters, and toUpper() and toLower() will do case changes when
/// the character has a well-defined uppercase/lowercase equivalent.
/// For locale-dependent comparisons, use QString::localeAwareCompare().
/// 
/// The conversion functions include unicode() (to a scalar),
/// toLatin1() (to scalar, but converts all non-Latin-1 characters to
/// 0), row() (gives the Unicode row), cell() (gives the Unicode
/// cell), digitValue() (gives the integer value of any of the
/// numerous digit characters), and a host of constructors.
/// 
/// QChar provides constructors and cast operators that make it easy
/// to convert to and from traditional 8-bit `char` s. If you
/// defined `QT_NO_CAST_FROM_ASCII` and `QT_NO_CAST_TO_ASCII,` as
/// explained in the QString documentation, you will need to
/// explicitly call fromLatin1(), or use QLatin1Char,
/// to construct a QChar from an 8-bit `char,` and you will need to
/// call toLatin1() to get the 8-bit value back.
/// 
/// For more information see
/// ["About the Unicode Character Database"](http://www.unicode.org/ucd/)
/// 
/// 
/// **See also:** Unicode
/// [`String`]
/// [`Latin1Char`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct Char {
    /// 
    /// Returns the character's category.
    /// 
    /// **Overloads**  Returns the category of the UCS-4-encoded character specified by *ucs4.*
    category() -> Char::Category,
    /// 
    /// Returns the character's direction.
    /// 
    /// **Overloads**  Returns the direction of the UCS-4-encoded character specified by *ucs4.*
    direction() -> Char::Direction,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    joining_type() -> Char::JoiningType,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// Returns information about the joining properties of the character
    /// (needed for certain languages such as Arabic).
    /// 
    /// **Overloads**
    /// Returns information about the joining properties of the UCS-4-encoded
    /// character specified by *ucs4* (needed for certain languages such as Arabic).
    joining() -> Char::Joining,
    /// 
    /// Returns the combining class for the character as defined in the
    /// Unicode standard. This is mainly useful as a positioning hint for
    /// marks attached to a base character.
    /// 
    /// The Qt text rendering engine uses this information to correctly
    /// position non-spacing marks around a base character.
    /// 
    /// **Overloads**  Returns the combining class for the UCS-4-encoded character specified by
    /// *ucs4,* as defined in the Unicode standard.
    combining_class() -> unsigned,
    /// 
    /// Returns the mirrored character if this character is a mirrored
    /// character; otherwise returns the character itself.
    /// 
    /// **See also:** [`has_mirrored()`]
    /// 
    /// **Overloads**  Returns the mirrored character if the UCS-4-encoded character specified
    /// by *ucs4* is a mirrored character; otherwise returns the character itself.
    /// 
    /// **See also:** [`has_mirrored()`]
    mirrored_char() -> Char,
    /// 
    /// Returns `true` if the character should be reversed if the text
    /// direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (ch.mirroredChar() != ch).
    /// 
    /// **See also:** [`mirrored_char()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// should be reversed if the text direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (QChar::mirroredChar(ucs4) != ucs4).
    /// 
    /// **See also:** [`mirrored_char()`]
    has_mirrored() -> bool,
    /// 
    /// Decomposes a character into it's constituent parts. Returns an empty string
    /// if no decomposition exists.
    /// 
    /// **Overloads**  Decomposes the UCS-4-encoded character specified by *ucs4* into it's
    /// constituent parts. Returns an empty string if no decomposition exists.
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    decomposition() -> String,
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    decomposition_tag() -> Char::Decomposition,
    /// 
    /// Returns the numeric value of the digit, or -1 if the character is not a digit.
    /// 
    /// **Overloads**  Returns the numeric value of the digit specified by the UCS-4-encoded
    /// character, *ucs4,* or -1 if the character is not a digit.
    digit_value() -> i32,
    /// 
    /// Returns the lowercase equivalent if the character is uppercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the lowercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is uppercase or titlecase; otherwise returns
    /// the character itself.
    to_lower() -> Char,
    /// 
    /// Returns the uppercase equivalent if the character is lowercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the uppercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or titlecase; otherwise returns
    /// the character itself.
    to_upper() -> Char,
    /// 
    /// Returns the title case equivalent if the character is lowercase or uppercase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the title case equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or uppercase; otherwise returns
    /// the character itself.
    to_title_case() -> Char,
    /// 
    /// Returns the case folded equivalent of the character.
    /// For most Unicode characters this is the same as toLower().
    /// 
    /// **Overloads**  Returns the case folded equivalent of the UCS-4-encoded character specified
    /// by *ucs4.* For most Unicode characters this is the same as toLower().
    to_case_folded() -> Char,
    /// 
    /// Returns the Unicode script property value for this character.
    /// 
    /// **Overloads**
    /// Returns the Unicode script property value for the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    script() -> Char::Script,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    unicode_version() -> Char::UnicodeVersion,
    /// 
    /// Returns the Latin-1 character equivalent to the QChar, or 0. This
    /// is mainly useful for non-internationalized software.
    /// 
    /// **Note**: It is not possible to distinguish a non-Latin-1 character from a Latin-1 0
    /// (NUL) character. Prefer to use unicode(), which does not have this ambiguity.
    /// 
    /// **See also:** [`unicode()`]
    to_latin1() -> char,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    /// 
    /// Returns a reference to the numeric Unicode value of the QChar.
    /// 
    /// Returns the numeric Unicode value of the QChar.
    unicode() -> ushort,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    /// 
    /// Returns a reference to the numeric Unicode value of the QChar.
    /// 
    /// Returns the numeric Unicode value of the QChar.
    [org_name(unicode)]
    unicode_2() -> ushort?,
    /// 
    /// Converts the Latin-1 character *c* to its equivalent QChar. This
    /// is mainly useful for non-internationalized software.
    /// 
    /// An alternative is to use QLatin1Char.
    /// 
    /// **See also:** [`to_latin1()`]
    /// [`unicode()`]
    [static] from_latin1(c: char) -> Char,
    /// 
    /// Returns `true` if the character is the Unicode character 0x0000
    /// ('\\0'); otherwise returns `false.`
    is_null() -> bool,
    /// 
    /// Returns `true` if the character is a printable character; otherwise
    /// returns `false.` This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a printable character; otherwise returns `false.`
    /// This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    is_print() -> bool,
    /// 
    /// Returns `true` if the character is a separator character
    /// (Separator_* categories or certain code points from Other_Control category);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a separator character (Separator_* categories or certain code points
    /// from Other_Control category); otherwise returns `false.`
    is_space() -> bool,
    /// 
    /// Returns `true` if the character is a mark (Mark_* categories);
    /// otherwise returns `false.`
    /// 
    /// See QChar::Category for more information regarding marks.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a mark (Mark_* categories); otherwise returns `false.`
    is_mark() -> bool,
    /// 
    /// Returns `true` if the character is a punctuation mark (Punctuation_*
    /// categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a punctuation mark (Punctuation_* categories); otherwise returns `false.`
    is_punct() -> bool,
    /// 
    /// Returns `true` if the character is a symbol (Symbol_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a symbol (Symbol_* categories); otherwise returns `false.`
    is_symbol() -> bool,
    /// 
    /// Returns `true` if the character is a letter (Letter_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter (Letter_* categories); otherwise returns `false.`
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    is_letter() -> bool,
    /// 
    /// Returns `true` if the character is a number (Number_* categories,
    /// not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** [`is_digit()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a number (Number_* categories, not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** [`is_digit()`]
    is_number() -> bool,
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    is_letter_or_number() -> bool,
    /// 
    /// Returns `true` if the character is a decimal digit
    /// (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** [`is_number()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a decimal digit (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** [`is_number()`]
    is_digit() -> bool,
    /// 
    /// Returns `true` if the character is a lowercase letter, for example
    /// category() is Letter_Lowercase.
    /// 
    /// **See also:** [`is_upper()`]
    /// [`to_lower()`]
    /// [`to_upper()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a lowercase letter, for example category() is Letter_Lowercase.
    /// 
    /// **See also:** [`is_upper()`]
    /// [`to_lower()`]
    /// [`to_upper()`]
    is_lower() -> bool,
    /// 
    /// Returns `true` if the character is an uppercase letter, for example
    /// category() is Letter_Uppercase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is an uppercase letter, for example category() is Letter_Uppercase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    is_upper() -> bool,
    /// 
    /// Returns `true` if the character is a titlecase letter, for example
    /// category() is Letter_Titlecase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    /// [`to_title_case()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a titlecase letter, for example category() is Letter_Titlecase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    /// [`to_title_case()`]
    is_title_case() -> bool,
    /// 
    /// Returns `true` if the QChar is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    is_non_character() -> bool,
    /// 
    /// Returns `true` if the QChar is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    is_high_surrogate() -> bool,
    /// 
    /// Returns `true` if the QChar is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    is_low_surrogate() -> bool,
    /// 
    /// Returns `true` if the QChar contains a code point that is in either
    /// the high or the low part of the UTF-16 surrogate range
    /// (for example if its code point is in range [0xd800..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// contains a code point that is in either the high or the low part of the
    /// UTF-16 surrogate range (for example if its code point is in range [0xd800..0xdfff]);
    /// false otherwise.
    is_surrogate() -> bool,
    /// 
    /// Returns the cell (least significant byte) of the Unicode character.
    /// 
    /// **See also:** [`row()`]
    cell() -> uchar,
    /// 
    /// Returns the row (most significant byte) of the Unicode character.
    /// 
    /// **See also:** [`cell()`]
    row() -> uchar,
    set_cell(acell: uchar),
    set_row(arow: uchar),
    /// 
    /// Returns `true` if the QChar is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a non-character; false otherwise.
    /// 
    /// Unicode has a certain number of code points that are classified
    /// as that is, they can be used for internal purposes
    /// in applications but cannot be used for text interchange.
    /// Those are the last two entries each Unicode Plane ([0xfffe..0xffff],
    /// [0x1fffe..0x1ffff], etc.) as well as the entries in range [0xfdd0..0xfdef].
    [org_name(isNonCharacter)]
    [static] is_non_character_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the QChar is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the high part of a UTF16 surrogate
    /// (for example if its code point is in range [0xd800..0xdbff]); false otherwise.
    [org_name(isHighSurrogate)]
    [static] is_high_surrogate_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the QChar is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is the low part of a UTF16 surrogate
    /// (for example if its code point is in range [0xdc00..0xdfff]); false otherwise.
    [org_name(isLowSurrogate)]
    [static] is_low_surrogate_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the QChar contains a code point that is in either
    /// the high or the low part of the UTF-16 surrogate range
    /// (for example if its code point is in range [0xd800..0xdfff]); false otherwise.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// contains a code point that is in either the high or the low part of the
    /// UTF-16 surrogate range (for example if its code point is in range [0xd800..0xdfff]);
    /// false otherwise.
    [org_name(isSurrogate)]
    [static] is_surrogate_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// can be split into the high and low parts of a UTF16 surrogate
    /// (for example if its code point is greater than or equals to 0x10000);
    /// false otherwise.
    [static] requires_surrogates(ucs4: uint) -> bool,
    /// 
    /// Converts a UTF16 surrogate pair with the given *high* and *low* values
    /// to it's UCS-4-encoded code point.
    /// 
    /// **Overloads**
    /// Converts a UTF16 surrogate pair ( *high,* *low)* to it's UCS-4-encoded code point.
    [static] surrogate_to_ucs4(high: ushort, low: ushort) -> uint,
    /// 
    /// Converts a UTF16 surrogate pair with the given *high* and *low* values
    /// to it's UCS-4-encoded code point.
    /// 
    /// **Overloads**
    /// Converts a UTF16 surrogate pair ( *high,* *low)* to it's UCS-4-encoded code point.
    [org_name(surrogateToUcs4)]
    [static] surrogate_to_ucs4_2(high: CharType, low: CharType) -> uint,
    /// 
    /// Returns the high surrogate part of a UCS-4-encoded code point.
    /// The returned result is undefined if *ucs4* is smaller than 0x10000.
    [static] high_surrogate(ucs4: uint) -> ushort,
    /// 
    /// Returns the low surrogate part of a UCS-4-encoded code point.
    /// The returned result is undefined if *ucs4* is smaller than 0x10000.
    [static] low_surrogate(ucs4: uint) -> ushort,
    /// 
    /// Returns the character's category.
    /// 
    /// **Overloads**  Returns the category of the UCS-4-encoded character specified by *ucs4.*
    [org_name(category)]
    [static] category_2(ucs4: uint) -> Char::Category,
    /// 
    /// Returns the character's direction.
    /// 
    /// **Overloads**  Returns the direction of the UCS-4-encoded character specified by *ucs4.*
    [org_name(direction)]
    [static] direction_2(ucs4: uint) -> Char::Direction,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    [org_name(joiningType)]
    [static] joining_type_2(ucs4: uint) -> Char::JoiningType,
    /// 
    /// Returns information about the joining type attributes of the character
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// **Overloads**
    /// Returns information about the joining type attributes of the UCS-4-encoded
    /// character specified by *ucs4*
    /// (needed for certain languages such as Arabic or Syriac).
    /// 
    /// Returns information about the joining properties of the character
    /// (needed for certain languages such as Arabic).
    /// 
    /// **Overloads**
    /// Returns information about the joining properties of the UCS-4-encoded
    /// character specified by *ucs4* (needed for certain languages such as Arabic).
    [org_name(joining)]
    [static] joining_2(ucs4: uint) -> Char::Joining,
    /// 
    /// Returns the combining class for the character as defined in the
    /// Unicode standard. This is mainly useful as a positioning hint for
    /// marks attached to a base character.
    /// 
    /// The Qt text rendering engine uses this information to correctly
    /// position non-spacing marks around a base character.
    /// 
    /// **Overloads**  Returns the combining class for the UCS-4-encoded character specified by
    /// *ucs4,* as defined in the Unicode standard.
    [org_name(combiningClass)]
    [static] combining_class_2(ucs4: uint) -> unsigned,
    /// 
    /// Returns the mirrored character if this character is a mirrored
    /// character; otherwise returns the character itself.
    /// 
    /// **See also:** [`has_mirrored()`]
    /// 
    /// **Overloads**  Returns the mirrored character if the UCS-4-encoded character specified
    /// by *ucs4* is a mirrored character; otherwise returns the character itself.
    /// 
    /// **See also:** [`has_mirrored()`]
    [org_name(mirroredChar)]
    [static] mirrored_char_2(ucs4: uint) -> uint,
    /// 
    /// Returns `true` if the character should be reversed if the text
    /// direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (ch.mirroredChar() != ch).
    /// 
    /// **See also:** [`mirrored_char()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// should be reversed if the text direction is reversed; otherwise returns `false.`
    /// 
    /// A bit faster equivalent of (QChar::mirroredChar(ucs4) != ucs4).
    /// 
    /// **See also:** [`mirrored_char()`]
    [org_name(hasMirrored)]
    [static] has_mirrored_2(ucs4: uint) -> bool,
    /// 
    /// Decomposes a character into it's constituent parts. Returns an empty string
    /// if no decomposition exists.
    /// 
    /// **Overloads**  Decomposes the UCS-4-encoded character specified by *ucs4* into it's
    /// constituent parts. Returns an empty string if no decomposition exists.
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    [org_name(decomposition)]
    [static] decomposition_2(ucs4: uint) -> String,
    /// 
    /// Returns the tag defining the composition of the character. Returns
    /// QChar::NoDecomposition if no decomposition exists.
    /// 
    /// **Overloads**  Returns the tag defining the composition of the UCS-4-encoded character
    /// specified by *ucs4.* Returns QChar::NoDecomposition if no decomposition exists.
    [org_name(decompositionTag)]
    [static] decomposition_tag_2(ucs4: uint) -> Char::Decomposition,
    /// 
    /// Returns the numeric value of the digit, or -1 if the character is not a digit.
    /// 
    /// **Overloads**  Returns the numeric value of the digit specified by the UCS-4-encoded
    /// character, *ucs4,* or -1 if the character is not a digit.
    [org_name(digitValue)]
    [static] digit_value_2(ucs4: uint) -> i32,
    /// 
    /// Returns the lowercase equivalent if the character is uppercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the lowercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is uppercase or titlecase; otherwise returns
    /// the character itself.
    [org_name(toLower)]
    [static] to_lower_2(ucs4: uint) -> uint,
    /// 
    /// Returns the uppercase equivalent if the character is lowercase or titlecase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the uppercase equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or titlecase; otherwise returns
    /// the character itself.
    [org_name(toUpper)]
    [static] to_upper_2(ucs4: uint) -> uint,
    /// 
    /// Returns the title case equivalent if the character is lowercase or uppercase;
    /// otherwise returns the character itself.
    /// 
    /// **Overloads**  Returns the title case equivalent of the UCS-4-encoded character specified
    /// by *ucs4* if the character is lowercase or uppercase; otherwise returns
    /// the character itself.
    [org_name(toTitleCase)]
    [static] to_title_case_2(ucs4: uint) -> uint,
    /// 
    /// Returns the case folded equivalent of the character.
    /// For most Unicode characters this is the same as toLower().
    /// 
    /// **Overloads**  Returns the case folded equivalent of the UCS-4-encoded character specified
    /// by *ucs4.* For most Unicode characters this is the same as toLower().
    [org_name(toCaseFolded)]
    [static] to_case_folded_2(ucs4: uint) -> uint,
    /// 
    /// Returns the Unicode script property value for this character.
    /// 
    /// **Overloads**
    /// Returns the Unicode script property value for the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    [org_name(script)]
    [static] script_2(ucs4: uint) -> Char::Script,
    /// 
    /// Returns the Unicode version that introduced this character.
    /// 
    /// **Overloads**  Returns the Unicode version that introduced the character specified in
    /// its UCS-4-encoded form as *ucs4.*
    [org_name(unicodeVersion)]
    [static] unicode_version_2(ucs4: uint) -> Char::UnicodeVersion,
    /// 
    /// Returns the most recent supported Unicode version.
    [static] current_unicode_version() -> Char::UnicodeVersion,
    /// 
    /// Returns `true` if the character is a printable character; otherwise
    /// returns `false.` This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a printable character; otherwise returns `false.`
    /// This is any character not of category Other_*.
    /// 
    /// Note that this gives no indication of whether the character is
    /// available in a particular font.
    [org_name(isPrint)]
    [static] is_print_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a separator character
    /// (Separator_* categories or certain code points from Other_Control category);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a separator character (Separator_* categories or certain code points
    /// from Other_Control category); otherwise returns `false.`
    [org_name(isSpace)]
    [static] is_space_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a mark (Mark_* categories);
    /// otherwise returns `false.`
    /// 
    /// See QChar::Category for more information regarding marks.
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a mark (Mark_* categories); otherwise returns `false.`
    [org_name(isMark)]
    [static] is_mark_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a punctuation mark (Punctuation_*
    /// categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a punctuation mark (Punctuation_* categories); otherwise returns `false.`
    [org_name(isPunct)]
    [static] is_punct_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a symbol (Symbol_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a symbol (Symbol_* categories); otherwise returns `false.`
    [org_name(isSymbol)]
    [static] is_symbol_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a letter (Letter_* categories);
    /// otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter (Letter_* categories); otherwise returns `false.`
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    [org_name(isLetter)]
    [static] is_letter_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a number (Number_* categories,
    /// not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** [`is_digit()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a number (Number_* categories, not just 0-9); otherwise returns `false.`
    /// 
    /// **See also:** [`is_digit()`]
    [org_name(isNumber)]
    [static] is_number_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a letter or number (Letter_* or
    /// Number_* categories); otherwise returns `false.`
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a letter or number (Letter_* or Number_* categories); otherwise returns `false.`
    [org_name(isLetterOrNumber)]
    [static] is_letter_or_number_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a decimal digit
    /// (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** [`is_number()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4* is
    /// a decimal digit (Number_DecimalDigit); otherwise returns `false.`
    /// 
    /// **See also:** [`is_number()`]
    [org_name(isDigit)]
    [static] is_digit_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a lowercase letter, for example
    /// category() is Letter_Lowercase.
    /// 
    /// **See also:** [`is_upper()`]
    /// [`to_lower()`]
    /// [`to_upper()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a lowercase letter, for example category() is Letter_Lowercase.
    /// 
    /// **See also:** [`is_upper()`]
    /// [`to_lower()`]
    /// [`to_upper()`]
    [org_name(isLower)]
    [static] is_lower_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is an uppercase letter, for example
    /// category() is Letter_Uppercase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is an uppercase letter, for example category() is Letter_Uppercase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    [org_name(isUpper)]
    [static] is_upper_2(ucs4: uint) -> bool,
    /// 
    /// Returns `true` if the character is a titlecase letter, for example
    /// category() is Letter_Titlecase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    /// [`to_title_case()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the UCS-4-encoded character specified by *ucs4*
    /// is a titlecase letter, for example category() is Letter_Titlecase.
    /// 
    /// **See also:** [`is_lower()`]
    /// [`to_upper()`]
    /// [`to_lower()`]
    /// [`to_title_case()`]
    [org_name(isTitleCase)]
    [static] is_title_case_2(ucs4: uint) -> bool,
}

[org_name(QChar)]
enum SpecialCharacter {
    /// A QChar with this value isNull().
    Null = 0,
    /// Character tabulation.
    Tabulation = 9,
    /// 
    LineFeed = 10,
    /// 
    CarriageReturn = 13,
    /// 
    Space = 32,
    /// Non-breaking space.
    Nbsp = 160,
    /// 
    SoftHyphen = 173,
    /// The character shown when a font has no glyph for a certain codepoint. A special question mark character is often used. Codecs use this codepoint when input data cannot be represented in Unicode.
    ReplacementCharacter = 65533,
    /// Used to represent an object such as an image when such objects cannot be presented.
    ObjectReplacementCharacter = 65532,
    /// 
    ByteOrderMark = 65279,
    /// 
    ByteOrderSwapped = 65534,
    /// 
    ParagraphSeparator = 8233,
    /// 
    LineSeparator = 8232,
    /// 
    LastValidCodePoint = 1114111,
}

[org_name(QChar)]
enum Category {
    /// Unicode class name Mn
    Mark_NonSpacing = 0,
    /// Unicode class name Mc
    Mark_SpacingCombining = 1,
    /// Unicode class name Me
    Mark_Enclosing = 2,
    /// Unicode class name Nd
    Number_DecimalDigit = 3,
    /// Unicode class name Nl
    Number_Letter = 4,
    /// Unicode class name No
    Number_Other = 5,
    /// Unicode class name Zs
    Separator_Space = 6,
    /// Unicode class name Zl
    Separator_Line = 7,
    /// Unicode class name Zp
    Separator_Paragraph = 8,
    /// Unicode class name Cc
    Other_Control = 9,
    /// Unicode class name Cf
    Other_Format = 10,
    /// Unicode class name Cs
    Other_Surrogate = 11,
    /// Unicode class name Co
    Other_PrivateUse = 12,
    /// Unicode class name Cn The following categories are informative in Unicode:
    Other_NotAssigned = 13,
    /// Unicode class name Lu
    Letter_Uppercase = 14,
    /// Unicode class name Ll
    Letter_Lowercase = 15,
    /// Unicode class name Lt
    Letter_Titlecase = 16,
    /// Unicode class name Lm
    Letter_Modifier = 17,
    /// Unicode class name Lo
    Letter_Other = 18,
    /// Unicode class name Pc
    Punctuation_Connector = 19,
    /// Unicode class name Pd
    Punctuation_Dash = 20,
    /// Unicode class name Ps
    Punctuation_Open = 21,
    /// Unicode class name Pe
    Punctuation_Close = 22,
    /// Unicode class name Pi
    Punctuation_InitialQuote = 23,
    /// Unicode class name Pf
    Punctuation_FinalQuote = 24,
    /// Unicode class name Po
    Punctuation_Other = 25,
    /// Unicode class name Sm
    Symbol_Math = 26,
    /// Unicode class name Sc
    Symbol_Currency = 27,
    /// Unicode class name Sk
    Symbol_Modifier = 28,
    /// Unicode class name So
    Symbol_Other = 29,
}

[org_name(QChar)]
enum Script {
    /// For unassigned, private-use, noncharacter, and surrogate code points.
    Script_Unknown = 0,
    /// For characters that may be used with multiple scripts and that inherit their script from the preceding characters. These include nonspacing marks, enclosing marks, and zero width joiner/non-joiner characters.
    Script_Inherited = 1,
    /// For characters that may be used with multiple scripts and that do not inherit their script from the preceding characters.
    Script_Common = 2,
    /// 
    Script_Latin = 3,
    /// 
    Script_Greek = 4,
    /// 
    Script_Cyrillic = 5,
    /// 
    Script_Armenian = 6,
    /// 
    Script_Hebrew = 7,
    /// 
    Script_Arabic = 8,
    /// 
    Script_Syriac = 9,
    /// 
    Script_Thaana = 10,
    /// 
    Script_Devanagari = 11,
    /// 
    Script_Bengali = 12,
    /// 
    Script_Gurmukhi = 13,
    /// 
    Script_Gujarati = 14,
    /// 
    Script_Oriya = 15,
    /// 
    Script_Tamil = 16,
    /// 
    Script_Telugu = 17,
    /// 
    Script_Kannada = 18,
    /// 
    Script_Malayalam = 19,
    /// 
    Script_Sinhala = 20,
    /// 
    Script_Thai = 21,
    /// 
    Script_Lao = 22,
    /// 
    Script_Tibetan = 23,
    /// 
    Script_Myanmar = 24,
    /// 
    Script_Georgian = 25,
    /// 
    Script_Hangul = 26,
    /// 
    Script_Ethiopic = 27,
    /// 
    Script_Cherokee = 28,
    /// 
    Script_CanadianAboriginal = 29,
    /// 
    Script_Ogham = 30,
    /// 
    Script_Runic = 31,
    /// 
    Script_Khmer = 32,
    /// 
    Script_Mongolian = 33,
    /// 
    Script_Hiragana = 34,
    /// 
    Script_Katakana = 35,
    /// 
    Script_Bopomofo = 36,
    /// 
    Script_Han = 37,
    /// 
    Script_Yi = 38,
    /// 
    Script_OldItalic = 39,
    /// 
    Script_Gothic = 40,
    /// 
    Script_Deseret = 41,
    /// 
    Script_Tagalog = 42,
    /// 
    Script_Hanunoo = 43,
    /// 
    Script_Buhid = 44,
    /// 
    Script_Tagbanwa = 45,
    /// 
    Script_Coptic = 46,
    /// 
    Script_Limbu = 47,
    /// 
    Script_TaiLe = 48,
    /// 
    Script_LinearB = 49,
    /// 
    Script_Ugaritic = 50,
    /// 
    Script_Shavian = 51,
    /// 
    Script_Osmanya = 52,
    /// 
    Script_Cypriot = 53,
    /// 
    Script_Braille = 54,
    /// 
    Script_Buginese = 55,
    /// 
    Script_NewTaiLue = 56,
    /// 
    Script_Glagolitic = 57,
    /// 
    Script_Tifinagh = 58,
    /// 
    Script_SylotiNagri = 59,
    /// 
    Script_OldPersian = 60,
    /// 
    Script_Kharoshthi = 61,
    /// 
    Script_Balinese = 62,
    /// 
    Script_Cuneiform = 63,
    /// 
    Script_Phoenician = 64,
    /// 
    Script_PhagsPa = 65,
    /// 
    Script_Nko = 66,
    /// 
    Script_Sundanese = 67,
    /// 
    Script_Lepcha = 68,
    /// 
    Script_OlChiki = 69,
    /// 
    Script_Vai = 70,
    /// 
    Script_Saurashtra = 71,
    /// 
    Script_KayahLi = 72,
    /// 
    Script_Rejang = 73,
    /// 
    Script_Lycian = 74,
    /// 
    Script_Carian = 75,
    /// 
    Script_Lydian = 76,
    /// 
    Script_Cham = 77,
    /// 
    Script_TaiTham = 78,
    /// 
    Script_TaiViet = 79,
    /// 
    Script_Avestan = 80,
    /// 
    Script_EgyptianHieroglyphs = 81,
    /// 
    Script_Samaritan = 82,
    /// 
    Script_Lisu = 83,
    /// 
    Script_Bamum = 84,
    /// 
    Script_Javanese = 85,
    /// 
    Script_MeeteiMayek = 86,
    /// 
    Script_ImperialAramaic = 87,
    /// 
    Script_OldSouthArabian = 88,
    /// 
    Script_InscriptionalParthian = 89,
    /// 
    Script_InscriptionalPahlavi = 90,
    /// 
    Script_OldTurkic = 91,
    /// 
    Script_Kaithi = 92,
    /// 
    Script_Batak = 93,
    /// 
    Script_Brahmi = 94,
    /// 
    Script_Mandaic = 95,
    /// 
    Script_Chakma = 96,
    /// 
    Script_MeroiticCursive = 97,
    /// 
    Script_MeroiticHieroglyphs = 98,
    /// 
    Script_Miao = 99,
    /// 
    Script_Sharada = 100,
    /// 
    Script_SoraSompeng = 101,
    /// 
    Script_Takri = 102,
    /// 
    Script_CaucasianAlbanian = 103,
    /// 
    Script_BassaVah = 104,
    /// 
    Script_Duployan = 105,
    /// 
    Script_Elbasan = 106,
    /// 
    Script_Grantha = 107,
    /// 
    Script_PahawhHmong = 108,
    /// 
    Script_Khojki = 109,
    /// 
    Script_LinearA = 110,
    /// 
    Script_Mahajani = 111,
    /// 
    Script_Manichaean = 112,
    /// 
    Script_MendeKikakui = 113,
    /// 
    Script_Modi = 114,
    /// 
    Script_Mro = 115,
    /// 
    Script_OldNorthArabian = 116,
    /// 
    Script_Nabataean = 117,
    /// 
    Script_Palmyrene = 118,
    /// 
    Script_PauCinHau = 119,
    /// 
    Script_OldPermic = 120,
    /// 
    Script_PsalterPahlavi = 121,
    /// 
    Script_Siddham = 122,
    /// 
    Script_Khudawadi = 123,
    /// 
    Script_Tirhuta = 124,
    /// 
    Script_WarangCiti = 125,
    /// 
    Script_Ahom = 126,
    /// 
    Script_AnatolianHieroglyphs = 127,
    /// 
    Script_Hatran = 128,
    /// 
    Script_Multani = 129,
    /// 
    Script_OldHungarian = 130,
    /// 
    Script_SignWriting = 131,
    /// 
    Script_Adlam = 132,
    /// 
    Script_Bhaiksuki = 133,
    /// 
    Script_Marchen = 134,
    /// 
    Script_Newa = 135,
    /// 
    Script_Osage = 136,
    /// 
    Script_Tangut = 137,
    /// 
    Script_MasaramGondi = 138,
    /// 
    Script_Nushu = 139,
    /// 
    Script_Soyombo = 140,
    /// 
    Script_ZanabazarSquare = 141,
    ScriptCount = 142,
}

[org_name(QChar)]
enum Direction {
    /// 
    DirL = 0,
    /// 
    DirR = 1,
    /// 
    DirEN = 2,
    /// 
    DirES = 3,
    /// 
    DirET = 4,
    /// 
    DirAN = 5,
    /// 
    DirCS = 6,
    /// 
    DirB = 7,
    /// 
    DirS = 8,
    /// 
    DirWS = 9,
    /// 
    DirON = 10,
    /// 
    DirLRE = 11,
    /// 
    DirLRO = 12,
    /// 
    DirAL = 13,
    /// 
    DirRLE = 14,
    /// 
    DirRLO = 15,
    /// 
    DirPDF = 16,
    /// 
    DirNSM = 17,
    /// 
    DirBN = 18,
    /// Since Qt 5.3
    DirLRI = 19,
    /// Since Qt 5.3
    DirRLI = 20,
    /// Since Qt 5.3
    DirFSI = 21,
    /// Since Qt 5.3
    DirPDI = 22,
}

[org_name(QChar)]
enum Decomposition {
    /// 
    NoDecomposition = 0,
    /// 
    Canonical = 1,
    /// 
    Font = 2,
    /// 
    NoBreak = 3,
    /// 
    Initial = 4,
    /// 
    Medial = 5,
    /// 
    Final = 6,
    /// 
    Isolated = 7,
    /// 
    Circle = 8,
    /// 
    Super = 9,
    /// 
    Sub = 10,
    /// 
    Vertical = 11,
    /// 
    Wide = 12,
    /// 
    Narrow = 13,
    /// 
    Small = 14,
    /// 
    Square = 15,
    /// 
    Compat = 16,
    /// 
    Fraction = 17,
}

[org_name(QChar)]
enum JoiningType {
    /// 
    Joining_None = 0,
    /// 
    Joining_Causing = 1,
    /// 
    Joining_Dual = 2,
    /// 
    Joining_Right = 3,
    /// 
    Joining_Left = 4,
    /// 
    Joining_Transparent = 5,
}

[org_name(QChar)]
enum Joining {
    /// 
    OtherJoining = 0,
    /// 
    Dual = 1,
    /// 
    Right = 2,
    /// 
    Center = 3,
}

[org_name(QChar)]
enum CombiningClass {
    /// 
    Combining_BelowLeftAttached = 200,
    /// 
    Combining_BelowAttached = 202,
    /// 
    Combining_BelowRightAttached = 204,
    /// 
    Combining_LeftAttached = 208,
    /// 
    Combining_RightAttached = 210,
    /// 
    Combining_AboveLeftAttached = 212,
    /// 
    Combining_AboveAttached = 214,
    /// 
    Combining_AboveRightAttached = 216,
    /// 
    Combining_BelowLeft = 218,
    /// 
    Combining_Below = 220,
    /// 
    Combining_BelowRight = 222,
    /// 
    Combining_Left = 224,
    /// 
    Combining_Right = 226,
    /// 
    Combining_AboveLeft = 228,
    /// 
    Combining_Above = 230,
    /// 
    Combining_AboveRight = 232,
    /// 
    Combining_DoubleBelow = 233,
    /// 
    Combining_DoubleAbove = 234,
    /// 
    Combining_IotaSubscript = 240,
}

[org_name(QChar)]
enum UnicodeVersion {
    /// The value is not assigned to any character in version 8.0 of Unicode.
    Unicode_Unassigned = 0,
    /// Version 1.1
    Unicode_1_1 = 1,
    /// Version 2.0
    Unicode_2_0 = 2,
    /// Version 2.1.2
    Unicode_2_1_2 = 3,
    /// Version 3.0
    Unicode_3_0 = 4,
    /// Version 3.1
    Unicode_3_1 = 5,
    /// Version 3.2
    Unicode_3_2 = 6,
    /// Version 4.0
    Unicode_4_0 = 7,
    /// Version 4.1
    Unicode_4_1 = 8,
    /// Version 5.0
    Unicode_5_0 = 9,
    /// Version 5.1
    Unicode_5_1 = 10,
    /// Version 5.2
    Unicode_5_2 = 11,
    /// Version 6.0
    Unicode_6_0 = 12,
    /// Version 6.1
    Unicode_6_1 = 13,
    /// Version 6.2
    Unicode_6_2 = 14,
    /// Version 6.3 Since Qt 5.3
    Unicode_6_3 = 15,
    /// Version 7.0 Since Qt 5.5
    Unicode_7_0 = 16,
    /// Version 8.0 Since Qt 5.6
    Unicode_8_0 = 17,
    /// Version 9.0 Since Qt 5.11
    Unicode_9_0 = 18,
    /// Version 10.0 Since Qt 5.11
    Unicode_10_0 = 19,
}

// vim: syntax=rust expandtab ts=4 sw=4
