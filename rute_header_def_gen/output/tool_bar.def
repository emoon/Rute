///     \class QToolBar
/// 
///     \brief The QToolBar class provides a movable panel that contains a
///     set of controls.
/// 
///     \ingroup mainwindow-classes
///     \inmodule QtWidgets
/// 
///     Toolbar buttons are added by adding \e actions, using addAction()
///     or insertAction(). Groups of buttons can be separated using
///     addSeparator() or insertSeparator(). If a toolbar button is not
///     appropriate, a widget can be inserted instead using addWidget() or
///     insertWidget(). Examples of suitable widgets are QSpinBox,
///     QDoubleSpinBox, and QComboBox. When a toolbar button is pressed, it
///     emits the actionTriggered() signal.
/// 
///     A toolbar can be fixed in place in a particular area (e.g., at the
///     top of the window), or it can be movable between toolbar areas;
///     see setMovable(), isMovable(), allowedAreas() and isAreaAllowed().
/// 
///     When a toolbar is resized in such a way that it is too small to
///     show all the items it contains, an extension button will appear as
///     the last item in the toolbar. Pressing the extension button will
///     pop up a menu containing the items that do not currently fit in
///     the toolbar.
/// 
///     When a QToolBar is not a child of a QMainWindow, it loses the ability
///     to populate the extension pop up with widgets added to the toolbar using
///     addWidget(). Please use widget actions created by inheriting QWidgetAction
///     and implementing QWidgetAction::createWidget() instead.
/// 
///     \sa QToolButton, QMenu, QAction, {Application Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct ToolBar : Widget {
    set_movable(movable: bool),
    is_movable() -> bool,
    ///     \property QToolBar::allowedAreas
    ///     \brief areas where the toolbar may be placed
    /// 
    ///     The default is Qt::AllToolBarAreas.
    /// 
    ///     This property only makes sense if the toolbar is in a
    ///     QMainWindow.
    /// 
    ///     \sa movable
    set_allowed_areas(areas: Rute::ToolBarAreas),
    allowed_areas() -> Rute::ToolBarAreas,
    is_area_allowed(area: Rute::ToolBarArea) -> bool,
    set_orientation(orientation: Rute::Orientation),
    orientation() -> Rute::Orientation,
    ///     Removes all actions from the toolbar.
    /// 
    ///     \sa removeAction()
    clear(),
    ///     \overload
    /// 
    ///     Creates a new action with the given \a icon and \a text. This
    ///     action is added to the end of the toolbar. The action's
    ///     \l{QAction::triggered()}{triggered()} signal is connected to \a
    ///     member in \a receiver.
    add_action(text: String) -> Action?,
    ///     \overload
    /// 
    ///     Creates a new action with the given \a icon and \a text. This
    ///     action is added to the end of the toolbar. The action's
    ///     \l{QAction::triggered()}{triggered()} signal is connected to \a
    ///     member in \a receiver.
    add_action(icon: &IconType, text: String) -> Action?,
    ///     \overload
    /// 
    ///     Creates a new action with the given \a icon and \a text. This
    ///     action is added to the end of the toolbar. The action's
    ///     \l{QAction::triggered()}{triggered()} signal is connected to \a
    ///     member in \a receiver.
    add_action(text: String, receiver: *ObjectType, member: *char) -> Action?,
    ///     \overload
    /// 
    ///     Creates a new action with the given \a icon and \a text. This
    ///     action is added to the end of the toolbar. The action's
    ///     \l{QAction::triggered()}{triggered()} signal is connected to \a
    ///     member in \a receiver.
    add_action(icon: &IconType, text: String, receiver: *ObjectType, member: *char) -> Action?,
    ///     Inserts a separator into the toolbar in front of the toolbar
    ///     item associated with the \a before action.
    /// 
    ///     \sa addSeparator()
    insert_separator(before: *ActionType) -> Action?,
    ///     Adds the given \a widget to the toolbar as the toolbar's last
    ///     item.
    /// 
    ///     The toolbar takes ownership of \a widget.
    /// 
    ///     If you add a QToolButton with this method, the toolbar's
    ///     Qt::ToolButtonStyle will not be respected.
    /// 
    ///     \note You should use QAction::setVisible() to change the
    ///     visibility of the widget. Using QWidget::setVisible(),
    ///     QWidget::show() and QWidget::hide() does not work.
    /// 
    ///     \sa insertWidget()
    add_widget(widget: *WidgetType) -> Action?,
    ///     Inserts the given \a widget in front of the toolbar item
    ///     associated with the \a before action.
    /// 
    ///     Note: You should use QAction::setVisible() to change the
    ///     visibility of the widget. Using QWidget::setVisible(),
    ///     QWidget::show() and QWidget::hide() does not work.
    /// 
    ///     \sa addWidget()
    insert_widget(before: *ActionType, widget: *WidgetType) -> Action?,
    ///     Returns the action at point \a p. This function returns zero if no
    ///     action was found.
    /// 
    ///     \sa QWidget::childAt()
    action_at(p: &PointType) -> Action?,
    ///     Returns the action at point \a p. This function returns zero if no
    ///     action was found.
    /// 
    ///     \sa QWidget::childAt()
    action_at(x: i32, y: i32) -> Action?,
    ///     Returns a checkable action that can be used to show or hide this
    ///     toolbar.
    /// 
    ///     The action's text is set to the toolbar's window title.
    /// 
    ///     \sa QAction::text, QWidget::windowTitle
    toggle_view_action() -> Action?,
    ///     \property QToolBar::iconSize
    ///     \brief size of icons in the toolbar.
    /// 
    ///     The default size is determined by the application's style and is
    ///     derived from the QStyle::PM_ToolBarIconSize pixel metric. It is
    ///     the maximum size an icon can have. Icons of smaller size will not
    ///     be scaled up.
    icon_size() -> Size,
    ///     \property QToolBar::toolButtonStyle
    ///     \brief the style of toolbar buttons
    /// 
    ///     This property defines the style of all tool buttons that are added
    ///     as \l{QAction}s. Note that if you add a QToolButton with the
    ///     addWidget() method, it will not get this button style.
    /// 
    ///     To have the style of toolbuttons follow the system settings, set this property to Qt::ToolButtonFollowStyle.
    ///     On Unix, the user settings from the desktop environment will be used.
    ///     On other platforms, Qt::ToolButtonFollowStyle means icon only.
    /// 
    ///     The default is Qt::ToolButtonIconOnly.
    tool_button_style() -> Rute::ToolButtonStyle,
    ///     \since 4.2
    /// 
    ///     Returns the widget associated with the specified \a action.
    /// 
    ///     \sa addWidget()
    widget_for_action(action: *ActionType) -> Widget?,
    ///     \property QToolBar::floatable
    ///     \brief whether the toolbar can be dragged and dropped as an independent window.
    /// 
    ///     The default is true.
    is_floatable() -> bool,
    set_floatable(floatable: bool),
    ///     \property QToolBar::floating
    ///     \brief whether the toolbar is an independent window.
    /// 
    ///     By default, this property is \c true.
    /// 
    ///     \sa QWidget::isWindow()
    is_floating() -> bool,
    set_icon_size(icon_size: &SizeType),
    set_tool_button_style(tool_button_style: Rute::ToolButtonStyle),
    [signal] action_triggered(action: *ActionType),
    [signal] movable_changed(movable: bool),
    [signal] allowed_areas_changed(allowed_areas: Rute::ToolBarAreas),
    [signal] orientation_changed(orientation: Rute::Orientation),
    [signal] icon_size_changed(icon_size: &SizeType),
    [signal] tool_button_style_changed(tool_button_style: Rute::ToolButtonStyle),
    [signal] top_level_changed(top_level: bool),
    [signal] visibility_changed(visible: bool),
    [event] action_event(event: *ActionEventType),
    [event] change_event(event: *EventType),
    [event] paint_event(event: *PaintEventType),
    [event] event(event: *EventType) -> bool,
    ///     \internal
    init_style_option(option: *StyleOptionToolBarType),
}

// vim: syntax=rust expandtab ts=4 sw=4
