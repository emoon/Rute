///     \class QToolBar
/// 
///     \brief The QToolBar class provides a movable panel that contains a
///     set of controls.
/// 
///     \ingroup mainwindow-classes
///     \inmodule QtWidgets
/// 
///     Toolbar buttons are added by adding \e actions, using addAction()
///     or insertAction(). Groups of buttons can be separated using
///     addSeparator() or insertSeparator(). If a toolbar button is not
///     appropriate, a widget can be inserted instead using addWidget() or
///     insertWidget(). Examples of suitable widgets are QSpinBox,
///     QDoubleSpinBox, and QComboBox. When a toolbar button is pressed, it
///     emits the actionTriggered() signal.
/// 
///     A toolbar can be fixed in place in a particular area (e.g., at the
///     top of the window), or it can be movable between toolbar areas;
///     see setMovable(), isMovable(), allowedAreas() and isAreaAllowed().
/// 
///     When a toolbar is resized in such a way that it is too small to
///     show all the items it contains, an extension button will appear as
///     the last item in the toolbar. Pressing the extension button will
///     pop up a menu containing the items that do not currently fit in
///     the toolbar.
/// 
///     When a QToolBar is not a child of a QMainWindow, it loses the ability
///     to populate the extension pop up with widgets added to the toolbar using
///     addWidget(). Please use widget actions created by inheriting QWidgetAction
///     and implementing QWidgetAction::createWidget() instead.
/// 
///     \sa QToolButton, QMenu, QAction, {Application Example}
struct ToolBar : Widget {
    set_movable(movable: bool),
    is_movable() -> bool,
    set_allowed_areas(areas: Rute::ToolBarAreas),
    allowed_areas() -> Rute::ToolBarAreas,
    is_area_allowed(area: Rute::ToolBarArea) -> bool,
    set_orientation(orientation: Rute::Orientation),
    orientation() -> Rute::Orientation,
    clear(),
    add_action(text: String) -> Action?,
    add_action(icon: &IconType, text: String) -> Action?,
    add_action(text: String, receiver: *ObjectType, member: *char) -> Action?,
    add_action(icon: &IconType, text: String, receiver: *ObjectType, member: *char) -> Action?,
    insert_separator(before: *ActionType) -> Action?,
    add_widget(widget: *WidgetType) -> Action?,
    insert_widget(before: *ActionType, widget: *WidgetType) -> Action?,
    action_at(p: &PointType) -> Action?,
    action_at(x: i32, y: i32) -> Action?,
    toggle_view_action() -> Action?,
    icon_size() -> Size,
    tool_button_style() -> Rute::ToolButtonStyle,
    widget_for_action(action: *ActionType) -> Widget?,
    is_floatable() -> bool,
    set_floatable(floatable: bool),
    is_floating() -> bool,
    set_icon_size(icon_size: &SizeType),
    set_tool_button_style(tool_button_style: Rute::ToolButtonStyle),
    [signal] action_triggered(action: *ActionType),
    [signal] movable_changed(movable: bool),
    [signal] allowed_areas_changed(allowed_areas: Rute::ToolBarAreas),
    [signal] orientation_changed(orientation: Rute::Orientation),
    [signal] icon_size_changed(icon_size: &SizeType),
    [signal] tool_button_style_changed(tool_button_style: Rute::ToolButtonStyle),
    [signal] top_level_changed(top_level: bool),
    [signal] visibility_changed(visible: bool),
    [event] action_event(event: *ActionEventType),
    [event] change_event(event: *EventType),
    [event] paint_event(event: *PaintEventType),
    [event] event(event: *EventType) -> bool,
    init_style_option(option: *StyleOptionToolBarType),
}

// vim: syntax=rust expandtab ts=4 sw=4
