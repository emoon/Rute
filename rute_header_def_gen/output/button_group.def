///     \class QButtonGroup
///     \brief The QButtonGroup class provides a container to organize groups of
///     button widgets.
/// 
///     \ingroup organizers
///     \ingroup geomanagement
///     \inmodule QtWidgets
/// 
///     QButtonGroup provides an abstract container into which button widgets can
///     be placed. It does not provide a visual representation of this container
///     (see QGroupBox for a container widget), but instead manages the states of
///     each of the buttons in the group.
/// 
///     An \l {QButtonGroup::exclusive} {exclusive} button group switches
///     off all checkable (toggle) buttons except the one that has been
///     clicked. By default, a button group is exclusive. The buttons in a
///     button group are usually checkable \l{QPushButton}s, \l{QCheckBox}es
///     (normally for non-exclusive button groups), or \l{QRadioButton}s.
///     If you create an exclusive button group, you should ensure that
///     one of the buttons in the group is initially checked; otherwise,
///     the group will initially be in a state where no buttons are
///     checked.
/// 
///     A button can be added to the group with addButton() and removed
///     with removeButton(). If the group is exclusive, the
///     currently checked button is available with checkedButton(). If a
///     button is clicked, the buttonClicked() signal is emitted; for a
///     checkable button in an exclusive group this means that the button
///     has been checked. The list of buttons in the group is returned by
///     buttons().
/// 
///     In addition, QButtonGroup can map between integers and buttons.
///     You can assign an integer id to a button with setId(), and
///     retrieve it with id(). The id of the currently checked button is
///     available with checkedId(), and there is an overloaded signal
///     buttonClicked() which emits the id of the button. The id \c {-1}
///     is reserved by QButtonGroup to mean "no such button". The purpose
///     of the mapping mechanism is to simplify the representation of enum
///     values in a user interface.
/// 
///     \sa QGroupBox, QPushButton, QCheckBox, QRadioButton
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct ButtonGroup : Object {
    set_exclusive(arg0: bool),
    ///     \property QButtonGroup::exclusive
    ///     \brief whether the button group is exclusive
    /// 
    ///     If this property is \c true, then only one button in the group can be checked
    ///     at any given time. The user can click on any button to check it, and that
    ///     button will replace the existing one as the checked button in the group.
    /// 
    ///     In an exclusive group, the user cannot uncheck the currently checked button
    ///     by clicking on it; instead, another button in the group must be clicked
    ///     to set the new checked button for that group.
    /// 
    ///     By default, this property is \c true.
    exclusive() -> bool,
    ///     Adds the given \a button to the button group. If \a id is -1,
    ///     an id will be assigned to the button.
    ///     Automatically assigned ids are guaranteed to be negative,
    ///     starting with -2. If you are assigning your own ids, use
    ///     positive values to avoid conflicts.
    /// 
    ///     \sa removeButton(), buttons()
    add_button(arg0: *AbstractButtonType, id: i32),
    ///     Removes the given \a button from the button group.
    /// 
    ///     \sa addButton(), buttons()
    remove_button(arg0: *AbstractButtonType),
    ///     Returns the button group's list of buttons. This may be empty.
    /// 
    ///     \sa addButton(), removeButton()
    buttons() -> [AbstractButton?],
    ///     Returns the button group's checked button, or 0 if no buttons are
    ///     checked.
    /// 
    ///     \sa buttonClicked()
    checked_button() -> AbstractButton?,
    ///     \since 4.1
    /// 
    ///     Returns the button with the specified \a id, or 0 if no such button
    ///     exists.
    button(id: i32) -> AbstractButton?,
    ///     \since 4.1
    /// 
    ///     Sets the \a id for the specified \a button. Note that \a id cannot
    ///     be -1.
    /// 
    ///     \sa id()
    set_id(button: *AbstractButtonType, id: i32),
    ///     \since 4.1
    /// 
    ///     Returns the id for the specified \a button, or -1 if no such button
    ///     exists.
    /// 
    /// 
    ///     \sa setId()
    id(button: *AbstractButtonType) -> i32,
    ///     \since 4.1
    /// 
    ///     Returns the id of the checkedButton(), or -1 if no button is checked.
    /// 
    ///     \sa setId()
    checked_id() -> i32,
    [signal] button_clicked(arg0: *AbstractButtonType),
    [signal] button_clicked(arg0: i32),
    [signal] button_pressed(arg0: *AbstractButtonType),
    [signal] button_pressed(arg0: i32),
    [signal] button_released(arg0: *AbstractButtonType),
    [signal] button_released(arg0: i32),
    [signal] button_toggled(arg0: *AbstractButtonType, arg1: bool),
    [signal] button_toggled(arg0: i32, arg1: bool),
}

// vim: syntax=rust expandtab ts=4 sw=4
