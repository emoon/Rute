///     \class QDial
/// 
///     \brief The QDial class provides a rounded range control (like a speedometer or potentiometer).
/// 
///     \ingroup basicwidgets
///     \inmodule QtWidgets
/// 
///     \image windows-dial.png
/// 
///     QDial is used when the user needs to control a value within a
///     program-definable range, and the range either wraps around
///     (for example, with angles measured from 0 to 359 degrees) or the
///     dialog layout needs a square widget.
/// 
///     Since QDial inherits from QAbstractSlider, the dial behaves in
///     a similar way to a \l{QSlider}{slider}. When wrapping() is false
///     (the default setting) there is no real difference between a slider
///     and a dial. They both share the same signals, slots and member
///     functions. Which one you use depends on the expectations of
///     your users and on the type of application.
/// 
///     The dial initially emits valueChanged() signals continuously while
///     the slider is being moved; you can make it emit the signal less
///     often by disabling the \l{QAbstractSlider::tracking} {tracking}
///     property. The sliderMoved() signal is emitted continuously even
///     when tracking is disabled.
/// 
///     The dial also emits sliderPressed() and sliderReleased() signals
///     when the mouse button is pressed and released. Note that the
///     dial's value can change without these signals being emitted since
///     the keyboard and wheel can also be used to change the value.
/// 
///     Unlike the slider, QDial attempts to draw a "nice" number of
///     notches rather than one per line step. If possible, the number of
///     notches drawn is one per line step, but if there aren't enough pixels
///     to draw every one, QDial will skip notches to try and draw a uniform
///     set (e.g. by drawing every second or third notch).
/// 
///     Like the slider, the dial makes the QAbstractSlider function setValue()
///     available as a slot.
/// 
///     The dial's keyboard interface is fairly simple: The
///     \uicontrol{left}/\uicontrol{up} and \uicontrol{right}/\uicontrol{down} arrow keys adjust
///     the dial's \l {QAbstractSlider::value} {value} by the defined
///     \l {QAbstractSlider::singleStep} {singleStep}, \uicontrol{Page Up} and
///     \uicontrol{Page Down} by the defined \l {QAbstractSlider::pageStep}
///     {pageStep}, and the \uicontrol Home and \uicontrol End keys set the value to
///     the defined \l {QAbstractSlider::minimum} {minimum} and
///     \l {QAbstractSlider::maximum} {maximum} values.
/// 
///     If you are using the mouse wheel to adjust the dial, the increment
///     value is determined by the lesser value of
///     \l{QApplication::wheelScrollLines()} {wheelScrollLines} multipled
///     by \l {QAbstractSlider::singleStep} {singleStep}, and
///     \l {QAbstractSlider::pageStep} {pageStep}.
/// 
///     \sa QScrollBar, QSpinBox, QSlider, {fowler}{GUI Design Handbook: Slider}, {Sliders Example}
struct Dial : AbstractSlider {
    wrapping() -> bool,
    notch_size() -> i32,
    set_notch_target(target: double),
    notch_target() -> f32,
    notches_visible() -> bool,
    [event] size_hint() -> Size,
    [event] minimum_size_hint() -> Size,
    set_notches_visible(visible: bool),
    set_wrapping(on: bool),
    [event] event(e: *EventType) -> bool,
    [event] resize_event(re: *ResizeEventType),
    [event] paint_event(pe: *PaintEventType),
    [event] mouse_press_event(me: *MouseEventType),
    [event] mouse_release_event(me: *MouseEventType),
    [event] mouse_move_event(me: *MouseEventType),
    [event] slider_change(change: AbstractSlider::SliderChange),
    init_style_option(option: *StyleOptionSliderType),
}

// vim: syntax=rust expandtab ts=4 sw=4
