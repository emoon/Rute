///     \class QDial
/// 
///     \brief The QDial class provides a rounded range control (like a speedometer or potentiometer).
/// 
///     \ingroup basicwidgets
///     \inmodule QtWidgets
/// 
///     \image windows-dial.png
/// 
///     QDial is used when the user needs to control a value within a
///     program-definable range, and the range either wraps around
///     (for example, with angles measured from 0 to 359 degrees) or the
///     dialog layout needs a square widget.
/// 
///     Since QDial inherits from QAbstractSlider, the dial behaves in
///     a similar way to a \l{QSlider}{slider}. When wrapping() is false
///     (the default setting) there is no real difference between a slider
///     and a dial. They both share the same signals, slots and member
///     functions. Which one you use depends on the expectations of
///     your users and on the type of application.
/// 
///     The dial initially emits valueChanged() signals continuously while
///     the slider is being moved; you can make it emit the signal less
///     often by disabling the \l{QAbstractSlider::tracking} {tracking}
///     property. The sliderMoved() signal is emitted continuously even
///     when tracking is disabled.
/// 
///     The dial also emits sliderPressed() and sliderReleased() signals
///     when the mouse button is pressed and released. Note that the
///     dial's value can change without these signals being emitted since
///     the keyboard and wheel can also be used to change the value.
/// 
///     Unlike the slider, QDial attempts to draw a "nice" number of
///     notches rather than one per line step. If possible, the number of
///     notches drawn is one per line step, but if there aren't enough pixels
///     to draw every one, QDial will skip notches to try and draw a uniform
///     set (e.g. by drawing every second or third notch).
/// 
///     Like the slider, the dial makes the QAbstractSlider function setValue()
///     available as a slot.
/// 
///     The dial's keyboard interface is fairly simple: The
///     \uicontrol{left}/\uicontrol{up} and \uicontrol{right}/\uicontrol{down} arrow keys adjust
///     the dial's \l {QAbstractSlider::value} {value} by the defined
///     \l {QAbstractSlider::singleStep} {singleStep}, \uicontrol{Page Up} and
///     \uicontrol{Page Down} by the defined \l {QAbstractSlider::pageStep}
///     {pageStep}, and the \uicontrol Home and \uicontrol End keys set the value to
///     the defined \l {QAbstractSlider::minimum} {minimum} and
///     \l {QAbstractSlider::maximum} {maximum} values.
/// 
///     If you are using the mouse wheel to adjust the dial, the increment
///     value is determined by the lesser value of
///     \l{QApplication::wheelScrollLines()} {wheelScrollLines} multipled
///     by \l {QAbstractSlider::singleStep} {singleStep}, and
///     \l {QAbstractSlider::pageStep} {pageStep}.
/// 
///     \sa QScrollBar, QSpinBox, QSlider, {fowler}{GUI Design Handbook: Slider}, {Sliders Example}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct Dial : AbstractSlider {
    ///     \property QDial::wrapping
    ///     \brief whether wrapping is enabled
    /// 
    ///     If true, wrapping is enabled; otherwise some space is inserted at the bottom
    ///     of the dial to separate the ends of the range of valid values.
    /// 
    ///     If enabled, the arrow can be oriented at any angle on the dial. If disabled,
    ///     the arrow will be restricted to the upper part of the dial; if it is rotated
    ///     into the space at the bottom of the dial, it will be clamped to the closest
    ///     end of the valid range of values.
    /// 
    ///     By default this property is \c false.
    wrapping() -> bool,
    ///     \property QDial::notchSize
    ///     \brief the current notch size
    /// 
    ///     The notch size is in range control units, not pixels, and if
    ///     possible it is a multiple of singleStep() that results in an
    ///     on-screen notch size near notchTarget().
    /// 
    ///     By default, this property has a value of 1.
    /// 
    ///     \sa notchTarget(), singleStep()
    notch_size() -> i32,
    set_notch_target(target: double),
    ///     \property QDial::notchTarget
    ///     \brief the target number of pixels between notches
    /// 
    ///     The notch target is the number of pixels QDial attempts to put
    ///     between each notch.
    /// 
    ///     The actual size may differ from the target size.
    /// 
    ///     The default notch target is 3.7 pixels.
    notch_target() -> f32,
    ///     \property QDial::notchesVisible
    ///     \brief whether the notches are shown
    /// 
    ///     If the property is \c true, a series of notches are drawn around the dial
    ///     to indicate the range of values available; otherwise no notches are
    ///     shown.
    /// 
    ///     By default, this property is disabled.
    notches_visible() -> bool,
    ///   \reimp
    [event] size_hint() -> Size,
    ///   \reimp
    [event] minimum_size_hint() -> Size,
    set_notches_visible(visible: bool),
    set_wrapping(on: bool),
    ///   \reimp
    [event] event(e: *EventType) -> bool,
    [event] resize_event(re: *ResizeEventType),
    ///   \reimp
    [event] paint_event(pe: *PaintEventType),
    ///   \reimp
    [event] mouse_press_event(me: *MouseEventType),
    ///   \reimp
    [event] mouse_release_event(me: *MouseEventType),
    ///   \reimp
    [event] mouse_move_event(me: *MouseEventType),
    ///     \reimp
    [event] slider_change(change: AbstractSlider::SliderChange),
    ///     Initialize \a option with the values from this QDial. This method
    ///     is useful for subclasses when they need a QStyleOptionSlider, but don't want
    ///     to fill in all the information themselves.
    /// 
    ///     \sa QStyleOption::initFrom()
    init_style_option(option: *StyleOptionSliderType),
}

// vim: syntax=rust expandtab ts=4 sw=4
