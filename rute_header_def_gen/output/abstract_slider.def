///     \class QAbstractSlider
///     \brief The QAbstractSlider class provides an integer value within a range.
/// 
///     \ingroup abstractwidgets
///     \inmodule QtWidgets
/// 
///     The class is designed as a common super class for widgets like
///     QScrollBar, QSlider and QDial.
/// 
///     Here are the main properties of the class:
/// 
///     \list 1
/// 
///     \li \l value: The bounded integer that QAbstractSlider maintains.
/// 
///     \li \l minimum: The lowest possible value.
/// 
///     \li \l maximum: The highest possible value.
/// 
///     \li \l singleStep: The smaller of two natural steps that an
///     abstract sliders provides and typically corresponds to the user
///     pressing an arrow key.
/// 
///     \li \l pageStep: The larger of two natural steps that an abstract
///     slider provides and typically corresponds to the user pressing
///     PageUp or PageDown.
/// 
///     \li \l tracking: Whether slider tracking is enabled.
/// 
///     \li \l sliderPosition: The current position of the slider. If \l
///     tracking is enabled (the default), this is identical to \l value.
/// 
///     \endlist
/// 
///     Unity (1) may be viewed as a third step size. setValue() lets you
///     set the current value to any integer in the allowed range, not
///     just minimum() + \e n * singleStep() for integer values of \e n.
///     Some widgets may allow the user to set any value at all; others
///     may just provide multiples of singleStep() or pageStep().
/// 
///     QAbstractSlider emits a comprehensive set of signals:
/// 
///     \table
///     \header \li Signal \li Emitted when
///     \row \li \l valueChanged()
///          \li the value has changed. The \l tracking
///             determines whether this signal is emitted during user
///             interaction.
///     \row \li \l sliderPressed()
///          \li the user starts to drag the slider.
///     \row \li \l sliderMoved()
///          \li the user drags the slider.
///     \row \li \l sliderReleased()
///          \li the user releases the slider.
///     \row \li \l actionTriggered()
///          \li a slider action was triggerd.
///     \row \li \l rangeChanged()
///          \li a the range has changed.
///     \endtable
/// 
///     QAbstractSlider provides a virtual sliderChange() function that is
///     well suited for updating the on-screen representation of
///     sliders. By calling triggerAction(), subclasses trigger slider
///     actions. Two helper functions QStyle::sliderPositionFromValue() and
///     QStyle::sliderValueFromPosition() help subclasses and styles to map
///     screen coordinates to logical range values.
/// 
///     \sa QAbstractSpinBox, QSlider, QDial, QScrollBar, {Sliders Example}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QAbstractSlider)]
enum SliderAction {
    SliderNoAction,
    SliderSingleStepAdd,
    SliderSingleStepSub,
    SliderPageStepAdd,
    SliderPageStepSub,
    SliderToMinimum,
    SliderToMaximum,
    SliderMove,
}

[org_name(QAbstractSlider)]
enum SliderChange {
    SliderRangeChange,
    SliderOrientationChange,
    SliderStepsChange,
    SliderValueChange,
}

struct AbstractSlider : Widget {
    orientation() -> Rute::Orientation,
    ///     \property QAbstractSlider::minimum
    ///     \brief the sliders's minimum value
    /// 
    ///     When setting this property, the \l maximum is adjusted if
    ///     necessary to ensure that the range remains valid. Also the
    ///     slider's current value is adjusted to be within the new range.
    /// 
    set_minimum(arg0: i32),
    minimum() -> i32,
    ///     \property QAbstractSlider::maximum
    ///     \brief the slider's maximum value
    /// 
    ///     When setting this property, the \l minimum is adjusted if
    ///     necessary to ensure that the range remains valid.  Also the
    ///     slider's current value is adjusted to be within the new range.
    /// 
    /// 
    set_maximum(arg0: i32),
    maximum() -> i32,
    ///     \property QAbstractSlider::singleStep
    ///     \brief the single step.
    /// 
    ///     The smaller of two natural steps that an
    ///     abstract sliders provides and typically corresponds to the user
    ///     pressing an arrow key.
    /// 
    ///     If the property is modified during an auto repeating key event, behavior
    ///     is undefined.
    /// 
    ///     \sa pageStep
    set_single_step(arg0: i32),
    single_step() -> i32,
    ///     \property QAbstractSlider::pageStep
    ///     \brief the page step.
    /// 
    ///     The larger of two natural steps that an abstract slider provides
    ///     and typically corresponds to the user pressing PageUp or PageDown.
    /// 
    ///     \sa singleStep
    set_page_step(arg0: i32),
    page_step() -> i32,
    ///     \property QAbstractSlider::tracking
    ///     \brief whether slider tracking is enabled
    /// 
    ///     If tracking is enabled (the default), the slider emits the
    ///     valueChanged() signal while the slider is being dragged. If
    ///     tracking is disabled, the slider emits the valueChanged() signal
    ///     only when the user releases the slider.
    /// 
    ///     \sa sliderDown
    set_tracking(enable: bool),
    has_tracking() -> bool,
    ///     \property QAbstractSlider::sliderDown
    ///     \brief whether the slider is pressed down.
    /// 
    ///     The property is set by subclasses in order to let the abstract
    ///     slider know whether or not \l tracking has any effect.
    /// 
    ///     Changing the slider down property emits the sliderPressed() and
    ///     sliderReleased() signals.
    /// 
    set_slider_down(arg0: bool),
    is_slider_down() -> bool,
    ///     \property QAbstractSlider::sliderPosition
    ///     \brief the current slider position
    /// 
    ///     If \l tracking is enabled (the default), this is identical to \l value.
    set_slider_position(arg0: i32),
    slider_position() -> i32,
    set_inverted_appearance(arg0: bool),
    ///     \property QAbstractSlider::invertedAppearance
    ///     \brief whether or not a slider shows its values inverted.
    /// 
    ///     If this property is \c false (the default), the minimum and maximum will
    ///     be shown in its classic position for the inherited widget. If the
    ///     value is true, the minimum and maximum appear at their opposite location.
    /// 
    ///     Note: This property makes most sense for sliders and dials. For
    ///     scroll bars, the visual effect of the scroll bar subcontrols depends on
    ///     whether or not the styles understand inverted appearance; most styles
    ///     ignore this property for scroll bars.
    inverted_appearance() -> bool,
    ///     \property QAbstractSlider::value
    ///     \brief the slider's current value
    /// 
    ///     The slider forces the value to be within the legal range: \l
    ///     minimum <= \c value <= \l maximum.
    /// 
    ///     Changing the value also changes the \l sliderPosition.
    value() -> i32,
    set_value(arg0: i32),
    ///     \property QAbstractSlider::orientation
    ///     \brief the orientation of the slider
    /// 
    ///     The orientation must be \l Qt::Vertical (the default) or \l
    ///     Qt::Horizontal.
    set_orientation(arg0: Rute::Orientation),
    ///     Sets the slider's minimum to \a min and its maximum to \a max.
    /// 
    ///     If \a max is smaller than \a min, \a min becomes the only legal
    ///     value.
    /// 
    ///     \sa minimum, maximum
    set_range(min: i32, max: i32),
    [signal] value_changed(value: i32),
    [signal] slider_pressed(),
    [signal] slider_moved(position: i32),
    [signal] slider_released(),
    [signal] range_changed(min: i32, max: i32),
    [signal] action_triggered(action: i32),
    ///     \reimp
    [event] event(e: *EventType) -> bool,
    set_repeat_action(action: AbstractSlider::SliderAction, threshold_time: i32, repeat_time: i32),
    repeat_action() -> AbstractSlider::SliderAction,
    [event] slider_change(change: AbstractSlider::SliderChange),
    ///     \reimp
    [event] key_press_event(ev: *KeyEventType),
    [event] timer_event(arg0: *TimerEventType),
    ///     \reimp
    [event] wheel_event(e: *WheelEventType),
    ///     \reimp
    [event] change_event(e: *EventType),
}

// vim: syntax=rust expandtab ts=4 sw=4
