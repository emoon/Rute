/// 
/// QGraphicsWidget is an extended base item that provides extra functionality
/// over QGraphicsItem. It is similar to QWidget in many ways:
/// 
/// * Provides a [palette,](palette,)
/// a [font](font)
/// and a [style().](style().)
/// 
/// * Has a defined geometry().
/// * Supports layouts with setLayout() and layout().
/// * Supports shortcuts and actions with grabShortcut() and insertAction()
/// 
/// Unlike QGraphicsItem, QGraphicsWidget is not an abstract class; you can
/// create instances of a QGraphicsWidget without having to subclass it.
/// This approach is useful for widgets that only serve the purpose of
/// organizing child widgets into a layout.
/// 
/// QGraphicsWidget can be used as a base item for your own custom item if
/// you require advanced input focus handling, e.g., tab focus and activation, or
/// layouts.
/// 
/// Since QGraphicsWidget resembles QWidget and has similar API, it is
/// easier to port a widget from QWidget to QGraphicsWidget, instead of
/// QGraphicsItem.
/// 
/// **Note**: QWidget-based widgets can be directly embedded into a
/// QGraphicsScene using QGraphicsProxyWidget.
/// 
/// Noticeable differences between QGraphicsWidget and QWidget are:
/// 
/// * QGraphicsWidget
/// * QWidget
/// * Coordinates and geometry are defined with qreals (doubles or floats, depending on the platform).
/// * QWidget uses integer geometry (QPoint, QRect).
/// * The widget is already visible by default; you do not have to call show() to display the widget.
/// * QWidget is hidden by default until you call show().
/// * A subset of widget attributes are supported.
/// * All widget attributes are supported.
/// * A top-level item's style defaults to QGraphicsScene::style
/// * A top-level widget's style defaults to QApplication::style
/// * Graphics View provides a custom drag and drop framework, different from QWidget.
/// * Standard drag and drop framework.
/// * Widget items do not support modality.
/// * Full modality support.
/// 
/// QGraphicsWidget supports a subset of Qt's widget attributes,
/// (Qt::WidgetAttribute), as shown in the table below. Any attributes not
/// listed in this table are unsupported, or otherwise unused.
/// 
/// * Widget Attribute
/// * Usage
/// * Qt::WA_SetLayoutDirection
/// * Set by setLayoutDirection(), cleared by unsetLayoutDirection(). You can test this attribute to check if the widget has been explicitly assigned a [layoutDirection](QGraphicsWidget::layoutDirection())
/// . If the attribute is not set, the [layoutDirection()](QGraphicsWidget::layoutDirection())
/// is inherited.
/// * Qt::WA_RightToLeft
/// * Toggled by setLayoutDirection(). Inherited from the parent/scene. If set, the widget's layout will order horizontally arranged widgets from right to left.
/// * Qt::WA_SetStyle
/// * Set and cleared by setStyle(). If this attribute is set, the widget has been explicitly assigned a style. If it is unset, the widget will use the scene's or the application's style.
/// * Qt::WA_Resized
/// * Set by setGeometry() and resize().
/// * Qt::WA_SetPalette
/// * Set by setPalette().
/// * Qt::WA_SetFont
/// * Set by setFont().
/// * Qt::WA_WindowPropagation
/// * Enables propagation to window widgets.
/// 
/// Although QGraphicsWidget inherits from both QObject and QGraphicsItem,
/// you should use the functions provided by QGraphicsItem, *not* QObject, to
/// manage the relationships between parent and child items. These functions
/// control the stacking order of items as well as their ownership.
/// 
/// **Note**: The QObject::parent() should always return 0 for QGraphicsWidgets,
/// but this policy is not strictly defined.
/// 
/// **See also:** QGraphicsProxyWidget
/// QGraphicsItem
/// {Widgets and Layouts}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QGraphicsWidget)]
enum GraphicsWidgetFixMeEnums {
    Type,
}

struct GraphicsWidget : GraphicsObject, GraphicsLayoutItem {
    /// 
    /// Any existing layout manager is deleted before the new layout is assigned. If
    /// *layout* is 0, the widget is left without a layout. Existing subwidgets'
    /// geometries will remain unaffected.
    /// 
    /// QGraphicsWidget takes ownership of *layout.*
    /// 
    /// All widgets that are currently managed by *layout* or all of its
    /// sublayouts, are automatically reparented to this item. The layout is then
    /// invalidated, and the child widget geometries are adjusted according to
    /// this item's geometry() and contentsMargins(). Children who are not
    /// explicitly managed by *layout* remain unaffected by the layout after
    /// it has been assigned to this widget.
    /// 
    /// If no layout is currently managing this widget, layout() will return 0.
    /// 
    /// 
    /// Returns this widget's layout, or 0 if no layout is currently managing this
    /// widget.
    /// 
    /// **See also:** setLayout()
    /// 
    /// This property modifies this widget's and all of its descendants'
    /// Qt::WA_RightToLeft attribute. It also sets this widget's
    /// Qt::WA_SetLayoutDirection attribute.
    /// 
    /// The widget's layout direction determines the order in which the layout
    /// manager horizontally arranges subwidgets of this widget. The default
    /// value depends on the language and locale of the application, and is
    /// typically in the same direction as words are read and written. With
    /// Qt::LeftToRight, the layout starts placing subwidgets from the left
    /// side of this widget towards the right. Qt::RightToLeft does the opposite -
    /// the layout will place widgets starting from the right edge moving towards
    /// the left.
    /// 
    /// Subwidgets inherit their layout direction from the parent. Top-level
    /// widget items inherit their layout direction from
    /// QGraphicsScene::layoutDirection. If you change a widget's layout direction
    /// by calling setLayoutDirection(), the widget will send itself a
    /// [LayoutDirectionChange](QEvent::LayoutDirectionChange)
    /// event, and then
    /// propagate the new layout direction to all its descendants.
    /// 
    /// **See also:** QWidget::layoutDirection
    /// QApplication::layoutDirection
    layout() -> GraphicsLayout?,
    /// 
    /// Sets the layout for this widget to *layout.* Any existing layout manager
    /// is deleted before the new layout is assigned. If *layout* is 0, the
    /// widget is left without a layout. Existing subwidgets' geometries will
    /// remain unaffected.
    /// 
    /// All widgets that are currently managed by *layout* or all of its
    /// sublayouts, are automatically reparented to this item. The layout is then
    /// invalidated, and the child widget geometries are adjusted according to
    /// this item's geometry() and contentsMargins(). Children who are not
    /// explicitly managed by *layout* remain unaffected by the layout after
    /// it has been assigned to this widget.
    /// 
    /// QGraphicsWidget takes ownership of *layout.*
    /// 
    /// **See also:** layout()
    /// QGraphicsLinearLayout::addItem()
    /// QGraphicsLayout::invalidate()
    set_layout(layout: *GraphicsLayoutType),
    /// 
    /// Adjusts the size of the widget to its effective preferred size hint.
    /// 
    /// This function is called implicitly when the item is shown for the first
    /// time.
    /// 
    /// **See also:** effectiveSizeHint()
    /// Qt::MinimumSize
    adjust_size(),
    /// 
    /// This property modifies this widget's and all of its descendants'
    /// Qt::WA_RightToLeft attribute. It also sets this widget's
    /// Qt::WA_SetLayoutDirection attribute.
    /// 
    /// The widget's layout direction determines the order in which the layout
    /// manager horizontally arranges subwidgets of this widget. The default
    /// value depends on the language and locale of the application, and is
    /// typically in the same direction as words are read and written. With
    /// Qt::LeftToRight, the layout starts placing subwidgets from the left
    /// side of this widget towards the right. Qt::RightToLeft does the opposite -
    /// the layout will place widgets starting from the right edge moving towards
    /// the left.
    /// 
    /// Subwidgets inherit their layout direction from the parent. Top-level
    /// widget items inherit their layout direction from
    /// QGraphicsScene::layoutDirection. If you change a widget's layout direction
    /// by calling setLayoutDirection(), the widget will send itself a
    /// [LayoutDirectionChange](QEvent::LayoutDirectionChange)
    /// event, and then
    /// propagate the new layout direction to all its descendants.
    /// 
    /// **See also:** QWidget::layoutDirection
    /// QApplication::layoutDirection
    layout_direction() -> Rute::LayoutDirection,
    set_layout_direction(direction: Rute::LayoutDirection),
    unset_layout_direction(),
    /// 
    /// Returns a pointer to the widget's style. If this widget does not have any
    /// explicitly assigned style, the scene's style is returned instead. In turn,
    /// if the scene does not have any assigned style, this function returns
    /// QApplication::style().
    /// 
    /// **See also:** setStyle()
    style() -> Style?,
    /// 
    /// Sets the widget's style to *style.* QGraphicsWidget does *not* take
    /// ownership of *style.*
    /// 
    /// If no style is assigned, or *style* is 0, the widget will use
    /// QGraphicsScene::style() (if this has been set). Otherwise the widget will
    /// use QApplication::style().
    /// 
    /// This function sets the Qt::WA_SetStyle attribute if *style* is not 0;
    /// otherwise it clears the attribute.
    /// 
    /// **See also:** style()
    set_style(style: *StyleType),
    /// 
    /// This property provides the widget's font.
    /// 
    /// QFont consists of font properties that have been explicitly defined and
    /// properties implicitly inherited from the widget's parent. Hence, font()
    /// can return a different font compared to the one set with setFont().
    /// This scheme allows you to define single entries in a font without
    /// affecting the font's inherited entries.
    /// 
    /// When a widget's font changes, it resolves its entries against its
    /// parent widget. If the widget does not have a parent widget, it resolves
    /// its entries against the scene. The widget then sends itself a
    /// [FontChange](QEvent::FontChange)
    /// event and notifies all its
    /// descendants so that they can resolve their fonts as well.
    /// 
    /// By default, this property contains the application's default font.
    /// 
    /// **See also:** QApplication::font()
    /// QGraphicsScene::font
    /// QFont::resolve()
    font() -> Font,
    set_font(font: &FontType),
    /// 
    /// This property provides the widget's palette. The palette provides colors
    /// and brushes for color groups (e.g., QPalette::Button) and states (e.g.,
    /// QPalette::Inactive), loosely defining the general look of the widget and
    /// its children.
    /// 
    /// QPalette consists of color groups that have been explicitly defined, and
    /// groups that are implicitly inherited from the widget's parent. Because of
    /// this, palette() can return a different palette than what has been set with
    /// setPalette(). This scheme allows you to define single entries in a palette
    /// without affecting the palette's inherited entries.
    /// 
    /// When a widget's palette changes, it resolves its entries against its
    /// parent widget, or if it doesn't have a parent widget, it resolves against
    /// the scene. It then sends itself a [PaletteChange](QEvent::PaletteChange)
    /// 
    /// event, and notifies all its descendants so they can resolve their palettes
    /// as well.
    /// 
    /// By default, this property contains the application's default palette.
    /// 
    /// **See also:** QApplication::palette()
    /// QGraphicsScene::palette
    /// QPalette::resolve()
    palette() -> Palette,
    set_palette(palette: &PaletteType),
    /// 
    /// If enabled, this property will cause Qt to fill the background of the
    /// widget before invoking the paint() method. The color used is defined by the
    /// QPalette::Window color role from the widget's [palette](QPalette)
    /// 
    /// 
    /// In addition, Windows are always filled with QPalette::Window, unless the
    /// WA_OpaquePaintEvent or WA_NoSystemBackground attributes are set.
    /// 
    /// By default, this property is `false.`
    /// 
    /// **See also:** Qt::WA_OpaquePaintEvent
    /// Qt::WA_NoSystemBackground
    /// */
    /// bool QGraphicsWidget::autoFillBackground() const
    /// 
    /// Q_D(const QGraphicsWidget);
    /// return d->autoFillBackground;
    /// 
    /// void QGraphicsWidget::setAutoFillBackground(bool enabled)
    /// 
    /// Q_D(QGraphicsWidget);
    /// if (d->autoFillBackground != enabled) {
    /// d->autoFillBackground = enabled;
    /// update();
    /// 
    /// 
    /// /*!
    /// If this widget is currently managed by a layout, this function notifies
    /// the layout that the widget's size hints have changed and the layout
    /// may need to resize and reposition the widget accordingly.
    /// 
    /// Call this function if the widget's sizeHint() has changed.
    /// 
    /// **See also:** QGraphicsLayout::invalidate()
    auto_fill_background() -> bool,
    set_auto_fill_background(enabled: bool),
    /// 
    /// **Overloads**
    /// Constructs a resize with the given `width` ( *w)* and `height` ( *h).*
    /// This convenience function is equivalent to calling resize(QSizeF(w, h)).
    /// 
    /// **See also:** setGeometry()
    /// setTransform()
    /// 
    /// This event handler, for
    /// [GraphicsSceneResize](QEvent::GraphicsSceneResize)
    /// events, is
    /// delivered after the widget has been resized (i.e., its local size has
    /// changed). *event* contains both the old and the new size.
    /// 
    /// This event is only delivered when the widget is resized locally; calling
    /// setTransform() on the widget or any of its ancestors or view, does not
    /// affect the widget's local size.
    /// 
    /// You can reimplement this event handler to detect when your widget has been
    /// resized. Calling QEvent::accept() or QEvent::ignore() on *event* has no
    /// effect.
    /// 
    /// **See also:** geometry()
    /// setGeometry()
    resize(size: &SizeFType),
    /// 
    /// **Overloads**
    /// Constructs a resize with the given `width` ( *w)* and `height` ( *h).*
    /// This convenience function is equivalent to calling resize(QSizeF(w, h)).
    /// 
    /// **See also:** setGeometry()
    /// setTransform()
    /// 
    /// This event handler, for
    /// [GraphicsSceneResize](QEvent::GraphicsSceneResize)
    /// events, is
    /// delivered after the widget has been resized (i.e., its local size has
    /// changed). *event* contains both the old and the new size.
    /// 
    /// This event is only delivered when the widget is resized locally; calling
    /// setTransform() on the widget or any of its ancestors or view, does not
    /// affect the widget's local size.
    /// 
    /// You can reimplement this event handler to detect when your widget has been
    /// resized. Calling QEvent::accept() or QEvent::ignore() on *event* has no
    /// effect.
    /// 
    /// **See also:** geometry()
    /// setGeometry()
    resize(w: f32, h: f32),
    /// 
    /// Calling resize() resizes the widget to a *size* bounded by minimumSize()
    /// and maximumSize(). This property only affects the widget's width and
    /// height (e.g., its right and bottom edges); the widget's position and
    /// top-left corner remains unaffected.
    /// 
    /// Resizing a widget triggers the widget to immediately receive a
    /// [GraphicsSceneResize](QEvent::GraphicsSceneResize)
    /// event with the
    /// widget's old and new size. If the widget has a layout assigned when this
    /// event arrives, the layout will be activated and it will automatically
    /// update any child widgets's geometry.
    /// 
    /// This property does not affect any layout of the parent widget. If the
    /// widget itself is managed by a parent layout; e.g., it has a parent widget
    /// with a layout assigned, that layout will not activate.
    /// 
    /// By default, this property contains a size with zero width and height.
    /// 
    /// **See also:** setGeometry()
    /// QGraphicsSceneResizeEvent
    /// QGraphicsLayout
    /// 
    /// **See also:** sizePolicy()
    /// setSizePolicy()
    /// QWidget::sizePolicy()
    /// 
    size() -> SizeF,
    /// 
    /// Returns the item's local rect as a QRectF. This function is equivalent
    /// to QRectF(QPointF(), size()).
    /// 
    /// **See also:** setGeometry()
    /// resize()
    rect() -> RectF,
    /// 
    /// Sets the widget's contents margins to *left,* *top,* *right* and *bottom.*
    /// 
    /// Contents margins are used by the assigned layout to define the placement
    /// of subwidgets and layouts. Margins are particularly useful for widgets
    /// that constrain subwidgets to only a section of its own geometry. For
    /// example, a group box with a layout will place subwidgets inside its frame,
    /// but below the title.
    /// 
    /// Changing a widget's contents margins will always trigger an update(), and
    /// any assigned layout will be activated automatically. The widget will then
    /// receive a [ContentsRectChange](QEvent::ContentsRectChange)
    /// event.
    /// 
    /// **See also:** getContentsMargins()
    /// setGeometry()
    set_contents_margins(left: f32, top: f32, right: f32, bottom: f32),
    /// 
    /// Gets the widget's contents margins. The margins are stored in *left,* *top,* *right* and *bottom,* as pointers to qreals. Each argument can
    /// be *omitted* by passing 0.
    /// 
    /// **See also:** setContentsMargins()
    [event] get_contents_margins(left: *f32, top: *f32, right: *f32, bottom: *f32),
    /// 
    /// Sets the widget's window frame margins to *left,* *top,* *right* and
    /// *bottom.* The default frame margins are provided by the style, and they
    /// depend on the current window flags.
    /// 
    /// If you would like to draw your own window decoration, you can set your
    /// own frame margins to override the default margins.
    /// 
    /// **See also:** unsetWindowFrameMargins()
    /// getWindowFrameMargins()
    /// windowFrameRect()
    set_window_frame_margins(left: f32, top: f32, right: f32, bottom: f32),
    /// 
    /// Gets the widget's window frame margins. The margins are stored in *left,*
    /// *top,* *right* and *bottom* as pointers to qreals. Each argument can
    /// be *omitted* by passing 0.
    /// 
    /// **See also:** setWindowFrameMargins()
    /// windowFrameRect()
    get_window_frame_margins(left: *f32, top: *f32, right: *f32, bottom: *f32),
    /// 
    /// Resets the window frame margins to the default value, provided by the style.
    /// 
    /// **See also:** setWindowFrameMargins()
    /// getWindowFrameMargins()
    /// windowFrameRect()
    unset_window_frame_margins(),
    /// 
    /// Returns the widget's local rect including any window frame.
    /// 
    /// **See also:** windowFrameGeometry()
    /// getWindowFrameMargins()
    /// setWindowFrameMargins()
    window_frame_rect() -> RectF,
    /// 
    /// Window flags are a combination of a window type (e.g., Qt::Dialog) and
    /// several flags giving hints on the behavior of the window. The behavior
    /// is platform-dependent.
    /// 
    /// By default, this property contains no window flags.
    /// 
    /// Windows are panels. If you set the Qt::Window flag, the ItemIsPanel flag
    /// will be set automatically. If you clear the Qt::Window flag, the
    /// ItemIsPanel flag is also cleared. Note that the ItemIsPanel flag can be
    /// set independently of Qt::Window.
    /// 
    /// **See also:** isWindow()
    /// isPanel()
    window_flags() -> Rute::WindowFlags,
    /// 
    /// Returns the widgets window type.
    /// 
    /// **See also:** windowFlags()
    /// isWindow()
    /// isPanel()
    window_type() -> Rute::WindowType,
    set_window_flags(w_flags: Rute::WindowFlags),
    /// 
    /// Returns `true` if this widget's window is in the active window, or if the
    /// widget does not have a window but is in an active scene (i.e., a scene
    /// that currently has focus).
    /// 
    /// The active window is the window that either contains a child widget that
    /// currently has input focus, or that itself has input focus.
    /// 
    /// **See also:** QGraphicsScene::activeWindow()
    /// QGraphicsScene::setActiveWindow()
    /// isActive()
    is_active_window() -> bool,
    set_window_title(title: String),
    /// 
    /// This property is only used for windows.
    /// 
    /// By default, if no title has been set, this property contains an
    /// empty string.
    window_title() -> String,
    /// 
    /// The focus policy is Qt::TabFocus if the widget accepts keyboard focus by
    /// tabbing, Qt::ClickFocus if the widget accepts focus by clicking,
    /// Qt::StrongFocus if it accepts both, and Qt::NoFocus (the default) if it
    /// does not accept focus at all.
    /// 
    /// You must enable keyboard focus for a widget if it processes keyboard
    /// events. This is normally done from the widget's constructor. For instance,
    /// the QLineEdit constructor calls setFocusPolicy(Qt::StrongFocus).
    /// 
    /// If you enable a focus policy (i.e., not Qt::NoFocus), QGraphicsWidget will
    /// automatically enable the ItemIsFocusable flag. Setting Qt::NoFocus on a
    /// widget will clear the ItemIsFocusable flag. If the widget currently has
    /// keyboard focus, the widget will automatically lose focus.
    /// 
    /// **See also:** focusInEvent()
    /// focusOutEvent()
    /// keyPressEvent()
    /// keyReleaseEvent()
    /// enabled
    focus_policy() -> Rute::FocusPolicy,
    set_focus_policy(policy: Rute::FocusPolicy),
    /// 
    /// Moves the *second* widget around the ring of focus widgets so that
    /// keyboard focus moves from the *first* widget to the *second* widget when
    /// the Tab key is pressed.
    /// 
    /// Note that since the tab order of the *second* widget is changed, you
    /// should order a chain like this:
    /// 
    /// *not* like this:
    /// 
    /// If *first* is 0, this indicates that *second* should be the first widget
    /// to receive input focus should the scene gain Tab focus (i.e., the user
    /// hits Tab so that focus passes into the scene). If *second* is 0, this
    /// indicates that *first* should be the first widget to gain focus if the
    /// scene gained BackTab focus.
    /// 
    /// By default, tab order is defined implicitly using widget creation order.
    /// 
    /// **See also:** focusPolicy
    /// {Keyboard Focus in Widgets}
    [static] set_tab_order(first: *GraphicsWidgetType, second: *GraphicsWidgetType),
    /// 
    /// If this widget, a child or descendant of this widget currently has input
    /// focus, this function will return a pointer to that widget. If
    /// no descendant widget has input focus, 0 is returned.
    /// 
    /// **See also:** QGraphicsItem::focusItem()
    /// QWidget::focusWidget()
    focus_widget() -> GraphicsWidget?,
    /// 
    /// Adds a shortcut to Qt's shortcut system that watches for the given key *sequence* in the given *context.* If the *context* is
    /// Qt::ApplicationShortcut, the shortcut applies to the application as a
    /// whole. Otherwise, it is either local to this widget, Qt::WidgetShortcut,
    /// or to the window itself, Qt::WindowShortcut. For widgets that are not part
    /// of a window (i.e., top-level widgets and their children),
    /// Qt::WindowShortcut shortcuts apply to the scene.
    /// 
    /// If the same key *sequence* has been grabbed by several widgets,
    /// when the key *sequence* occurs a QEvent::Shortcut event is sent
    /// to all the widgets to which it applies in a non-deterministic
    /// order, but with the ``ambiguous'' flag set to true.
    /// 
    /// **Warning**: You should not normally need to use this function;
    /// instead create [QAction](QAction)
    /// s with the shortcut key sequences you
    /// require (if you also want equivalent menu options and toolbar
    /// buttons), or create [QShortcut](QShortcut)
    /// s if you just need key sequences.
    /// Both QAction and QShortcut handle all the event filtering for you,
    /// and provide signals which are triggered when the user triggers the
    /// key sequence, so are much easier to use than this low-level
    /// function.
    /// 
    /// **See also:** releaseShortcut()
    /// setShortcutEnabled()
    /// QWidget::grabShortcut()
    grab_shortcut(sequence: &KeySequenceType, context: Rute::ShortcutContext) -> i32,
    /// 
    /// Removes the shortcut with the given *id* from Qt's shortcut
    /// system. The widget will no longer receive QEvent::Shortcut events
    /// for the shortcut's key sequence (unless it has other shortcuts
    /// with the same key sequence).
    /// 
    /// **Warning**: You should not normally need to use this function since
    /// Qt's shortcut system removes shortcuts automatically when their
    /// parent widget is destroyed. It is best to use QAction or
    /// QShortcut to handle shortcuts, since they are easier to use than
    /// this low-level function. Note also that this is an expensive
    /// operation.
    /// 
    /// **See also:** grabShortcut()
    /// setShortcutEnabled()
    /// QWidget::releaseShortcut()
    release_shortcut(id: i32),
    /// 
    /// If *enabled* is true, the shortcut with the given *id* is
    /// enabled; otherwise the shortcut is disabled.
    /// 
    /// **Warning**: You should not normally need to use this function since
    /// Qt's shortcut system enables/disables shortcuts automatically as
    /// widgets become hidden/visible and gain or lose focus. It is best
    /// to use QAction or QShortcut to handle shortcuts, since they are
    /// easier to use than this low-level function.
    /// 
    /// **See also:** grabShortcut()
    /// releaseShortcut()
    /// QWidget::setShortcutEnabled()
    set_shortcut_enabled(id: i32, enabled: bool),
    /// 
    /// If *enabled* is true, auto repeat of the shortcut with the
    /// given *id* is enabled; otherwise it is disabled.
    /// 
    /// **See also:** grabShortcut()
    /// releaseShortcut()
    /// QWidget::setShortcutAutoRepeat()
    set_shortcut_auto_repeat(id: i32, enabled: bool),
    /// 
    /// Appends the action *action* to this widget's list of actions.
    /// 
    /// All QGraphicsWidgets have a list of [QAction](QAction)
    /// s, however they can be
    /// represented graphically in many different ways. The default use of the
    /// QAction list (as returned by actions()) is to create a context QMenu.
    /// 
    /// A QGraphicsWidget should only have one of each action and adding an action
    /// it already has will not cause the same action to be in the widget twice.
    /// 
    /// **See also:** removeAction()
    /// insertAction()
    /// actions()
    /// QWidget::addAction()
    add_action(action: *ActionType),
    add_actions(actions: [*ActionType]),
    insert_actions(before: *ActionType, actions: [*ActionType]),
    /// 
    /// Inserts the action *action* to this widget's list of actions,
    /// before the action *before.* It appends the action if *before* is 0 or
    /// *before* is not a valid action for this widget.
    /// 
    /// A QGraphicsWidget should only have one of each action.
    /// 
    /// **See also:** removeAction()
    /// addAction()
    /// QMenu
    /// actions()
    /// QWidget::insertActions()
    insert_action(before: *ActionType, action: *ActionType),
    /// 
    /// Removes the action *action* from this widget's list of actions.
    /// 
    /// **See also:** insertAction()
    /// actions()
    /// insertAction()
    /// QWidget::removeAction()
    remove_action(action: *ActionType),
    /// 
    /// Returns the (possibly empty) list of this widget's actions.
    /// 
    /// **See also:** insertAction()
    /// removeAction()
    /// QWidget::actions()
    /// QAction::associatedWidgets()
    /// QAction::associatedGraphicsWidgets()
    actions() -> [Action?],
    /// 
    [event] type() -> i32,
    /// 
    /// 
    /// This virtual function is called by QGraphicsScene to draw the window frame
    /// for windows using *painter,* *option,* and *widget,* in local
    /// coordinates. The base implementation uses the current style to render the
    /// frame and title bar.
    /// 
    /// You can reimplement this function in a subclass of QGraphicsWidget to
    /// provide custom rendering of the widget's window frame.
    /// 
    /// **See also:** QGraphicsItem::paint()
    [event] paint(painter: *PainterType, option: *StyleOptionGraphicsItemType, widget: *WidgetType),
    /// 
    /// This virtual function is called by QGraphicsScene to draw the window frame
    /// for windows using *painter,* *option,* and *widget,* in local
    /// coordinates. The base implementation uses the current style to render the
    /// frame and title bar.
    /// 
    /// You can reimplement this function in a subclass of QGraphicsWidget to
    /// provide custom rendering of the widget's window frame.
    /// 
    /// **See also:** QGraphicsItem::paint()
    [event] paint_window_frame(painter: *PainterType, option: *StyleOptionGraphicsItemType, widget: *WidgetType),
    /// 
    [event] bounding_rect() -> RectF,
    /// 
    [event] shape() -> PainterPath,
    [signal] layout_changed(),
    /// 
    /// This event handler, for *event,* can be reimplemented in a subclass to
    /// receive widget close events. The default implementation accepts the
    /// event.
    /// 
    /// **See also:** close()
    /// QCloseEvent
    /// 
    /// Call this function to close the widget.
    /// 
    /// Returns `true` if the widget was closed; otherwise returns `false.`
    /// This slot will first send a QCloseEvent to the widget, which may or may
    /// not accept the event. If the event was ignored, nothing happens. If the
    /// event was accepted, it will hide() the widget.
    /// 
    /// If the widget has the Qt::WA_DeleteOnClose attribute set it will be
    /// deleted.
    close() -> bool,
    /// 
    /// Populates a style option object for this widget based on its current
    /// state, and stores the output in *option.* The default implementation
    /// populates *option* with the following properties.
    /// 
    /// * Style Option Property
    /// * Value
    /// 
    /// * state & QStyle::State_Enabled
    /// * Corresponds to QGraphicsItem::isEnabled().
    /// 
    /// * state & QStyle::State_HasFocus
    /// * Corresponds to QGraphicsItem::hasFocus().
    /// 
    /// * state & QStyle::State_MouseOver
    /// * Corresponds to QGraphicsItem::isUnderMouse().
    /// 
    /// * direction
    /// * Corresponds to QGraphicsWidget::layoutDirection().
    /// 
    /// * rect
    /// * Corresponds to QGraphicsWidget::rect().toRect().
    /// 
    /// * palette
    /// * Corresponds to QGraphicsWidget::palette().
    /// 
    /// * fontMetrics
    /// * Corresponds to QFontMetrics(QGraphicsWidget::font()).
    /// 
    /// Subclasses of QGraphicsWidget should call the base implementation, and
    /// then test the type of *option* using qstyleoption_cast<>() or test
    /// QStyleOption::Type before storing widget-specific options.
    /// 
    /// For example:
    /// 
    /// **See also:** QStyleOption::initFrom()
    [event] init_style_option(option: *StyleOptionType),
    /// 
    [event] size_hint(which: Rute::SizeHint, constraint: &SizeFType) -> SizeF,
    /// 
    /// QGraphicsWidget uses the base implementation of this function to catch and
    /// deliver events related to state changes in the item. Because of this, it is
    /// very important that subclasses call the base implementation.
    /// 
    /// *change* specifies the type of change, and *value* is the new value.
    /// 
    /// For example, QGraphicsWidget uses ItemVisibleChange to deliver
    /// [Show](QEvent::Show)
    /// and [Hide](QEvent::Hide)
    /// events,
    /// ItemPositionHasChanged to deliver [Move](QEvent::Move)
    /// events,
    /// and ItemParentChange both to deliver [ParentChange](QEvent::ParentChange)
    /// events, and for managing the focus chain.
    /// 
    /// QGraphicsWidget enables the ItemSendsGeometryChanges flag by default in
    /// order to track position changes.
    /// 
    /// **See also:** QGraphicsItem::itemChange()
    [event] item_change(change: GraphicsItem::GraphicsItemChange, value: &VariantType) -> Variant,
    [event] property_change(property_name: String, value: &VariantType) -> Variant,
    /// 
    /// QGraphicsWidget's implementation of sceneEvent() simply passes *event* to
    /// QGraphicsWidget::event(). You can handle all events for your widget in
    /// event() or in any of the convenience functions; you should not have to
    /// reimplement this function in a subclass of QGraphicsWidget.
    /// 
    /// **See also:** QGraphicsItem::sceneEvent()
    [event] scene_event(event: *EventType) -> bool,
    /// 
    /// This event handler, for *event,* receives events for the window frame if
    /// this widget is a window. Its base implementation provides support for
    /// default window frame interaction such as moving, resizing, etc.
    /// 
    /// You can reimplement this handler in a subclass of QGraphicsWidget to
    /// provide your own custom window frame interaction support.
    /// 
    /// Returns `true` if *event* has been recognized and processed; otherwise,
    /// returns `false.`
    /// 
    /// **See also:** event()
    [event] window_frame_event(e: *EventType) -> bool,
    /// 
    /// Returns the window frame section at position *pos,* or
    /// Qt::NoSection if there is no window frame section at this
    /// position.
    /// 
    /// This function is used in QGraphicsWidget's base implementation for window
    /// frame interaction.
    /// 
    /// You can reimplement this function if you want to customize how a window
    /// can be interactively moved or resized. For instance, if you only want to
    /// allow a window to be resized by the bottom right corner, you can
    /// reimplement this function to return Qt::NoSection for all sections except
    /// Qt::BottomRightSection.
    /// 
    /// **See also:** windowFrameEvent()
    /// paintWindowFrame()
    /// windowFrameGeometry()
    [event] window_frame_section_at(pos: &PointFType) -> Rute::WindowFrameSection,
    /// 
    /// Handles the *event.* QGraphicsWidget handles the following
    /// events:
    /// 
    /// * Event
    /// * Usage
    /// * Polish
    /// * Delivered to the widget some time after it has been shown.
    /// * GraphicsSceneMove
    /// * Delivered to the widget after its local position has changed.
    /// * GraphicsSceneResize
    /// * Delivered to the widget after its size has changed.
    /// * Show
    /// * Delivered to the widget before it has been shown.
    /// * Hide
    /// * Delivered to the widget after it has been hidden.
    /// * PaletteChange
    /// * Delivered to the widget after its palette has changed.
    /// * FontChange
    /// * Delivered to the widget after its font has changed.
    /// * EnabledChange
    /// * Delivered to the widget after its enabled state has changed.
    /// * StyleChange
    /// * Delivered to the widget after its style has changed.
    /// * LayoutDirectionChange
    /// * Delivered to the widget after its layout direction has changed.
    /// * ContentsRectChange
    /// * Delivered to the widget after its contents margins/ contents rect has changed.
    [event] event(event: *EventType) -> bool,
    /// 
    /// This event handler can be reimplemented to handle state changes.
    /// 
    /// The state being changed in this event can be retrieved through *event.*
    /// 
    /// Change events include: QEvent::ActivationChange, QEvent::EnabledChange,
    /// QEvent::FontChange, QEvent::StyleChange, QEvent::PaletteChange,
    /// QEvent::ParentChange, QEvent::LayoutDirectionChange, and
    /// QEvent::ContentsRectChange.
    [event] change_event(event: *EventType),
    /// 
    /// This event handler, for *event,* can be reimplemented in a subclass to
    /// receive widget close events. The default implementation accepts the
    /// event.
    /// 
    /// **See also:** close()
    /// QCloseEvent
    [event] close_event(event: *CloseEventType),
    /// 
    [event] focus_in_event(event: *FocusEventType),
    /// 
    /// Finds a new widget to give the keyboard focus to, as appropriate for Tab
    /// and Shift+Tab, and returns `true` if it can find a new widget; returns `false`
    /// otherwise. If *next* is true, this function searches forward; if *next*
    /// is false, it searches backward.
    /// 
    /// Sometimes, you will want to reimplement this function to provide special
    /// focus handling for your widget and its subwidgets. For example, a web
    /// browser might reimplement it to move its current active link forward or
    /// backward, and call the base implementation only when it reaches the last
    /// or first link on the page.
    /// 
    /// Child widgets call focusNextPrevChild() on their parent widgets, but only
    /// the window that contains the child widgets decides where to redirect
    /// focus. By reimplementing this function for an object, you gain control of
    /// focus traversal for all child widgets.
    /// 
    /// **See also:** focusPolicy()
    [event] focus_next_prev_child(next: bool) -> bool,
    /// 
    [event] focus_out_event(event: *FocusEventType),
    /// 
    /// This event handler, for [Hide](QEvent::Hide)
    /// events, is delivered after
    /// the widget has been hidden, for example, setVisible(false) has been called
    /// for the widget or one of its ancestors when the widget was previously
    /// shown.
    /// 
    /// You can reimplement this event handler to detect when your widget is
    /// hidden. Calling QEvent::accept() or QEvent::ignore() on *event* has no
    /// effect.
    /// 
    /// **See also:** showEvent()
    /// QWidget::hideEvent()
    /// ItemVisibleChange
    [event] hide_event(event: *HideEventType),
    /// 
    /// This event handler, for [GraphicsSceneMove](QEvent::GraphicsSceneMove)
    /// 
    /// events, is delivered after the widget has moved (e.g., its local position
    /// has changed).
    /// 
    /// This event is only delivered when the item is moved locally. Calling
    /// setTransform() or moving any of the item's ancestors does not affect the
    /// item's local position.
    /// 
    /// You can reimplement this event handler to detect when your widget has
    /// moved. Calling QEvent::accept() or QEvent::ignore() on *event* has no
    /// effect.
    /// 
    /// **See also:** ItemPositionChange
    /// ItemPositionHasChanged
    [event] move_event(event: *GraphicsSceneMoveEventType),
    /// 
    /// This event is delivered to the item by the scene at some point after it
    /// has been constructed, but before it is shown or otherwise accessed through
    /// the scene. You can use this event handler to do last-minute initializations
    /// of the widget which require the item to be fully constructed.
    /// 
    /// The base implementation does nothing.
    [event] polish_event(),
    /// 
    /// This event handler, for
    /// [GraphicsSceneResize](QEvent::GraphicsSceneResize)
    /// events, is
    /// delivered after the widget has been resized (i.e., its local size has
    /// changed). *event* contains both the old and the new size.
    /// 
    /// This event is only delivered when the widget is resized locally; calling
    /// setTransform() on the widget or any of its ancestors or view, does not
    /// affect the widget's local size.
    /// 
    /// You can reimplement this event handler to detect when your widget has been
    /// resized. Calling QEvent::accept() or QEvent::ignore() on *event* has no
    /// effect.
    /// 
    /// **See also:** geometry()
    /// setGeometry()
    [event] resize_event(event: *GraphicsSceneResizeEventType),
    /// 
    /// This event handler, for [Show](QEvent::Show)
    /// events, is delivered before
    /// the widget has been shown, for example, setVisible(true) has been called
    /// for the widget or one of its ancestors when the widget was previously
    /// hidden.
    /// 
    /// You can reimplement this event handler to detect when your widget is
    /// shown. Calling QEvent::accept() or QEvent::ignore() on *event* has no
    /// effect.
    /// 
    /// **See also:** hideEvent()
    /// QWidget::showEvent()
    /// ItemVisibleChange
    [event] show_event(event: *ShowEventType),
    /// 
    [event] hover_move_event(event: *GraphicsSceneHoverEventType),
    /// 
    [event] hover_leave_event(event: *GraphicsSceneHoverEventType),
    /// 
    /// This event handler, for *event,* can be reimplemented in a subclass to
    /// receive notifications for QEvent::GrabMouse events.
    /// 
    /// **See also:** grabMouse()
    /// grabKeyboard()
    [event] grab_mouse_event(event: *EventType),
    /// 
    /// This event handler, for *event,* can be reimplemented in a subclass to
    /// receive notifications for QEvent::UngrabMouse events.
    /// 
    /// **See also:** ungrabMouse()
    /// ungrabKeyboard()
    [event] ungrab_mouse_event(event: *EventType),
    /// 
    /// This event handler, for *event,* can be reimplemented in a subclass to
    /// receive notifications for QEvent::GrabKeyboard events.
    /// 
    /// **See also:** grabKeyboard()
    /// grabMouse()
    [event] grab_keyboard_event(event: *EventType),
    /// 
    /// This event handler, for *event,* can be reimplemented in a subclass to
    /// receive notifications for QEvent::UngrabKeyboard events.
    /// 
    /// **See also:** ungrabKeyboard()
    /// ungrabMouse()
    [event] ungrab_keyboard_event(event: *EventType),
}

// vim: syntax=rust expandtab ts=4 sw=4
