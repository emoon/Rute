///     \class QTouchEvent
///     \brief The QTouchEvent class contains parameters that describe a touch event.
///     \since 4.6
///     \ingroup events
///     \ingroup touch
///     \inmodule QtGui
/// 
///     \section1 Enabling Touch Events
/// 
///     Touch events occur when pressing, releasing, or moving one or more touch points on a touch
///     device (such as a touch-screen or track-pad). To receive touch events, widgets have to have the
///     Qt::WA_AcceptTouchEvents attribute set and graphics items need to have the
///     \l{QGraphicsItem::setAcceptTouchEvents()}{acceptTouchEvents} attribute set to true.
/// 
///     When using QAbstractScrollArea based widgets, you should enable the Qt::WA_AcceptTouchEvents
///     attribute on the scroll area's \l{QAbstractScrollArea::viewport()}{viewport}.
/// 
///     Similarly to QMouseEvent, Qt automatically grabs each touch point on the first press inside a
///     widget, and the widget will receive all updates for the touch point until it is released.
///     Note that it is possible for a widget to receive events for numerous touch points, and that
///     multiple widgets may be receiving touch events at the same time.
/// 
///     \section1 Event Handling
/// 
///     All touch events are of type QEvent::TouchBegin, QEvent::TouchUpdate, QEvent::TouchEnd or
///     QEvent::TouchCancel. Reimplement QWidget::event() or QAbstractScrollArea::viewportEvent() for
///     widgets and QGraphicsItem::sceneEvent() for items in a graphics view to receive touch events.
/// 
///     Unlike widgets, QWindows receive touch events always, there is no need to opt in. When working
///     directly with a QWindow, it is enough to reimplement QWindow::touchEvent().
/// 
///     The QEvent::TouchUpdate and QEvent::TouchEnd events are sent to the widget or item that
///     accepted the QEvent::TouchBegin event. If the QEvent::TouchBegin event is not accepted and not
///     filtered by an event filter, then no further touch events are sent until the next
///     QEvent::TouchBegin.
/// 
///     Some systems may send an event of type QEvent::TouchCancel. Upon receiving this event
///     applications are requested to ignore the entire active touch sequence. For example in a
///     composited system the compositor may decide to treat certain gestures as system-wide
///     gestures. Whenever such a decision is made (the gesture is recognized), the clients will be
///     notified with a QEvent::TouchCancel event so they can update their state accordingly.
/// 
///     The touchPoints() function returns a list of all touch points contained in the event. Note that
///     this list may be empty, for example in case of a QEvent::TouchCancel event. Information about
///     each touch point can be retrieved using the QTouchEvent::TouchPoint class. The
///     Qt::TouchPointState enum describes the different states that a touch point may have.
/// 
///     \note The list of touchPoints() will never be partial: A touch event will always contain a touch
///     point for each existing physical touch contacts targetting the window or widget to which the
///     event is sent. For instance, assuming that all touches target the same window or widget, an
///     event with a condition of touchPoints().count()==2 is guaranteed to imply that the number of
///     fingers touching the touchscreen or touchpad is exactly two.
/// 
///     \section1 Event Delivery and Propagation
/// 
///     By default, QGuiApplication translates the first touch point in a QTouchEvent into
///     a QMouseEvent. This makes it possible to enable touch events on existing widgets that do not
///     normally handle QTouchEvent. See below for information on some special considerations needed
///     when doing this.
/// 
///     QEvent::TouchBegin is the first touch event sent to a widget. The QEvent::TouchBegin event
///     contains a special accept flag that indicates whether the receiver wants the event. By default,
///     the event is accepted. You should call ignore() if the touch event is not handled by your
///     widget. The QEvent::TouchBegin event is propagated up the parent widget chain until a widget
///     accepts it with accept(), or an event filter consumes it. For QGraphicsItems, the
///     QEvent::TouchBegin event is propagated to items under the mouse (similar to mouse event
///     propagation for QGraphicsItems).
/// 
///     \section1 Touch Point Grouping
/// 
///     As mentioned above, it is possible that several widgets can be receiving QTouchEvents at the
///     same time. However, Qt makes sure to never send duplicate QEvent::TouchBegin events to the same
///     widget, which could theoretically happen during propagation if, for example, the user touched 2
///     separate widgets in a QGroupBox and both widgets ignored the QEvent::TouchBegin event.
/// 
///     To avoid this, Qt will group new touch points together using the following rules:
/// 
///     \list
/// 
///     \li When the first touch point is detected, the destination widget is determined firstly by the
///     location on screen and secondly by the propagation rules.
/// 
///     \li When additional touch points are detected, Qt first looks to see if there are any active
///     touch points on any ancestor or descendent of the widget under the new touch point. If there
///     are, the new touch point is grouped with the first, and the new touch point will be sent in a
///     single QTouchEvent to the widget that handled the first touch point. (The widget under the new
///     touch point will not receive an event).
/// 
///     \endlist
/// 
///     This makes it possible for sibling widgets to handle touch events independently while making
///     sure that the sequence of QTouchEvents is always correct.
/// 
///     \section1 Mouse Events and Touch Event Synthesizing
/// 
///     QTouchEvent delivery is independent from that of QMouseEvent. The application flags
///     Qt::AA_SynthesizeTouchForUnhandledMouseEvents and Qt::AA_SynthesizeMouseForUnhandledTouchEvents
///     can be used to enable or disable automatic synthesizing of touch events to mouse events and
///     mouse events to touch events.
/// 
///     \section1 Caveats
/// 
///     \list
/// 
///     \li As mentioned above, enabling touch events means multiple widgets can be receiving touch
///     events simultaneously. Combined with the default QWidget::event() handling for QTouchEvents,
///     this gives you great flexibility in designing touch user interfaces. Be aware of the
///     implications. For example, it is possible that the user is moving a QSlider with one finger and
///     pressing a QPushButton with another. The signals emitted by these widgets will be
///     interleaved.
/// 
///     \li Recursion into the event loop using one of the exec() methods (e.g., QDialog::exec() or
///     QMenu::exec()) in a QTouchEvent event handler is not supported. Since there are multiple event
///     recipients, recursion may cause problems, including but not limited to lost events
///     and unexpected infinite recursion.
/// 
///     \li QTouchEvents are not affected by a \l{QWidget::grabMouse()}{mouse grab} or an
///     \l{QApplication::activePopupWidget()}{active pop-up widget}. The behavior of QTouchEvents is
///     undefined when opening a pop-up or grabbing the mouse while there are more than one active touch
///     points.
/// 
///     \endlist
/// 
///     \sa QTouchEvent::TouchPoint, Qt::TouchPointState, Qt::WA_AcceptTouchEvents,
///     QGraphicsItem::acceptTouchEvents()
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct TouchEvent : InputEvent {
    window() -> Window?,
    target() -> Object?,
    touch_point_states() -> Rute::TouchPointStates,
    touch_points() -> onst QList<QTouchEvent::TouchPoint> &,
    device() -> TouchDevice?,
    set_window(awindow: *WindowType),
    set_target(atarget: *ObjectType),
    set_touch_point_states(a_touch_point_states: Rute::TouchPointStates),
    set_touch_points(atouch_points: onst QList<QTouchEvent::TouchPoint> &),
    set_device(adevice: *TouchDeviceType),
}

// vim: syntax=rust expandtab ts=4 sw=4
