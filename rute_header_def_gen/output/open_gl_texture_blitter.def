/// 
/// Drawing textured quads, in order to get the contents of a texture
/// onto the screen, is a common operation when developing 2D user
/// interfaces. QOpenGLTextureBlitter provides a convenience class to
/// avoid repeating vertex data, shader sources, buffer and program
/// management and matrix calculations.
/// 
/// For example, a QOpenGLWidget subclass can do the following to draw
/// the contents rendered into a framebuffer at the pixel position `(x, y)` :
/// 
/// ```
/// void OpenGLWidget::initializeGL()
/// 
/// m_blitter.create();
/// m_fbo = new QOpenGLFramebufferObject(size);
/// 
/// 
/// void OpenGLWidget::paintGL()
/// 
/// m_fbo->bind();
/// // update offscreen content
/// m_fbo->release();
/// 
/// m_blitter.bind();
/// const QRect targetRect(QPoint(x, y), m_fbo->size());
/// const QMatrix4x4 target = QOpenGLTextureBlitter::targetTransform(targetRect, QRect(QPoint(0, 0), m_fbo->size()));
/// m_blitter.blit(m_fbo->texture(), target, QOpenGLTextureBlitter::OriginBottomLeft);
/// m_blitter.release();
/// 
/// ```
/// 
/// The blitter implements GLSL shaders both for GLSL 1.00 (suitable
/// for OpenGL (ES) 2.x and compatibility profiles of newer OpenGL
/// versions) and version 150 (suitable for core profile contexts with
/// OpenGL 3.2 and newer).
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QOpenGLTextureBlitter)]
enum Origin {
    OriginBottomLeft,
    OriginTopLeft,
}


struct OpenGLTextureBlitter {
    /// 
    /// Initializes the graphics resources used by the blitter.
    /// 
    /// **Returns** `true` if successful, `false` if there was a
    /// failure. Failures can occur when there is no OpenGL context
    /// current on the current thread, or when shader compilation fails
    /// for some reason.
    /// 
    /// **See also:** isCreated()
    /// destroy()
    create() -> bool,
    /// 
    /// **Returns** `true` if create() was called and succeeded. `false` otherwise.
    /// 
    /// **See also:** create()
    /// destroy()
    is_created() -> bool,
    /// 
    /// **Returns** `true` when bind() accepts `GL_TEXTURE_EXTERNAL_OES` as
    /// its target argument.
    /// 
    /// **See also:** bind()
    /// blit()
    supports_external_oes_target() -> bool,
    /// 
    /// Binds the graphics resources used by the blitter. This must be
    /// called before calling blit(). Code modifying the OpenGL state
    /// should be avoided between the call to bind() and blit() because
    /// otherwise conflicts may arise.
    /// 
    /// *target* is the texture target for the source texture and must be
    /// either `GL_TEXTURE_2D` or `GL_OES_EGL_image_external.`
    /// 
    /// **See also:** release()
    /// blit()
    bind(target: i32),
    /// 
    /// Unbinds the graphics resources used by the blitter.
    /// 
    /// **See also:** bind()
    release(),
    /// 
    /// Sets whether swizzling is enabled for the red and blue color channels to
    /// *swizzle.* An BGRA to RGBA conversion (occurring in the shader on
    /// the GPU, instead of a slow CPU-side transformation) can be useful
    /// when the source texture contains data from a QImage with a format
    /// like QImage::Format_ARGB32 which maps to BGRA on little endian
    /// systems.
    /// 
    /// By default the red-blue swizzle is disabled since this is what a
    /// texture attached to an framebuffer object or a texture based on a
    /// byte ordered QImage format (like QImage::Format_RGBA8888) needs.
    set_red_blue_swizzle(swizzle: bool),
    /// 
    /// Changes the opacity to *opacity.* The default opacity is 1.0.
    /// 
    /// **Note**: the blitter does not alter the blend state. It is up to the
    /// caller of blit() to ensure the correct blend settings are active.
    /// 
    set_opacity(opacity: f32),
    /// 
    /// Performs the blit with the source texture *texture.*
    /// 
    /// *targetTransform* specifies the transformation applied. This is
    /// usually generated by the targetTransform() helper function.
    /// 
    /// *sourceOrigin* specifies if the image data needs flipping. When
    /// *texture* corresponds to a texture attached to an FBO pass
    /// OriginBottomLeft. On the other hand, when *texture* is based on
    /// unflipped image data, pass OriginTopLeft. This is more efficient
    /// than using QImage::mirrored().
    /// 
    /// **See also:** targetTransform()
    /// Origin
    /// bind()
    /// 
    /// Performs the blit with the source texture *texture.*
    /// 
    /// *targetTransform* specifies the transformation applied. This is
    /// usually generated by the targetTransform() helper function.
    /// 
    /// *sourceTransform* specifies the transformation applied to the
    /// source. This allows using only a sub-rect of the source
    /// texture. This is usually generated by the sourceTransform() helper
    /// function.
    /// 
    /// **See also:** sourceTransform()
    /// targetTransform()
    /// Origin
    /// bind()
    blit(texture: i32, target_transform: &Matrix4x4Type, source_origin: OpenGLTextureBlitter::Origin),
    /// 
    /// Performs the blit with the source texture *texture.*
    /// 
    /// *targetTransform* specifies the transformation applied. This is
    /// usually generated by the targetTransform() helper function.
    /// 
    /// *sourceOrigin* specifies if the image data needs flipping. When
    /// *texture* corresponds to a texture attached to an FBO pass
    /// OriginBottomLeft. On the other hand, when *texture* is based on
    /// unflipped image data, pass OriginTopLeft. This is more efficient
    /// than using QImage::mirrored().
    /// 
    /// **See also:** targetTransform()
    /// Origin
    /// bind()
    /// 
    /// Performs the blit with the source texture *texture.*
    /// 
    /// *targetTransform* specifies the transformation applied. This is
    /// usually generated by the targetTransform() helper function.
    /// 
    /// *sourceTransform* specifies the transformation applied to the
    /// source. This allows using only a sub-rect of the source
    /// texture. This is usually generated by the sourceTransform() helper
    /// function.
    /// 
    /// **See also:** sourceTransform()
    /// targetTransform()
    /// Origin
    /// bind()
    blit(texture: i32, target_transform: &Matrix4x4Type, source_transform: &Matrix3x3Type),
    /// 
    /// Calculates a target transform suitable for blit().
    /// 
    /// *target* is the target rectangle in pixels. *viewport* describes
    /// the source dimensions and will in most cases be set to (0, 0,
    /// image width, image height).
    /// 
    /// For unscaled output the size of *target* and *viewport* should
    /// match.
    /// 
    /// **See also:** blit()
    [static] target_transform(target: &RectFType, viewport: &RectType) -> Matrix4x4,
    /// 
    /// Calculates a 3x3 matrix suitable as the input to blit(). This is
    /// used when only a part of the texture is to be used in the blit.
    /// 
    /// *subTexture* is the desired source rectangle in pixels, *textureSize* is the full width and height of the texture data. *origin* specifies the orientation of the image data when it comes
    /// to the Y axis.
    /// 
    /// **See also:** blit()
    /// Origin
    [static] source_transform(sub_texture: &RectFType, texture_size: &SizeType, origin: OpenGLTextureBlitter::Origin) -> Matrix3x3,
}

// vim: syntax=rust expandtab ts=4 sw=4
