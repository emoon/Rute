///     \class QDir
///     \inmodule QtCore
///     \brief The QDir class provides access to directory structures and their contents.
/// 
///     \ingroup io
///     \ingroup shared
///     \reentrant
/// 
/// 
///     A QDir is used to manipulate path names, access information
///     regarding paths and files, and manipulate the underlying file
///     system. It can also be used to access Qt's \l{resource system}.
/// 
///     Qt uses "/" as a universal directory separator in the same way
///     that "/" is used as a path separator in URLs. If you always use
///     "/" as a directory separator, Qt will translate your paths to
///     conform to the underlying operating system.
/// 
///     A QDir can point to a file using either a relative or an absolute
///     path. Absolute paths begin with the directory separator
///     (optionally preceded by a drive specification under Windows).
///     Relative file names begin with a directory name or a file name and
///     specify a path relative to the current directory.
/// 
///     Examples of absolute paths:
/// 
///     \snippet code/src_corelib_io_qdir.cpp 0
/// 
///     On Windows, the second example above will be translated to
///     \c{C:\Documents and Settings} when used to access files.
/// 
///     Examples of relative paths:
/// 
///     \snippet code/src_corelib_io_qdir.cpp 1
/// 
///     You can use the isRelative() or isAbsolute() functions to check if
///     a QDir is using a relative or an absolute file path. Call
///     makeAbsolute() to convert a relative QDir to an absolute one.
/// 
///     \section1 Navigation and Directory Operations
/// 
///     A directory's path can be obtained with the path() function, and
///     a new path set with the setPath() function. The absolute path to
///     a directory is found by calling absolutePath().
/// 
///     The name of a directory is found using the dirName() function. This
///     typically returns the last element in the absolute path that specifies
///     the location of the directory. However, it can also return "." if
///     the QDir represents the current directory.
/// 
///     \snippet code/src_corelib_io_qdir.cpp 2
/// 
///     The path for a directory can also be changed with the cd() and cdUp()
///     functions, both of which operate like familiar shell commands.
///     When cd() is called with the name of an existing directory, the QDir
///     object changes directory so that it represents that directory instead.
///     The cdUp() function changes the directory of the QDir object so that
///     it refers to its parent directory; i.e. cd("..") is equivalent to
///     cdUp().
/// 
///     Directories can be created with mkdir(), renamed with rename(), and
///     removed with rmdir().
/// 
///     You can test for the presence of a directory with a given name by
///     using exists(), and the properties of a directory can be tested with
///     isReadable(), isAbsolute(), isRelative(), and isRoot().
/// 
///     The refresh() function re-reads the directory's data from disk.
/// 
///     \section1 Files and Directory Contents
/// 
///     Directories contain a number of entries, representing files,
///     directories, and symbolic links. The number of entries in a
///     directory is returned by count().
///     A string list of the names of all the entries in a directory can be
///     obtained with entryList(). If you need information about each
///     entry, use entryInfoList() to obtain a list of QFileInfo objects.
/// 
///     Paths to files and directories within a directory can be
///     constructed using filePath() and absoluteFilePath().
///     The filePath() function returns a path to the specified file
///     or directory relative to the path of the QDir object;
///     absoluteFilePath() returns an absolute path to the specified
///     file or directory. Neither of these functions checks for the
///     existence of files or directory; they only construct paths.
/// 
///     \snippet code/src_corelib_io_qdir.cpp 3
/// 
///     Files can be removed by using the remove() function. Directories
///     cannot be removed in the same way as files; use rmdir() to remove
///     them instead.
/// 
///     It is possible to reduce the number of entries returned by
///     entryList() and entryInfoList() by applying filters to a QDir object.
///     You can apply a name filter to specify a pattern with wildcards that
///     file names need to match, an attribute filter that selects properties
///     of entries and can distinguish between files and directories, and a
///     sort order.
/// 
///     Name filters are lists of strings that are passed to setNameFilters().
///     Attribute filters consist of a bitwise OR combination of Filters, and
///     these are specified when calling setFilter().
///     The sort order is specified using setSorting() with a bitwise OR
///     combination of SortFlags.
/// 
///     You can test to see if a filename matches a filter using the match()
///     function.
/// 
///     Filter and sort order flags may also be specified when calling
///     entryList() and entryInfoList() in order to override previously defined
///     behavior.
/// 
///     \section1 The Current Directory and Other Special Paths
/// 
///     Access to some common directories is provided with a number of static
///     functions that return QDir objects. There are also corresponding functions
///     for these that return strings:
/// 
///     \table
///     \header \li QDir      \li QString         \li Return Value
///     \row    \li current() \li currentPath()   \li The application's working directory
///     \row    \li home()    \li homePath()      \li The user's home directory
///     \row    \li root()    \li rootPath()      \li The root directory
///     \row    \li temp()    \li tempPath()      \li The system's temporary directory
///     \endtable
/// 
///     The setCurrent() static function can also be used to set the application's
///     working directory.
/// 
///     If you want to find the directory containing the application's executable,
///     see \l{QCoreApplication::applicationDirPath()}.
/// 
///     The drives() static function provides a list of root directories for each
///     device that contains a filing system. On Unix systems this returns a list
///     containing a single root directory "/"; on Windows the list will usually
///     contain \c{C:/}, and possibly other drive letters such as \c{D:/}, depending
///     on the configuration of the user's system.
/// 
///     \section1 Path Manipulation and Strings
/// 
///     Paths containing "." elements that reference the current directory at that
///     point in the path, ".." elements that reference the parent directory, and
///     symbolic links can be reduced to a canonical form using the canonicalPath()
///     function.
/// 
///     Paths can also be simplified by using cleanPath() to remove redundant "/"
///     and ".." elements.
/// 
///     It is sometimes necessary to be able to show a path in the native
///     representation for the user's platform. The static toNativeSeparators()
///     function returns a copy of the specified path in which each directory
///     separator is replaced by the appropriate separator for the underlying
///     operating system.
/// 
///     \section1 Examples
/// 
///     Check if a directory exists:
/// 
///     \snippet code/src_corelib_io_qdir.cpp 4
/// 
///     (We could also use the static convenience function
///     QFile::exists().)
/// 
///     Traversing directories and reading a file:
/// 
///     \snippet code/src_corelib_io_qdir.cpp 5
/// 
///     A program that lists all the files in the current directory
///     (excluding symbolic links), sorted by size, smallest first:
/// 
///     \snippet qdir-listfiles/main.cpp 0
/// 
///     \sa QFileInfo, QFile, QFileDialog, QCoreApplication::applicationDirPath(), {Find Files Example}
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QDir)]
enum Filter {
    Dirs,
    Files,
    Drives,
    NoSymLinks,
    AllEntries,
    TypeMask,
    Readable,
    Writable,
    Executable,
    PermissionMask,
    Modified,
    Hidden,
    System,
    AccessMask,
    AllDirs,
    CaseSensitive,
    NoDot,
    NoDotDot,
    NoDotAndDotDot,
    NoFilter,
}

[org_name(QDir)]
enum SortFlag {
    Name,
    Time,
    Size,
    Unsorted,
    SortByMask,
    DirsFirst,
    Reversed,
    IgnoreCase,
    DirsLast,
    LocaleAware,
    Type,
    NoSort,
}


struct Dir {
    swap(other: &DirType),
    ///     Sets the path of the directory to \a path. The path is cleaned of
    ///     redundant ".", ".." and of multiple separators. No check is made
    ///     to see whether a directory with this path actually exists; but you
    ///     can check for yourself using exists().
    /// 
    ///     The path can be either absolute or relative. Absolute paths begin
    ///     with the directory separator "/" (optionally preceded by a drive
    ///     specification under Windows). Relative file names begin with a
    ///     directory name or a file name and specify a path relative to the
    ///     current directory. An example of an absolute path is the string
    ///     "/tmp/quartz", a relative path might look like "src/fatlib".
    /// 
    ///     \sa path(), absolutePath(), exists(), cleanPath(), dirName(),
    ///       absoluteFilePath(), isRelative(), makeAbsolute()
    set_path(path: String),
    ///     Returns the path. This may contain symbolic links, but never
    ///     contains redundant ".", ".." or multiple separators.
    /// 
    ///     The returned path can be either absolute or relative (see
    ///     setPath()).
    /// 
    ///     \sa setPath(), absolutePath(), exists(), cleanPath(), dirName(),
    ///     absoluteFilePath(), toNativeSeparators(), makeAbsolute()
    path() -> String,
    ///     Returns the absolute path (a path that starts with "/" or with a
    ///     drive specification), which may contain symbolic links, but never
    ///     contains redundant ".", ".." or multiple separators.
    /// 
    ///     \sa setPath(), canonicalPath(), exists(), cleanPath(),
    ///     dirName(), absoluteFilePath()
    absolute_path() -> String,
    ///     Returns the canonical path, i.e. a path without symbolic links or
    ///     redundant "." or ".." elements.
    /// 
    ///     On systems that do not have symbolic links this function will
    ///     always return the same string that absolutePath() returns. If the
    ///     canonical path does not exist (normally due to dangling symbolic
    ///     links) canonicalPath() returns an empty string.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_corelib_io_qdir.cpp 6
    /// 
    ///     \sa path(), absolutePath(), exists(), cleanPath(), dirName(),
    ///         absoluteFilePath()
    canonical_path() -> String,
    ///     \obsolete
    /// 
    ///     Use QDir::addSearchPath() with a prefix instead.
    /// 
    ///     Adds \a path to the search paths searched in to find resources
    ///     that are not specified with an absolute path. The default search
    ///     path is to search only in the root (\c{:/}).
    /// 
    ///     \sa {The Qt Resource System}
    [static] add_resource_search_path(path: String),
    ///     \since 4.3
    /// 
    ///     Sets or replaces Qt's search paths for file names with the prefix \a prefix
    ///     to \a searchPaths.
    /// 
    ///     To specify a prefix for a file name, prepend the prefix followed by a single
    ///     colon (e.g., "images:undo.png", "xmldocs:books.xml"). \a prefix can only
    ///     contain letters or numbers (e.g., it cannot contain a colon, nor a slash).
    /// 
    ///     Qt uses this search path to locate files with a known prefix. The search
    ///     path entries are tested in order, starting with the first entry.
    /// 
    ///     \snippet code/src_corelib_io_qdir.cpp 8
    /// 
    ///     File name prefix must be at least 2 characters long to avoid conflicts with
    ///     Windows drive letters.
    /// 
    ///     Search paths may contain paths to \l{The Qt Resource System}.
    [static] set_search_paths(prefix: String, search_paths: &[String]),
    ///     \since 4.3
    /// 
    ///     Adds \a path to the search path for \a prefix.
    /// 
    ///     \sa setSearchPaths()
    [static] add_search_path(prefix: String, path: String),
    ///     \since 4.3
    /// 
    ///     Returns the search paths for \a prefix.
    /// 
    ///     \sa setSearchPaths(), addSearchPath()
    [static] search_paths(prefix: String) -> [String],
    ///     Returns the name of the directory; this is \e not the same as the
    ///     path, e.g. a directory with the name "mail", might have the path
    ///     "/var/spool/mail". If the directory has no name (e.g. it is the
    ///     root directory) an empty string is returned.
    /// 
    ///     No check is made to ensure that a directory with this name
    ///     actually exists; but see exists().
    /// 
    ///     \sa path(), filePath(), absolutePath(), absoluteFilePath()
    dir_name() -> String,
    ///     Returns the path name of a file in the directory. Does \e not
    ///     check if the file actually exists in the directory; but see
    ///     exists(). If the QDir is relative the returned path name will also
    ///     be relative. Redundant multiple separators or "." and ".."
    ///     directories in \a fileName are not removed (see cleanPath()).
    /// 
    ///     \sa dirName(), absoluteFilePath(), isRelative(), canonicalPath()
    file_path(file_name: String) -> String,
    ///     Returns the absolute path name of a file in the directory. Does \e
    ///     not check if the file actually exists in the directory; but see
    ///     exists(). Redundant multiple separators or "." and ".."
    ///     directories in \a fileName are not removed (see cleanPath()).
    /// 
    ///     \sa relativeFilePath(), filePath(), canonicalPath()
    absolute_file_path(file_name: String) -> String,
    ///     Returns the path to \a fileName relative to the directory.
    /// 
    ///     \snippet code/src_corelib_io_qdir.cpp 7
    /// 
    ///     \sa absoluteFilePath(), filePath(), canonicalPath()
    relative_file_path(file_name: String) -> String,
    ///     \since 4.2
    /// 
    ///     Returns \a pathName with the '/' separators converted to
    ///     separators that are appropriate for the underlying operating
    ///     system.
    /// 
    ///     On Windows, toNativeSeparators("c:/winnt/system32") returns
    ///     "c:\\winnt\\system32".
    /// 
    ///     The returned string may be the same as the argument on some
    ///     operating systems, for example on Unix.
    /// 
    ///     \sa fromNativeSeparators(), separator()
    [static] to_native_separators(path_name: String) -> String,
    ///     \since 4.2
    /// 
    ///     Returns \a pathName using '/' as file separator. On Windows,
    ///     for instance, fromNativeSeparators("\c{c:\\winnt\\system32}") returns
    ///     "c:/winnt/system32".
    /// 
    ///     The returned string may be the same as the argument on some
    ///     operating systems, for example on Unix.
    /// 
    ///     \sa toNativeSeparators(), separator()
    [static] from_native_separators(path_name: String) -> String,
    ///     Changes the QDir's directory to \a dirName.
    /// 
    ///     Returns \c true if the new directory exists;
    ///     otherwise returns \c false. Note that the logical cd() operation is
    ///     not performed if the new directory does not exist.
    /// 
    ///     Calling cd("..") is equivalent to calling cdUp().
    /// 
    ///     \sa cdUp(), isReadable(), exists(), path()
    cd(dir_name: String) -> bool,
    ///     Changes directory by moving one directory up from the QDir's
    ///     current directory.
    /// 
    ///     Returns \c true if the new directory exists;
    ///     otherwise returns \c false. Note that the logical cdUp() operation is
    ///     not performed if the new directory does not exist.
    /// 
    ///     \sa cd(), isReadable(), exists(), path()
    cd_up() -> bool,
    ///     Returns the string list set by setNameFilters()
    name_filters() -> [String],
    ///     Sets the name filters used by entryList() and entryInfoList() to the
    ///     list of filters specified by \a nameFilters.
    /// 
    ///     Each name filter is a wildcard (globbing) filter that understands
    ///     \c{*} and \c{?} wildcards. (See \l{QRegExp wildcard matching}.)
    /// 
    ///     For example, the following code sets three name filters on a QDir
    ///     to ensure that only files with extensions typically used for C++
    ///     source files are listed:
    /// 
    ///     \snippet qdir-namefilters/main.cpp 0
    /// 
    ///     \sa nameFilters(), setFilter()
    set_name_filters(name_filters: &[String]),
    ///     Returns the value set by setFilter()
    filter() -> Dir::Filters,
    ///     Sets the filter used by entryList() and entryInfoList() to \a
    ///     filters. The filter is used to specify the kind of files that
    ///     should be returned by entryList() and entryInfoList(). See
    ///     \l{QDir::Filter}.
    /// 
    ///     \sa filter(), setNameFilters()
    set_filter(filter: Dir::Filters),
    ///     Returns the value set by setSorting()
    /// 
    ///     \sa setSorting(), SortFlag
    sorting() -> Dir::SortFlags,
    ///     Sets the sort order used by entryList() and entryInfoList().
    /// 
    ///     The \a sort is specified by OR-ing values from the enum
    ///     \l{QDir::SortFlag}.
    /// 
    ///     \sa sorting(), SortFlag
    set_sorting(sort: Dir::SortFlags),
    ///     Returns the total number of directories and files in the directory.
    /// 
    ///     Equivalent to entryList().count().
    /// 
    ///     \sa operator[](), entryList()
    count() -> uint,
    ///     Returns whether the directory is empty.
    /// 
    ///     Equivalent to \c{count() == 0} with filters
    ///     \c{QDir::AllEntries | QDir::NoDotAndDotDot}, but faster as it just checks
    ///     whether the directory contains at least one entry.
    /// 
    ///     \note Unless you set the \a filters flags to include \c{QDir::NoDotAndDotDot}
    ///           (as the default value does), no directory is empty.
    /// 
    ///     \sa count(), entryList(), setFilter()
    ///     \since 5.9
    is_empty(filters: Dir::Filters) -> bool,
    ///     Creates a sub-directory called \a dirName.
    /// 
    ///     Returns \c true on success; otherwise returns \c false.
    /// 
    ///     If the directory already exists when this function is called, it will return false.
    /// 
    ///     \sa rmdir()
    mkdir(dir_name: String) -> bool,
    ///     Removes the directory specified by \a dirName.
    /// 
    ///     The directory must be empty for rmdir() to succeed.
    /// 
    ///     Returns \c true if successful; otherwise returns \c false.
    /// 
    ///     \sa mkdir()
    rmdir(dir_name: String) -> bool,
    ///     Creates the directory path \a dirPath.
    /// 
    ///     The function will create all parent directories necessary to
    ///     create the directory.
    /// 
    ///     Returns \c true if successful; otherwise returns \c false.
    /// 
    ///     If the path already exists when this function is called, it will return true.
    /// 
    ///     \sa rmpath()
    mkpath(dir_path: String) -> bool,
    ///     Removes the directory path \a dirPath.
    /// 
    ///     The function will remove all parent directories in \a dirPath,
    ///     provided that they are empty. This is the opposite of
    ///     mkpath(dirPath).
    /// 
    ///     Returns \c true if successful; otherwise returns \c false.
    /// 
    ///     \sa mkpath()
    rmpath(dir_path: String) -> bool,
    ///     \since 5.0
    ///     Removes the directory, including all its contents.
    /// 
    ///     Returns \c true if successful, otherwise false.
    /// 
    ///     If a file or directory cannot be removed, removeRecursively() keeps going
    ///     and attempts to delete as many files and sub-directories as possible,
    ///     then returns \c false.
    /// 
    ///     If the directory was already removed, the method returns \c true
    ///     (expected result already reached).
    /// 
    ///     Note: this function is meant for removing a small application-internal
    ///     directory (such as a temporary directory), but not user-visible
    ///     directories. For user-visible operations, it is rather recommended
    ///     to report errors more precisely to the user, to offer solutions
    ///     in case of errors, to show progress during the deletion since it
    ///     could take several minutes, etc.
    remove_recursively() -> bool,
    ///     Returns \c true if the directory is readable \e and we can open files
    ///     by name; otherwise returns \c false.
    /// 
    ///     \warning A false value from this function is not a guarantee that
    ///     files in the directory are not accessible.
    /// 
    ///     \sa QFileInfo::isReadable()
    is_readable() -> bool,
    ///     Returns \c true if the file called \a name exists; otherwise returns
    ///     false.
    /// 
    ///     Unless \a name contains an absolute file path, the file name is assumed
    ///     to be relative to the directory itself, so this function is typically used
    ///     to check for the presence of files within a directory.
    /// 
    ///     \sa QFileInfo::exists(), QFile::exists()
    exists() -> bool,
    ///     Returns \c true if the directory is the root directory; otherwise
    ///     returns \c false.
    /// 
    ///     Note: If the directory is a symbolic link to the root directory
    ///     this function returns \c false. If you want to test for this use
    ///     canonicalPath(), e.g.
    /// 
    ///     \snippet code/src_corelib_io_qdir.cpp 9
    /// 
    ///     \sa root(), rootPath()
    is_root() -> bool,
    ///     Returns \c true if \a path is relative; returns \c false if it is
    ///     absolute.
    /// 
    ///     \sa isRelative(), isAbsolutePath(), makeAbsolute()
    [static] is_relative_path(path: String) -> bool,
    [static] is_absolute_path(path: String) -> bool,
    ///     Returns \c true if the directory path is relative; otherwise returns
    ///     false. (Under Unix a path is relative if it does not start with a
    ///     "/").
    /// 
    ///     \sa makeAbsolute(), isAbsolute(), isAbsolutePath(), cleanPath()
    is_relative() -> bool,
    is_absolute() -> bool,
    ///     Converts the directory path to an absolute path. If it is already
    ///     absolute nothing happens. Returns \c true if the conversion
    ///     succeeded; otherwise returns \c false.
    /// 
    ///     \sa isAbsolute(), isAbsolutePath(), isRelative(), cleanPath()
    make_absolute() -> bool,
    ///     Removes the file, \a fileName.
    /// 
    ///     Returns \c true if the file is removed successfully; otherwise
    ///     returns \c false.
    remove(file_name: String) -> bool,
    ///     Renames a file or directory from \a oldName to \a newName, and returns
    ///     true if successful; otherwise returns \c false.
    /// 
    ///     On most file systems, rename() fails only if \a oldName does not
    ///     exist, or if a file with the new name already exists.
    ///     However, there are also other reasons why rename() can
    ///     fail. For example, on at least one file system rename() fails if
    ///     \a newName points to an open file.
    /// 
    ///     If \a oldName is a file (not a directory) that can't be renamed
    ///     right away, Qt will try to copy \a oldName to \a newName and remove
    ///     \a oldName.
    /// 
    ///     \sa QFile::rename()
    rename(old_name: String, new_name: String) -> bool,
    ///     Returns \c true if the file called \a name exists; otherwise returns
    ///     false.
    /// 
    ///     Unless \a name contains an absolute file path, the file name is assumed
    ///     to be relative to the directory itself, so this function is typically used
    ///     to check for the presence of files within a directory.
    /// 
    ///     \sa QFileInfo::exists(), QFile::exists()
    exists(name: String) -> bool,
    ///     Returns a list of the root directories on this system.
    /// 
    ///     On Windows this returns a list of QFileInfo objects containing "C:/",
    ///     "D:/", etc. On other operating systems, it returns a list containing
    ///     just one root directory (i.e. "/").
    /// 
    ///     \sa root(), rootPath()
    [static] drives() -> FileInfoList,
    [static] list_separator() -> Char,
    ///     Returns the native directory separator: "/" under Unix
    ///     and "\\" under Windows.
    /// 
    ///     You do not need to use this function to build file paths. If you
    ///     always use "/", Qt will translate your paths to conform to the
    ///     underlying operating system. If you want to display paths to the
    ///     user using their operating system's separator use
    ///     toNativeSeparators().
    /// 
    ///     \sa listSeparator()
    [static] separator() -> Char,
    ///     Sets the application's current working directory to \a path.
    ///     Returns \c true if the directory was successfully changed; otherwise
    ///     returns \c false.
    /// 
    ///     \sa current(), currentPath(), home(), root(), temp()
    [static] set_current(path: String) -> bool,
    [static] current() -> Dir,
    ///     Returns the absolute path of the application's current directory. The
    ///     current directory is the last directory set with QDir::setCurrent() or, if
    ///     that was never called, the directory at which this application was started
    ///     at by the parent process.
    /// 
    ///     \sa current(), setCurrent(), homePath(), rootPath(), tempPath(), QCoreApplication::applicationDirPath()
    [static] current_path() -> String,
    [static] home() -> Dir,
    ///     Returns the absolute path of the user's home directory.
    /// 
    ///     Under Windows this function will return the directory of the
    ///     current user's profile. Typically, this is:
    /// 
    ///     \snippet code/src_corelib_io_qdir.cpp 12
    /// 
    ///     Use the toNativeSeparators() function to convert the separators to
    ///     the ones that are appropriate for the underlying operating system.
    /// 
    ///     If the directory of the current user's profile does not exist or
    ///     cannot be retrieved, the following alternatives will be checked (in
    ///     the given order) until an existing and available path is found:
    /// 
    ///     \list 1
    ///     \li The path specified by the \c USERPROFILE environment variable.
    ///     \li The path formed by concatenating the \c HOMEDRIVE and \c HOMEPATH
    ///     environment variables.
    ///     \li The path specified by the \c HOME environment variable.
    ///     \li The path returned by the rootPath() function (which uses the \c SystemDrive
    ///     environment variable)
    ///     \li  The \c{C:/} directory.
    ///     \endlist
    /// 
    ///     Under non-Windows operating systems the \c HOME environment
    ///     variable is used if it exists, otherwise the path returned by the
    ///     rootPath().
    /// 
    ///     \sa home(), currentPath(), rootPath(), tempPath()
    [static] home_path() -> String,
    [static] root() -> Dir,
    ///     Returns the absolute path of the root directory.
    /// 
    ///     For Unix operating systems this returns "/". For Windows file
    ///     systems this normally returns "c:/".
    /// 
    ///     \sa root(), drives(), currentPath(), homePath(), tempPath()
    [static] root_path() -> String,
    [static] temp() -> Dir,
    ///     Returns the absolute path of the system's temporary directory.
    /// 
    ///     On Unix/Linux systems this is the path in the \c TMPDIR environment
    ///     variable or \c{/tmp} if \c TMPDIR is not defined. On Windows this is
    ///     usually the path in the \c TEMP or \c TMP environment
    ///     variable.
    ///     The path returned by this method doesn't end with a directory separator
    ///     unless it is the root directory (of a drive).
    /// 
    ///     \sa temp(), currentPath(), homePath(), rootPath()
    [static] temp_path() -> String,
    ///     Returns \c true if the \a fileName matches the wildcard (glob)
    ///     pattern \a filter; otherwise returns \c false. The \a filter may
    ///     contain multiple patterns separated by spaces or semicolons.
    ///     The matching is case insensitive.
    /// 
    ///     \sa {QRegExp wildcard matching}, QRegExp::exactMatch(), entryList(), entryInfoList()
    [static] match(filters: &[String], file_name: String) -> bool,
    ///     Returns \c true if the \a fileName matches the wildcard (glob)
    ///     pattern \a filter; otherwise returns \c false. The \a filter may
    ///     contain multiple patterns separated by spaces or semicolons.
    ///     The matching is case insensitive.
    /// 
    ///     \sa {QRegExp wildcard matching}, QRegExp::exactMatch(), entryList(), entryInfoList()
    [static] match(filter: String, file_name: String) -> bool,
    ///     Returns \a path with directory separators normalized (converted to "/") and
    ///     redundant ones removed, and "."s and ".."s resolved (as far as possible).
    /// 
    ///     Symbolic links are kept. This function does not return the
    ///     canonical path, but rather the simplest version of the input.
    ///     For example, "./local" becomes "local", "local/../bin" becomes
    ///     "bin" and "/local/usr/../bin" becomes "/local/bin".
    /// 
    ///     \sa absolutePath(), canonicalPath()
    [static] clean_path(path: String) -> String,
    ///     Refreshes the directory information.
    refresh(),
}

// vim: syntax=rust expandtab ts=4 sw=4
