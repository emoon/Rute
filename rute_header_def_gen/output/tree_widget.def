///   \class QTreeWidget
/// 
///   \brief The QTreeWidget class provides a tree view that uses a predefined
///   tree model.
/// 
///   \ingroup model-view
///   \inmodule QtWidgets
/// 
///   \image windows-treeview.png
/// 
///   The QTreeWidget class is a convenience class that provides a standard
///   tree widget with a classic item-based interface similar to that used by
///   the QListView class in Qt 3.
///   This class is based on Qt's Model/View architecture and uses a default
///   model to hold items, each of which is a QTreeWidgetItem.
/// 
///   Developers who do not need the flexibility of the Model/View framework
///   can use this class to create simple hierarchical lists very easily. A more
///   flexible approach involves combining a QTreeView with a standard item model.
///   This allows the storage of data to be separated from its representation.
/// 
///   In its simplest form, a tree widget can be constructed in the following way:
/// 
///   \snippet code/src_gui_itemviews_qtreewidget.cpp 0
/// 
///   Before items can be added to the tree widget, the number of columns must
///   be set with setColumnCount(). This allows each item to have one or more
///   labels or other decorations. The number of columns in use can be found
///   with the columnCount() function.
/// 
///   The tree can have a header that contains a section for each column in
///   the widget. It is easiest to set up the labels for each section by
///   supplying a list of strings with setHeaderLabels(), but a custom header
///   can be constructed with a QTreeWidgetItem and inserted into the tree
///   with the setHeaderItem() function.
/// 
///   The items in the tree can be sorted by column according to a predefined
///   sort order. If sorting is enabled, the user can sort the items by clicking
///   on a column header. Sorting can be enabled or disabled by calling
///   \l{QTreeView::setSortingEnabled()}{setSortingEnabled()}. The
///   \l{QTreeView::isSortingEnabled()}{isSortingEnabled()} function indicates
///   whether sorting is enabled.
/// 
///   \sa QTreeWidgetItem, QTreeWidgetItemIterator, QTreeView,
///   {Model/View Programming}, {Settings Editor Example}
struct TreeWidget : TreeView {
    column_count() -> i32,
    set_column_count(columns: i32),
    ///   \since 4.2
    /// 
    ///   Returns the tree widget's invisible root item.
    /// 
    ///   The invisible root item provides access to the tree widget's top-level items
    ///   through the QTreeWidgetItem API, making it possible to write functions that
    ///   can treat top-level items and their children in a uniform way; for example,
    ///   recursive functions.
    invisible_root_item() -> TreeWidgetItem?,
    ///   Returns the top level item at the given \a index, or 0 if the item does
    ///   not exist.
    /// 
    ///   \sa topLevelItemCount(), insertTopLevelItem()
    top_level_item(index: i32) -> TreeWidgetItem?,
    ///     \property QTreeWidget::topLevelItemCount
    ///     \brief the number of top-level items
    /// 
    ///     By default, this property has a value of 0.
    /// 
    ///     \sa columnCount(), currentItem()
    top_level_item_count() -> i32,
    ///   Inserts the \a item at \a index in the top level in the view.
    /// 
    ///   If the item has already been inserted somewhere else it won't be inserted.
    /// 
    ///   \sa addTopLevelItem(), columnCount()
    insert_top_level_item(index: i32, item: *TreeWidgetItemType),
    ///     \since 4.1
    /// 
    ///     Appends the \a item as a top-level item in the widget.
    /// 
    ///     \sa insertTopLevelItem()
    add_top_level_item(item: *TreeWidgetItemType),
    ///   Removes the top-level item at the given \a index in the tree and
    ///   returns it, otherwise returns 0;
    /// 
    ///   \sa insertTopLevelItem(), topLevelItem(), topLevelItemCount()
    take_top_level_item(index: i32) -> TreeWidgetItem?,
    index_of_top_level_item(item: *TreeWidgetItemType) -> i32,
    ///   \since 4.1
    /// 
    ///   Inserts the list of \a items at \a index in the top level in the view.
    /// 
    ///   Items that have already been inserted somewhere else won't be inserted.
    /// 
    ///   \sa addTopLevelItems()
    insert_top_level_items(index: i32, items: [*TreeWidgetItemType]),
    ///   Appends the list of \a items as a top-level items in the widget.
    /// 
    ///   \sa insertTopLevelItems()
    add_top_level_items(items: [*TreeWidgetItemType]),
    ///     Returns the item used for the tree widget's header.
    /// 
    ///     \sa setHeaderItem()
    header_item() -> TreeWidgetItem?,
    ///     Sets the header \a item for the tree widget. The label for each column in
    ///     the header is supplied by the corresponding label in the item.
    /// 
    ///     The tree widget takes ownership of the item.
    /// 
    ///     \sa headerItem(), setHeaderLabels()
    set_header_item(item: *TreeWidgetItemType),
    ///   Adds a column in the header for each item in the \a labels list, and sets
    ///   the label for each column.
    /// 
    ///   Note that setHeaderLabels() won't remove existing columns.
    /// 
    ///   \sa setHeaderItem(), setHeaderLabel()
    set_header_labels(labels: &[String]),
    set_header_label(label: String),
    ///     Returns the current item in the tree widget.
    /// 
    ///     \sa setCurrentItem(), currentItemChanged()
    current_item() -> TreeWidgetItem?,
    ///     \since 4.1
    ///     Returns the current column in the tree widget.
    /// 
    ///     \sa setCurrentItem(), columnCount()
    current_column() -> i32,
    ///   \since 4.1
    ///   Sets the current \a item in the tree widget and the current column to \a column.
    /// 
    ///   \sa currentItem()
    set_current_item(item: *TreeWidgetItemType),
    ///   \since 4.1
    ///   Sets the current \a item in the tree widget and the current column to \a column.
    /// 
    ///   \sa currentItem()
    set_current_item(item: *TreeWidgetItemType, column: i32),
    ///   \since 4.1
    ///   Sets the current \a item in the tree widget and the current column to \a column.
    /// 
    ///   \sa currentItem()
    set_current_item(item: *TreeWidgetItemType, column: i32, command: ItemSelectionModel::SelectionFlags),
    ///   Returns a pointer to the item at the coordinates \a p. The coordinates
    ///   are relative to the tree widget's \l{QAbstractScrollArea::}{viewport()}.
    /// 
    ///   \sa visualItemRect()
    item_at(p: &PointType) -> TreeWidgetItem?,
    ///   Returns a pointer to the item at the coordinates \a p. The coordinates
    ///   are relative to the tree widget's \l{QAbstractScrollArea::}{viewport()}.
    /// 
    ///   \sa visualItemRect()
    item_at(x: i32, y: i32) -> TreeWidgetItem?,
    ///   Returns the rectangle on the viewport occupied by the item at \a item.
    /// 
    ///   \sa itemAt()
    visual_item_rect(item: *TreeWidgetItemType) -> Rect,
    ///   \since 4.1
    /// 
    ///   Returns the column used to sort the contents of the widget.
    /// 
    ///   \sa sortItems()
    sort_column() -> i32,
    ///   Sorts the items in the widget in the specified \a order by the values in
    ///   the given \a column.
    /// 
    ///   \sa sortColumn()
    sort_items(column: i32, order: Rute::SortOrder),
    ///   Starts editing the \a item in the given \a column if it is editable.
    edit_item(item: *TreeWidgetItemType, column: i32),
    ///   Opens a persistent editor for the \a item in the given \a column.
    /// 
    ///   \sa closePersistentEditor(), isPersistentEditorOpen()
    open_persistent_editor(item: *TreeWidgetItemType, column: i32),
    ///   Closes the persistent editor for the \a item in the given \a column.
    /// 
    ///   This function has no effect if no persistent editor is open for this
    ///   combination of item and column.
    /// 
    ///   \sa openPersistentEditor(), isPersistentEditorOpen()
    close_persistent_editor(item: *TreeWidgetItemType, column: i32),
    ///     \since 5.10
    /// 
    ///     Returns whether a persistent editor is open for item \a item in
    ///     column \a column.
    /// 
    ///     \sa openPersistentEditor(), closePersistentEditor()
    is_persistent_editor_open(item: *TreeWidgetItemType, column: i32) -> bool,
    ///     \since 4.1
    /// 
    ///     Returns the widget displayed in the cell specified by \a item and the given \a column.
    /// 
    item_widget(item: *TreeWidgetItemType, column: i32) -> Widget?,
    ///     \since 4.1
    /// 
    ///     Sets the given \a widget to be displayed in the cell specified by the given
    ///     \a item and \a column.
    /// 
    ///     The given \a widget's \l {QWidget::}{autoFillBackground} property must be
    ///     set to true, otherwise the widget's background will be transparent, showing
    ///     both the model data and the tree widget item.
    /// 
    ///     This function should only be used to display static content in the place of
    ///     a tree widget item. If you want to display custom dynamic content or
    ///     implement a custom editor widget, use QTreeView and subclass QItemDelegate
    ///     instead.
    /// 
    ///     This function cannot be called before the item hierarchy has been set up,
    ///     i.e., the QTreeWidgetItem that will hold \a widget must have been added to
    ///     the view before \a widget is set.
    /// 
    ///     \note The tree takes ownership of the widget.
    /// 
    ///     \sa {Delegate Classes}
    set_item_widget(item: *TreeWidgetItemType, column: i32, widget: *WidgetType),
    remove_item_widget(item: *TreeWidgetItemType, column: i32),
    ///   Returns \c true if the \a item is selected; otherwise returns \c false.
    /// 
    ///   \sa itemSelectionChanged()
    /// 
    ///   \obsolete
    /// 
    ///   This function is deprecated. Use \l{QTreeWidgetItem::isSelected()} instead.
    is_item_selected(item: *TreeWidgetItemType) -> bool,
    ///   If \a select is true, the given \a item is selected; otherwise it is
    ///   deselected.
    /// 
    ///   \sa itemSelectionChanged()
    /// 
    ///   \obsolete
    /// 
    ///   This function is deprecated. Use \l{QTreeWidgetItem::setSelected()} instead.
    set_item_selected(item: *TreeWidgetItemType, select: bool),
    ///   Returns a list of all selected non-hidden items.
    /// 
    ///   \sa itemSelectionChanged()
    selected_items() -> [TreeWidgetItem?],
    ///   Returns a list of items that match the given \a text, using the given \a flags, in the given \a column.
    find_items(text: String, flags: Rute::MatchFlags, column: i32) -> [TreeWidgetItem?],
    ///   Returns \c true if the \a item is explicitly hidden, otherwise returns \c false.
    /// 
    ///   \obsolete
    /// 
    ///   This function is deprecated. Use \l{QTreeWidgetItem::isHidden()} instead.
    is_item_hidden(item: *TreeWidgetItemType) -> bool,
    ///   Hides the given \a item if \a hide is true; otherwise shows the item.
    /// 
    ///   \sa itemChanged()
    /// 
    ///   \obsolete
    /// 
    ///   This function is deprecated. Use \l{QTreeWidgetItem::setHidden()} instead.
    set_item_hidden(item: *TreeWidgetItemType, hide: bool),
    ///   Returns \c true if the given \a item is open; otherwise returns \c false.
    /// 
    ///   \sa itemExpanded()
    /// 
    ///   \obsolete
    /// 
    ///   This function is deprecated. Use \l{QTreeWidgetItem::isExpanded()} instead.
    is_item_expanded(item: *TreeWidgetItemType) -> bool,
    ///     Sets the item referred to by \a item to either closed or opened,
    ///     depending on the value of \a expand.
    /// 
    ///     \sa expandItem(), collapseItem(), itemExpanded()
    /// 
    ///     \obsolete
    /// 
    ///     This function is deprecated. Use \l{QTreeWidgetItem::setExpanded()} instead.
    set_item_expanded(item: *TreeWidgetItemType, expand: bool),
    ///   \since 4.3
    /// 
    ///   Returns \c true if the given \a item is set to show only one section over all columns;
    ///   otherwise returns \c false.
    /// 
    ///   \sa setFirstItemColumnSpanned()
    is_first_item_column_spanned(item: *TreeWidgetItemType) -> bool,
    ///   \since 4.3
    /// 
    ///   Sets the given \a item to only show one section for all columns if \a span is true;
    ///   otherwise the item will show one section per column.
    /// 
    ///   \sa isFirstItemColumnSpanned()
    set_first_item_column_spanned(item: *TreeWidgetItemType, span: bool),
    ///   \since 4.3
    /// 
    ///   Returns the item above the given \a item.
    item_above(item: *TreeWidgetItemType) -> TreeWidgetItem?,
    ///   \since 4.3
    /// 
    ///   Returns the item visually below the given \a item.
    item_below(item: *TreeWidgetItemType) -> TreeWidgetItem?,
    [event] set_selection_model(selection_model: *ItemSelectionModelType),
    ///     Ensures that the \a item is visible, scrolling the view if necessary using
    ///     the specified \a hint.
    /// 
    ///     \sa currentItem(), itemAt(), topLevelItem()
    scroll_to_item(item: *TreeWidgetItemType, hint: AbstractItemView::ScrollHint),
    ///     Expands the \a item. This causes the tree containing the item's children
    ///     to be expanded.
    /// 
    ///     \sa collapseItem(), currentItem(), itemAt(), topLevelItem(), itemExpanded()
    expand_item(item: *TreeWidgetItemType),
    ///     Closes the \a item. This causes the tree containing the item's children
    ///     to be collapsed.
    /// 
    ///     \sa expandItem(), currentItem(), itemAt(), topLevelItem()
    collapse_item(item: *TreeWidgetItemType),
    ///     Clears the tree widget by removing all of its items and selections.
    /// 
    ///     \b{Note:} Since each item is removed from the tree widget before being
    ///     deleted, the return value of QTreeWidgetItem::treeWidget() will be invalid
    ///     when called from an item's destructor.
    /// 
    ///     \sa takeTopLevelItem(), topLevelItemCount(), columnCount()
    clear(),
    [signal] item_pressed(item: *TreeWidgetItemType, column: i32),
    [signal] item_clicked(item: *TreeWidgetItemType, column: i32),
    [signal] item_double_clicked(item: *TreeWidgetItemType, column: i32),
    [signal] item_activated(item: *TreeWidgetItemType, column: i32),
    [signal] item_entered(item: *TreeWidgetItemType, column: i32),
    [signal] item_changed(item: *TreeWidgetItemType, column: i32),
    [signal] item_expanded(item: *TreeWidgetItemType),
    [signal] item_collapsed(item: *TreeWidgetItemType),
    [signal] current_item_changed(current: *TreeWidgetItemType, previous: *TreeWidgetItemType),
    [signal] item_selection_changed(),
    ///     \reimp
    [event] event(e: *EventType) -> bool,
    ///     Returns a list of MIME types that can be used to describe a list of
    ///     treewidget items.
    /// 
    ///     \sa mimeData()
    [event] mime_types() -> [String],
    ///     Returns an object that contains a serialized description of the specified
    ///     \a items. The format used to describe the items is obtained from the
    ///     mimeTypes() function.
    /// 
    ///     If the list of items is empty, 0 is returned rather than a serialized
    ///     empty list.
    [event] mime_data(items: [*TreeWidgetItemType]) -> MimeData?,
    [event] drop_mime_data(parent: *TreeWidgetItemType, index: i32, data: *MimeDataType, action: Rute::DropAction) -> bool,
    ///   Returns the drop actions supported by this view.
    /// 
    ///   \sa Qt::DropActions
    [event] supported_drop_actions() -> Rute::DropActions,
    ///   \obsolete
    ///   Returns an empty list
    /// 
    ///   \sa mimeData()
    items(data: *MimeDataType) -> [TreeWidgetItem?],
    ///     \overload
    ///     \internal
    index_from_item(item: *TreeWidgetItemType, column: i32) -> ModelIndex,
    ///     \overload
    ///     \internal
    index_from_item(item: *TreeWidgetItemType, column: i32) -> ModelIndex,
    ///     Returns a pointer to the QTreeWidgetItem associated with the given \a index.
    /// 
    ///     \sa indexFromItem()
    item_from_index(index: &ModelIndexType) -> TreeWidgetItem?,
    [event] drop_event(event: *DropEventType),
}

// vim: syntax=rust expandtab ts=4 sw=4
