///     \class QOpenGLFunctions
///     \brief The QOpenGLFunctions class provides cross-platform access to the OpenGL ES 2.0 API.
///     \since 5.0
///     \ingroup painting-3D
///     \inmodule QtGui
/// 
///     OpenGL ES 2.0 defines a subset of the OpenGL specification that is
///     common across many desktop and embedded OpenGL implementations.
///     However, it can be difficult to use the functions from that subset
///     because they need to be resolved manually on desktop systems.
/// 
///     QOpenGLFunctions provides a guaranteed API that is available on all
///     OpenGL systems and takes care of function resolution on systems
///     that need it.  The recommended way to use QOpenGLFunctions is by
///     direct inheritance:
/// 
///     \code
///     class MyGLWindow : public QWindow, protected QOpenGLFunctions
///     {
///         Q_OBJECT
///     public:
///         MyGLWindow(QScreen *screen = 0);
/// 
///     protected:
///         void initializeGL();
///         void paintGL();
/// 
///         QOpenGLContext *m_context;
///     };
/// 
///     MyGLWindow(QScreen *screen)
///       : QWindow(screen), QOpenGLWidget(parent)
///     {
///         setSurfaceType(OpenGLSurface);
///         create();
/// 
///         // Create an OpenGL context
///         m_context = new QOpenGLContext;
///         m_context->create();
/// 
///         // Setup scene and render it
///         initializeGL();
///         paintGL();
///     }
/// 
///     void MyGLWindow::initializeGL()
///     {
///         m_context->makeCurrent(this);
///         initializeOpenGLFunctions();
///     }
///     \endcode
/// 
///     The \c{paintGL()} function can then use any of the OpenGL ES 2.0
///     functions without explicit resolution, such as glActiveTexture()
///     in the following example:
/// 
///     \code
///     void MyGLWindow::paintGL()
///     {
///         m_context->makeCurrent(this);
///         glActiveTexture(GL_TEXTURE1);
///         glBindTexture(GL_TEXTURE_2D, textureId);
///         ...
///         m_context->swapBuffers(this);
///         m_context->doneCurrent();
///     }
///     \endcode
/// 
///     QOpenGLFunctions can also be used directly for ad-hoc invocation
///     of OpenGL ES 2.0 functions on all platforms:
/// 
///     \code
///     QOpenGLFunctions glFuncs(QOpenGLContext::currentContext());
///     glFuncs.glActiveTexture(GL_TEXTURE1);
///     \endcode
/// 
///     An alternative approach is to query the context's associated
///     QOpenGLFunctions instance. This is somewhat faster than the previous
///     approach due to avoiding the creation of a new instance, but the difference
///     is fairly small since the internal data structures are shared, and function
///     resolving happens only once for a given context, regardless of the number of
///     QOpenGLFunctions instances initialized for it.
/// 
///     \code
///     QOpenGLFunctions *glFuncs = QOpenGLContext::currentContext()->functions();
///     glFuncs->glActiveTexture(GL_TEXTURE1);
///     \endcode
/// 
///     QOpenGLFunctions provides wrappers for all OpenGL ES 2.0
///     functions, including the common subset of OpenGL 1.x and ES
///     2.0. While such functions, for example glClear() or
///     glDrawArrays(), can be called also directly, as long as the
///     application links to the platform-specific OpenGL library, calling
///     them via QOpenGLFunctions enables the possibility of dynamically
///     loading the OpenGL implementation.
/// 
///     The hasOpenGLFeature() and openGLFeatures() functions can be used
///     to determine if the OpenGL implementation has a major OpenGL ES 2.0
///     feature.  For example, the following checks if non power of two
///     textures are available:
/// 
///     \code
///     QOpenGLFunctions funcs(QOpenGLContext::currentContext());
///     bool npot = funcs.hasOpenGLFeature(QOpenGLFunctions::NPOTTextures);
///     \endcode
/// 
///     \sa QOpenGLContext, QSurfaceFormat
[org_name(QOpenGLFunctions)]
enum OpenGLFeature {
    Multitexture,
    Shaders,
    Buffers,
    Framebuffers,
    BlendColor,
    BlendEquation,
    BlendEquationSeparate,
    BlendFuncSeparate,
    BlendSubtract,
    CompressedTextures,
    Multisample,
    StencilSeparate,
    NPOTTextures,
    NPOTTextureRepeat,
    FixedFunctionPipeline,
    TextureRGFormats,
    MultipleRenderTargets,
}


struct OpenGLFunctions {
    ///     Returns the set of features that are present on this system's
    ///     OpenGL implementation.
    /// 
    ///     It is assumed that the QOpenGLContext associated with this function
    ///     resolver is current.
    /// 
    ///     \sa hasOpenGLFeature()
    open_gl_features() -> OpenGLFunctions::OpenGLFeatures,
    ///     Returns \c true if \a feature is present on this system's OpenGL
    ///     implementation; false otherwise.
    /// 
    ///     It is assumed that the QOpenGLContext associated with this function
    ///     resolver is current.
    /// 
    ///     \sa openGLFeatures()
    has_open_gl_feature(feature: OpenGLFunctions::OpenGLFeature) -> bool,
    ///     Initializes OpenGL function resolution for the current context.
    /// 
    ///     After calling this function, the QOpenGLFunctions object can only be
    ///     used with the current context and other contexts that share with it.
    ///     Call initializeOpenGLFunctions() again to change the object's context
    ///     association.
    initialize_open_gl_functions(),
    gl_bind_texture(target: i32, texture: i32),
    gl_blend_func(sfactor: i32, dfactor: i32),
    gl_clear(mask: i32),
    gl_clear_color(red: i32, green: i32, blue: i32, alpha: i32),
    gl_clear_stencil(s: GLint),
    gl_color_mask(red: i32, green: i32, blue: i32, alpha: i32),
    gl_copy_tex_image2_d(target: i32, level: GLint, internalformat: i32, x: GLint, y: GLint, width: i32, height: i32, border: GLint),
    gl_copy_tex_sub_image2_d(target: i32, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: i32, height: i32),
    gl_cull_face(mode: i32),
    gl_delete_textures(n: i32, textures: *i32),
    gl_depth_func(func: i32),
    gl_depth_mask(flag: i32),
    gl_disable(cap: i32),
    gl_draw_arrays(mode: i32, first: GLint, count: i32),
    gl_draw_elements(mode: i32, count: i32, type: i32, indices: *i32),
    gl_enable(cap: i32),
    gl_finish(),
    gl_flush(),
    gl_front_face(mode: i32),
    gl_gen_textures(n: i32, textures: *i32),
    gl_get_booleanv(pname: i32, params: *i32),
    gl_get_error() -> i32,
    gl_get_floatv(pname: i32, params: *i32),
    gl_get_integerv(pname: i32, params: *GLint),
    gl_get_tex_parameterfv(target: i32, pname: i32, params: *i32),
    gl_get_tex_parameteriv(target: i32, pname: i32, params: *GLint),
    gl_hint(target: i32, mode: i32),
    gl_is_enabled(cap: i32) -> i32,
    gl_is_texture(texture: i32) -> i32,
    gl_line_width(width: i32),
    gl_pixel_storei(pname: i32, param: GLint),
    gl_polygon_offset(factor: i32, units: i32),
    gl_read_pixels(x: GLint, y: GLint, width: i32, height: i32, format: i32, type: i32, pixels: *i32),
    gl_scissor(x: GLint, y: GLint, width: i32, height: i32),
    gl_stencil_func(func: i32, ref: GLint, mask: i32),
    gl_stencil_mask(mask: i32),
    gl_stencil_op(fail: i32, zfail: i32, zpass: i32),
    gl_tex_image2_d(target: i32, level: GLint, internalformat: GLint, width: i32, height: i32, border: GLint, format: i32, type: i32, pixels: *i32),
    gl_tex_parameterf(target: i32, pname: i32, param: i32),
    gl_tex_parameterfv(target: i32, pname: i32, params: *i32),
    gl_tex_parameteri(target: i32, pname: i32, param: GLint),
    gl_tex_parameteriv(target: i32, pname: i32, params: *GLint),
    gl_tex_sub_image2_d(target: i32, level: GLint, xoffset: GLint, yoffset: GLint, width: i32, height: i32, format: i32, type: i32, pixels: *i32),
    gl_viewport(x: GLint, y: GLint, width: i32, height: i32),
    gl_active_texture(texture: i32),
    gl_attach_shader(program: i32, shader: i32),
    gl_bind_buffer(target: i32, buffer: i32),
    gl_bind_framebuffer(target: i32, framebuffer: i32),
    gl_bind_renderbuffer(target: i32, renderbuffer: i32),
    gl_blend_color(red: i32, green: i32, blue: i32, alpha: i32),
    gl_blend_equation(mode: i32),
    gl_blend_equation_separate(mode_rgb: i32, mode_alpha: i32),
    gl_blend_func_separate(src_rgb: i32, dst_rgb: i32, src_alpha: i32, dst_alpha: i32),
    gl_buffer_data(target: i32, size: qopengl_GLsizeiptr, data: *void, usage: i32),
    gl_buffer_sub_data(target: i32, offset: qopengl_GLintptr, size: qopengl_GLsizeiptr, data: *void),
    gl_check_framebuffer_status(target: i32) -> i32,
    gl_clear_depthf(depth: i32),
    gl_compile_shader(shader: i32),
    gl_compressed_tex_image2_d(target: i32, level: GLint, internalformat: i32, width: i32, height: i32, border: GLint, image_size: i32, data: *void),
    gl_compressed_tex_sub_image2_d(target: i32, level: GLint, xoffset: GLint, yoffset: GLint, width: i32, height: i32, format: i32, image_size: i32, data: *void),
    gl_create_program() -> i32,
    gl_create_shader(type: i32) -> i32,
    gl_delete_buffers(n: i32, buffers: *i32),
    gl_delete_framebuffers(n: i32, framebuffers: *i32),
    gl_delete_program(program: i32),
    gl_delete_renderbuffers(n: i32, renderbuffers: *i32),
    gl_delete_shader(shader: i32),
    gl_depth_rangef(z_near: i32, z_far: i32),
    gl_detach_shader(program: i32, shader: i32),
    gl_framebuffer_renderbuffer(target: i32, attachment: i32, renderbuffertarget: i32, renderbuffer: i32),
    gl_framebuffer_texture2_d(target: i32, attachment: i32, textarget: i32, texture: i32, level: GLint),
    gl_gen_buffers(n: i32, buffers: *i32),
    gl_generate_mipmap(target: i32),
    gl_gen_framebuffers(n: i32, framebuffers: *i32),
    gl_gen_renderbuffers(n: i32, renderbuffers: *i32),
    gl_get_active_uniform(program: i32, index: i32, bufsize: i32, length: *i32, size: *GLint, type: *i32, name: *char),
    gl_get_attached_shaders(program: i32, maxcount: i32, count: *i32, shaders: *i32),
    gl_get_buffer_parameteriv(target: i32, pname: i32, params: *GLint),
    gl_get_framebuffer_attachment_parameteriv(target: i32, attachment: i32, pname: i32, params: *GLint),
    gl_get_programiv(program: i32, pname: i32, params: *GLint),
    gl_get_program_info_log(program: i32, bufsize: i32, length: *i32, infolog: *char),
    gl_get_renderbuffer_parameteriv(target: i32, pname: i32, params: *GLint),
    gl_get_shaderiv(shader: i32, pname: i32, params: *GLint),
    gl_get_shader_info_log(shader: i32, bufsize: i32, length: *i32, infolog: *char),
    gl_get_shader_precision_format(shadertype: i32, precisiontype: i32, range: *GLint, precision: *GLint),
    gl_get_shader_source(shader: i32, bufsize: i32, length: *i32, source: *char),
    gl_get_uniformfv(program: i32, location: GLint, params: *i32),
    gl_get_uniformiv(program: i32, location: GLint, params: *GLint),
    gl_get_uniform_location(program: i32, name: *char) -> i32,
    gl_is_buffer(buffer: i32) -> i32,
    gl_is_framebuffer(framebuffer: i32) -> i32,
    gl_is_program(program: i32) -> i32,
    gl_is_renderbuffer(renderbuffer: i32) -> i32,
    gl_is_shader(shader: i32) -> i32,
    gl_link_program(program: i32),
    gl_release_shader_compiler(),
    gl_renderbuffer_storage(target: i32, internalformat: i32, width: i32, height: i32),
    gl_sample_coverage(value: i32, invert: i32),
    gl_shader_binary(n: GLint, shaders: *i32, binaryformat: i32, binary: *void, length: GLint),
    gl_shader_source(shader: i32, count: i32, string: *char, length: *GLint),
    gl_stencil_func_separate(face: i32, func: i32, ref: GLint, mask: i32),
    gl_stencil_mask_separate(face: i32, mask: i32),
    gl_stencil_op_separate(face: i32, fail: i32, zfail: i32, zpass: i32),
    gl_uniform1f(location: GLint, x: i32),
    gl_uniform1fv(location: GLint, count: i32, v: *i32),
    gl_uniform1i(location: GLint, x: GLint),
    gl_uniform1iv(location: GLint, count: i32, v: *GLint),
    gl_uniform2f(location: GLint, x: i32, y: i32),
    gl_uniform2fv(location: GLint, count: i32, v: *i32),
    gl_uniform2i(location: GLint, x: GLint, y: GLint),
    gl_uniform2iv(location: GLint, count: i32, v: *GLint),
    gl_uniform3f(location: GLint, x: i32, y: i32, z: i32),
    gl_uniform3fv(location: GLint, count: i32, v: *i32),
    gl_uniform3i(location: GLint, x: GLint, y: GLint, z: GLint),
    gl_uniform3iv(location: GLint, count: i32, v: *GLint),
    gl_uniform4f(location: GLint, x: i32, y: i32, z: i32, w: i32),
    gl_uniform4fv(location: GLint, count: i32, v: *i32),
    gl_uniform4i(location: GLint, x: GLint, y: GLint, z: GLint, w: GLint),
    gl_uniform4iv(location: GLint, count: i32, v: *GLint),
    gl_use_program(program: i32),
    gl_validate_program(program: i32),
    [static] is_initialized(d: *OpenGLFunctionsPrivateType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
