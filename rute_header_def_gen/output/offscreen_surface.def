///     \class QOffscreenSurface
///     \inmodule QtGui
///     \since 5.1
///     \brief The QOffscreenSurface class represents an offscreen surface in the underlying platform.
/// 
///     QOffscreenSurface is intended to be used with QOpenGLContext to allow rendering with OpenGL in
///     an arbitrary thread without the need to create a QWindow.
/// 
///     Even though the surface is typically renderable, the surface's pixels are not accessible.
///     QOffscreenSurface should only be used to create OpenGL resources such as textures
///     or framebuffer objects.
/// 
///     An application will typically use QOffscreenSurface to perform some time-consuming tasks in a
///     separate thread in order to avoid stalling the main rendering thread. Resources created in the
///     QOffscreenSurface's context can be shared with the main OpenGL context. Some common use cases
///     are asynchronous texture uploads or rendering into a QOpenGLFramebufferObject.
/// 
///     How the offscreen surface is implemented depends on the underlying platform, but it will
///     typically use a pixel buffer (pbuffer). If the platform doesn't implement or support
///     offscreen surfaces, QOffscreenSurface will use an invisible QWindow internally.
/// 
///     \note Due to the fact that QOffscreenSurface is backed by a QWindow on some platforms,
///     cross-platform applications must ensure that create() is only called on the main (GUI)
///     thread. The QOffscreenSurface is then safe to be used with
///     \l{QOpenGLContext::makeCurrent()}{makeCurrent()} on other threads, but the
///     initialization and destruction must always happen on the main (GUI) thread.
/// 
///     \note In order to create an offscreen surface that is guaranteed to be compatible with
///     a given context and window, make sure to set the format to the context's or the
///     window's actual format, that is, the QSurfaceFormat returned from
///     QOpenGLContext::format() or QWindow::format() \e{after the context or window has been
///     created}. Passing the format returned from QWindow::requestedFormat() to setFormat()
///     may result in an incompatible offscreen surface since the underlying windowing system
///     interface may offer a different set of configurations for window and pbuffer surfaces.
/// 
///     \note Some platforms may utilize a surfaceless context extension (for example
///     EGL_KHR_surfaceless_context) when available. In this case there will be no underlying
///     native surface. For the use cases of QOffscreenSurface (rendering to FBOs, texture
///     upload) this is not a problem.
struct OffscreenSurface : Object, Surface {
    ///     Returns the surface type of the offscreen surface.
    /// 
    ///     The surface type of an offscreen surface is always QSurface::OpenGLSurface.
    [event] surface_type() -> Surface::SurfaceType,
    ///     Allocates the platform resources associated with the offscreen surface.
    /// 
    ///     It is at this point that the surface format set using setFormat() gets resolved
    ///     into an actual native surface.
    /// 
    ///     Call destroy() to free the platform resources if necessary.
    /// 
    ///     \note Some platforms require this function to be called on the main (GUI) thread.
    /// 
    ///     \sa destroy()
    create(),
    ///     Returns \c true if this offscreen surface is valid; otherwise returns \c false.
    /// 
    ///     The offscreen surface is valid if the platform resources have been successfuly allocated.
    /// 
    ///     \sa create()
    is_valid() -> bool,
    ///     Sets the offscreen surface \a format.
    /// 
    ///     The surface format will be resolved in the create() function. Calling
    ///     this function after create() will not re-resolve the surface format of the native surface.
    /// 
    ///     \sa create(), destroy()
    set_format(format: &SurfaceFormatType),
    ///     Returns the actual format of this offscreen surface.
    /// 
    ///     After the offscreen surface has been created, this function will return the actual
    ///     surface format of the surface. It might differ from the requested format if the requested
    ///     format could not be fulfilled by the platform.
    /// 
    ///     \sa create(), requestedFormat()
    [event] format() -> SurfaceFormat,
    requested_format() -> SurfaceFormat,
    ///     Returns the size of the offscreen surface.
    [event] size() -> Size,
    ///     Returns the screen to which the offscreen surface is connected.
    /// 
    ///     \sa setScreen()
    screen() -> Screen?,
    ///     Sets the screen to which the offscreen surface is connected.
    /// 
    ///     If the offscreen surface has been created, it will be recreated on the \a newScreen.
    /// 
    ///     \sa screen()
    set_screen(screen: *ScreenType),
    ///     Returns the platform offscreen surface corresponding to the offscreen surface.
    /// 
    ///     \internal
    handle() -> PlatformOffscreenSurface?,
    ///     Returns an optional native handle to which the offscreen surface is connected.
    /// 
    ///     \since 5.9
    ///     \sa setNativeHandle()
    native_handle(),
    ///     Sets the native handle to which the offscreen surface is connected to \a handle.
    /// 
    ///     The native handle will be resolved in the create() function. Calling
    ///     this function after create() will not re-create a native surface.
    /// 
    ///     \note The interpretation of the native handle is platform specific.  Only
    ///     some platforms will support adopting native handles of offscreen surfaces
    ///     and platforms that do not implement this support will ignore the handle.
    /// 
    ///     \since 5.9
    ///     \sa nativeHandle()
    set_native_handle(handle: *void),
    [signal] screen_changed(screen: *ScreenType),
}

// vim: syntax=rust expandtab ts=4 sw=4
