///     \class QDataStream
///     \inmodule QtCore
///     \reentrant
///     \brief The QDataStream class provides serialization of binary data
///     to a QIODevice.
/// 
///     \ingroup io
/// 
/// 
///     A data stream is a binary stream of encoded information which is
///     100% independent of the host computer's operating system, CPU or
///     byte order. For example, a data stream that is written by a PC
///     under Windows can be read by a Sun SPARC running Solaris.
/// 
///     You can also use a data stream to read/write \l{raw}{raw
///     unencoded binary data}. If you want a "parsing" input stream, see
///     QTextStream.
/// 
///     The QDataStream class implements the serialization of C++'s basic
///     data types, like \c char, \c short, \c int, \c{char *}, etc.
///     Serialization of more complex data is accomplished by breaking up
///     the data into primitive units.
/// 
///     A data stream cooperates closely with a QIODevice. A QIODevice
///     represents an input/output medium one can read data from and write
///     data to. The QFile class is an example of an I/O device.
/// 
///     Example (write binary data to a stream):
/// 
///     \snippet code/src_corelib_io_qdatastream.cpp 0
/// 
///     Example (read binary data from a stream):
/// 
///     \snippet code/src_corelib_io_qdatastream.cpp 1
/// 
///     Each item written to the stream is written in a predefined binary
///     format that varies depending on the item's type. Supported Qt
///     types include QBrush, QColor, QDateTime, QFont, QPixmap, QString,
///     QVariant and many others. For the complete list of all Qt types
///     supporting data streaming see \l{Serializing Qt Data Types}.
/// 
///     For integers it is best to always cast to a Qt integer type for
///     writing, and to read back into the same Qt integer type. This
///     ensures that you get integers of the size you want and insulates
///     you from compiler and platform differences.
/// 
///     To take one example, a \c{char *} string is written as a 32-bit
///     integer equal to the length of the string including the '\\0' byte,
///     followed by all the characters of the string including the
///     '\\0' byte. When reading a \c{char *} string, 4 bytes are read to
///     create the 32-bit length value, then that many characters for the
///     \c {char *} string including the '\\0' terminator are read.
/// 
///     The initial I/O device is usually set in the constructor, but can be
///     changed with setDevice(). If you've reached the end of the data
///     (or if there is no I/O device set) atEnd() will return true.
/// 
///     \section1 Versioning
/// 
///     QDataStream's binary format has evolved since Qt 1.0, and is
///     likely to continue evolving to reflect changes done in Qt. When
///     inputting or outputting complex types, it's very important to
///     make sure that the same version of the stream (version()) is used
///     for reading and writing. If you need both forward and backward
///     compatibility, you can hardcode the version number in the
///     application:
/// 
///     \snippet code/src_corelib_io_qdatastream.cpp 2
/// 
///     If you are producing a new binary data format, such as a file
///     format for documents created by your application, you could use a
///     QDataStream to write the data in a portable format. Typically, you
///     would write a brief header containing a magic string and a version
///     number to give yourself room for future expansion. For example:
/// 
///     \snippet code/src_corelib_io_qdatastream.cpp 3
/// 
///     Then read it in with:
/// 
///     \snippet code/src_corelib_io_qdatastream.cpp 4
/// 
///     You can select which byte order to use when serializing data. The
///     default setting is big endian (MSB first). Changing it to little
///     endian breaks the portability (unless the reader also changes to
///     little endian). We recommend keeping this setting unless you have
///     special requirements.
/// 
///     \target raw
///     \section1 Reading and Writing Raw Binary Data
/// 
///     You may wish to read/write your own raw binary data to/from the
///     data stream directly. Data may be read from the stream into a
///     preallocated \c{char *} using readRawData(). Similarly data can be
///     written to the stream using writeRawData(). Note that any
///     encoding/decoding of the data must be done by you.
/// 
///     A similar pair of functions is readBytes() and writeBytes(). These
///     differ from their \e raw counterparts as follows: readBytes()
///     reads a quint32 which is taken to be the length of the data to be
///     read, then that number of bytes is read into the preallocated
///     \c{char *}; writeBytes() writes a quint32 containing the length of the
///     data, followed by the data. Note that any encoding/decoding of
///     the data (apart from the length quint32) must be done by you.
/// 
///     \section1 Reading and Writing Qt Collection Classes
/// 
///     The Qt container classes can also be serialized to a QDataStream.
///     These include QList, QLinkedList, QVector, QSet, QHash, and QMap.
///     The stream operators are declared as non-members of the classes.
/// 
///     \target Serializing Qt Classes
///     \section1 Reading and Writing Other Qt Classes
/// 
///     In addition to the overloaded stream operators documented here,
///     any Qt classes that you might want to serialize to a QDataStream
///     will have appropriate stream operators declared as non-member of
///     the class:
/// 
///     \code
///     QDataStream &operator<<(QDataStream &, const QXxx &);
///     QDataStream &operator>>(QDataStream &, QXxx &);
///     \endcode
/// 
///     For example, here are the stream operators declared as non-members
///     of the QImage class:
/// 
///     \code
///     QDataStream & operator<< (QDataStream& stream, const QImage& image);
///     QDataStream & operator>> (QDataStream& stream, QImage& image);
///     \endcode
/// 
///     To see if your favorite Qt class has similar stream operators
///     defined, check the \b {Related Non-Members} section of the
///     class's documentation page.
/// 
///     \section1 Using Read Transactions
/// 
///     When a data stream operates on an asynchronous device, the chunks of data
///     can arrive at arbitrary points in time. The QDataStream class implements
///     a transaction mechanism that provides the ability to read the data
///     atomically with a series of stream operators. As an example, you can
///     handle incomplete reads from a socket by using a transaction in a slot
///     connected to the readyRead() signal:
/// 
///     \snippet code/src_corelib_io_qdatastream.cpp 6
/// 
///     If no full packet is received, this code restores the stream to the
///     initial position, after which you need to wait for more data to arrive.
/// 
///     \sa QTextStream, QVariant
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QDataStream)]
enum Version {
    Qt_1_0,
    Qt_2_0,
    Qt_2_1,
    Qt_3_0,
    Qt_3_1,
    Qt_3_3,
    Qt_4_0,
    Qt_4_1,
    Qt_4_2,
    Qt_4_3,
    Qt_4_4,
    Qt_4_5,
    Qt_4_6,
    Qt_4_7,
    Qt_4_8,
    Qt_4_9,
    Qt_5_0,
    Qt_5_1,
    Qt_5_2,
    Qt_5_3,
    Qt_5_4,
    Qt_5_5,
    Qt_5_6,
    Qt_5_7,
    Qt_5_8,
    Qt_5_9,
    Qt_5_10,
    Qt_5_11,
    Qt_DefaultCompiledVersion,
}

[org_name(QDataStream)]
enum ByteOrder {
    BigEndian,
    LittleEndian,
}

[org_name(QDataStream)]
enum Status {
    Ok,
    ReadPastEnd,
    ReadCorruptData,
    WriteFailed,
}

[org_name(QDataStream)]
enum FloatingPointPrecision {
    SinglePrecision,
    DoublePrecision,
}


struct DataStream {
    device() -> IODevice?,
    ///     void QDataStream::setDevice(QIODevice *d)
    /// 
    ///     Sets the I/O device to \a d, which can be 0
    ///     to unset to current I/O device.
    /// 
    ///     \sa device()
    set_device(arg0: *IODeviceType),
    ///     \obsolete
    ///     Unsets the I/O device.
    ///     Use setDevice(0) instead.
    unset_device(),
    ///     \fn bool QDataStream::atEnd() const
    /// 
    ///     Returns \c true if the I/O device has reached the end position (end of
    ///     the stream or file) or if there is no I/O device set; otherwise
    ///     returns \c false.
    /// 
    ///     \sa QIODevice::atEnd()
    at_end() -> bool,
    ///     Returns the status of the data stream.
    /// 
    ///     \sa Status, setStatus(), resetStatus()
    status() -> DataStream::Status,
    ///     Sets the status of the data stream to the \a status given.
    /// 
    ///     Subsequent calls to setStatus() are ignored until resetStatus()
    ///     is called.
    /// 
    ///     \sa Status, status(), resetStatus()
    set_status(status: DataStream::Status),
    ///     Resets the status of the data stream.
    /// 
    ///     \sa Status, status(), setStatus()
    reset_status(),
    ///     Returns the floating point precision of the data stream.
    /// 
    ///     \since 4.6
    /// 
    ///     \sa FloatingPointPrecision, setFloatingPointPrecision()
    floating_point_precision() -> DataStream::FloatingPointPrecision,
    ///     Sets the floating point precision of the data stream to \a precision. If the floating point precision is
    ///     DoublePrecision and the version of the data stream is Qt_4_6 or higher, all floating point
    ///     numbers will be written and read with 64-bit precision. If the floating point precision is
    ///     SinglePrecision and the version is Qt_4_6 or higher, all floating point numbers will be written
    ///     and read with 32-bit precision.
    /// 
    ///     For versions prior to Qt_4_6, the precision of floating point numbers in the data stream depends
    ///     on the stream operator called.
    /// 
    ///     The default is DoublePrecision.
    /// 
    ///     Note that this property does not affect the serialization or deserialization of \c qfloat16
    ///     instances.
    /// 
    ///     \warning This property must be set to the same value on the object that writes and the object
    ///     that reads the data stream.
    /// 
    ///     \since 4.6
    set_floating_point_precision(precision: DataStream::FloatingPointPrecision),
    byte_order() -> DataStream::ByteOrder,
    ///     Sets the serialization byte order to \a bo.
    /// 
    ///     The \a bo parameter can be QDataStream::BigEndian or
    ///     QDataStream::LittleEndian.
    /// 
    ///     The default setting is big endian. We recommend leaving this
    ///     setting unless you have special requirements.
    /// 
    ///     \sa byteOrder()
    set_byte_order(arg0: DataStream::ByteOrder),
    version() -> i32,
    set_version(arg0: i32),
    read_bytes(arg0: &*char, len: &uint) -> DataStream?,
    ///     Reads at most \a len bytes from the stream into \a s and returns the number of
    ///     bytes read. If an error occurs, this function returns -1.
    /// 
    ///     The buffer \a s must be preallocated. The data is \e not decoded.
    /// 
    ///     \sa readBytes(), QIODevice::read(), writeRawData()
    read_raw_data(arg0: *char, len: i32) -> i32,
    write_bytes(arg0: *char, len: uint) -> DataStream?,
    ///     Writes \a len bytes from \a s to the stream. Returns the
    ///     number of bytes actually written, or -1 on error.
    ///     The data is \e not encoded.
    /// 
    ///     \sa writeBytes(), QIODevice::write(), readRawData()
    write_raw_data(arg0: *char, len: i32) -> i32,
    ///     \since 4.1
    /// 
    ///     Skips \a len bytes from the device. Returns the number of bytes
    ///     actually skipped, or -1 on error.
    /// 
    ///     This is equivalent to calling readRawData() on a buffer of length
    ///     \a len and ignoring the buffer.
    /// 
    ///     \sa QIODevice::seek()
    skip_raw_data(len: i32) -> i32,
    ///     \since 5.7
    /// 
    ///     Starts a new read transaction on the stream.
    /// 
    ///     Defines a restorable point within the sequence of read operations. For
    ///     sequential devices, read data will be duplicated internally to allow
    ///     recovery in case of incomplete reads. For random-access devices,
    ///     this function saves the current position of the stream. Call
    ///     commitTransaction(), rollbackTransaction(), or abortTransaction() to
    ///     finish the current transaction.
    /// 
    ///     Once a transaction is started, subsequent calls to this function will make
    ///     the transaction recursive. Inner transactions act as agents of the
    ///     outermost transaction (i.e., report the status of read operations to the
    ///     outermost transaction, which can restore the position of the stream).
    /// 
    ///     \note Restoring to the point of the nested startTransaction() call is not
    ///     supported.
    /// 
    ///     When an error occurs during a transaction (including an inner transaction
    ///     failing), reading from the data stream is suspended (all subsequent read
    ///     operations return empty/zero values) and subsequent inner transactions are
    ///     forced to fail. Starting a new outermost transaction recovers from this
    ///     state. This behavior makes it unnecessary to error-check every read
    ///     operation separately.
    /// 
    ///     \sa commitTransaction(), rollbackTransaction(), abortTransaction()
    start_transaction(),
    ///     \since 5.7
    /// 
    ///     Completes a read transaction. Returns \c true if no read errors have
    ///     occurred during the transaction; otherwise returns \c false.
    /// 
    ///     If called on an inner transaction, committing will be postponed until
    ///     the outermost commitTransaction(), rollbackTransaction(), or
    ///     abortTransaction() call occurs.
    /// 
    ///     Otherwise, if the stream status indicates reading past the end of the
    ///     data, this function restores the stream data to the point of the
    ///     startTransaction() call. When this situation occurs, you need to wait for
    ///     more data to arrive, after which you start a new transaction. If the data
    ///     stream has read corrupt data or any of the inner transactions was aborted,
    ///     this function aborts the transaction.
    /// 
    ///     \sa startTransaction(), rollbackTransaction(), abortTransaction()
    commit_transaction() -> bool,
    ///     \since 5.7
    /// 
    ///     Reverts a read transaction.
    /// 
    ///     This function is commonly used to rollback the transaction when an
    ///     incomplete read was detected prior to committing the transaction.
    /// 
    ///     If called on an inner transaction, reverting is delegated to the outermost
    ///     transaction, and subsequently started inner transactions are forced to
    ///     fail.
    /// 
    ///     For the outermost transaction, restores the stream data to the point of
    ///     the startTransaction() call. If the data stream has read corrupt data or
    ///     any of the inner transactions was aborted, this function aborts the
    ///     transaction.
    /// 
    ///     If the preceding stream operations were successful, sets the status of the
    ///     data stream to \value ReadPastEnd.
    /// 
    ///     \sa startTransaction(), commitTransaction(), abortTransaction()
    rollback_transaction(),
    ///     \since 5.7
    /// 
    ///     Aborts a read transaction.
    /// 
    ///     This function is commonly used to discard the transaction after
    ///     higher-level protocol errors or loss of stream synchronization.
    /// 
    ///     If called on an inner transaction, aborting is delegated to the outermost
    ///     transaction, and subsequently started inner transactions are forced to
    ///     fail.
    /// 
    ///     For the outermost transaction, discards the restoration point and any
    ///     internally duplicated data of the stream. Will not affect the current
    ///     read position of the stream.
    /// 
    ///     Sets the status of the data stream to \value ReadCorruptData.
    /// 
    ///     \sa startTransaction(), commitTransaction(), rollbackTransaction()
    abort_transaction(),
}

// vim: syntax=rust expandtab ts=4 sw=4
