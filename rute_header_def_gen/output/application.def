///     \class QApplication
///     \brief The QApplication class manages the GUI application's control
///     flow and main settings.
/// 
///     \inmodule QtWidgets
/// 
///     QApplication specializes QGuiApplication with some functionality needed
///     for QWidget-based applications. It handles widget specific initialization,
///     finalization.
/// 
///     For any GUI application using Qt, there is precisely \b one QApplication
///     object, no matter whether the application has 0, 1, 2 or more windows at
///     any given time. For non-QWidget based Qt applications, use QGuiApplication instead,
///     as it does not depend on the \l QtWidgets library.
/// 
///     Some GUI applications provide a special batch mode ie. provide command line
///     arguments for executing tasks without manual intervention. In such non-GUI
///     mode, it is often sufficient to instantiate a plain QCoreApplication to
///     avoid unnecessarily initializing resources needed for a graphical user
///     interface. The following example shows how to dynamically create an
///     appropriate type of application instance:
/// 
///     \snippet code/src_gui_kernel_qapplication.cpp 0
/// 
///     The QApplication object is accessible through the instance() function that
///     returns a pointer equivalent to the global qApp pointer.
/// 
///     QApplication's main areas of responsibility are:
///         \list
///             \li  It initializes the application with the user's desktop settings
///                 such as palette(), font() and doubleClickInterval(). It keeps
///                 track of these properties in case the user changes the desktop
///                 globally, for example through some kind of control panel.
/// 
///             \li  It performs event handling, meaning that it receives events
///                 from the underlying window system and dispatches them to the
///                 relevant widgets. By using sendEvent() and postEvent() you can
///                 send your own events to widgets.
/// 
///             \li  It parses common command line arguments and sets its internal
///                 state accordingly. See the \l{QApplication::QApplication()}
///                 {constructor documentation} below for more details.
/// 
///             \li  It defines the application's look and feel, which is
///                 encapsulated in a QStyle object. This can be changed at runtime
///                 with setStyle().
/// 
///             \li  It specifies how the application is to allocate colors. See
///                 setColorSpec() for details.
/// 
///             \li  It provides localization of strings that are visible to the
///                 user via translate().
/// 
///             \li  It provides some magical objects like the desktop() and the
///                 clipboard().
/// 
///             \li  It knows about the application's windows. You can ask which
///                 widget is at a certain position using widgetAt(), get a list of
///                 topLevelWidgets() and closeAllWindows(), etc.
/// 
///             \li  It manages the application's mouse cursor handling, see
///                 setOverrideCursor()
///         \endlist
/// 
///     Since the QApplication object does so much initialization, it \e{must} be
///     created before any other objects related to the user interface are created.
///     QApplication also deals with common command line arguments. Hence, it is
///     usually a good idea to create it \e before any interpretation or
///     modification of \c argv is done in the application itself.
/// 
///     \table
///     \header
///         \li{2,1} Groups of functions
/// 
///         \row
///         \li  System settings
///         \li  desktopSettingsAware(),
///             setDesktopSettingsAware(),
///             cursorFlashTime(),
///             setCursorFlashTime(),
///             doubleClickInterval(),
///             setDoubleClickInterval(),
///             setKeyboardInputInterval(),
///             wheelScrollLines(),
///             setWheelScrollLines(),
///             palette(),
///             setPalette(),
///             font(),
///             setFont(),
///             fontMetrics().
/// 
///         \row
///         \li  Event handling
///         \li  exec(),
///             processEvents(),
///             exit(),
///             quit().
///             sendEvent(),
///             postEvent(),
///             sendPostedEvents(),
///             removePostedEvents(),
///             hasPendingEvents(),
///             notify().
/// 
///         \row
///         \li  GUI Styles
///         \li  style(),
///             setStyle().
/// 
///         \row
///         \li  Color usage
///         \li  colorSpec(),
///             setColorSpec().
/// 
///         \row
///         \li  Text handling
///         \li  installTranslator(),
///             removeTranslator()
///             translate().
/// 
///         \row
///         \li  Widgets
///         \li  allWidgets(),
///             topLevelWidgets(),
///             desktop(),
///             activePopupWidget(),
///             activeModalWidget(),
///             clipboard(),
///             focusWidget(),
///             activeWindow(),
///             widgetAt().
/// 
///         \row
///         \li  Advanced cursor handling
///         \li  overrideCursor(),
///             setOverrideCursor(),
///             restoreOverrideCursor().
/// 
///         \row
///         \li  Miscellaneous
///         \li  closeAllWindows(),
///             startingUp(),
///             closingDown().
///     \endtable
/// 
///     \sa QCoreApplication, QAbstractEventDispatcher, QEventLoop, QSettings
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QApplication)]
enum ColorSpec {
    NormalColor,
    CustomColor,
    ManyColor,
}

struct Application : GuiApplication {
    ///     Returns the application's style object.
    /// 
    ///     \sa setStyle(), QStyle
    [static] style() -> Style?,
    ///     \overload
    /// 
    ///     Requests a QStyle object for \a style from the QStyleFactory.
    /// 
    ///     The string must be one of the QStyleFactory::keys(), typically one of
    ///     "windows", "windowsvista", "fusion", or "macintosh". Style
    ///     names are case insensitive.
    /// 
    ///     Returns 0 if an unknown \a style is passed, otherwise the QStyle object
    ///     returned is set as the application's GUI style.
    /// 
    ///     \warning To ensure that the application's style is set correctly, it is
    ///     best to call this function before the QApplication constructor, if
    ///     possible.
    [static] set_style(arg0: *StyleType),
    ///     \overload
    /// 
    ///     Requests a QStyle object for \a style from the QStyleFactory.
    /// 
    ///     The string must be one of the QStyleFactory::keys(), typically one of
    ///     "windows", "windowsvista", "fusion", or "macintosh". Style
    ///     names are case insensitive.
    /// 
    ///     Returns 0 if an unknown \a style is passed, otherwise the QStyle object
    ///     returned is set as the application's GUI style.
    /// 
    ///     \warning To ensure that the application's style is set correctly, it is
    ///     best to call this function before the QApplication constructor, if
    ///     possible.
    [static] set_style(arg0: String) -> Style?,
    ///     Returns the color specification.
    ///     \obsolete
    /// 
    ///     \sa QApplication::setColorSpec()
    [static] color_spec() -> i32,
    ///     Sets the color specification for the application to \a spec.
    ///     \obsolete
    /// 
    ///     This call has no effect.
    /// 
    ///     The color specification controls how the application allocates colors when
    ///     run on a display with a limited amount of colors, e.g. 8 bit / 256 color
    ///     displays.
    /// 
    ///     The color specification must be set before you create the QApplication
    ///     object.
    /// 
    ///     The options are:
    ///     \list
    ///         \li  QApplication::NormalColor. This is the default color allocation
    ///             strategy. Use this option if your application uses buttons, menus,
    ///             texts and pixmaps with few colors. With this option, the
    ///             application uses system global colors. This works fine for most
    ///             applications under X11, but on the Windows platform, it may cause
    ///             dithering of non-standard colors.
    ///         \li  QApplication::CustomColor. Use this option if your application
    ///             needs a small number of custom colors. On X11, this option is the
    ///             same as NormalColor. On Windows, Qt creates a Windows palette, and
    ///             allocates colors to it on demand.
    ///         \li  QApplication::ManyColor. Use this option if your application is
    ///             very color hungry, e.g., it requires thousands of colors. \br
    ///             Under X11 the effect is:
    ///             \list
    ///                 \li  For 256-color displays which have at best a 256 color true
    ///                     color visual, the default visual is used, and colors are
    ///                     allocated from a color cube. The color cube is the 6x6x6
    ///                     (216 color) "Web palette" (the red, green, and blue
    ///                     components always have one of the following values: 0x00,
    ///                     0x33, 0x66, 0x99, 0xCC, or 0xFF), but the number of colors
    ///                     can be changed by the \e -ncols option. The user can force
    ///                     the application to use the true color visual with the
    ///                     \l{QApplication::QApplication()}{-visual} option.
    ///                 \li  For 256-color displays which have a true color visual with
    ///                     more than 256 colors, use that visual. Silicon Graphics X
    ///                     servers this feature, for example. They provide an 8 bit
    ///                     visual by default but can deliver true color when asked.
    ///             \endlist
    ///             On Windows, Qt creates a Windows palette, and fills it with a color
    ///             cube.
    ///     \endlist
    /// 
    ///     Be aware that the CustomColor and ManyColor choices may lead to colormap
    ///     flashing: The foreground application gets (most) of the available colors,
    ///     while the background windows will look less attractive.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_gui_kernel_qapplication.cpp 2
    /// 
    ///     \sa colorSpec()
    [static] set_color_spec(arg0: i32),
    ///     \overload
    /// 
    ///     Returns the palette for widgets of the given \a className.
    /// 
    ///     \sa setPalette(), QWidget::palette()
    [static] palette(arg0: *WidgetType) -> Palette,
    ///     \overload
    /// 
    ///     Returns the palette for widgets of the given \a className.
    /// 
    ///     \sa setPalette(), QWidget::palette()
    [static] palette(class_name: *char) -> Palette,
    ///     Changes the default application palette to \a palette.
    /// 
    ///     If \a className is passed, the change applies only to widgets that inherit
    ///     \a className (as reported by QObject::inherits()). If \a className is left
    ///     0, the change affects all widgets, thus overriding any previously set class
    ///     specific palettes.
    /// 
    ///     The palette may be changed according to the current GUI style in
    ///     QStyle::polish().
    /// 
    ///     \warning Do not use this function in conjunction with \l{Qt Style Sheets}.
    ///     When using style sheets, the palette of a widget can be customized using
    ///     the "color", "background-color", "selection-color",
    ///     "selection-background-color" and "alternate-background-color".
    /// 
    ///     \note Some styles do not use the palette for all drawing, for instance, if
    ///     they make use of native theme engines. This is the case for the
    ///     Windows Vista and \macos styles.
    /// 
    ///     \sa QWidget::setPalette(), palette(), QStyle::polish()
    [static] set_palette(arg0: &PaletteType, class_name: *char),
    ///     \overload
    /// 
    ///     Returns the font for widgets of the given \a className.
    /// 
    ///     \sa setFont(), QWidget::font()
    [static] font() -> Font,
    ///     \overload
    /// 
    ///     Returns the font for widgets of the given \a className.
    /// 
    ///     \sa setFont(), QWidget::font()
    [static] font(arg0: *WidgetType) -> Font,
    ///     \overload
    /// 
    ///     Returns the font for widgets of the given \a className.
    /// 
    ///     \sa setFont(), QWidget::font()
    [static] font(class_name: *char) -> Font,
    ///     Changes the default application font to \a font. If \a className is passed,
    ///     the change applies only to classes that inherit \a className (as reported
    ///     by QObject::inherits()).
    /// 
    ///     On application start-up, the default font depends on the window system. It
    ///     can vary depending on both the window system version and the locale. This
    ///     function lets you override the default font; but overriding may be a bad
    ///     idea because, for example, some locales need extra large fonts to support
    ///     their special characters.
    /// 
    ///     \warning Do not use this function in conjunction with \l{Qt Style Sheets}.
    ///     The font of an application can be customized using the "font" style sheet
    ///     property. To set a bold font for all QPushButtons, set the application
    ///     styleSheet() as "QPushButton { font: bold }"
    /// 
    ///     \sa font(), fontMetrics(), QWidget::setFont()
    [static] set_font(arg0: &FontType, class_name: *char),
    [static] set_window_icon(icon: &IconType),
    ///     \property QApplication::windowIcon
    ///     \brief the default window icon
    /// 
    ///     \sa QWidget::setWindowIcon(), {Setting the Application Icon}
    [static] window_icon() -> Icon,
    ///     Returns a list of all the widgets in the application.
    /// 
    ///     The list is empty (QList::isEmpty()) if there are no widgets.
    /// 
    ///     \note Some of the widgets may be hidden.
    /// 
    ///     Example:
    ///     \snippet code/src_gui_kernel_qapplication.cpp 5
    /// 
    ///     \sa topLevelWidgets(), QWidget::isVisible()
    [static] all_widgets() -> WidgetList,
    ///     Returns a list of the top-level widgets (windows) in the application.
    /// 
    ///     \note Some of the top-level widgets may be hidden, for example a tooltip if
    ///     no tooltip is currently shown.
    /// 
    ///     Example:
    /// 
    ///     \snippet code/src_gui_kernel_qapplication.cpp 4
    /// 
    ///     \sa allWidgets(), QWidget::isWindow(), QWidget::isHidden()
    [static] top_level_widgets() -> WidgetList,
    ///     Returns the desktop widget (also called the root window).
    /// 
    ///     The desktop may be composed of multiple screens, so it would be incorrect,
    ///     for example, to attempt to \e center some widget in the desktop's geometry.
    ///     QDesktopWidget has various functions for obtaining useful geometries upon
    ///     the desktop, such as QDesktopWidget::screenGeometry() and
    ///     QDesktopWidget::availableGeometry().
    /// 
    ///     On X11, it is also possible to draw on the desktop.
    [static] desktop() -> DesktopWidget?,
    ///     Returns the active popup widget.
    /// 
    ///     A popup widget is a special top-level widget that sets the \c
    ///     Qt::WType_Popup widget flag, e.g. the QMenu widget. When the application
    ///     opens a popup widget, all events are sent to the popup. Normal widgets and
    ///     modal widgets cannot be accessed before the popup widget is closed.
    /// 
    ///     Only other popup widgets may be opened when a popup widget is shown. The
    ///     popup widgets are organized in a stack. This function returns the active
    ///     popup widget at the top of the stack.
    /// 
    ///     \sa activeModalWidget(), topLevelWidgets()
    [static] active_popup_widget() -> Widget?,
    ///     Returns the active modal widget.
    /// 
    ///     A modal widget is a special top-level widget which is a subclass of QDialog
    ///     that specifies the modal parameter of the constructor as true. A modal
    ///     widget must be closed before the user can continue with other parts of the
    ///     program.
    /// 
    ///     Modal widgets are organized in a stack. This function returns the active
    ///     modal widget at the top of the stack.
    /// 
    ///     \sa activePopupWidget(), topLevelWidgets()
    [static] active_modal_widget() -> Widget?,
    ///     Returns the application widget that has the keyboard input focus, or 0 if
    ///     no widget in this application has the focus.
    /// 
    ///     \sa QWidget::setFocus(), QWidget::hasFocus(), activeWindow(), focusChanged()
    [static] focus_widget() -> Widget?,
    ///     Returns the application top-level window that has the keyboard input focus,
    ///     or 0 if no application window has the focus. There might be an
    ///     activeWindow() even if there is no focusWidget(), for example if no widget
    ///     in that window accepts key events.
    /// 
    ///     \sa QWidget::setFocus(), QWidget::hasFocus(), focusWidget()
    [static] active_window() -> Widget?,
    ///     \fn void QApplication::setActiveWindow(QWidget* active)
    /// 
    ///     Sets the active window to the \a active widget in response to a system
    ///     event. The function is called from the platform specific event handlers.
    /// 
    ///     \warning This function does \e not set the keyboard focus to the active
    ///     widget. Call QWidget::activateWindow() instead.
    /// 
    ///     It sets the activeWindow() and focusWidget() attributes and sends proper
    ///     \l{QEvent::WindowActivate}{WindowActivate}/\l{QEvent::WindowDeactivate}
    ///     {WindowDeactivate} and \l{QEvent::FocusIn}{FocusIn}/\l{QEvent::FocusOut}
    ///     {FocusOut} events to all appropriate widgets. The window will then be
    ///     painted in active state (e.g. cursors in line edits will blink), and it
    ///     will have tool tips enabled.
    /// 
    ///     \sa activeWindow(), QWidget::activateWindow()
    [static] set_active_window(act: *WidgetType),
    ///     \fn QWidget *QApplication::widgetAt(const QPoint &point)
    /// 
    ///     Returns the widget at global screen position \a point, or 0 if there is no
    ///     Qt widget there.
    /// 
    ///     This function can be slow.
    /// 
    ///     \sa QCursor::pos(), QWidget::grabMouse(), QWidget::grabKeyboard()
    [static] widget_at(p: &PointType) -> Widget?,
    ///     \fn QWidget *QApplication::widgetAt(const QPoint &point)
    /// 
    ///     Returns the widget at global screen position \a point, or 0 if there is no
    ///     Qt widget there.
    /// 
    ///     This function can be slow.
    /// 
    ///     \sa QCursor::pos(), QWidget::grabMouse(), QWidget::grabKeyboard()
    [static] widget_at(x: i32, y: i32) -> Widget?,
    ///     \fn QWidget *QApplication::topLevelAt(const QPoint &point)
    /// 
    ///     Returns the top-level widget at the given \a point; returns 0 if
    ///     there is no such widget.
    [static] top_level_at(p: &PointType) -> Widget?,
    ///     \fn QWidget *QApplication::topLevelAt(const QPoint &point)
    /// 
    ///     Returns the top-level widget at the given \a point; returns 0 if
    ///     there is no such widget.
    [static] top_level_at(x: i32, y: i32) -> Widget?,
    ///     \fn void QApplication::beep()
    /// 
    ///     Sounds the bell, using the default volume and sound. The function is \e not
    ///     available in Qt for Embedded Linux.
    [static] beep(),
    ///     \fn void QApplication::alert(QWidget *widget, int msec)
    ///     \since 4.3
    /// 
    ///     Causes an alert to be shown for \a widget if the window is not the active
    ///     window. The alert is shown for \a msec miliseconds. If \a msec is zero (the
    ///     default), then the alert is shown indefinitely until the window becomes
    ///     active again.
    /// 
    ///     Currently this function does nothing on Qt for Embedded Linux.
    /// 
    ///     On \macos, this works more at the application level and will cause the
    ///     application icon to bounce in the dock.
    /// 
    ///     On Windows, this causes the window's taskbar entry to flash for a time. If
    ///     \a msec is zero, the flashing will stop and the taskbar entry will turn a
    ///     different color (currently orange).
    /// 
    ///     On X11, this will cause the window to be marked as "demands attention", the
    ///     window must not be hidden (i.e. not have hide() called on it, but be
    ///     visible in some sort of way) in order for this to work.
    [static] alert(widget: *WidgetType, duration: i32),
    ///     \property QApplication::cursorFlashTime
    ///     \brief the text cursor's flash (blink) time in milliseconds
    /// 
    ///     The flash time is the time required to display, invert and restore the
    ///     caret display. Usually the text cursor is displayed for half the cursor
    ///     flash time, then hidden for the same amount of time, but this may vary.
    /// 
    ///     The default value on X11 is 1000 milliseconds. On Windows, the
    ///     \uicontrol{Control Panel} value is used and setting this property sets the cursor
    ///     flash time for all applications.
    /// 
    ///     We recommend that widgets do not cache this value as it may change at any
    ///     time if the user changes the global desktop settings.
    /// 
    ///     \note This property may hold a negative value, for instance if cursor
    ///     blinking is disabled.
    [static] set_cursor_flash_time(arg0: i32),
    [static] cursor_flash_time() -> i32,
    ///     \property QApplication::doubleClickInterval
    ///     \brief the time limit in milliseconds that distinguishes a double click
    ///     from two consecutive mouse clicks
    /// 
    ///     The default value on X11 is 400 milliseconds. On Windows and Mac OS, the
    ///     operating system's value is used.
    [static] set_double_click_interval(arg0: i32),
    [static] double_click_interval() -> i32,
    ///     \property QApplication::keyboardInputInterval
    ///     \brief the time limit in milliseconds that distinguishes a key press
    ///     from two consecutive key presses
    ///     \since 4.2
    /// 
    ///     The default value on X11 is 400 milliseconds. On Windows and Mac OS, the
    ///     operating system's value is used.
    [static] set_keyboard_input_interval(arg0: i32),
    [static] keyboard_input_interval() -> i32,
    [static] set_wheel_scroll_lines(arg0: i32),
    ///     \property QApplication::wheelScrollLines
    ///     \brief the number of lines to scroll a widget, when the
    ///     mouse wheel is rotated.
    /// 
    ///     If the value exceeds the widget's number of visible lines, the widget
    ///     should interpret the scroll operation as a single \e{page up} or
    ///     \e{page down}. If the widget is an \l{QAbstractItemView}{item view class},
    ///     then the result of scrolling one \e line depends on the setting of the
    ///     widget's \l{QAbstractItemView::verticalScrollMode()}{scroll mode}. Scroll
    ///     one \e line can mean \l{QAbstractItemView::ScrollPerItem}{scroll one item}
    ///     or \l{QAbstractItemView::ScrollPerPixel}{scroll one pixel}.
    /// 
    ///     By default, this property has a value of 3.
    /// 
    ///     \sa QStyleHints::wheelScrollLines()
    [static] wheel_scroll_lines() -> i32,
    [static] set_start_drag_time(ms: i32),
    ///     \property QApplication::startDragTime
    ///     \brief the time in milliseconds that a mouse button must be held down
    ///     before a drag and drop operation will begin
    /// 
    ///     If you support drag and drop in your application, and want to start a drag
    ///     and drop operation after the user has held down a mouse button for a
    ///     certain amount of time, you should use this property's value as the delay.
    /// 
    ///     Qt also uses this delay internally, e.g. in QTextEdit and QLineEdit, for
    ///     starting a drag.
    /// 
    ///     The default value is 500 ms.
    /// 
    ///     \sa startDragDistance(), {Drag and Drop}
    [static] start_drag_time() -> i32,
    [static] set_start_drag_distance(l: i32),
    ///     \property QApplication::startDragDistance
    /// 
    ///     If you support drag and drop in your application, and want to start a drag
    ///     and drop operation after the user has moved the cursor a certain distance
    ///     with a button held down, you should use this property's value as the
    ///     minimum distance required.
    /// 
    ///     For example, if the mouse position of the click is stored in \c startPos
    ///     and the current position (e.g. in the mouse move event) is \c currentPos,
    ///     you can find out if a drag should be started with code like this:
    /// 
    ///     \snippet code/src_gui_kernel_qapplication.cpp 7
    /// 
    ///     Qt uses this value internally, e.g. in QFileDialog.
    /// 
    ///     The default value (if the platform doesn't provide a different default)
    ///     is 10 pixels.
    /// 
    ///     \sa startDragTime(), QPoint::manhattanLength(), {Drag and Drop}
    [static] start_drag_distance() -> i32,
    ///     \fn bool QApplication::isEffectEnabled(Qt::UIEffect effect)
    /// 
    ///     Returns \c true if \a effect is enabled; otherwise returns \c false.
    /// 
    ///     By default, Qt will try to use the desktop settings. To prevent this, call
    ///     setDesktopSettingsAware(false).
    /// 
    ///     \note All effects are disabled on screens running at less than 16-bit color
    ///     depth.
    /// 
    ///     \sa setEffectEnabled(), Qt::UIEffect
    [static] is_effect_enabled(arg0: Rute::UIEffect) -> bool,
    ///     \fn void QApplication::setEffectEnabled(Qt::UIEffect effect, bool enable)
    /// 
    ///     Enables the UI effect \a effect if \a enable is true, otherwise the effect
    ///     will not be used.
    /// 
    ///     \note All effects are disabled on screens running at less than 16-bit color
    ///     depth.
    /// 
    ///     \sa isEffectEnabled(), Qt::UIEffect, setDesktopSettingsAware()
    [static] set_effect_enabled(arg0: Rute::UIEffect, enable: bool),
    ///     Enters the main event loop and waits until exit() is called, then returns
    ///     the value that was set to exit() (which is 0 if exit() is called via
    ///     quit()).
    /// 
    ///     It is necessary to call this function to start event handling. The main
    ///     event loop receives events from the window system and dispatches these to
    ///     the application widgets.
    /// 
    ///     Generally, no user interaction can take place before calling exec(). As a
    ///     special case, modal widgets like QMessageBox can be used before calling
    ///     exec(), because modal widgets call exec() to start a local event loop.
    /// 
    ///     To make your application perform idle processing, i.e., executing a special
    ///     function whenever there are no pending events, use a QTimer with 0 timeout.
    ///     More advanced idle processing schemes can be achieved using processEvents().
    /// 
    ///     We recommend that you connect clean-up code to the
    ///     \l{QCoreApplication::}{aboutToQuit()} signal, instead of putting it in your
    ///     application's \c{main()} function. This is because, on some platforms the
    ///     QApplication::exec() call may not return. For example, on the Windows
    ///     platform, when the user logs off, the system terminates the process after Qt
    ///     closes all top-level windows. Hence, there is \e{no guarantee} that the
    ///     application will have time to exit its event loop and execute code at the
    ///     end of the \c{main()} function, after the QApplication::exec() call.
    /// 
    ///     \sa quitOnLastWindowClosed, QCoreApplication::quit(), QCoreApplication::exit(),
    ///         QCoreApplication::processEvents(), QCoreApplication::exec()
    [static] exec() -> i32,
    [event] notify(arg0: *ObjectType, arg1: *EventType) -> bool,
    [signal] focus_changed(old: *WidgetType, now: *WidgetType),
    style_sheet() -> String,
    set_style_sheet(sheet: String),
    ///     \property QApplication::autoSipEnabled
    ///     \since 4.5
    ///     \brief toggles automatic SIP (software input panel) visibility
    /// 
    ///     Set this property to \c true to automatically display the SIP when entering
    ///     widgets that accept keyboard input. This property only affects widgets with
    ///     the WA_InputMethodEnabled attribute set, and is typically used to launch
    ///     a virtual keyboard on devices which have very few or no keys.
    /// 
    ///     \b{ The property only has an effect on platforms that use software input
    ///     panels.}
    /// 
    ///     The default is platform dependent.
    set_auto_sip_enabled(enabled: bool),
    auto_sip_enabled() -> bool,
    ///     Closes all top-level windows.
    /// 
    ///     This function is particularly useful for applications with many top-level
    ///     windows. It could, for example, be connected to a \uicontrol{Exit} entry in the
    ///     \uicontrol{File} menu:
    /// 
    ///     \snippet mainwindows/mdi/mainwindow.cpp 0
    /// 
    ///     The windows are closed in random order, until one window does not accept
    ///     the close event. The application quits when the last window was
    ///     successfully closed; this can be turned off by setting
    ///     \l quitOnLastWindowClosed to false.
    /// 
    ///     \sa quitOnLastWindowClosed, lastWindowClosed(), QWidget::close(),
    ///     QWidget::closeEvent(), lastWindowClosed(), QCoreApplication::quit(), topLevelWidgets(),
    ///     QWidget::isWindow()
    [static] close_all_windows(),
    ///     Displays a simple message box about Qt. The message includes the version
    ///     number of Qt being used by the application.
    /// 
    ///     This is useful for inclusion in the \uicontrol Help menu of an application, as
    ///     shown in the \l{mainwindows/menus}{Menus} example.
    /// 
    ///     This function is a convenience slot for QMessageBox::aboutQt().
    [static] about_qt(),
    ///     \since 4.1
    ///     \fn void QApplication::focusChanged(QWidget *old, QWidget *now)
    /// 
    ///     This signal is emitted when the widget that has keyboard focus changed from
    ///     \a old to \a now, i.e., because the user pressed the tab-key, clicked into
    ///     a widget or changed the active window. Both \a old and \a now can be the
    ///     null-pointer.
    /// 
    ///     The signal is emitted after both widget have been notified about the change
    ///     through QFocusEvent.
    /// 
    ///     \sa QWidget::setFocus(), QWidget::clearFocus(), Qt::FocusReason
    [event] event(arg0: *EventType) -> bool,
    ///     \internal
    [event] compress_event(arg0: *EventType, receiver: *ObjectType, arg1: *PostEventListType) -> bool,
}

// vim: syntax=rust expandtab ts=4 sw=4
