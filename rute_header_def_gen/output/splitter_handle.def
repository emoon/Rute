///     \class QSplitterHandle
///     \brief The QSplitterHandle class provides handle functionality for the splitter.
/// 
///     \ingroup organizers
///     \inmodule QtWidgets
/// 
///     QSplitterHandle is typically what people think about when they think about
///     a splitter. It is the handle that is used to resize the widgets.
/// 
///     A typical developer using QSplitter will never have to worry about
///     QSplitterHandle. It is provided for developers who want splitter handles
///     that provide extra features, such as popup menus.
/// 
///     The typical way one would create splitter handles is to subclass QSplitter and then
///     reimplement QSplitter::createHandle() to instantiate the custom splitter
///     handle. For example, a minimum QSplitter subclass might look like this:
/// 
///     \snippet splitterhandle/splitter.h 0
/// 
///     The \l{QSplitter::}{createHandle()} implementation simply constructs a
///     custom splitter handle, called \c Splitter in this example:
/// 
///     \snippet splitterhandle/splitter.cpp 1
/// 
///     Information about a given handle can be obtained using functions like
///     orientation() and opaqueResize(), and is retrieved from its parent splitter.
///     Details like these can be used to give custom handles different appearances
///     depending on the splitter's orientation.
/// 
///     The complexity of a custom handle subclass depends on the tasks that it
///     needs to perform. A simple subclass might only provide a paintEvent()
///     implementation:
/// 
///     \snippet splitterhandle/splitter.cpp 0
/// 
///     In this example, a predefined gradient is set up differently depending on
///     the orientation of the handle. QSplitterHandle provides a reasonable
///     size hint for the handle, so the subclass does not need to provide a
///     reimplementation of sizeHint() unless the handle has special size
///     requirements.
/// 
///     \sa QSplitter
struct SplitterHandle : Widget {
    set_orientation(o: Rute::Orientation),
    orientation() -> Rute::Orientation,
    opaque_resize() -> bool,
    splitter() -> Splitter?,
    [event] size_hint() -> Size,
    [event] paint_event(arg0: *PaintEventType),
    [event] mouse_move_event(arg0: *MouseEventType),
    [event] mouse_press_event(arg0: *MouseEventType),
    [event] mouse_release_event(arg0: *MouseEventType),
    [event] resize_event(arg0: *ResizeEventType),
    [event] event(arg0: *EventType) -> bool,
    move_splitter(p: i32),
    closest_legal_position(p: i32) -> i32,
}

// vim: syntax=rust expandtab ts=4 sw=4
