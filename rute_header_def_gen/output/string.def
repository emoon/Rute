/// 
/// QString stores a string of 16-bit [QChar](QChar)
/// s, where each QChar
/// corresponds to one UTF-16 code unit. (Unicode characters
/// with code values above 65535 are stored using surrogate pairs,
/// i.e., two consecutive [QChar](QChar)
/// s.)
/// 
/// [Unicode](Unicode)
/// is an international standard that supports most of the
/// writing systems in use today. It is a superset of US-ASCII (ANSI
/// X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1
/// characters are available at the same code positions.
/// 
/// Behind the scenes, QString uses [implicit sharing](implicit%20sharing)
/// (copy-on-write) to reduce memory usage and to avoid the needless
/// copying of data. This also helps reduce the inherent overhead of
/// storing 16-bit characters instead of 8-bit characters.
/// 
/// In addition to QString, Qt also provides the QByteArray class to
/// store raw bytes and traditional 8-bit '\\0'-terminated strings.
/// For most purposes, QString is the class you want to use. It is
/// used throughout the Qt API, and the Unicode support ensures that
/// your applications will be easy to translate if you want to expand
/// your application's market at some point. The two main cases where
/// QByteArray is appropriate are when you need to store raw binary
/// data, and when memory conservation is critical (like in embedded
/// systems).
/// 
/// # Initializing a String
/// 
/// One way to initialize a QString is simply to pass a `const char
/// *` to its constructor. For example, the following code creates a
/// QString of size 5 containing the data :
/// 
/// QString converts the `const char *` data into Unicode using the
/// fromUtf8() function.
/// 
/// In all of the QString functions that take `const char *`
/// parameters, the `const char *` is interpreted as a classic
/// C-style '\\0'-terminated string encoded in UTF-8. It is legal for
/// the `const char *` parameter to be 0.
/// 
/// You can also provide string data as an array of [QChar](QChar)
/// s:
/// 
/// QString makes a deep copy of the QChar data, so you can modify it
/// later without experiencing side effects. (If for performance
/// reasons you don't want to take a deep copy of the character data,
/// use QString::fromRawData() instead.)
/// 
/// Another approach is to set the size of the string using resize()
/// and to initialize the data character per character. QString uses
/// 0-based indexes, just like C++ arrays. To access the character at
/// a particular index position, you can use [operator[]().](operator[]().)
/// On
/// non-const strings, [operator[]()](operator[]())
/// returns a reference to a
/// character that can be used on the left side of an assignment. For
/// example:
/// 
/// For read-only access, an alternative syntax is to use the at()
/// function:
/// 
/// The at() function can be faster than [operator[](),](operator[](),)
/// because it
/// never causes a [deep copy](deep%20copy)
/// to occur. Alternatively, use the
/// left(), right(), or mid() functions to extract several characters
/// at a time.
/// 
/// A QString can embed '\\0' characters (QChar::Null). The size()
/// function always returns the size of the whole string, including
/// embedded '\\0' characters.
/// 
/// After a call to the resize() function, newly allocated characters
/// have undefined values. To set all the characters in the string to
/// a particular value, use the fill() function.
/// 
/// QString provides dozens of overloads designed to simplify string
/// usage. For example, if you want to compare a QString with a string
/// literal, you can write code like this and it will work as expected:
/// 
/// You can also pass string literals to functions that take QStrings
/// as arguments, invoking the QString(const char *)
/// constructor. Similarly, you can pass a QString to a function that
/// takes a `const char *` argument using the [qPrintable()](qPrintable())
/// macro
/// which returns the given QString as a `const char *` . This is
/// equivalent to calling <QString>.toLocal8Bit().constData().
/// 
/// # Manipulating String Data
/// 
/// QString provides the following basic functions for modifying the
/// character data: append(), prepend(), insert(), replace(), and
/// remove(). For example:
/// 
/// If you are building a QString gradually and know in advance
/// approximately how many characters the QString will contain, you
/// can call reserve(), asking QString to preallocate a certain amount
/// of memory. You can also call capacity() to find out how much
/// memory QString actually allocated.
/// 
/// The replace() and remove() functions' first two arguments are the
/// position from which to start erasing and the number of characters
/// that should be erased. If you want to replace all occurrences of
/// a particular substring with another, use one of the two-parameter
/// replace() overloads.
/// 
/// A frequent requirement is to remove whitespace characters from a
/// string ('\\n', '\\t', ' ', etc.). If you want to remove whitespace
/// from both ends of a QString, use the trimmed() function. If you
/// want to remove whitespace from both ends and replace multiple
/// consecutive whitespaces with a single space character within the
/// string, use simplified().
/// 
/// If you want to find all occurrences of a particular character or
/// substring in a QString, use the indexOf() or lastIndexOf()
/// functions. The former searches forward starting from a given index
/// position, the latter searches backward. Both return the index
/// position of the character or substring if they find it; otherwise,
/// they return -1. For example, here's a typical loop that finds all
/// occurrences of a particular substring:
/// 
/// QString provides many functions for converting numbers into
/// strings and strings into numbers. See the arg() functions, the
/// setNum() functions, the number() static functions, and the
/// toInt(), toDouble(), and similar functions.
/// 
/// To get an upper- or lowercase version of a string use toUpper() or
/// toLower().
/// 
/// Lists of strings are handled by the QStringList class. You can
/// split a string into a list of strings using the split() function,
/// and join a list of strings into a single string with an optional
/// separator using QStringList::join(). You can obtain a list of
/// strings from a string list that contain a particular substring or
/// that match a particular QRegExp using the QStringList::filter()
/// function.
/// 
/// # Querying String Data
/// 
/// If you want to see if a QString starts or ends with a particular
/// substring use startsWith() or endsWith(). If you simply want to
/// check whether a QString contains a particular character or
/// substring, use the contains() function. If you want to find out
/// how many times a particular character or substring occurs in the
/// string, use count().
/// 
/// QStrings can be compared using overloaded operators such as [operator<(),](operator%3C(),)
/// [operator<=(),](operator%3C=(),)
/// [operator==(),](operator==(),)
/// [operator>=(),](operator%3E=(),)
/// 
/// and so on. Note that the comparison is based exclusively on the
/// numeric Unicode values of the characters. It is very fast, but is
/// not what a human would expect; the QString::localeAwareCompare()
/// function is a better choice for sorting user-interface strings.
/// 
/// To obtain a pointer to the actual character data, call data() or
/// constData(). These functions return a pointer to the beginning of
/// the QChar data. The pointer is guaranteed to remain valid until a
/// non-const function is called on the QString.
/// 
/// # Converting Between 8-Bit Strings and Unicode Strings
/// 
/// QString provides the following three functions that return a
/// `const char *` version of the string as QByteArray: toUtf8(),
/// toLatin1(), and toLocal8Bit().
/// 
/// * toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.
/// * toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a superset of US-ASCII (ANSI X3.4-1986) that supports the entire Unicode character set through multibyte sequences.
/// * toLocal8Bit() returns an 8-bit string using the system's local encoding.
/// 
/// To convert from one of these encodings, QString provides
/// fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other
/// encodings are supported through the QTextCodec class.
/// 
/// As mentioned above, QString provides a lot of functions and
/// operators that make it easy to interoperate with `const char *`
/// strings. But this functionality is a double-edged sword: It makes
/// QString more convenient to use if all strings are US-ASCII or
/// Latin-1, but there is always the risk that an implicit conversion
/// from or to `const char *` is done using the wrong 8-bit
/// encoding. To minimize these risks, you can turn off these implicit
/// conversions by defining the following two preprocessor symbols:
/// 
/// * `QT_NO_CAST_FROM_ASCII` disables automatic conversions from C string literals and pointers to Unicode.
/// * `QT_RESTRICTED_CAST_FROM_ASCII` allows automatic conversions from C characters and character arrays, but disables automatic conversions from character pointers to Unicode.
/// * `QT_NO_CAST_TO_ASCII` disables automatic conversion from QString to C strings.
/// 
/// One way to define these preprocessor symbols globally for your
/// application is to add the following entry to your [qmake project file](Creating%20Project%20Files)
/// 
/// 
/// You then need to explicitly call fromUtf8(), fromLatin1(),
/// or fromLocal8Bit() to construct a QString from an
/// 8-bit string, or use the lightweight QLatin1String class, for
/// example:
/// 
/// Similarly, you must call toLatin1(), toUtf8(), or
/// toLocal8Bit() explicitly to convert the QString to an 8-bit
/// string. (Other encodings are supported through the QTextCodec
/// class.)
/// 
/// * Note for C Programmers
/// 
/// * Due to C++'s type system and the fact that QString is [implicitly shared](implicitly%20shared)
/// , QStrings may be treated like `int` s or other basic types. For example: The `result` variable, is a normal variable allocated on the stack. When `return` is called, and because we're returning by value, the copy constructor is called and a copy of the string is returned. No actual copying takes place thanks to the implicit sharing.
/// 
/// # Distinction Between Null and Empty Strings
/// 
/// For historical reasons, QString distinguishes between a null
/// string and an empty string. A *null* string is a string that is
/// initialized using QString's default constructor or by passing
/// (const char *)0 to the constructor. An *empty* string is any
/// string with size 0. A null string is always empty, but an empty
/// string isn't necessarily null:
/// 
/// All functions except isNull() treat null strings the same as empty
/// strings. For example, toUtf8().constData() returns a pointer to a
/// '\\0' character for a null string ( *not* a null pointer), and
/// QString() compares equal to QString(""). We recommend that you
/// always use the isEmpty() function and avoid isNull().
/// 
/// # Argument Formats
/// 
/// In member functions where an argument *format* can be specified
/// (e.g., arg(), number()), the argument *format* can be one of the
/// following:
/// 
/// * Format
/// * Meaning
/// * `e`
/// * format as [-]9.9e[+|-]999
/// * `E`
/// * format as [-]9.9E[+|-]999
/// * `f`
/// * format as [-]9.9
/// * `g`
/// * use `e` or `f` format, whichever is the most concise
/// * `G`
/// * use `E` or `f` format, whichever is the most concise
/// 
/// A *precision* is also specified with the argument *format.* For
/// the 'e', 'E', and 'f' formats, the *precision* represents the
/// number of digits *after* the decimal point. For the 'g' and 'G'
/// formats, the *precision* represents the maximum number of
/// significant digits (trailing zeroes are omitted).
/// 
/// # More Efficient String Construction
/// 
/// Many strings are known at compile time. But the trivial
/// constructor QString("Hello"), will copy the contents of the string,
/// treating the contents as Latin-1. To avoid this one can use the
/// QStringLiteral macro to directly create the required data at compile
/// time. Constructing a QString out of the literal does then not cause
/// any overhead at runtime.
/// 
/// A slightly less efficient way is to use QLatin1String. This class wraps
/// a C string literal, precalculates it length at compile time and can
/// then be used for faster comparison with QStrings and conversion to
/// QStrings than a regular C string literal.
/// 
/// Using the QString `'+'` operator, it is easy to construct a
/// complex string from multiple substrings. You will often write code
/// like this:
/// 
/// There is nothing wrong with either of these string constructions,
/// but there are a few hidden inefficiencies. Beginning with Qt 4.6,
/// you can eliminate them.
/// 
/// First, multiple uses of the `'+'` operator usually means
/// multiple memory allocations. When concatenating *n* substrings,
/// where *n > 2* , there can be as many as *n - 1* calls to the
/// memory allocator.
/// 
/// In 4.6, an internal template class `QStringBuilder` has been
/// added along with a few helper functions. This class is marked
/// internal and does not appear in the documentation, because you
/// aren't meant to instantiate it in your code. Its use will be
/// automatic, as described below. The class is found in
/// `src/corelib/tools/qstringbuilder.cpp` if you want to have a
/// look at it.
/// 
/// `QStringBuilder` uses expression templates and reimplements the
/// `'%'` operator so that when you use `'%'` for string
/// concatenation instead of `'+'` , multiple substring
/// concatenations will be postponed until the final result is about
/// to be assigned to a QString. At this point, the amount of memory
/// required for the final result is known. The memory allocator is
/// then called *once* to get the required space, and the substrings
/// are copied into it one by one.
/// 
/// Additional efficiency is gained by inlining and reduced reference
/// counting (the QString created from a `QStringBuilder` typically
/// has a ref count of 1, whereas QString::append() needs an extra
/// test).
/// 
/// There are two ways you can access this improved method of string
/// construction. The straightforward way is to include
/// `QStringBuilder` wherever you want to use it, and use the
/// `'%'` operator instead of `'+'` when concatenating strings:
/// 
/// A more global approach which is the most convenient but
/// not entirely source compatible, is to this define in your
/// .pro file:
/// 
/// and the `'+'` will automatically be performed as the
/// `QStringBuilder` `'%'` everywhere.
/// 
/// **See also:** [`from_raw_data()`]
/// [`Char`]
/// [`Latin1String`]
/// [`ByteArray`]
/// [`StringRef`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct String {
    /// 
    /// Swaps string *other* with this string. This operation is very fast and
    /// never fails.
    swap(other: String),
    /// 
    /// Returns the number of characters in this string.
    /// 
    /// The last character in the string is at position size() - 1.
    /// 
    /// Example:
    /// 
    /// **See also:** [`is_empty()`]
    /// [`resize()`]
    size() -> i32,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// the string *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of occurrences of character *ch* in the string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count() Returns the number of (potentially overlapping) occurrences of the
    /// string reference *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *rx* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *re* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Same as size().
    count() -> i32,
    /// 
    /// Returns the number of characters in this string. Equivalent to
    /// size().
    /// 
    /// **See also:** [`resize()`]
    length() -> i32,
    /// 
    /// Returns `true` if the string has no characters; otherwise returns
    /// `false.`
    /// 
    /// Example:
    /// 
    /// **See also:** [`size()`]
    is_empty() -> bool,
    /// 
    /// Sets the size of the string to *size* characters.
    /// 
    /// If *size* is greater than the current size, the string is
    /// extended to make it *size* characters long with the extra
    /// characters added to the end. The new characters are uninitialized.
    /// 
    /// If *size* is less than the current size, characters are removed
    /// from the end.
    /// 
    /// Example:
    /// 
    /// If you want to append a certain number of identical characters to
    /// the string, use the [resize(int, QChar)](QString::)
    /// overload.
    /// 
    /// If you want to expand the string so that it reaches a certain
    /// width and fill the new positions with a particular character, use
    /// the leftJustified() function:
    /// 
    /// If *size* is negative, it is equivalent to passing zero.
    /// 
    /// **See also:** [`truncate()`]
    /// [`reserve()`]
    /// 
    /// **Overloads**
    /// Unlike [resize(int)](QString::)
    /// , this overload
    /// initializes the new characters to *fillChar:*
    /// 
    resize(size: i32),
    /// 
    /// Sets the size of the string to *size* characters.
    /// 
    /// If *size* is greater than the current size, the string is
    /// extended to make it *size* characters long with the extra
    /// characters added to the end. The new characters are uninitialized.
    /// 
    /// If *size* is less than the current size, characters are removed
    /// from the end.
    /// 
    /// Example:
    /// 
    /// If you want to append a certain number of identical characters to
    /// the string, use the [resize(int, QChar)](QString::)
    /// overload.
    /// 
    /// If you want to expand the string so that it reaches a certain
    /// width and fill the new positions with a particular character, use
    /// the leftJustified() function:
    /// 
    /// If *size* is negative, it is equivalent to passing zero.
    /// 
    /// **See also:** [`truncate()`]
    /// [`reserve()`]
    /// 
    /// **Overloads**
    /// Unlike [resize(int)](QString::)
    /// , this overload
    /// initializes the new characters to *fillChar:*
    /// 
    [org_name(resize)]
    resize_2(size: i32, fill_char: CharType),
    /// 
    /// Sets every character in the string to character *ch.* If *size*
    /// is different from -1 (default), the string is resized to *size* beforehand.
    /// 
    /// Example:
    /// 
    /// **See also:** [`resize()`]
    fill(c: CharType, size: i32) -> String?,
    /// 
    /// Returns a substring that contains the size() - *len* leftmost characters
    /// of this string.
    /// 
    /// **Note**: The behavior is undefined if *len* is negative or greater than size().
    /// 
    /// **See also:** [`ends_with()`]
    /// [`left()`]
    /// [`right()`]
    /// [`mid()`]
    /// [`chop()`]
    /// [`truncate()`]
    /// 
    /// Removes *n* characters from the end of the string.
    /// 
    /// If *n* is greater than or equal to size(), the result is an
    /// empty string; if *n* is negative, it is equivalent to passing zero.
    /// 
    /// Example:
    /// 
    /// If you want to remove characters from the *beginning* of the
    /// string, use remove() instead.
    /// 
    /// **See also:** [`truncate()`]
    /// [`resize()`]
    /// [`remove()`]
    /// [`StringRef::chop`]
    chop(n: i32),
    /// 
    /// Returns the maximum number of characters that can be stored in
    /// the string without forcing a reallocation.
    /// 
    /// The sole purpose of this function is to provide a means of fine
    /// tuning QString's memory usage. In general, you will rarely ever
    /// need to call this function. If you want to know how many
    /// characters are in the string, call size().
    /// 
    /// **See also:** [`reserve()`]
    /// [`squeeze()`]
    capacity() -> i32,
    /// 
    /// Attempts to allocate memory for at least *size* characters. If
    /// you know in advance how large the string will be, you can call
    /// this function, and if you resize the string often you are likely
    /// to get better performance. If *size* is an underestimate, the
    /// worst that will happen is that the QString will be a bit slower.
    /// 
    /// The sole purpose of this function is to provide a means of fine
    /// tuning QString's memory usage. In general, you will rarely ever
    /// need to call this function. If you want to change the size of the
    /// string, call resize().
    /// 
    /// This function is useful for code that needs to build up a long
    /// string and wants to avoid repeated reallocation. In this example,
    /// we want to add to the string until some condition is `true,` and
    /// we're fairly sure that size is large enough to make a call to
    /// reserve() worthwhile:
    /// 
    /// **See also:** [`squeeze()`]
    /// [`capacity()`]
    reserve(size: i32),
    /// 
    /// Releases any memory not required to store the character data.
    /// 
    /// The sole purpose of this function is to provide a means of fine
    /// tuning QString's memory usage. In general, you will rarely ever
    /// need to call this function.
    /// 
    /// **See also:** [`reserve()`]
    /// [`capacity()`]
    squeeze(),
    /// 
    /// Returns a Unicode representation of the string.
    /// The result remains valid until the string is modified.
    /// 
    /// **Note**: The returned string may not be '\\0'-terminated.
    /// Use size() to determine the length of the array.
    /// 
    /// **See also:** [`utf16()`]
    /// [`from_raw_data()`]
    unicode() -> Char?,
    /// 
    /// Returns a pointer to the data stored in the QString. The pointer
    /// can be used to access and modify the characters that compose the
    /// string.
    /// 
    /// Unlike constData() and unicode(), the returned data is always
    /// '\\0'-terminated.
    /// 
    /// Example:
    /// 
    /// Note that the pointer remains valid only as long as the string is
    /// not modified by other means. For read-only access, constData() is
    /// faster because it never causes a [deep copy](deep%20copy)
    /// to occur.
    /// 
    /// **See also:** [`const_data()`]
    /// [`operator()`]
    /// 
    /// **Overloads**
    /// **Note**: The returned string may not be '\\0'-terminated.
    /// Use size() to determine the length of the array.
    /// 
    /// **See also:** [`from_raw_data()`]
    data() -> Char?,
    /// 
    /// Returns a pointer to the data stored in the QString. The pointer
    /// can be used to access and modify the characters that compose the
    /// string.
    /// 
    /// Unlike constData() and unicode(), the returned data is always
    /// '\\0'-terminated.
    /// 
    /// Example:
    /// 
    /// Note that the pointer remains valid only as long as the string is
    /// not modified by other means. For read-only access, constData() is
    /// faster because it never causes a [deep copy](deep%20copy)
    /// to occur.
    /// 
    /// **See also:** [`const_data()`]
    /// [`operator()`]
    /// 
    /// **Overloads**
    /// **Note**: The returned string may not be '\\0'-terminated.
    /// Use size() to determine the length of the array.
    /// 
    /// **See also:** [`from_raw_data()`]
    [org_name(data)]
    data_2() -> Char?,
    /// 
    /// Returns a pointer to the data stored in the QString. The pointer
    /// can be used to access the characters that compose the string.
    /// 
    /// Note that the pointer remains valid only as long as the string is
    /// not modified.
    /// 
    /// **Note**: The returned string may not be '\\0'-terminated.
    /// Use size() to determine the length of the array.
    /// 
    /// **See also:** [`data()`]
    /// [`operator()`]
    /// [`from_raw_data()`]
    const_data() -> Char?,
    detach(),
    is_detached() -> bool,
    is_shared_with(other: String) -> bool,
    /// 
    /// Clears the contents of the string and makes it null.
    /// 
    /// **See also:** [`resize()`]
    /// [`is_null()`]
    clear(),
    /// 
    /// Returns the character at the given index *position* in the
    /// string.
    /// 
    /// The *position* must be a valid index position in the string
    /// (i.e., 0 <= *position* < size()).
    /// 
    /// **See also:** [`operator()`]
    at(i: i32) -> Char,
    /// 
    /// Returns the first character in the string.
    /// Same as `at(0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`back()`]
    /// [`at()`]
    /// [`operator()`]
    /// 
    /// Returns a reference to the first character in the string.
    /// Same as `operator[](0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`back()`]
    /// [`at()`]
    /// [`operator()`]
    front() -> Char,
    /// 
    /// Returns the first character in the string.
    /// Same as `at(0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`back()`]
    /// [`at()`]
    /// [`operator()`]
    /// 
    /// Returns a reference to the first character in the string.
    /// Same as `operator[](0)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`back()`]
    /// [`at()`]
    /// [`operator()`]
    [org_name(front)]
    front_2() -> CharRef,
    /// 
    /// Returns the last character in the string.
    /// Same as `at(size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`front()`]
    /// [`at()`]
    /// [`operator()`]
    /// 
    /// Returns a reference to the last character in the string.
    /// Same as `operator[](size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`front()`]
    /// [`at()`]
    /// [`operator()`]
    back() -> Char,
    /// 
    /// Returns the last character in the string.
    /// Same as `at(size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`front()`]
    /// [`at()`]
    /// [`operator()`]
    /// 
    /// Returns a reference to the last character in the string.
    /// Same as `operator[](size() - 1)` .
    /// 
    /// This function is provided for STL compatibility.
    /// 
    /// **Warning**: Calling this function on an empty string constitutes
    /// undefined behavior.
    /// 
    /// **See also:** [`front()`]
    /// [`at()`]
    /// [`operator()`]
    [org_name(back)]
    back_2() -> CharRef,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    arg(a: i64, fieldwidth: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_2(a: qulonglong, fieldwidth: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_3(a: long, fieldwidth: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_4(a: ulong, fieldwidth: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_5(a: i32, field_width: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_6(a: uint, field_width: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_7(a: short, field_width: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_8(a: ushort, field_width: i32, base: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_9(a: double, field_width: i32, fmt: char, prec: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_10(a: char, field_width: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_11(a: CharType, field_width: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_12(a: String, field_width: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_13(a: StringViewType, field_width: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_14(a: Latin1StringType, field_width: i32, fill_char: CharType) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_15(a1: String, a2: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_16(a1: String, a2: String, a3: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_17(a1: String, a2: String, a3: String, a4: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_18(a1: String, a2: String, a3: String, a4: String, a5: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_19(a1: String, a2: String, a3: String, a4: String, a5: String, a6: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_20(a1: String, a2: String, a3: String, a4: String, a5: String, a6: String, a7: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_21(a1: String, a2: String, a3: String, a4: String, a5: String, a6: String, a7: String, a8: String) -> String,
    /// 
    /// Returns a copy of this string with the lowest numbered place marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that argument *a* shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest numbered unreplaced place marker, no matter where it
    /// appears. Also, if place marker `%i` appears more than once in the
    /// string, the arg() replaces all of them.
    /// 
    /// If there is no unreplaced place marker remaining, a warning message
    /// is output and the result is undefined. Place marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// This example shows how we might create a `status` string for
    /// reporting progress while processing a list of files:
    /// 
    /// First, `arg(i)` replaces `%1.` Then `arg(total)` replaces `%2.` Finally, `arg(fileName)` replaces `%3.`
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads**
    /// Returns a copy of this string with the lowest-numbered place-marker
    /// replaced by string *a,* i.e., `%1,` `%2,` ..., `%99.`
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a*
    /// shall occupy. If *a* requires less space than *fieldWidth,* it
    /// is padded to *fieldWidth* with character *fillChar.* A positive
    /// *fieldWidth* produces right-aligned text. A negative *fieldWidth*
    /// produces left-aligned text.
    /// 
    /// One advantage of using arg() over asprintf() is that the order of the
    /// numbered place markers can change, if the application's strings are
    /// translated into other languages, but each arg() will still replace
    /// the lowest-numbered unreplaced place-marker, no matter where it
    /// appears. Also, if place-marker `%i` appears more than once in the
    /// string, arg() replaces all of them.
    /// 
    /// If there is no unreplaced place-marker remaining, a warning message
    /// is printed and the result is undefined. Place-marker numbers must be
    /// in the range 1 to 99.
    /// 
    /// **Overloads** arg()
    /// This is the same as `str.arg(a1).arg(a2)` , except that the
    /// strings *a1* and *a2* are replaced in one pass. This can make a
    /// difference if *a1* contains e.g. `%1` :
    /// 
    /// A similar problem occurs when the numbered place markers are not
    /// white space separated:
    /// 
    /// Let's look at the substitutions:
    /// * First, `Hello` replaces `%1` so the string becomes `"Hello%3%2"` .
    /// * Then, `20` replaces `%2` so the string becomes `"Hello%320"` .
    /// * Since the maximum numbered place marker value is 99, `50` replaces `%32` .
    /// Thus the string finally becomes `"Hello500"` .
    /// 
    /// In such cases, the following yields the expected results:
    /// 
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3),` except
    /// that the strings *a1,* *a2* and *a3* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4)` , except that the strings *a1,* *a2,* *a3* and *a4* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)` , except that the strings
    /// *a1,* *a2,* *a3,* *a4,* and *a5* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))` , except that
    /// the strings *a1,* *a2,* *a3,* *a4,* *a5,* and *a6* are
    /// replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,*
    /// and *a7* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* and *a8* are replaced in one pass.
    /// 
    /// **Overloads** arg()
    /// This is the same as calling `str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)` ,
    /// except that the strings *a1,* *a2,* *a3,* *a4,* *a5,* *a6,* *a7,* *a8,* and *a9* are replaced in one pass.
    /// **Overloads** arg()
    /// The *a* argument is expressed in base *base,* which is 10 by
    /// default and must be between 2 and 36. For bases other than 10, *a*
    /// is treated as an unsigned integer.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no default
    /// locale was specified, the locale is used. The 'L' flag is
    /// ignored if *base* is not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *a* argument is expressed in the given *base,* which is 10 by
    /// default and must be between 2 and 36.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale. The default locale is determined from the
    /// system's locale settings at application startup. It can be changed
    /// using QLocale::setDefault(). The 'L' flag is ignored if *base* is
    /// not 10.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* to a string. The base must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. *base* must be between 2 and 36, with 8
    /// giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The *base* argument specifies the base to use when converting the
    /// integer *a* into a string. The base must be between 2 and 36, with
    /// 8 giving octal, 10 decimal, and 16 hexadecimal numbers.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), the locale's zero is
    /// used. For negative numbers, zero padding might appear before the
    /// minus sign.
    /// 
    /// **Overloads** arg()
    /// 
    /// **Overloads** arg()
    /// The *a* argument is interpreted as a Latin-1 character.
    /// 
    /// **Overloads** arg()
    /// Argument *a* is formatted according to the specified *format* and
    /// *precision.* See [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// *fieldWidth* specifies the minimum amount of space that *a* is
    /// padded to and filled with the character *fillChar.* A positive
    /// value produces right-aligned text; a negative value produces
    /// left-aligned text.
    /// 
    /// The '%' can be followed by an 'L', in which case the sequence is
    /// replaced with a localized representation of *a.* The conversion
    /// uses the default locale, set by QLocale::setDefault(). If no
    /// default locale was specified, the locale is used.
    /// 
    /// If *fillChar* is '0' (the number 0, ASCII 48), this function will
    /// use the locale's zero to pad. For negative numbers, the zero padding
    /// will probably appear before the minus sign.
    /// 
    /// **See also:** [`Locale::to_string`]
    [org_name(arg)]
    arg_22(a1: String, a2: String, a3: String, a4: String, a5: String, a6: String, a7: String, a8: String, a9: String) -> String,
    /// 
    /// Use vasprintf(), arg() or QTextStream instead.
    vsprintf(format: *char, ap: va_list) -> String?,
    /// 
    /// Use asprintf(), arg() or QTextStream instead.
    sprintf(format: *char) -> String?,
    /// 
    /// Equivalent method to asprintf(), but takes a va_list *ap*
    /// instead a list of variable arguments. See the asprintf()
    /// documentation for an explanation of *cformat.*
    /// 
    /// This method does not call the va_end macro, the caller
    /// is responsible to call va_end on *ap.*
    /// 
    /// **See also:** [`asprintf()`]
    [static] vasprintf(format: *char, ap: va_list) -> String,
    /// 
    /// Safely builds a formatted string from the format string *cformat*
    /// and an arbitrary list of arguments.
    /// 
    /// The format string supports the conversion specifiers, length modifiers,
    /// and flags provided by printf() in the standard C++ library. The *cformat*
    /// string and `%s` arguments must be UTF-8 encoded.
    /// 
    /// **Note**: The `%lc` escape sequence expects a unicode character of type
    /// `char16_t,` or `ushort` (as returned by QChar::unicode()).
    /// The `%ls` escape sequence expects a pointer to a zero-terminated array
    /// of unicode characters of type `char16_t,` or ushort (as returned by
    /// QString::utf16()). This is at odds with the printf() in the standard C++
    /// library, which defines `%lc` to print a wchar_t and `%ls` to print
    /// a `wchar_t*` , and might also produce compiler warnings on platforms
    /// where the size of `wchar_t` is not 16 bits.
    /// 
    /// **Warning**: We do not recommend using QString::asprintf() in new Qt
    /// code. Instead, consider using QTextStream or arg(), both of
    /// which support Unicode strings seamlessly and are type-safe.
    /// Here's an example that uses QTextStream:
    /// 
    /// For [translations](QObject::tr())
    /// , especially if the strings
    /// contains more than one escape sequence, you should consider using
    /// the arg() function instead. This allows the order of the
    /// replacements to be controlled by the translator.
    /// 
    /// **See also:** [`arg()`]
    [static] asprintf(format: *char) -> String,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    index_of(c: CharType, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_2(s: String, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_3(s: Latin1StringType, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_4(s: &StringRefType, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    last_index_of(c: CharType, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_2(s: String, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_3(s: Latin1StringType, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_4(s: &StringRefType, from: i32, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    contains(c: CharType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_2(s: String, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_3(s: Latin1StringType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_4(s: &StringRefType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// the string *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of occurrences of character *ch* in the string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count() Returns the number of (potentially overlapping) occurrences of the
    /// string reference *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *rx* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *re* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Same as size().
    [org_name(count)]
    count_2(c: CharType, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// the string *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of occurrences of character *ch* in the string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count() Returns the number of (potentially overlapping) occurrences of the
    /// string reference *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *rx* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *re* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Same as size().
    [org_name(count)]
    count_3(s: String, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// the string *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of occurrences of character *ch* in the string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count() Returns the number of (potentially overlapping) occurrences of the
    /// string reference *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *rx* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *re* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Same as size().
    [org_name(count)]
    count_4(s: &StringRefType, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_5(arg0: &RegExpType, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_5(arg0: &RegExpType, from: i32) -> i32,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_5(rx: &RegExpType) -> bool,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// the string *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of occurrences of character *ch* in the string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count() Returns the number of (potentially overlapping) occurrences of the
    /// string reference *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *rx* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *re* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Same as size().
    [org_name(count)]
    count_5(arg0: &RegExpType) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_6(arg0: &RegExpType, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_6(arg0: &RegExpType, from: i32) -> i32,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_6(rx: &RegExpType) -> bool,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_7(re: &RegularExpressionType, from: i32) -> i32,
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// Returns the index position of the first occurrence of the string *str* in this string, searching forward from index position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// If *from* is -1, the search starts at the last character; if it is
    /// -2, at the next to last character and so on.
    /// 
    /// **See also:** [`last_index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the
    /// character *ch* in the string, searching forward from index
    /// position *from.* Returns -1 if *ch* could not be found.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first occurrence of the string
    /// reference *str* in this string, searching forward from index
    /// position *from.* Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *rx* in the string, searching forward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** indexOf()
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the first match of the regular
    /// expression *re* in the string, searching forward from index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(indexOf)]
    index_of_8(re: &RegularExpressionType, from: i32, rmatch: *RegularExpressionMatchType) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_7(re: &RegularExpressionType, from: i32) -> i32,
    /// 
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string *str* in this string, searching backward from index position *from.* If *from* is -1 (default), the search starts at the last
    /// character; if *from* is -2, at the next to last character and so
    /// on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the character
    /// *ch,* searching backward from position *from.*
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last occurrence of the string
    /// reference *str* in this string, searching backward from index
    /// position *from.* If *from* is -1 (default), the search starts at
    /// the last character; if *from* is -2, at the next to last character
    /// and so on. Returns -1 if *str* is not found.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`contains()`]
    /// [`count()`]
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *rx* in the string, searching backward from index
    /// position *from.* Returns -1 if *rx* didn't match anywhere.
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** lastIndexOf()
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads**
    /// Returns the index position of the last match of the regular
    /// expression *re* in the string, which starts before the index
    /// position *from.* Returns -1 if *re* didn't match anywhere.
    /// 
    /// If the match is successful and *rmatch* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *rmatch.*
    /// 
    /// Example:
    /// 
    [org_name(lastIndexOf)]
    last_index_of_8(re: &RegularExpressionType, from: i32, rmatch: *RegularExpressionMatchType) -> i32,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_7(re: &RegularExpressionType) -> bool,
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the latin-1 string
    /// *str;* otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if this string contains an occurrence of the
    /// character *ch;* otherwise returns `false.`
    /// 
    /// Returns `true` if this string contains an occurrence of the string
    /// reference *str;* otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`index_of()`]
    /// [`count()`]
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *rx* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// If there is a match, the *rx* regular expression will contain the
    /// matched captures (see QRegExp::matchedLength, QRegExp::cap).
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in
    /// this string; otherwise returns `false.`
    /// 
    /// **Overloads** contains()
    /// Returns `true` if the regular expression *re* matches somewhere in this
    /// string; otherwise returns `false.`
    /// 
    /// If the match is successful and *match* is not a null pointer, it also
    /// writes the results of the match into the QRegularExpressionMatch object
    /// pointed to by *match.*
    /// 
    /// **See also:** [`RegularExpression::match`]
    [org_name(contains)]
    contains_8(re: &RegularExpressionType, match: *RegularExpressionMatchType) -> bool,
    /// 
    /// Returns the number of (potentially overlapping) occurrences of
    /// the string *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of occurrences of character *ch* in the string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count() Returns the number of (potentially overlapping) occurrences of the
    /// string reference *str* in this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`contains()`]
    /// [`index_of()`]
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *rx* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Returns the number of times the regular expression *re* matches
    /// in the string.
    /// 
    /// This function counts overlapping matches, so in the example
    /// below, there are four instances of or :
    /// 
    /// 
    /// **Overloads** count()
    /// Same as size().
    [org_name(count)]
    count_6(re: &RegularExpressionType) -> i32,
    /// 
    /// This function returns a section of the string.
    /// 
    /// This string is treated as a sequence of fields separated by the
    /// character, *sep.* The returned string consists of the fields from
    /// position *start* to position *end* inclusive. If *end* is not
    /// specified, all fields from position *start* to the end of the
    /// string are included. Fields are numbered 0, 1, 2, etc., counting
    /// from the left, and -1, -2, etc., counting from right to left.
    /// 
    /// The *flags* argument can be used to affect some aspects of the
    /// function's behavior, e.g. whether to be case sensitive, whether
    /// to skip empty fields and how to deal with leading and trailing
    /// separators; see [SectionFlags](SectionFlags)
    /// 
    /// 
    /// If *start* or *end* is negative, we count fields from the right
    /// of the string, the right-most field being -1, the one from
    /// right-most field being -2, and so on.
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *reg.*
    /// 
    /// **Warning**: Using this QRegExp version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *re.*
    /// 
    /// **Warning**: Using this QRegularExpression version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    section(sep: CharType, start: i32, end: i32, flags: String::SectionFlags) -> String,
    /// 
    /// This function returns a section of the string.
    /// 
    /// This string is treated as a sequence of fields separated by the
    /// character, *sep.* The returned string consists of the fields from
    /// position *start* to position *end* inclusive. If *end* is not
    /// specified, all fields from position *start* to the end of the
    /// string are included. Fields are numbered 0, 1, 2, etc., counting
    /// from the left, and -1, -2, etc., counting from right to left.
    /// 
    /// The *flags* argument can be used to affect some aspects of the
    /// function's behavior, e.g. whether to be case sensitive, whether
    /// to skip empty fields and how to deal with leading and trailing
    /// separators; see [SectionFlags](SectionFlags)
    /// 
    /// 
    /// If *start* or *end* is negative, we count fields from the right
    /// of the string, the right-most field being -1, the one from
    /// right-most field being -2, and so on.
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *reg.*
    /// 
    /// **Warning**: Using this QRegExp version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *re.*
    /// 
    /// **Warning**: Using this QRegularExpression version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    [org_name(section)]
    section_2(in_sep: String, start: i32, end: i32, flags: String::SectionFlags) -> String,
    /// 
    /// This function returns a section of the string.
    /// 
    /// This string is treated as a sequence of fields separated by the
    /// character, *sep.* The returned string consists of the fields from
    /// position *start* to position *end* inclusive. If *end* is not
    /// specified, all fields from position *start* to the end of the
    /// string are included. Fields are numbered 0, 1, 2, etc., counting
    /// from the left, and -1, -2, etc., counting from right to left.
    /// 
    /// The *flags* argument can be used to affect some aspects of the
    /// function's behavior, e.g. whether to be case sensitive, whether
    /// to skip empty fields and how to deal with leading and trailing
    /// separators; see [SectionFlags](SectionFlags)
    /// 
    /// 
    /// If *start* or *end* is negative, we count fields from the right
    /// of the string, the right-most field being -1, the one from
    /// right-most field being -2, and so on.
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *reg.*
    /// 
    /// **Warning**: Using this QRegExp version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *re.*
    /// 
    /// **Warning**: Using this QRegularExpression version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    [org_name(section)]
    section_3(reg: &RegExpType, start: i32, end: i32, flags: String::SectionFlags) -> String,
    /// 
    /// This function returns a section of the string.
    /// 
    /// This string is treated as a sequence of fields separated by the
    /// character, *sep.* The returned string consists of the fields from
    /// position *start* to position *end* inclusive. If *end* is not
    /// specified, all fields from position *start* to the end of the
    /// string are included. Fields are numbered 0, 1, 2, etc., counting
    /// from the left, and -1, -2, etc., counting from right to left.
    /// 
    /// The *flags* argument can be used to affect some aspects of the
    /// function's behavior, e.g. whether to be case sensitive, whether
    /// to skip empty fields and how to deal with leading and trailing
    /// separators; see [SectionFlags](SectionFlags)
    /// 
    /// 
    /// If *start* or *end* is negative, we count fields from the right
    /// of the string, the right-most field being -1, the one from
    /// right-most field being -2, and so on.
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// 
    /// **See also:** [`split()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *reg.*
    /// 
    /// **Warning**: Using this QRegExp version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    /// 
    /// **Overloads** section()
    /// This string is treated as a sequence of fields separated by the
    /// regular expression, *re.*
    /// 
    /// **Warning**: Using this QRegularExpression version is much more expensive than
    /// the overloaded string and character versions.
    /// 
    /// **See also:** [`split()`]
    /// [`simplified()`]
    [org_name(section)]
    section_4(re: &RegularExpressionType, start: i32, end: i32, flags: String::SectionFlags) -> String,
    /// 
    /// Returns a substring that contains the *n* leftmost characters
    /// of the string.
    /// 
    /// The entire string is returned if *n* is greater than or equal
    /// to size(), or less than zero.
    /// 
    /// **See also:** [`right()`]
    /// [`mid()`]
    /// [`starts_with()`]
    /// [`chopped()`]
    /// [`chop()`]
    /// [`truncate()`]
    /// 
    /// Returns a string of size *width* that contains this string
    /// padded by the *fill* character.
    /// 
    /// If *truncate* is `false` and the size() of the string is more than
    /// *width,* then the returned string is a copy of the string.
    /// 
    /// If *truncate* is `true` and the size() of the string is more than
    /// *width,* then any characters in a copy of the string after
    /// position *width* are removed, and the copy is returned.
    /// 
    /// **See also:** [`right_justified()`]
    /// 
    /// Returns a substring reference to the *n* leftmost characters
    /// of the string.
    /// 
    /// If *n* is greater than or equal to size(), or less than zero,
    /// a reference to the entire string is returned.
    /// 
    /// **See also:** [`left()`]
    /// [`right_ref()`]
    /// [`mid_ref()`]
    /// [`starts_with()`]
    left(n: i32) -> String,
    /// 
    /// Returns a substring that contains the *n* rightmost characters
    /// of the string.
    /// 
    /// The entire string is returned if *n* is greater than or equal
    /// to size(), or less than zero.
    /// 
    /// **See also:** [`left()`]
    /// [`mid()`]
    /// [`ends_with()`]
    /// [`chopped()`]
    /// [`chop()`]
    /// [`truncate()`]
    /// 
    /// Returns a string of size() *width* that contains the *fill*
    /// character followed by the string. For example:
    /// 
    /// If *truncate* is `false` and the size() of the string is more than
    /// *width,* then the returned string is a copy of the string.
    /// 
    /// If *truncate* is true and the size() of the string is more than
    /// *width,* then the resulting string is truncated at position *width.*
    /// 
    /// **See also:** [`left_justified()`]
    /// 
    /// Returns a substring reference to the *n* rightmost characters
    /// of the string.
    /// 
    /// If *n* is greater than or equal to size(), or less than zero,
    /// a reference to the entire string is returned.
    /// 
    /// **See also:** [`right()`]
    /// [`left_ref()`]
    /// [`mid_ref()`]
    /// [`ends_with()`]
    right(n: i32) -> String,
    /// 
    /// Returns a string that contains *n* characters of this string,
    /// starting at the specified *position* index.
    /// 
    /// Returns a null string if the *position* index exceeds the
    /// length of the string. If there are less than *n* characters
    /// available in the string starting at the given *position,* or if
    /// *n* is -1 (default), the function returns all characters that
    /// are available from the specified *position.*
    /// 
    /// Example:
    /// 
    /// **See also:** [`left()`]
    /// [`right()`]
    /// [`chopped()`]
    /// [`chop()`]
    /// [`truncate()`]
    /// 
    /// Returns a substring reference to *n* characters of this string,
    /// starting at the specified *position.*
    /// 
    /// If the *position* exceeds the length of the string, a null
    /// reference is returned.
    /// 
    /// If there are less than *n* characters available in the string,
    /// starting at the given *position,* or if *n* is -1 (default), the
    /// function returns all characters from the specified *position*
    /// onwards.
    /// 
    /// Example:
    /// 
    /// **See also:** [`mid()`]
    /// [`left_ref()`]
    /// [`right_ref()`]
    mid(position: i32, n: i32) -> String,
    /// 
    /// Returns a substring that contains the size() - *len* leftmost characters
    /// of this string.
    /// 
    /// **Note**: The behavior is undefined if *len* is negative or greater than size().
    /// 
    /// **See also:** [`ends_with()`]
    /// [`left()`]
    /// [`right()`]
    /// [`mid()`]
    /// [`chop()`]
    /// [`truncate()`]
    chopped(n: i32) -> String,
    /// 
    /// Returns a substring reference to the *n* leftmost characters
    /// of the string.
    /// 
    /// If *n* is greater than or equal to size(), or less than zero,
    /// a reference to the entire string is returned.
    /// 
    /// **See also:** [`left()`]
    /// [`right_ref()`]
    /// [`mid_ref()`]
    /// [`starts_with()`]
    left_ref(n: i32) -> StringRef,
    /// 
    /// Returns a substring reference to the *n* rightmost characters
    /// of the string.
    /// 
    /// If *n* is greater than or equal to size(), or less than zero,
    /// a reference to the entire string is returned.
    /// 
    /// **See also:** [`right()`]
    /// [`left_ref()`]
    /// [`mid_ref()`]
    /// [`ends_with()`]
    right_ref(n: i32) -> StringRef,
    /// 
    /// Returns a substring reference to *n* characters of this string,
    /// starting at the specified *position.*
    /// 
    /// If the *position* exceeds the length of the string, a null
    /// reference is returned.
    /// 
    /// If there are less than *n* characters available in the string,
    /// starting at the given *position,* or if *n* is -1 (default), the
    /// function returns all characters from the specified *position*
    /// onwards.
    /// 
    /// Example:
    /// 
    /// **See also:** [`mid()`]
    /// [`left_ref()`]
    /// [`right_ref()`]
    mid_ref(position: i32, n: i32) -> StringRef,
    /// 
    /// Returns `true` if the string starts with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads** startsWith()
    /// 
    /// **Overloads** startsWith()
    /// Returns `true` if the string starts with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads**  Returns `true` if the string starts with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the string starts with the string-view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case-sensitive;
    /// otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    starts_with(s: String, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string starts with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads** startsWith()
    /// 
    /// **Overloads** startsWith()
    /// Returns `true` if the string starts with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads**  Returns `true` if the string starts with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the string starts with the string-view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case-sensitive;
    /// otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    [org_name(startsWith)]
    starts_with_2(s: &StringRefType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string starts with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads** startsWith()
    /// 
    /// **Overloads** startsWith()
    /// Returns `true` if the string starts with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads**  Returns `true` if the string starts with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the string starts with the string-view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case-sensitive;
    /// otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    [org_name(startsWith)]
    starts_with_3(s: StringViewType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string starts with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads** startsWith()
    /// 
    /// **Overloads** startsWith()
    /// Returns `true` if the string starts with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads**  Returns `true` if the string starts with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the string starts with the string-view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case-sensitive;
    /// otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    [org_name(startsWith)]
    starts_with_4(s: Latin1StringType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string starts with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads** startsWith()
    /// 
    /// **Overloads** startsWith()
    /// Returns `true` if the string starts with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads**  Returns `true` if the string starts with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    /// 
    /// **Overloads**
    /// Returns `true` if the string starts with the string-view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case-sensitive;
    /// otherwise the search is case insensitive.
    /// 
    /// **See also:** [`ends_with()`]
    [org_name(startsWith)]
    starts_with_5(c: CharType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    ends_with(s: String, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    [org_name(endsWith)]
    ends_with_2(s: &StringRefType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    [org_name(endsWith)]
    ends_with_3(s: StringViewType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    [org_name(endsWith)]
    ends_with_4(s: Latin1StringType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    [org_name(endsWith)]
    ends_with_5(c: CharType, cs: Rute::CaseSensitivity) -> bool,
    /// 
    /// Returns a string of size *width* that contains this string
    /// padded by the *fill* character.
    /// 
    /// If *truncate* is `false` and the size() of the string is more than
    /// *width,* then the returned string is a copy of the string.
    /// 
    /// If *truncate* is `true` and the size() of the string is more than
    /// *width,* then any characters in a copy of the string after
    /// position *width* are removed, and the copy is returned.
    /// 
    /// **See also:** [`right_justified()`]
    left_justified(width: i32, fill: CharType, trunc: bool) -> String,
    /// 
    /// Returns a string of size() *width* that contains the *fill*
    /// character followed by the string. For example:
    /// 
    /// If *truncate* is `false` and the size() of the string is more than
    /// *width,* then the returned string is a copy of the string.
    /// 
    /// If *truncate* is true and the size() of the string is more than
    /// *width,* then the resulting string is truncated at position *width.*
    /// 
    /// **See also:** [`left_justified()`]
    right_justified(width: i32, fill: CharType, trunc: bool) -> String,
    /// 
    /// Returns a lowercase copy of the string.
    /// 
    /// The case conversion will always happen in the 'C' locale. For locale dependent
    /// case folding use QLocale::toLower()
    /// 
    /// **See also:** [`to_upper()`]
    /// [`Locale::to_lower`]
    to_lower() -> String,
    /// 
    /// Returns a lowercase copy of the string.
    /// 
    /// The case conversion will always happen in the 'C' locale. For locale dependent
    /// case folding use QLocale::toLower()
    /// 
    /// **See also:** [`to_upper()`]
    /// [`Locale::to_lower`]
    [org_name(toLower)]
    to_lower_2() -> String,
    /// 
    /// Returns an uppercase copy of the string.
    /// 
    /// The case conversion will always happen in the 'C' locale. For locale dependent
    /// case folding use QLocale::toUpper()
    /// 
    /// **See also:** [`to_lower()`]
    /// [`Locale::to_lower`]
    to_upper() -> String,
    /// 
    /// Returns an uppercase copy of the string.
    /// 
    /// The case conversion will always happen in the 'C' locale. For locale dependent
    /// case folding use QLocale::toUpper()
    /// 
    /// **See also:** [`to_lower()`]
    /// [`Locale::to_lower`]
    [org_name(toUpper)]
    to_upper_2() -> String,
    /// 
    /// Returns the case folded equivalent of the string. For most Unicode
    /// characters this is the same as toLower().
    to_case_folded() -> String,
    /// 
    /// Returns the case folded equivalent of the string. For most Unicode
    /// characters this is the same as toLower().
    [org_name(toCaseFolded)]
    to_case_folded_2() -> String,
    /// 
    /// Returns a string that has whitespace removed from the start
    /// and the end, and that has each sequence of internal whitespace
    /// replaced with a single space.
    /// 
    /// Whitespace means any character for which QChar::isSpace() returns
    /// `true.` This includes the ASCII characters '\\t', '\\n', '\\v',
    /// '\\f', '\\r', and ' '.
    /// 
    /// Example:
    /// 
    /// **See also:** [`trimmed()`]
    simplified() -> String,
    /// 
    /// Returns a string that has whitespace removed from the start
    /// and the end, and that has each sequence of internal whitespace
    /// replaced with a single space.
    /// 
    /// Whitespace means any character for which QChar::isSpace() returns
    /// `true.` This includes the ASCII characters '\\t', '\\n', '\\v',
    /// '\\f', '\\r', and ' '.
    /// 
    /// Example:
    /// 
    /// **See also:** [`trimmed()`]
    [org_name(simplified)]
    simplified_2() -> String,
    /// 
    /// Converts a plain text string to an HTML string with
    /// HTML metacharacters `<` , `>` , `&` , and `"` replaced by HTML
    /// entities.
    /// 
    /// Example:
    /// 
    to_html_escaped() -> String,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    insert(i: i32, c: CharType) -> String?,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    [org_name(insert)]
    insert_2(i: i32, uc: *CharType, len: i32) -> String?,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    [org_name(insert)]
    insert_3(i: i32, s: String) -> String?,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    [org_name(insert)]
    insert_4(i: i32, s: &StringRefType) -> String?,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    [org_name(insert)]
    insert_5(i: i32, s: Latin1StringType) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    append(c: CharType) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    [org_name(append)]
    append_2(uc: *CharType, len: i32) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    [org_name(append)]
    append_3(s: String) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    [org_name(append)]
    append_4(s: &StringRefType) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    [org_name(append)]
    append_5(s: Latin1StringType) -> String?,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    prepend(c: CharType) -> String?,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    [org_name(prepend)]
    prepend_2(uc: *CharType, len: i32) -> String?,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    [org_name(prepend)]
    prepend_3(s: String) -> String?,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    [org_name(prepend)]
    prepend_4(s: &StringRefType) -> String?,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    [org_name(prepend)]
    prepend_5(s: Latin1StringType) -> String?,
    /// 
    /// Removes *n* characters from the string, starting at the given *position* index, and returns a reference to the string.
    /// 
    /// If the specified *position* index is within the string, but *position* + *n* is beyond the end of the string, the string is
    /// truncated at the specified *position.*
    /// 
    /// **See also:** [`insert()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// **Overloads**
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the character *ch* in this string, and
    /// returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// This is the same as `replace(ch,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *rx* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *re* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    remove(i: i32, len: i32) -> String?,
    /// 
    /// Removes *n* characters from the string, starting at the given *position* index, and returns a reference to the string.
    /// 
    /// If the specified *position* index is within the string, but *position* + *n* is beyond the end of the string, the string is
    /// truncated at the specified *position.*
    /// 
    /// **See also:** [`insert()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// **Overloads**
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the character *ch* in this string, and
    /// returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// This is the same as `replace(ch,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *rx* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *re* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    [org_name(remove)]
    remove_2(c: CharType, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Removes *n* characters from the string, starting at the given *position* index, and returns a reference to the string.
    /// 
    /// If the specified *position* index is within the string, but *position* + *n* is beyond the end of the string, the string is
    /// truncated at the specified *position.*
    /// 
    /// **See also:** [`insert()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// **Overloads**
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the character *ch* in this string, and
    /// returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// This is the same as `replace(ch,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *rx* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *re* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    [org_name(remove)]
    remove_3(s: Latin1StringType, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Removes *n* characters from the string, starting at the given *position* index, and returns a reference to the string.
    /// 
    /// If the specified *position* index is within the string, but *position* + *n* is beyond the end of the string, the string is
    /// truncated at the specified *position.*
    /// 
    /// **See also:** [`insert()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// **Overloads**
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the character *ch* in this string, and
    /// returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// This is the same as `replace(ch,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *rx* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *re* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    [org_name(remove)]
    remove_4(s: String, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    replace(i: i32, len: i32, after: CharType) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_2(i: i32, len: i32, s: *CharType, slen: i32) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_3(i: i32, len: i32, after: String) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_4(before: CharType, after: CharType, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_5(before: *CharType, blen: i32, after: *CharType, alen: i32, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_6(before: Latin1StringType, after: Latin1StringType, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_7(before: Latin1StringType, after: String, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_8(before: String, after: Latin1StringType, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_9(before: String, after: String, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_10(c: CharType, after: String, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_11(c: CharType, after: Latin1StringType, cs: Rute::CaseSensitivity) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_12(rx: &RegExpType, after: String) -> String?,
    /// 
    /// Removes *n* characters from the string, starting at the given *position* index, and returns a reference to the string.
    /// 
    /// If the specified *position* index is within the string, but *position* + *n* is beyond the end of the string, the string is
    /// truncated at the specified *position.*
    /// 
    /// **See also:** [`insert()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// **Overloads**
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the character *ch* in this string, and
    /// returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// This is the same as `replace(ch,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *rx* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *re* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    [org_name(remove)]
    remove_5(rx: &RegExpType) -> String?,
    /// 
    /// Replaces *n* characters beginning at index *position* with
    /// the string *after* and returns a reference to this string.
    /// 
    /// **Note**: If the specified *position* index is within the string,
    /// but *position* + *n* goes outside the strings range,
    /// then *n* will be adjusted to stop at the end of the string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`insert()`]
    /// [`remove()`]
    /// 
    /// **Overloads** replace() Replaces *n* characters beginning at index *position* with the
    /// first *size* characters of the QChar array *unicode* and returns a
    /// reference to this string.
    /// 
    /// **Overloads** replace()
    /// Replaces *n* characters beginning at index *position* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// **Note**: The replacement text is not rescanned after it is inserted.
    /// 
    /// Example:
    /// 
    /// 
    /// **Overloads** replace()
    /// Replaces each occurrence in this string of the first *blen*
    /// characters of *before* with the first *alen* characters of *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *ch* in the string with
    /// *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace() Replaces every occurrence of the character *before* with the
    /// character *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the string *before* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the character *c* with the string *after* and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **Note**: The text is not rescanned after a replacement.
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *rx* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing [capturing parentheses](capturing%20parentheses)
    /// 
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with *rx* .cap(1), cap(2), ...
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegExp::cap`]
    /// 
    /// **Overloads** replace()
    /// Replaces every occurrence of the regular expression *re* in the
    /// string with *after.* Returns a reference to the string. For
    /// example:
    /// 
    /// For regular expressions containing capturing groups,
    /// occurrences of **\\1** , **\\2** , ..., in *after* are replaced
    /// with the string captured by the corresponding capturing group.
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`remove()`]
    /// [`RegularExpression`]
    /// [`RegularExpressionMatch`]
    [org_name(replace)]
    replace_13(re: &RegularExpressionType, after: String) -> String?,
    /// 
    /// Removes *n* characters from the string, starting at the given *position* index, and returns a reference to the string.
    /// 
    /// If the specified *position* index is within the string, but *position* + *n* is beyond the end of the string, the string is
    /// truncated at the specified *position.*
    /// 
    /// **See also:** [`insert()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// **Overloads**
    /// Removes every occurrence of the given *str* string in this
    /// string, and returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is
    /// case sensitive; otherwise the search is case insensitive.
    /// 
    /// This is the same as `replace(str,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the character *ch* in this string, and
    /// returns a reference to this string.
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// Example:
    /// 
    /// This is the same as `replace(ch,` , cs).
    /// 
    /// **See also:** [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *rx* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    /// 
    /// Removes every occurrence of the regular expression *re* in the
    /// string, and returns a reference to the string. For example:
    /// 
    /// **See also:** [`index_of()`]
    /// [`last_index_of()`]
    /// [`replace()`]
    [org_name(remove)]
    remove_6(re: &RegularExpressionType) -> String?,
    /// 
    /// Splits the string into substrings wherever *sep* occurs, and
    /// returns the list of those strings. If *sep* does not match
    /// anywhere in the string, split() returns a single-element list
    /// containing this string.
    /// 
    /// *cs* specifies whether *sep* should be matched case
    /// sensitively or case insensitively.
    /// 
    /// If *behavior* is QString::SkipEmptyParts, empty entries don't
    /// appear in the result. By default, empty entries are kept.
    /// 
    /// Example:
    /// 
    /// If *sep* is empty, split() returns an empty string, followed
    /// by each of the string's characters, followed by another empty string:
    /// 
    /// To understand this behavior, recall that the empty string matches
    /// everywhere, so the above is qualitatively the same as:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    split(sep: String, behavior: String::SplitBehavior, cs: Rute::CaseSensitivity) -> [String],
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    split_ref(sep: String, behavior: String::SplitBehavior, cs: Rute::CaseSensitivity) -> [StringRef],
    /// 
    /// Splits the string into substrings wherever *sep* occurs, and
    /// returns the list of those strings. If *sep* does not match
    /// anywhere in the string, split() returns a single-element list
    /// containing this string.
    /// 
    /// *cs* specifies whether *sep* should be matched case
    /// sensitively or case insensitively.
    /// 
    /// If *behavior* is QString::SkipEmptyParts, empty entries don't
    /// appear in the result. By default, empty entries are kept.
    /// 
    /// Example:
    /// 
    /// If *sep* is empty, split() returns an empty string, followed
    /// by each of the string's characters, followed by another empty string:
    /// 
    /// To understand this behavior, recall that the empty string matches
    /// everywhere, so the above is qualitatively the same as:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    [org_name(split)]
    split_2(sep: CharType, behavior: String::SplitBehavior, cs: Rute::CaseSensitivity) -> [String],
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    [org_name(splitRef)]
    split_ref_2(sep: CharType, behavior: String::SplitBehavior, cs: Rute::CaseSensitivity) -> [StringRef],
    /// 
    /// Splits the string into substrings wherever *sep* occurs, and
    /// returns the list of those strings. If *sep* does not match
    /// anywhere in the string, split() returns a single-element list
    /// containing this string.
    /// 
    /// *cs* specifies whether *sep* should be matched case
    /// sensitively or case insensitively.
    /// 
    /// If *behavior* is QString::SkipEmptyParts, empty entries don't
    /// appear in the result. By default, empty entries are kept.
    /// 
    /// Example:
    /// 
    /// If *sep* is empty, split() returns an empty string, followed
    /// by each of the string's characters, followed by another empty string:
    /// 
    /// To understand this behavior, recall that the empty string matches
    /// everywhere, so the above is qualitatively the same as:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    [org_name(split)]
    split_3(sep: &RegExpType, behavior: String::SplitBehavior) -> [String],
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    [org_name(splitRef)]
    split_ref_3(sep: &RegExpType, behavior: String::SplitBehavior) -> [StringRef],
    /// 
    /// Splits the string into substrings wherever *sep* occurs, and
    /// returns the list of those strings. If *sep* does not match
    /// anywhere in the string, split() returns a single-element list
    /// containing this string.
    /// 
    /// *cs* specifies whether *sep* should be matched case
    /// sensitively or case insensitively.
    /// 
    /// If *behavior* is QString::SkipEmptyParts, empty entries don't
    /// appear in the result. By default, empty entries are kept.
    /// 
    /// Example:
    /// 
    /// If *sep* is empty, split() returns an empty string, followed
    /// by each of the string's characters, followed by another empty string:
    /// 
    /// To understand this behavior, recall that the empty string matches
    /// everywhere, so the above is qualitatively the same as:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substrings wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, split() returns a
    /// single-element list containing this string.
    /// 
    /// Here's an example where we extract the words in a sentence
    /// using one or more whitespace characters as the separator:
    /// 
    /// Here's a similar example, but this time we use any sequence of
    /// non-word characters as the separator:
    /// 
    /// Here's a third example where we use a zero-length assertion,
    /// **\\b** (word boundary), to split the string into an
    /// alternating sequence of non-word and word tokens:
    /// 
    /// **See also:** [`StringList::join`]
    /// [`section()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    [org_name(split)]
    split_4(sep: &RegularExpressionType, behavior: String::SplitBehavior) -> [String],
    /// 
    /// Splits the string into substring references wherever *sep* occurs, and
    /// returns the list of those strings.
    /// 
    /// See QString::split() for how *sep,* *behavior* and *cs* interact to form
    /// the result.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *rx* matches, and returns the list of those strings. If *rx*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** [`q_string_ref_split()`]
    /// 
    /// **Overloads**
    /// Splits the string into substring references wherever the regular expression
    /// *re* matches, and returns the list of those strings. If *re*
    /// does not match anywhere in the string, splitRef() returns a
    /// single-element vector containing this string reference.
    /// 
    /// **Note**: All references are valid as long this string is alive. Destroying this
    /// string will cause all references be dangling pointers.
    /// 
    /// **See also:** split() QStringRef
    [org_name(splitRef)]
    split_ref_4(sep: &RegularExpressionType, behavior: String::SplitBehavior) -> [StringRef],
    /// 
    /// Returns the string in the given Unicode normalization *mode,*
    /// according to the given *version* of the Unicode standard.
    normalized(mode: String::NormalizationForm, version: Char::UnicodeVersion) -> String,
    /// 
    /// Returns a copy of this string repeated the specified number of *times.*
    /// 
    /// If *times* is less than 1, an empty string is returned.
    /// 
    /// Example:
    /// 
    /// ```
    /// QString str("ab");
    /// str.repeated(4);            // returns "abababab"
    /// ```
    /// 
    repeated(times: i32) -> String,
    /// 
    /// Returns the QString as a '\\0\'-terminated array of unsigned
    /// shorts. The result remains valid until the string is modified.
    /// 
    /// The returned string is in host byte order.
    /// 
    /// **See also:** [`unicode()`]
    utf16() -> ushort?,
    /// 
    /// Returns a Latin-1 representation of the string as a QByteArray.
    /// 
    /// The returned byte array is undefined if the string contains non-Latin1
    /// characters. Those characters may be suppressed or replaced with a
    /// question mark.
    /// 
    /// **See also:** [`from_latin1()`]
    /// [`to_utf8()`]
    /// [`to_local8_bit()`]
    /// [`TextCodec`]
    to_latin1() -> ByteArray,
    /// 
    /// Returns a Latin-1 representation of the string as a QByteArray.
    /// 
    /// The returned byte array is undefined if the string contains non-Latin1
    /// characters. Those characters may be suppressed or replaced with a
    /// question mark.
    /// 
    /// **See also:** [`from_latin1()`]
    /// [`to_utf8()`]
    /// [`to_local8_bit()`]
    /// [`TextCodec`]
    [org_name(toLatin1)]
    to_latin1_2() -> ByteArray,
    /// 
    /// Returns a UTF-8 representation of the string as a QByteArray.
    /// 
    /// UTF-8 is a Unicode codec and can represent all characters in a Unicode
    /// string like QString.
    /// 
    /// **See also:** [`from_utf8()`]
    /// [`to_latin1()`]
    /// [`to_local8_bit()`]
    /// [`TextCodec`]
    to_utf8() -> ByteArray,
    /// 
    /// Returns a UTF-8 representation of the string as a QByteArray.
    /// 
    /// UTF-8 is a Unicode codec and can represent all characters in a Unicode
    /// string like QString.
    /// 
    /// **See also:** [`from_utf8()`]
    /// [`to_latin1()`]
    /// [`to_local8_bit()`]
    /// [`TextCodec`]
    [org_name(toUtf8)]
    to_utf8_2() -> ByteArray,
    /// 
    /// Returns the local 8-bit representation of the string as a
    /// QByteArray. The returned byte array is undefined if the string
    /// contains characters not supported by the local 8-bit encoding.
    /// 
    /// QTextCodec::codecForLocale() is used to perform the conversion from
    /// Unicode. If the locale encoding could not be determined, this function
    /// does the same as toLatin1().
    /// 
    /// If this string contains any characters that cannot be encoded in the
    /// locale, the returned byte array is undefined. Those characters may be
    /// suppressed or replaced by another.
    /// 
    /// **See also:** [`from_local8_bit()`]
    /// [`to_latin1()`]
    /// [`to_utf8()`]
    /// [`TextCodec`]
    to_local8_bit() -> ByteArray,
    /// 
    /// Returns the local 8-bit representation of the string as a
    /// QByteArray. The returned byte array is undefined if the string
    /// contains characters not supported by the local 8-bit encoding.
    /// 
    /// QTextCodec::codecForLocale() is used to perform the conversion from
    /// Unicode. If the locale encoding could not be determined, this function
    /// does the same as toLatin1().
    /// 
    /// If this string contains any characters that cannot be encoded in the
    /// locale, the returned byte array is undefined. Those characters may be
    /// suppressed or replaced by another.
    /// 
    /// **See also:** [`from_local8_bit()`]
    /// [`to_latin1()`]
    /// [`to_utf8()`]
    /// [`TextCodec`]
    [org_name(toLocal8Bit)]
    to_local8_bit_2() -> ByteArray,
    /// 
    /// Returns a UCS-4/UTF-32 representation of the string as a QVector<uint>.
    /// 
    /// UCS-4 is a Unicode codec and therefore it is lossless. All characters from
    /// this string will be encoded in UCS-4. Any invalid sequence of code units in
    /// this string is replaced by the Unicode's replacement character
    /// (QChar::ReplacementCharacter, which corresponds to `U+FFFD` ).
    /// 
    /// The returned vector is not NUL terminated.
    /// 
    /// **See also:** [`from_utf8()`]
    /// [`to_utf8()`]
    /// [`to_latin1()`]
    /// [`to_local8_bit()`]
    /// [`TextCodec`]
    /// [`from_ucs4()`]
    /// [`to_w_char_array()`]
    to_ucs4() -> [uint],
    /// Returns a QString initialized with the first *size* characters
    /// of the Latin-1 string *str.*
    /// 
    /// If *size* is -1 (default), it is taken to be strlen( *str).*
    /// 
    /// **See also:** [`to_latin1()`]
    /// [`from_utf8()`]
    /// [`from_local8_bit()`]
    /// 
    /// **Overloads**
    /// Returns a QString initialized with the Latin-1 string *str.*
    [static] from_latin1(str: *char, size: i32) -> String,
    /// Returns a QString initialized with the first *size* bytes
    /// of the UTF-8 string *str.*
    /// 
    /// If *size* is -1 (default), it is taken to be strlen( *str).*
    /// 
    /// UTF-8 is a Unicode codec and can represent all characters in a Unicode
    /// string like QString. However, invalid sequences are possible with UTF-8
    /// and, if any such are found, they will be replaced with one or more
    /// , or suppressed. These include non-Unicode
    /// sequences, non-characters, overlong sequences or surrogate codepoints
    /// encoded into UTF-8.
    /// 
    /// This function can be used to process incoming data incrementally as long as
    /// all UTF-8 characters are terminated within the incoming data. Any
    /// unterminated characters at the end of the string will be replaced or
    /// suppressed. In order to do stateful decoding, please use [QTextDecoder.](QTextDecoder.)
    /// 
    /// **See also:** [`to_utf8()`]
    /// [`from_latin1()`]
    /// [`from_local8_bit()`]
    /// 
    /// **Overloads**
    /// Returns a QString initialized with the UTF-8 string *str.*
    [static] from_utf8(str: *char, size: i32) -> String,
    /// Returns a QString initialized with the first *size* characters
    /// of the 8-bit string *str.*
    /// 
    /// If *size* is -1 (default), it is taken to be strlen( *str).*
    /// 
    /// QTextCodec::codecForLocale() is used to perform the conversion.
    /// 
    /// **See also:** [`to_local8_bit()`]
    /// [`from_latin1()`]
    /// [`from_utf8()`]
    /// 
    /// **Overloads**
    /// Returns a QString initialized with the 8-bit string *str.*
    [static] from_local8_bit(str: *char, size: i32) -> String,
    /// Returns a QString initialized with the first *size* characters
    /// of the Latin-1 string *str.*
    /// 
    /// If *size* is -1 (default), it is taken to be strlen( *str).*
    /// 
    /// **See also:** [`to_latin1()`]
    /// [`from_utf8()`]
    /// [`from_local8_bit()`]
    /// 
    /// **Overloads**
    /// Returns a QString initialized with the Latin-1 string *str.*
    [org_name(fromLatin1)]
    [static] from_latin1_2(str: &ByteArrayType) -> String,
    /// Returns a QString initialized with the first *size* bytes
    /// of the UTF-8 string *str.*
    /// 
    /// If *size* is -1 (default), it is taken to be strlen( *str).*
    /// 
    /// UTF-8 is a Unicode codec and can represent all characters in a Unicode
    /// string like QString. However, invalid sequences are possible with UTF-8
    /// and, if any such are found, they will be replaced with one or more
    /// , or suppressed. These include non-Unicode
    /// sequences, non-characters, overlong sequences or surrogate codepoints
    /// encoded into UTF-8.
    /// 
    /// This function can be used to process incoming data incrementally as long as
    /// all UTF-8 characters are terminated within the incoming data. Any
    /// unterminated characters at the end of the string will be replaced or
    /// suppressed. In order to do stateful decoding, please use [QTextDecoder.](QTextDecoder.)
    /// 
    /// **See also:** [`to_utf8()`]
    /// [`from_latin1()`]
    /// [`from_local8_bit()`]
    /// 
    /// **Overloads**
    /// Returns a QString initialized with the UTF-8 string *str.*
    [org_name(fromUtf8)]
    [static] from_utf8_2(str: &ByteArrayType) -> String,
    /// Returns a QString initialized with the first *size* characters
    /// of the 8-bit string *str.*
    /// 
    /// If *size* is -1 (default), it is taken to be strlen( *str).*
    /// 
    /// QTextCodec::codecForLocale() is used to perform the conversion.
    /// 
    /// **See also:** [`to_local8_bit()`]
    /// [`from_latin1()`]
    /// [`from_utf8()`]
    /// 
    /// **Overloads**
    /// Returns a QString initialized with the 8-bit string *str.*
    [org_name(fromLocal8Bit)]
    [static] from_local8_bit_2(str: &ByteArrayType) -> String,
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *unicode* (ISO-10646-UTF-16 encoded).
    /// 
    /// If *size* is -1 (default), *unicode* must be terminated
    /// with a 0.
    /// 
    /// This function checks for a Byte Order Mark (BOM). If it is missing,
    /// host byte order is assumed.
    /// 
    /// This function is slow compared to the other Unicode conversions.
    /// Use QString(const QChar *, int) or QString(const QChar *) if possible.
    /// 
    /// QString makes a deep copy of the Unicode data.
    /// 
    /// **See also:** [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_std_u16_string()`]
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *str* (ISO-10646-UTF-16 encoded).
    /// 
    /// If *size* is -1 (default), *str* must be terminated
    /// with a 0.
    /// 
    /// This function checks for a Byte Order Mark (BOM). If it is missing,
    /// host byte order is assumed.
    /// 
    /// This function is slow compared to the other Unicode conversions.
    /// Use QString(const QChar *, int) or QString(const QChar *) if possible.
    /// 
    /// QString makes a deep copy of the Unicode data.
    /// 
    /// **See also:** [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_std_u16_string()`]
    [static] from_utf16(arg0: *ushort, size: i32) -> String,
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *str* (ISO-10646-UCS-4 encoded).
    /// 
    /// If *size* is -1 (default), *str* must be terminated
    /// with a 0.
    /// 
    /// **See also:** [`to_ucs4()`]
    /// [`from_utf16()`]
    /// [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_w_char_array()`]
    /// [`from_std_u32_string()`]
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *unicode* (ISO-10646-UCS-4 encoded).
    /// 
    /// If *size* is -1 (default), *unicode* must be terminated
    /// with a 0.
    /// 
    /// **See also:** [`to_ucs4()`]
    /// [`from_utf16()`]
    /// [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_w_char_array()`]
    /// [`from_std_u32_string()`]
    [static] from_ucs4(arg0: *uint, size: i32) -> String,
    /// 
    /// Constructs a QString that uses the first *size* Unicode characters
    /// in the array *unicode.* The data in *unicode* is *not*
    /// copied. The caller must be able to guarantee that *unicode* will
    /// not be deleted or modified as long as the QString (or an
    /// unmodified copy of it) exists.
    /// 
    /// Any attempts to modify the QString or copies of it will cause it
    /// to create a deep copy of the data, ensuring that the raw data
    /// isn't modified.
    /// 
    /// Here's an example of how we can use a QRegularExpression on raw data in
    /// memory without requiring to copy the data into a QString:
    /// 
    /// **Warning**: A string created with fromRawData() is *not*
    /// '\\0'-terminated, unless the raw data contains a '\\0' character
    /// at position *size.* This means unicode() will *not* return a
    /// '\\0'-terminated string (although utf16() does, at the cost of
    /// copying the raw data).
    /// 
    /// **See also:** [`from_utf16()`]
    /// [`set_raw_data()`]
    [static] from_raw_data(arg0: *CharType, size: i32) -> String,
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *unicode* (ISO-10646-UTF-16 encoded).
    /// 
    /// If *size* is -1 (default), *unicode* must be terminated
    /// with a 0.
    /// 
    /// This function checks for a Byte Order Mark (BOM). If it is missing,
    /// host byte order is assumed.
    /// 
    /// This function is slow compared to the other Unicode conversions.
    /// Use QString(const QChar *, int) or QString(const QChar *) if possible.
    /// 
    /// QString makes a deep copy of the Unicode data.
    /// 
    /// **See also:** [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_std_u16_string()`]
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *str* (ISO-10646-UTF-16 encoded).
    /// 
    /// If *size* is -1 (default), *str* must be terminated
    /// with a 0.
    /// 
    /// This function checks for a Byte Order Mark (BOM). If it is missing,
    /// host byte order is assumed.
    /// 
    /// This function is slow compared to the other Unicode conversions.
    /// Use QString(const QChar *, int) or QString(const QChar *) if possible.
    /// 
    /// QString makes a deep copy of the Unicode data.
    /// 
    /// **See also:** [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_std_u16_string()`]
    [org_name(fromUtf16)]
    [static] from_utf16_2(str: *char16_t, size: i32) -> String,
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *str* (ISO-10646-UCS-4 encoded).
    /// 
    /// If *size* is -1 (default), *str* must be terminated
    /// with a 0.
    /// 
    /// **See also:** [`to_ucs4()`]
    /// [`from_utf16()`]
    /// [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_w_char_array()`]
    /// [`from_std_u32_string()`]
    /// 
    /// Returns a QString initialized with the first *size* characters
    /// of the Unicode string *unicode* (ISO-10646-UCS-4 encoded).
    /// 
    /// If *size* is -1 (default), *unicode* must be terminated
    /// with a 0.
    /// 
    /// **See also:** [`to_ucs4()`]
    /// [`from_utf16()`]
    /// [`utf16()`]
    /// [`set_utf16()`]
    /// [`from_w_char_array()`]
    /// [`from_std_u32_string()`]
    [org_name(fromUcs4)]
    [static] from_ucs4_2(str: *char32_t, size: i32) -> String,
    /// 
    /// Fills the *array* with the data contained in this QString object.
    /// The array is encoded in UTF-16 on platforms where
    /// wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms
    /// where wchar_t is 4 bytes wide (most Unix systems).
    /// 
    /// *array* has to be allocated by the caller and contain enough space to
    /// hold the complete string (allocating the array with the same length as the
    /// string is always sufficient).
    /// 
    /// This function returns the actual length of the string in *array.*
    /// 
    /// **Note**: This function does not append a null character to the array.
    /// 
    /// **See also:** [`utf16()`]
    /// [`to_ucs4()`]
    /// [`to_latin1()`]
    /// [`to_utf8()`]
    /// [`to_local8_bit()`]
    /// [`to_std_w_string()`]
    to_w_char_array(array: *wchar_t) -> i32,
    /// 
    /// Returns a copy of the *string,* where the encoding of *string* depends on
    /// the size of wchar. If wchar is 4 bytes, the *string* is interpreted as UCS-4,
    /// if wchar is 2 bytes it is interpreted as UTF-16.
    /// 
    /// If *size* is -1 (default), the *string* has to be 0 terminated.
    /// 
    /// **See also:** [`from_utf16()`]
    /// [`from_latin1()`]
    /// [`from_local8_bit()`]
    /// [`from_utf8()`]
    /// [`from_ucs4()`]
    /// [`from_std_w_string()`]
    [static] from_w_char_array(string: *wchar_t, size: i32) -> String,
    /// 
    /// Resets the QString to use the first *size* Unicode characters
    /// in the array *unicode.* The data in *unicode* is *not*
    /// copied. The caller must be able to guarantee that *unicode* will
    /// not be deleted or modified as long as the QString (or an
    /// unmodified copy of it) exists.
    /// 
    /// This function can be used instead of fromRawData() to re-use
    /// existings QString objects to save memory re-allocations.
    /// 
    /// **See also:** [`from_raw_data()`]
    set_raw_data(unicode: *CharType, size: i32) -> String?,
    /// 
    /// Resizes the string to *size* characters and copies *unicode*
    /// into the string.
    /// 
    /// If *unicode* is 0, nothing is copied, but the string is still
    /// resized to *size.*
    /// 
    /// **See also:** [`unicode()`]
    /// [`set_utf16()`]
    set_unicode(unicode: *CharType, size: i32) -> String?,
    /// 
    /// Resizes the string to *size* characters and copies *unicode*
    /// into the string.
    /// 
    /// If *unicode* is 0, nothing is copied, but the string is still
    /// resized to *size.*
    /// 
    /// Note that unlike fromUtf16(), this function does not consider BOMs and
    /// possibly differing byte ordering.
    /// 
    /// **See also:** [`utf16()`]
    /// [`set_unicode()`]
    set_utf16(utf16: *ushort, size: i32) -> String?,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    compare(s: String, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    [org_name(compare)]
    compare_2(other: Latin1StringType, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    [org_name(compare)]
    [static] compare_3(s1: String, s2: String, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    [org_name(compare)]
    [static] compare_4(s1: String, s2: Latin1StringType, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    [org_name(compare)]
    [static] compare_5(s1: Latin1StringType, s2: String, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    [org_name(compare)]
    compare_6(s: &StringRefType, cs: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// If *cs* is Qt::CaseSensitive, the comparison is case sensitive;
    /// otherwise the comparison is case insensitive.
    /// 
    /// Case sensitive comparison is based exclusively on the numeric
    /// Unicode values of the characters and is very fast, but is not what
    /// a human would expect. Consider sorting user-visible strings with
    /// localeAwareCompare().
    /// 
    /// **See also:** [`operator()`]
    /// [`operator()`]
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Performs a comparison of *s1* and *s2,* using the case
    /// sensitivity setting *cs.*
    /// 
    /// **Overloads** compare()
    /// Lexically compares this string with the *other* string and
    /// returns an integer less than, equal to, or greater than zero if
    /// this string is less than, equal to, or greater than the other
    /// string.
    /// 
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Same as compare(*this, *other,* *cs).*
    /// 
    /// **Overloads** compare()
    /// Compares the string reference, *ref,* with the string and returns
    /// an integer less than, equal to, or greater than zero if the string
    /// is less than, equal to, or greater than *ref.*
    /// 
    /// **Overloads** compare()
    [org_name(compare)]
    [static] compare_7(s1: String, s2: &StringRefType, arg0: Rute::CaseSensitivity) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// On MacOS and iOS this function compares according the
    /// setting in the International preferences panel.
    /// 
    /// **See also:** [`compare()`]
    /// [`Locale`]
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    locale_aware_compare(s: String) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// On MacOS and iOS this function compares according the
    /// setting in the International preferences panel.
    /// 
    /// **See also:** [`compare()`]
    /// [`Locale`]
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    [org_name(localeAwareCompare)]
    [static] locale_aware_compare_2(s1: String, s2: String) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// On MacOS and iOS this function compares according the
    /// setting in the International preferences panel.
    /// 
    /// **See also:** [`compare()`]
    /// [`Locale`]
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    [org_name(localeAwareCompare)]
    locale_aware_compare_3(s: &StringRefType) -> i32,
    /// 
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// On MacOS and iOS this function compares according the
    /// setting in the International preferences panel.
    /// 
    /// **See also:** [`compare()`]
    /// [`Locale`]
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares *s1* with *s2* and returns an integer less than, equal
    /// to, or greater than zero if *s1* is less than, equal to, or
    /// greater than *s2.*
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// **Overloads** localeAwareCompare()
    /// Compares this string with the *other* string and returns an
    /// integer less than, equal to, or greater than zero if this string
    /// is less than, equal to, or greater than the *other* string.
    /// 
    /// The comparison is performed in a locale- and also
    /// platform-dependent manner. Use this function to present sorted
    /// lists of strings to the user.
    /// 
    /// Same as `localeAwareCompare(*this, other)` .
    [org_name(localeAwareCompare)]
    [static] locale_aware_compare_4(s1: String, s2: &StringRefType) -> i32,
    /// 
    /// Returns the string converted to a `short` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toShort()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_u_short()`]
    /// [`to_int()`]
    /// [`Locale::to_short`]
    to_short(ok: *bool, base: i32) -> short,
    /// 
    /// Returns the string converted to an `unsigned short` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toUShort()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_short()`]
    /// [`Locale::to_u_short`]
    to_u_short(ok: *bool, base: i32) -> ushort,
    /// 
    /// Returns the string converted to an `int` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toInt()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_u_int()`]
    /// [`to_double()`]
    /// [`Locale::to_int`]
    to_int(ok: *bool, base: i32) -> i32,
    /// 
    /// Returns the string converted to an `unsigned int` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toUInt()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_int()`]
    /// [`Locale::to_u_int`]
    to_u_int(ok: *bool, base: i32) -> uint,
    /// 
    /// Returns the string converted to a `long long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toLongLong()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_u_long_long()`]
    /// [`to_int()`]
    /// [`Locale::to_long_long`]
    /// 
    /// Returns the string converted to a `long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toLongLong()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_u_long()`]
    /// [`to_int()`]
    /// [`Locale::to_int`]
    to_long(ok: *bool, base: i32) -> long,
    /// 
    /// Returns the string converted to an `unsigned long long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toULongLong()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_long_long()`]
    /// [`Locale::to_u_long_long`]
    /// 
    /// Returns the string converted to an `unsigned long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toULongLong()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`Locale::to_u_int`]
    to_u_long(ok: *bool, base: i32) -> ulong,
    /// 
    /// Returns the string converted to a `long long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toLongLong()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_u_long_long()`]
    /// [`to_int()`]
    /// [`Locale::to_long_long`]
    to_long_long(ok: *bool, base: i32) -> i64,
    /// 
    /// Returns the string converted to an `unsigned long long` using base *base,* which is 10 by default and must be between 2 and 36, or 0.
    /// Returns 0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// If *base* is 0, the C language convention is used: If the string
    /// begins with , base 16 is used; if the string begins with ,
    /// base 8 is used; otherwise, base 10 is used.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toULongLong()
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_long_long()`]
    /// [`Locale::to_u_long_long`]
    to_u_long_long(ok: *bool, base: i32) -> qulonglong,
    /// 
    /// Returns the string converted to a `float` value.
    /// 
    /// Returns 0.0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Warning**: The QString content may only contain valid numerical characters
    /// which includes the plus/minus sign, the character e used in scientific
    /// notation, and the decimal point. Including the unit or additional characters
    /// leads to a conversion error.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toFloat()
    /// 
    /// For historical reasons, this function does not handle
    /// thousands group separators. If you need to convert such numbers,
    /// use QLocale::toFloat().
    /// 
    /// Example:
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`to_double()`]
    /// [`to_int()`]
    /// [`Locale::to_float`]
    /// [`trimmed()`]
    to_float(ok: *bool) -> f32,
    /// 
    /// Returns the string converted to a `double` value.
    /// 
    /// Returns 0.0 if the conversion fails.
    /// 
    /// If *ok* is not `nullptr,` failure is reported by setting * *ok*
    /// to `false,` and success by setting * *ok* to `true.`
    /// 
    /// **Warning**: The QString content may only contain valid numerical characters
    /// which includes the plus/minus sign, the character e used in scientific
    /// notation, and the decimal point. Including the unit or additional characters
    /// leads to a conversion error.
    /// 
    /// The string conversion will always happen in the 'C' locale. For locale
    /// dependent conversion use QLocale::toDouble()
    /// 
    /// For historical reasons, this function does not handle
    /// thousands group separators. If you need to convert such numbers,
    /// use QLocale::toDouble().
    /// 
    /// This function ignores leading and trailing whitespace.
    /// 
    /// **See also:** [`number()`]
    /// [`Locale::set_default`]
    /// [`Locale::to_double`]
    /// [`trimmed()`]
    to_double(ok: *bool) -> double,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    set_num(arg0: short, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_2(arg0: ushort, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_3(arg0: i32, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_4(arg0: uint, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_5(arg0: long, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_6(arg0: ulong, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_7(arg0: i64, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_8(arg0: qulonglong, base: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_9(arg0: f32, f: char, prec: i32) -> String?,
    /// 
    /// Sets the string to the printed value of *n* in the specified *base,* and returns a reference to the string.
    /// 
    /// The base is 10 by default and must be between 2 and 36. For bases
    /// other than 10, *n* is treated as an unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The *format* can be 'e', 'E', 'f', 'g' or 'G' (see
    /// [Argument Formats](Argument%20Formats)
    /// for an explanation of the formats).
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **Overloads**
    /// Sets the string to the printed value of *n,* formatted according
    /// to the given *format* and *precision,* and returns a reference
    /// to the string.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    [org_name(setNum)]
    set_num_10(arg0: double, f: char, prec: i32) -> String?,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [static] number(arg0: i32, base: i32) -> String,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [org_name(number)]
    [static] number_2(arg0: uint, base: i32) -> String,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [org_name(number)]
    [static] number_3(arg0: long, base: i32) -> String,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [org_name(number)]
    [static] number_4(arg0: ulong, base: i32) -> String,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [org_name(number)]
    [static] number_5(arg0: i64, base: i32) -> String,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [org_name(number)]
    [static] number_6(arg0: qulonglong, base: i32) -> String,
    /// 
    /// Returns a string equivalent of the number *n* according to the
    /// specified *base.*
    /// 
    /// The base is 10 by default and must be between 2
    /// and 36. For bases other than 10, *n* is treated as an
    /// unsigned integer.
    /// 
    /// The formatting always uses QLocale::C, i.e., English/UnitedStates.
    /// To get a localized string representation of a number, use
    /// QLocale::toString() with the appropriate locale.
    /// 
    /// **See also:** [`set_num()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// Returns a string equivalent of the number *n,* formatted
    /// according to the specified *format* and *precision.* See
    /// [Argument Formats](Argument%20Formats)
    /// for details.
    /// 
    /// Unlike QLocale::toString(), this function does not honor the
    /// user's locale settings.
    /// 
    /// **See also:** [`set_num()`]
    /// [`Locale::to_string`]
    [org_name(number)]
    [static] number_7(arg0: double, f: char, prec: i32) -> String,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    [org_name(prepend)]
    prepend_6(s: *char) -> String?,
    /// 
    /// Prepends the string *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// **See also:** [`append()`]
    /// [`insert()`]
    /// 
    /// **Overloads** prepend()
    /// Prepends the Latin-1 string *str* to this string.
    /// **Overloads** prepend()
    /// Prepends *len* characters from the QChar array *str* to this string and
    /// returns a reference to this string.
    /// **Overloads** prepend()
    /// Prepends the string reference *str* to the beginning of this string and
    /// returns a reference to this string.
    /// 
    /// **Overloads** prepend()
    /// Prepends the byte array *ba* to this string. The byte array is
    /// converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the string *str* to this string. The const char pointer
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII` when you compile your applications. This
    /// can be useful if you want to ensure that all user-visible strings
    /// go through QObject::tr(), for example.
    /// 
    /// **Overloads** prepend()
    /// Prepends the character *ch* to this string.
    [org_name(prepend)]
    prepend_7(s: &ByteArrayType) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    [org_name(append)]
    append_6(s: *char) -> String?,
    /// 
    /// Appends the string *str* onto the end of this string.
    /// 
    /// Example:
    /// 
    /// This is the same as using the insert() function:
    /// 
    /// The append() function is typically very fast ( [constant time](constant%20time)
    /// ),
    /// because QString preallocates extra space at the end of the string
    /// data so it can grow without reallocating the entire string each
    /// time.
    /// 
    /// **See also:** [`operator()`]
    /// [`prepend()`]
    /// [`insert()`]
    /// 
    /// **Overloads** append()
    /// Appends *len* characters from the QChar array *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the Latin-1 string *str* to this string.
    /// 
    /// **Overloads** append()
    /// Appends the byte array *ba* to this string. The given byte array
    /// is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the string *str* to this string. The given const char
    /// pointer is converted to Unicode using the fromUtf8() function.
    /// 
    /// You can disable this function by defining `QT_NO_CAST_FROM_ASCII`
    /// when you compile your applications. This can be useful if you want
    /// to ensure that all user-visible strings go through QObject::tr(),
    /// for example.
    /// 
    /// **Overloads** append()
    /// Appends the character *ch* to this string.
    /// 
    /// Appends the given string *reference* to this string and returns the result.
    [org_name(append)]
    append_7(s: &ByteArrayType) -> String?,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    [org_name(insert)]
    insert_6(i: i32, s: *char) -> String?,
    /// 
    /// Inserts the string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// Example:
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **See also:** [`append()`]
    /// [`prepend()`]
    /// [`replace()`]
    /// [`remove()`]
    /// 
    /// **Overloads** insert()
    /// Inserts the string reference *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// **Overloads** insert()
    /// Inserts the C string *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the byte array *str* at the given index *position* and
    /// returns a reference to this string.
    /// 
    /// If the given *position* is greater than size(), the array is
    /// first extended using resize().
    /// 
    /// This function is not available when QT_NO_CAST_FROM_ASCII is
    /// defined.
    /// 
    /// **Overloads** insert()
    /// Inserts the Latin-1 string *str* at the given index *position.*
    /// 
    /// **Overloads** insert()
    /// Inserts the first *size* characters of the QChar array *unicode*
    /// at the given index *position* in the string.
    /// 
    /// **Overloads** insert()
    /// Inserts *ch* at the given index *position* in the string.
    [org_name(insert)]
    insert_7(i: i32, s: &ByteArrayType) -> String?,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character in
    /// the string.
    /// 
    /// **See also:** [`const_begin()`]
    /// [`end()`]
    /// 
    /// **Overloads** begin()
    begin() -> String::iterator,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character in
    /// the string.
    /// 
    /// **See also:** [`const_begin()`]
    /// [`end()`]
    /// 
    /// **Overloads** begin()
    [org_name(begin)]
    begin_2() -> String::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character
    /// in the string.
    /// 
    /// **See also:** [`begin()`]
    /// [`cend()`]
    cbegin() -> String::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the first character
    /// in the string.
    /// 
    /// **See also:** [`begin()`]
    /// [`const_end()`]
    const_begin() -> String::const_iterator,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary character
    /// after the last character in the string.
    /// 
    /// **See also:** [`begin()`]
    /// [`const_end()`]
    /// 
    /// **Overloads** end()
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    end() -> String::iterator,
    /// 
    /// Returns an [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary character
    /// after the last character in the string.
    /// 
    /// **See also:** [`begin()`]
    /// [`const_end()`]
    /// 
    /// **Overloads** end()
    /// 
    /// Returns `true` if the string ends with *s;* otherwise returns
    /// `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string reference *s;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith() Returns `true` if the string ends with the string view *str;*
    /// otherwise returns `false.`
    /// 
    /// If *cs* is Qt::CaseSensitive (default), the search is case
    /// sensitive; otherwise the search is case insensitive.
    /// 
    /// **See also:** [`starts_with()`]
    /// 
    /// **Overloads** endsWith()
    /// 
    /// Returns `true` if the string ends with *c;* otherwise returns
    /// `false.`
    /// 
    /// **Overloads** endsWith()
    [org_name(end)]
    end_2() -> String::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary
    /// character after the last character in the list.
    /// 
    /// **See also:** [`cbegin()`]
    /// [`end()`]
    cend() -> String::const_iterator,
    /// 
    /// Returns a const [STL-style iterator](STL-style%20iterators)
    /// pointing to the imaginary
    /// character after the last character in the list.
    /// 
    /// **See also:** [`const_begin()`]
    /// [`end()`]
    const_end() -> String::const_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to the first
    /// character in the string, in reverse order.
    /// 
    /// **See also:** [`begin()`]
    /// [`crbegin()`]
    /// [`rend()`]
    /// **Overloads**
    rbegin() -> String::reverse_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to one past
    /// the last character in the string, in reverse order.
    /// 
    /// **See also:** [`end()`]
    /// [`crend()`]
    /// [`rbegin()`]
    /// **Overloads**
    rend() -> String::reverse_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to the first
    /// character in the string, in reverse order.
    /// 
    /// **See also:** [`begin()`]
    /// [`crbegin()`]
    /// [`rend()`]
    /// **Overloads**
    [org_name(rbegin)]
    rbegin_2() -> String::const_reverse_iterator,
    /// 
    /// Returns a [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to one past
    /// the last character in the string, in reverse order.
    /// 
    /// **See also:** [`end()`]
    /// [`crend()`]
    /// [`rbegin()`]
    /// **Overloads**
    [org_name(rend)]
    rend_2() -> String::const_reverse_iterator,
    /// 
    /// Returns a const [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to the first
    /// character in the string, in reverse order.
    /// 
    /// **See also:** [`begin()`]
    /// [`rbegin()`]
    /// [`rend()`]
    crbegin() -> String::const_reverse_iterator,
    /// 
    /// Returns a const [STL-style](STL-style%20iterators)
    /// reverse iterator pointing to one
    /// past the last character in the string, in reverse order.
    /// 
    /// **See also:** [`end()`]
    /// [`rend()`]
    /// [`rbegin()`]
    crend() -> String::const_reverse_iterator,
    /// 
    /// This function is provided for STL compatibility, appending the
    /// given *other* string onto the end of this string. It is
    /// equivalent to `append(other).`
    /// 
    /// **See also:** [`append()`]
    /// 
    /// **Overloads**
    /// Appends the given *ch* character onto the end of this string.
    push_back(c: CharType),
    /// 
    /// This function is provided for STL compatibility, appending the
    /// given *other* string onto the end of this string. It is
    /// equivalent to `append(other).`
    /// 
    /// **See also:** [`append()`]
    /// 
    /// **Overloads**
    /// Appends the given *ch* character onto the end of this string.
    [org_name(push_back)]
    push_back_2(s: String),
    /// 
    /// This function is provided for STL compatibility, prepending the
    /// given *other* string to the beginning of this string. It is
    /// equivalent to `prepend(other).`
    /// 
    /// **See also:** [`prepend()`]
    /// 
    /// **Overloads**
    /// Prepends the given *ch* character to the beginning of this string.
    push_front(c: CharType),
    /// 
    /// This function is provided for STL compatibility, prepending the
    /// given *other* string to the beginning of this string. It is
    /// equivalent to `prepend(other).`
    /// 
    /// **See also:** [`prepend()`]
    /// 
    /// **Overloads**
    /// Prepends the given *ch* character to the beginning of this string.
    [org_name(push_front)]
    push_front_2(s: String),
    /// 
    /// This function is provided for STL compatibility. It is
    /// equivalent to squeeze().
    /// 
    /// **See also:** [`squeeze()`]
    shrink_to_fit(),
    /// 
    /// Returns `true` if this string is null; otherwise returns `false.`
    /// 
    /// Example:
    /// 
    /// Qt makes a distinction between null strings and empty strings for
    /// historical reasons. For most applications, what matters is
    /// whether or not a string contains any data, and this can be
    /// determined using the isEmpty() function.
    /// 
    /// **See also:** [`is_empty()`]
    is_null() -> bool,
    is_simple_text() -> bool,
    /// 
    /// Returns `true` if the string is read right to left.
    /// 
    /// **See also:** [`StringRef::is_right_to_left`]
    is_right_to_left() -> bool,
}

[org_name(QString)]
enum SectionFlag {
    SectionDefault,
    SectionSkipEmpty,
    SectionIncludeLeadingSep,
    SectionIncludeTrailingSep,
    SectionCaseInsensitiveSeps,
}

[org_name(QString)]
enum SplitBehavior {
    KeepEmptyParts,
    SkipEmptyParts,
}

[org_name(QString)]
enum NormalizationForm {
    NormalizationForm_D,
    NormalizationForm_C,
    NormalizationForm_KD,
    NormalizationForm_KC,
}

// vim: syntax=rust expandtab ts=4 sw=4
