///     \class QImageIOPlugin
///     \inmodule QtGui
///     \brief The QImageIOPlugin class defines an interface for writing
///     an image format plugin.
///     \reentrant
/// 
///     \ingroup plugins
/// 
///     QImageIOPlugin is a factory for creating QImageIOHandler objects,
///     which are used internally by QImageReader and QImageWriter to add
///     support for different image formats to Qt.
/// 
///     Writing an image I/O plugin is achieved by subclassing this
///     base class, reimplementing the pure virtual functions capabilities()
///     and create(), and exporting the class with the
///     Q_PLUGIN_METADATA() macro. See \l{How to Create Qt Plugins} for details.
/// 
///     An image format plugin can support three capabilities: reading (\l
///     CanRead), writing (\l CanWrite) and \e incremental reading (\l
///     CanReadIncremental). Reimplement capabilities() in you subclass to
///     expose the capabilities of your image format.
/// 
///     create() should create an instance of your QImageIOHandler
///     subclass, with the provided device and format properly set, and
///     return this handler.
/// 
///     The json metadata file for the plugin needs to contain information
///     about the image formats the plugins supports, together with the
///     corresponding MIME types (one for each format). For a jpeg plugin, this
///     could, for example, look as follows:
/// 
///     \code
///     {
///       "Keys": [ "jpg", "jpeg" ],
///       "MimeTypes": [ "image/jpeg", "image/jpeg" ]
///     }
///     \endcode
/// 
///     Different plugins can support different capabilities. For example,
///     you may have one plugin that supports reading the GIF format, and
///     another that supports writing. Qt will select the correct plugin
///     for the job, depending on the return value of capabilities(). If
///     several plugins support the same capability, Qt will select one
///     arbitrarily.
/// 
///     \sa QImageIOHandler, {How to Create Qt Plugins}
[org_name(QImageIOPlugin)]
enum Capability {
    CanRead,
    CanWrite,
    CanReadIncremental,
}

struct ImageIOPlugin : Object {
    [event] capabilities(device: *IODeviceType, format: &ByteArrayType) -> ImageIOPlugin::Capabilities,
    [event] create(device: *IODeviceType, format: &ByteArrayType) -> ImageIOHandler?,
}

// vim: syntax=rust expandtab ts=4 sw=4
