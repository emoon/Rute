/// 
/// QOpenGLTexture makes it easy to work with OpenGL textures and the myriad features
/// and targets that they offer depending upon the capabilities of your OpenGL implementation.
/// 
/// The typical usage pattern for QOpenGLTexture is
/// * Instantiate the object specifying the texture target type
/// * Set properties that affect the storage requirements e.g. storage format, dimensions
/// * Allocate the server-side storage
/// * Optionally upload pixel data
/// * Optionally set any additional properties e.g. filtering and border options
/// * Render with texture or render to texture
/// 
/// In the common case of simply using a QImage as the source of texture pixel data
/// most of the above steps are performed automatically.
/// 
/// ```
/// // Prepare texture
/// QOpenGLTexture *texture = new QOpenGLTexture(QImage(fileName).mirrored());
/// texture->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);
/// texture->setMagnificationFilter(QOpenGLTexture::Linear);
/// ...
/// // Render with texture
/// texture->bind();
/// glDrawArrays(...);
/// ```
/// 
/// Note that the QImage is mirrored vertically to account for the fact that
/// OpenGL and QImage use opposite directions for the y axis. Another option
/// would be to transform your texture coordinates.
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct OpenGLTexture {
    qt_check_for_qgadget_macro(),
    /// 
    /// Returns the binding target of this texture.
    /// 
    target() -> OpenGLTexture::Target,
    /// 
    /// Creates the underlying OpenGL texture object. This requires a current valid
    /// OpenGL context. If the texture object already exists, this function does
    /// nothing.
    /// 
    /// Once the texture object is created you can obtain the object
    /// name from the textureId() function. This may be useful if you wish to make
    /// some raw OpenGL calls related to this texture.
    /// 
    /// Normally it should not be necessary to call this function directly as all
    /// functions that set properties of the texture object implicitly call create()
    /// on your behalf.
    /// 
    /// Returns `true` if the creation succeeded, otherwise returns `false.`
    /// 
    /// **See also:** [`destroy()`]
    /// [`is_created()`]
    /// [`texture_id()`]
    /// 
    /// Attempts to create a texture view onto this texture. A texture
    /// view is somewhat analogous to a view in SQL in that it presents
    /// a restricted or reinterpreted view of the original data. Texture
    /// views do not allocate any more server-side storage, insted relying
    /// on the storage buffer of the source texture.
    /// 
    /// Texture views are only available when using immutable storage. For
    /// more information on texture views see
    /// http://www.opengl.org/wiki/Texture_Storage#Texture_views.
    /// 
    /// The *target* argument specifies the target to use for the view.
    /// Only some targets can be used depending upon the target of the original
    /// target. For e.g. a view onto a Target1DArray texture can specify
    /// either Target1DArray or Target1D but for the latter the number of
    /// array layers specified with *minimumLayer* and *maximumLayer* must
    /// be exactly 1.
    /// 
    /// Simpliar constraints apply for the *viewFormat.* See the above link
    /// and the specification for more details.
    /// 
    /// The *minimumMipmapLevel,* *maximumMipmapLevel,* *minimumLayer,*
    /// and *maximumLayer* arguments serve to restrict the parts of the
    /// texture accessible by the texture view.
    /// 
    /// If creation of the texture view fails this function will return
    /// 0. If the function succeeds it will return a pointer to a new
    /// QOpenGLTexture object that will return `true` from its isTextureView()
    /// function.
    /// 
    /// **See also:** [`is_texture_view()`]
    create() -> bool,
    /// 
    /// Returns `true` if the underlying OpenGL texture object has been created.
    /// 
    /// **See also:** [`create()`]
    /// [`destroy()`]
    /// [`texture_id()`]
    is_created() -> bool,
    /// 
    /// Returns the name of the underlying OpenGL texture object or 0 if it has
    /// not yet been created.
    /// 
    /// **See also:** [`create()`]
    /// [`destroy()`]
    /// [`is_created()`]
    texture_id() -> GLuint,
    /// 
    /// Binds this texture to the currently active texture unit ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// **See also:** [`release()`]
    /// 
    /// Binds this texture to texture unit *unit* ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// If parameter *reset* is `true` then this function will restore
    /// the active unit to the texture unit that was active upon entry.
    /// 
    /// **See also:** [`release()`]
    bind(),
    /// 
    /// Binds this texture to the currently active texture unit ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// **See also:** [`release()`]
    /// 
    /// Binds this texture to texture unit *unit* ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// If parameter *reset* is `true` then this function will restore
    /// the active unit to the texture unit that was active upon entry.
    /// 
    /// **See also:** [`release()`]
    [org_name(bind)]
    bind_2(unit: uint, reset: OpenGLTexture::TextureUnitReset),
    /// 
    /// Unbinds this texture from the currently active texture unit.
    /// 
    /// **See also:** [`bind()`]
    /// 
    /// Unbinds this texture from texture unit *unit.*
    /// 
    /// If parameter *reset* is `true` then this function
    /// will restore the active unit to the texture unit that was active
    /// upon entry.
    release(),
    /// 
    /// Unbinds this texture from the currently active texture unit.
    /// 
    /// **See also:** [`bind()`]
    /// 
    /// Unbinds this texture from texture unit *unit.*
    /// 
    /// If parameter *reset* is `true` then this function
    /// will restore the active unit to the texture unit that was active
    /// upon entry.
    [org_name(release)]
    release_2(unit: uint, reset: OpenGLTexture::TextureUnitReset),
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of the currently active texture unit.
    /// 
    /// **See also:** [`bind()`]
    /// [`release()`]
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of texture unit *unit.*
    /// 
    /// **See also:** [`bind()`]
    /// [`release()`]
    is_bound() -> bool,
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of the currently active texture unit.
    /// 
    /// **See also:** [`bind()`]
    /// [`release()`]
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of texture unit *unit.*
    /// 
    /// **See also:** [`bind()`]
    /// [`release()`]
    [org_name(isBound)]
    is_bound_2(unit: uint) -> bool,
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the currently active texture unit.
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the texture unit *unit.*
    [static] bound_texture_id(target: OpenGLTexture::BindingTarget) -> GLuint,
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the currently active texture unit.
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the texture unit *unit.*
    [org_name(boundTextureId)]
    [static] bound_texture_id_2(unit: uint, target: OpenGLTexture::BindingTarget) -> GLuint,
    /// 
    /// Sets the format of this texture object to *format.* This function
    /// must be called before texture storage is allocated.
    /// 
    /// Note that all formats may not be supported. The exact set of supported
    /// formats is dependent upon your OpenGL implementation and version.
    /// 
    /// **See also:** [`format()`]
    /// [`allocate_storage()`]
    set_format(format: OpenGLTexture::TextureFormat),
    /// 
    /// Returns the format of this texture object.
    /// 
    /// **See also:** [`set_format()`]
    format() -> OpenGLTexture::TextureFormat,
    /// 
    /// Sets the dimensions of this texture object to *width,*
    /// *height,* and *depth.* The default for each dimension is 1.
    /// The maximum allowable texture size is dependent upon your OpenGL
    /// implementation. Allocating storage for a texture less than the
    /// maximum size can still fail if your system is low on resources.
    /// 
    /// If a non-power-of-two *width,* *height* or *depth* is provided and your
    /// OpenGL implementation doesn't have support for repeating non-power-of-two
    /// textures, then the wrap mode is automatically set to ClampToEdge.
    /// 
    /// **See also:** [`width()`]
    /// [`height()`]
    /// [`depth()`]
    set_size(width: i32, height: i32, depth: i32),
    /// 
    /// Returns the width of a 1D, 2D or 3D texture.
    /// 
    /// **See also:** [`height()`]
    /// [`depth()`]
    /// [`set_size()`]
    width() -> i32,
    /// 
    /// Returns the height of a 2D or 3D texture.
    /// 
    /// **See also:** [`width()`]
    /// [`depth()`]
    /// [`set_size()`]
    height() -> i32,
    /// 
    /// Returns the depth of a 3D texture.
    /// 
    /// **See also:** [`width()`]
    /// [`height()`]
    /// [`set_size()`]
    /// 
    /// Returns the depth stencil mode for textures using a combined depth/stencil format.
    /// 
    /// **See also:** [`set_depth_stencil_mode()`]
    depth() -> i32,
    /// 
    /// For texture targets that support mipmaps, this function
    /// sets the requested number of mipmap *levels* to allocate storage
    /// for. This function should be called before storage is allocated
    /// for the texture.
    /// 
    /// If the texture target does not support mipmaps this function
    /// has no effect.
    /// 
    /// **See also:** [`mip_levels()`]
    /// [`maximum_mip_levels()`]
    /// [`is_storage_allocated()`]
    set_mip_levels(levels: i32),
    /// 
    /// Returns the number of mipmap levels for this texture. If storage
    /// has not yet been allocated for this texture it returns the
    /// requested number of mipmap levels.
    /// 
    /// **See also:** [`set_mip_levels()`]
    /// [`maximum_mip_levels()`]
    /// [`is_storage_allocated()`]
    mip_levels() -> i32,
    /// 
    /// Returns the maximum number of mipmap levels that this texture
    /// can have given the current dimensions.
    /// 
    /// **See also:** [`set_mip_levels()`]
    /// [`mip_levels()`]
    /// [`set_size()`]
    maximum_mip_levels() -> i32,
    /// 
    /// Sets the number of array *layers* to allocate storage for. This
    /// function should be called before storage is allocated for the texture.
    /// 
    /// For targets that do not support array layers this function has
    /// no effect.
    /// 
    /// **See also:** [`layers()`]
    /// [`is_storage_allocated()`]
    set_layers(layers: i32),
    /// 
    /// Returns the number of array layers for this texture. If
    /// storage has not yet been allocated for this texture then
    /// this function returns the requested number of array layers.
    /// 
    /// For texture targets that do not support array layers this
    /// will return 1.
    /// 
    /// **See also:** [`set_layers()`]
    /// [`is_storage_allocated()`]
    layers() -> i32,
    /// 
    /// Returns the number of faces for this texture. For cubemap
    /// and cubemap array type targets this will be 6.
    /// 
    /// For non-cubemap type targets this will return 1.
    faces() -> i32,
    /// 
    /// Sets the number of *samples* to allocate storage for when rendering to
    /// a multisample capable texture target. This function should
    /// be called before storage is allocated for the texture.
    /// 
    /// For targets that do not support multisampling this function has
    /// no effect.
    /// 
    /// **See also:** [`samples()`]
    /// [`is_storage_allocated()`]
    set_samples(samples: i32),
    /// 
    /// Returns the number of multisample sample points for this texture.
    /// If storage has not yet been allocated for this texture then
    /// this function returns the requested number of samples.
    /// 
    /// For texture targets that do not support multisampling this
    /// will return 0.
    /// 
    /// **See also:** [`set_samples()`]
    /// [`is_storage_allocated()`]
    samples() -> i32,
    /// 
    /// Sets whether the sample positions and number of samples used with
    /// a multisample capable texture target to *fixed.* If set to `true`
    /// the sample positions and number of samples used are the same for
    /// all texels in the image and will not depend upon the image size or
    /// internal format. This function should be called before storage is allocated
    /// for the texture.
    /// 
    /// For targets that do not support multisampling this function has
    /// no effect.
    /// 
    /// The default value is `true.`
    /// 
    /// **See also:** [`is_fixed_sample_positions()`]
    /// [`is_storage_allocated()`]
    set_fixed_sample_positions(fixed: bool),
    /// 
    /// Returns whether this texture uses a fixed pattern of multisample
    /// samples. If storage has not yet been allocated for this texture then
    /// this function returns the requested fixed sample position setting.
    /// 
    /// For texture targets that do not support multisampling this
    /// will return `true.`
    /// 
    /// **See also:** [`set_fixed_sample_positions()`]
    /// [`is_storage_allocated()`]
    is_fixed_sample_positions() -> bool,
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **Note**: If immutable texture storage is not available,
    /// then a default pixel format and pixel type will be used to
    /// create the mutable storage. You can use the other
    /// allocateStorage() overload to specify exactly the pixel format
    /// and the pixel type to use when allocating mutable storage;
    /// this is particulary useful under certain OpenGL ES implementations
    /// (notably, OpenGL ES 2), where the pixel format and the pixel type
    /// used at allocation time must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// **See also:** [`is_storage_allocated()`]
    /// [`set_data()`]
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage. However, if immutable texture storage is not available,
    /// then the specified *pixelFormat* and *pixelType* will be used
    /// to allocate mutable storage; note that in certain OpenGL implementations
    /// (notably, OpenGL ES 2) they must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **See also:** [`is_storage_allocated()`]
    /// [`set_data()`]
    allocate_storage(),
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **Note**: If immutable texture storage is not available,
    /// then a default pixel format and pixel type will be used to
    /// create the mutable storage. You can use the other
    /// allocateStorage() overload to specify exactly the pixel format
    /// and the pixel type to use when allocating mutable storage;
    /// this is particulary useful under certain OpenGL ES implementations
    /// (notably, OpenGL ES 2), where the pixel format and the pixel type
    /// used at allocation time must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// **See also:** [`is_storage_allocated()`]
    /// [`set_data()`]
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage. However, if immutable texture storage is not available,
    /// then the specified *pixelFormat* and *pixelType* will be used
    /// to allocate mutable storage; note that in certain OpenGL implementations
    /// (notably, OpenGL ES 2) they must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **See also:** [`is_storage_allocated()`]
    /// [`set_data()`]
    [org_name(allocateStorage)]
    allocate_storage_2(pixel_format: OpenGLTexture::PixelFormat, pixel_type: OpenGLTexture::PixelType),
    /// 
    /// Returns `true` if server-side storage for this texture as been
    /// allocated.
    /// 
    /// The texture format, dimensions, mipmap levels and array layers
    /// cannot be altered once storage ihas been allocated.
    /// 
    /// **See also:** [`allocate_storage()`]
    /// [`set_size()`]
    /// [`set_mip_levels()`]
    /// [`set_layers()`]
    /// [`set_format()`]
    is_storage_allocated() -> bool,
    /// 
    /// Attempts to create a texture view onto this texture. A texture
    /// view is somewhat analogous to a view in SQL in that it presents
    /// a restricted or reinterpreted view of the original data. Texture
    /// views do not allocate any more server-side storage, insted relying
    /// on the storage buffer of the source texture.
    /// 
    /// Texture views are only available when using immutable storage. For
    /// more information on texture views see
    /// http://www.opengl.org/wiki/Texture_Storage#Texture_views.
    /// 
    /// The *target* argument specifies the target to use for the view.
    /// Only some targets can be used depending upon the target of the original
    /// target. For e.g. a view onto a Target1DArray texture can specify
    /// either Target1DArray or Target1D but for the latter the number of
    /// array layers specified with *minimumLayer* and *maximumLayer* must
    /// be exactly 1.
    /// 
    /// Simpliar constraints apply for the *viewFormat.* See the above link
    /// and the specification for more details.
    /// 
    /// The *minimumMipmapLevel,* *maximumMipmapLevel,* *minimumLayer,*
    /// and *maximumLayer* arguments serve to restrict the parts of the
    /// texture accessible by the texture view.
    /// 
    /// If creation of the texture view fails this function will return
    /// 0. If the function succeeds it will return a pointer to a new
    /// QOpenGLTexture object that will return `true` from its isTextureView()
    /// function.
    /// 
    /// **See also:** [`is_texture_view()`]
    create_texture_view(target: OpenGLTexture::Target, view_format: OpenGLTexture::TextureFormat, minimum_mipmap_level: i32, maximum_mipmap_level: i32, minimum_layer: i32, maximum_layer: i32) -> OpenGLTexture?,
    /// 
    /// Returns `true` if this texture object is actually a view onto another
    /// texture object.
    /// 
    /// **See also:** [`create_texture_view()`]
    is_texture_view() -> bool,
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_2(mip_level: i32, layer: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_3(mip_level: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_4(source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_5(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_6(mip_level: i32, layer: i32, layer_count: i32, cube_face: OpenGLTexture::CubeMapFace, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_7(mip_level: i32, layer: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_8(mip_level: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_9(source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_2(mip_level: i32, layer: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_3(mip_level: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_4(data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_5(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_6(mip_level: i32, layer: i32, layer_count: i32, cube_face: OpenGLTexture::CubeMapFace, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_7(mip_level: i32, layer: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_8(mip_level: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    [org_name(setCompressedData)]
    set_compressed_data_9(data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** [`set_compressed_data()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    [org_name(setData)]
    set_data_10(image: &ImageType, gen_mip_maps: OpenGLTexture::MipMapGeneration),
    /// 
    /// Returns `true` if your OpenGL implementation and version supports the texture
    /// feature *feature.*
    [static] has_feature(feature: OpenGLTexture::Feature) -> bool,
    /// 
    /// Sets the base mipmap level used for all texture lookups with this texture to *baseLevel.*
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`mip_base_level()`]
    /// [`set_mip_max_level()`]
    /// [`set_mip_level_range()`]
    set_mip_base_level(base_level: i32),
    /// 
    /// Returns the mipmap base level used for all texture lookups with this texture.
    /// The default is 0.
    /// 
    /// **See also:** [`set_mip_base_level()`]
    /// [`mip_max_level()`]
    /// [`mip_level_range()`]
    mip_base_level() -> i32,
    /// 
    /// Sets the maximum mipmap level used for all texture lookups with this texture to *maxLevel.*
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`mip_max_level()`]
    /// [`set_mip_base_level()`]
    /// [`set_mip_level_range()`]
    set_mip_max_level(max_level: i32),
    /// 
    /// Returns the mipmap maximum level used for all texture lookups with this texture.
    /// 
    /// **See also:** [`set_mip_max_level()`]
    /// [`mip_base_level()`]
    /// [`mip_level_range()`]
    mip_max_level() -> i32,
    /// 
    /// Sets the range of mipmap levels that can be used for texture lookups with this texture
    /// to range from *baseLevel* to *maxLevel.*
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`set_mip_base_level()`]
    /// [`set_mip_max_level()`]
    /// [`mip_level_range()`]
    set_mip_level_range(base_level: i32, max_level: i32),
    /// 
    /// Returns the range of mipmap levels that can be used for texture lookups with this texture.
    /// 
    /// **See also:** [`mip_base_level()`]
    /// [`mip_max_level()`]
    mip_level_range() -> Pair<int,,
    /// 
    /// If *enabled* is `true,` enables automatic mipmap generation for this texture object
    /// to occur whenever the level 0 mipmap data is set via setData().
    /// 
    /// The automatic mipmap generation is enabled by default.
    /// 
    /// **Note**: Mipmap generation is not supported for compressed textures with OpenGL ES 2.0.
    /// 
    /// **See also:** [`is_auto_mip_map_generation_enabled()`]
    /// [`generate_mip_maps()`]
    set_auto_mip_map_generation_enabled(enabled: bool),
    /// 
    /// Returns whether auto mipmap generation is enabled for this texture object.
    /// 
    /// **See also:** [`set_auto_mip_map_generation_enabled()`]
    /// [`generate_mip_maps()`]
    is_auto_mip_map_generation_enabled() -> bool,
    /// 
    /// Generates mipmaps for this texture object from mipmap level 0. If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// **Note**: Mipmap generation is not supported for compressed textures with OpenGL
    /// ES 2.0.
    /// 
    /// **See also:** [`set_auto_mip_map_generation_enabled()`]
    /// [`set_mip_levels()`]
    /// [`mip_levels()`]
    /// 
    /// Generates mipmaps for this texture object from mipmap level *baseLevel.* If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// The generation of mipmaps to above *baseLevel* is achieved by setting the mipmap
    /// base level to *baseLevel* and then generating the mipmap chain. If *resetBaseLevel*
    /// is `true,` then the baseLevel of the texture will be reset to its previous value.
    /// 
    /// **See also:** [`set_auto_mip_map_generation_enabled()`]
    /// [`set_mip_levels()`]
    /// [`mip_levels()`]
    generate_mip_maps(),
    /// 
    /// Generates mipmaps for this texture object from mipmap level 0. If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// **Note**: Mipmap generation is not supported for compressed textures with OpenGL
    /// ES 2.0.
    /// 
    /// **See also:** [`set_auto_mip_map_generation_enabled()`]
    /// [`set_mip_levels()`]
    /// [`mip_levels()`]
    /// 
    /// Generates mipmaps for this texture object from mipmap level *baseLevel.* If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// The generation of mipmaps to above *baseLevel* is achieved by setting the mipmap
    /// base level to *baseLevel* and then generating the mipmap chain. If *resetBaseLevel*
    /// is `true,` then the baseLevel of the texture will be reset to its previous value.
    /// 
    /// **See also:** [`set_auto_mip_map_generation_enabled()`]
    /// [`set_mip_levels()`]
    /// [`mip_levels()`]
    [org_name(generateMipMaps)]
    generate_mip_maps_2(base_level: i32, reset_base_level: bool),
    /// 
    /// GLSL shaders are able to reorder the components of the vec4 returned by texture
    /// functions. It is also desirable to be able to control this reordering from CPU
    /// side code. This is made possible by swizzle masks since OpenGL 3.3.
    /// 
    /// Each component of the texture can be mapped to one of the SwizzleValue options.
    /// 
    /// This function maps *component* to the output *value.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`swizzle_mask()`]
    /// 
    /// Parameters *r* , *g* , *b* , and *a* are values used for setting
    /// the colors red, green, blue, and the alpha value.
    /// **Overloads**
    set_swizzle_mask(component: OpenGLTexture::SwizzleComponent, value: OpenGLTexture::SwizzleValue),
    /// 
    /// GLSL shaders are able to reorder the components of the vec4 returned by texture
    /// functions. It is also desirable to be able to control this reordering from CPU
    /// side code. This is made possible by swizzle masks since OpenGL 3.3.
    /// 
    /// Each component of the texture can be mapped to one of the SwizzleValue options.
    /// 
    /// This function maps *component* to the output *value.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`swizzle_mask()`]
    /// 
    /// Parameters *r* , *g* , *b* , and *a* are values used for setting
    /// the colors red, green, blue, and the alpha value.
    /// **Overloads**
    [org_name(setSwizzleMask)]
    set_swizzle_mask_2(r: OpenGLTexture::SwizzleValue, g: OpenGLTexture::SwizzleValue, b: OpenGLTexture::SwizzleValue, a: OpenGLTexture::SwizzleValue),
    /// 
    /// Returns the swizzle mask for texture *component.*
    swizzle_mask(component: OpenGLTexture::SwizzleComponent) -> OpenGLTexture::SwizzleValue,
    /// 
    /// If using a texture that has a combined depth/stencil format this function sets
    /// which component of the texture is accessed to *mode.*
    /// 
    /// When the parameter is set to DepthMode, then accessing it from the
    /// shader will access the depth component as a single float, as normal. But when
    /// the parameter is set to StencilMode, the shader will access the stencil component.
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`depth_stencil_mode()`]
    set_depth_stencil_mode(mode: OpenGLTexture::DepthStencilMode),
    /// 
    /// Returns the depth stencil mode for textures using a combined depth/stencil format.
    /// 
    /// **See also:** [`set_depth_stencil_mode()`]
    depth_stencil_mode() -> OpenGLTexture::DepthStencilMode,
    set_comparison_function(function: OpenGLTexture::ComparisonFunction),
    /// 
    /// Returns the texture comparison operator set on this texture. By default, a
    /// texture has a CompareLessEqual comparison function.
    /// 
    /// **See also:** [`set_comparison_function()`]
    comparison_function() -> OpenGLTexture::ComparisonFunction,
    /// 
    /// Sets the texture comparison mode on this texture to *mode.* The texture
    /// comparison mode is used by shadow samplers when sampling a depth texture.
    /// 
    /// **See also:** [`comparison_mode()`]
    set_comparison_mode(mode: OpenGLTexture::ComparisonMode),
    /// 
    /// Returns the texture comparison mode set on this texture. By default, a
    /// texture has a CompareNone comparison mode (i.e. comparisons are disabled).
    /// 
    /// **See also:** [`set_comparison_mode()`]
    comparison_mode() -> OpenGLTexture::ComparisonMode,
    /// 
    /// Sets the filter used for minification to *filter.*
    /// 
    /// **See also:** [`minification_filter()`]
    /// [`set_magnification_filter()`]
    /// [`set_min_mag_filters()`]
    set_minification_filter(filter: OpenGLTexture::Filter),
    /// 
    /// Returns the minification filter.
    /// 
    /// **See also:** [`set_minification_filter()`]
    minification_filter() -> OpenGLTexture::Filter,
    /// 
    /// Sets the magnification filter to *filter.*
    /// 
    /// **See also:** [`magnification_filter()`]
    /// [`set_minification_filter()`]
    /// [`set_min_mag_filters()`]
    set_magnification_filter(filter: OpenGLTexture::Filter),
    /// 
    /// Returns the magnification filter.
    /// 
    /// **See also:** [`set_magnification_filter()`]
    magnification_filter() -> OpenGLTexture::Filter,
    /// 
    /// Sets the minification filter to *minificationFilter* and the magnification filter
    /// to *magnificationFilter.*
    /// 
    /// **See also:** [`min_mag_filters()`]
    /// [`set_minification_filter()`]
    /// [`set_magnification_filter()`]
    set_min_mag_filters(minification_filter: OpenGLTexture::Filter, magnification_filter: OpenGLTexture::Filter),
    /// 
    /// Returns the current minification and magnification filters.
    /// 
    /// **See also:** [`set_min_mag_filters()`]
    min_mag_filters() -> Pair<QOpenGLTexture::Filter, QOpenGLTexture::Filter>,
    /// 
    /// Sets the wrap (or repeat mode) for all texture dimentions to *mode.*
    /// 
    /// **See also:** [`wrap_mode()`]
    /// 
    /// Holds the texture dimension *direction.*
    /// **Overloads**
    set_wrap_mode(mode: OpenGLTexture::WrapMode),
    /// 
    /// Sets the wrap (or repeat mode) for all texture dimentions to *mode.*
    /// 
    /// **See also:** [`wrap_mode()`]
    /// 
    /// Holds the texture dimension *direction.*
    /// **Overloads**
    [org_name(setWrapMode)]
    set_wrap_mode_2(direction: OpenGLTexture::CoordinateDirection, mode: OpenGLTexture::WrapMode),
    /// 
    /// Returns the wrap mode for the texture dimension *direction.*
    /// 
    /// **See also:** [`set_wrap_mode()`]
    wrap_mode(direction: OpenGLTexture::CoordinateDirection) -> OpenGLTexture::WrapMode,
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`border_color()`]
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    set_border_color(color: ColorType),
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`border_color()`]
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    [org_name(setBorderColor)]
    set_border_color_2(r: f32, g: f32, b: f32, a: f32),
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`border_color()`]
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    [org_name(setBorderColor)]
    set_border_color_3(r: i32, g: i32, b: i32, a: i32),
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** [`border_color()`]
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    [org_name(setBorderColor)]
    set_border_color_4(r: uint, g: uint, b: uint, a: uint),
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    border_color() -> Color,
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    [org_name(borderColor)]
    border_color_2(border: *f32),
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    [org_name(borderColor)]
    border_color_3(border: *i32),
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** [`set_border_color()`]
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    [org_name(borderColor)]
    border_color_4(border: *unsigned),
    /// 
    /// Sets the minimum level of detail to *value.* This limits the selection of highest
    /// resolution mipmap (lowest mipmap level). The default value is -1000.
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`minimum_level_of_detail()`]
    /// [`set_maximum_level_of_detail()`]
    /// [`set_level_of_detail_range()`]
    set_minimum_level_of_detail(value: f32),
    /// 
    /// Returns the minimum level of detail parameter.
    /// 
    /// **See also:** [`set_minimum_level_of_detail()`]
    /// [`maximum_level_of_detail()`]
    /// [`level_of_detail_range()`]
    minimum_level_of_detail() -> f32,
    /// 
    /// Sets the maximum level of detail to *value.* This limits the selection of lowest
    /// resolution mipmap (highest mipmap level). The default value is 1000.
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`maximum_level_of_detail()`]
    /// [`set_minimum_level_of_detail()`]
    /// [`set_level_of_detail_range()`]
    set_maximum_level_of_detail(value: f32),
    /// 
    /// Returns the maximum level of detail parameter.
    /// 
    /// **See also:** [`set_maximum_level_of_detail()`]
    /// [`minimum_level_of_detail()`]
    /// [`level_of_detail_range()`]
    maximum_level_of_detail() -> f32,
    /// 
    /// Sets the minimum level of detail parameters to *min* and the maximum level
    /// to *max.*
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`level_of_detail_range()`]
    /// [`set_minimum_level_of_detail()`]
    /// [`set_maximum_level_of_detail()`]
    set_level_of_detail_range(min: f32, max: f32),
    /// 
    /// Returns the minimum and maximum level of detail parameters.
    /// 
    /// **See also:** [`set_level_of_detail_range()`]
    /// [`minimum_level_of_detail()`]
    /// [`maximum_level_of_detail()`]
    level_of_detail_range() -> Pair<float,,
    /// 
    /// Sets the level of detail bias to *bias.*
    /// Level of detail bias affects the point at which mipmapping levels change.
    /// Increasing values for level of detail bias makes the overall images blurrier
    /// or smoother. Decreasing values make the overall images sharper.
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** [`levelof_detail_bias()`]
    set_levelof_detail_bias(bias: f32),
    /// 
    /// Returns the level of detail bias parameter.
    /// 
    /// **See also:** [`set_levelof_detail_bias()`]
    levelof_detail_bias() -> f32,
}

[org_name(QOpenGLTexture)]
enum Target {
    /// A 1-dimensional texture. Equivalent to GL_TEXTURE_1D.
    Target1D = 3552,
    /// An array of 1-dimensional textures. Equivalent to GL_TEXTURE_1D_ARRAY
    Target1DArray = 35864,
    /// A 2-dimensional texture. Equivalent to GL_TEXTURE_2D
    Target2D = 3553,
    /// An array of 1-dimensional textures. Equivalent to GL_TEXTURE_2D_ARRAY
    Target2DArray = 35866,
    /// A 3-dimensional texture. Equivalent to GL_TEXTURE_3D
    Target3D = 32879,
    /// A cubemap texture. Equivalent to GL_TEXTURE_CUBE_MAP
    TargetCubeMap = 34067,
    /// An array of cubemap textures. Equivalent to GL_TEXTURE_CUBE_MAP_ARRAY
    TargetCubeMapArray = 36873,
    /// A 2-dimensional texture with multisample support. Equivalent to GL_TEXTURE_2D_MULTISAMPLE
    Target2DMultisample = 37120,
    /// An array of 2-dimensional textures with multisample support. Equivalent to GL_TEXTURE_2D_MULTISAMPLE_ARRAY
    Target2DMultisampleArray = 37122,
    /// A rectangular 2-dimensional texture. Equivalent to GL_TEXTURE_RECTANGLE
    TargetRectangle = 34037,
    /// A texture with data from an OpenGL buffer object. Equivalent to GL_TEXTURE_BUFFER
    TargetBuffer = 35882,
}

[org_name(QOpenGLTexture)]
enum BindingTarget {
    /// Equivalent to GL_TEXTURE_BINDING_1D
    BindingTarget1D = 32872,
    /// Equivalent to GL_TEXTURE_BINDING_1D_ARRAY
    BindingTarget1DArray = 35868,
    /// Equivalent to GL_TEXTURE_BINDING_2D
    BindingTarget2D = 32873,
    /// Equivalent to GL_TEXTURE_BINDING_2D_ARRAY
    BindingTarget2DArray = 35869,
    /// Equivalent to GL_TEXTURE_BINDING_3D
    BindingTarget3D = 32874,
    /// Equivalent to GL_TEXTURE_BINDING_CUBE_MAP
    BindingTargetCubeMap = 34068,
    /// Equivalent to GL_TEXTURE_BINDING_CUBE_MAP_ARRAY
    BindingTargetCubeMapArray = 36874,
    /// Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE
    BindingTarget2DMultisample = 37124,
    /// Equivalent to GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY
    BindingTarget2DMultisampleArray = 37125,
    /// Equivalent to GL_TEXTURE_BINDING_RECTANGLE
    BindingTargetRectangle = 34038,
    /// Equivalent to GL_TEXTURE_BINDING_BUFFER
    BindingTargetBuffer = 35884,
}

[org_name(QOpenGLTexture)]
enum MipMapGeneration {
    /// Mipmaps should be generated
    GenerateMipMaps = 0,
    /// Mipmaps should not be generated
    DontGenerateMipMaps = 1,
}

[org_name(QOpenGLTexture)]
enum TextureUnitReset {
    /// The previous active texture unit will be reset
    ResetTextureUnit = 0,
    /// The previous active texture unit will not be rest
    DontResetTextureUnit = 1,
}

[org_name(QOpenGLTexture)]
enum TextureFormat {
    /// Equivalent to GL_NONE
    NoFormat = 0,
    /// Equivalent to GL_R8
    R8_UNorm = 33321,
    /// Equivalent to GL_RG8
    RG8_UNorm = 33323,
    /// Equivalent to GL_RGB8
    RGB8_UNorm = 32849,
    /// Equivalent to GL_RGBA8
    RGBA8_UNorm = 32856,
    /// Equivalent to GL_R16
    R16_UNorm = 33322,
    /// Equivalent to GL_RG16
    RG16_UNorm = 33324,
    /// Equivalent to GL_RGB16
    RGB16_UNorm = 32852,
    /// Equivalent to GL_RGBA16
    RGBA16_UNorm = 32859,
    /// Equivalent to GL_R8_SNORM
    R8_SNorm = 36756,
    /// Equivalent to GL_RG8_SNORM
    RG8_SNorm = 36757,
    /// Equivalent to GL_RGB8_SNORM
    RGB8_SNorm = 36758,
    /// Equivalent to GL_RGBA8_SNORM
    RGBA8_SNorm = 36759,
    /// Equivalent to GL_R16_SNORM
    R16_SNorm = 36760,
    /// Equivalent to GL_RG16_SNORM
    RG16_SNorm = 36761,
    /// Equivalent to GL_RGB16_SNORM
    RGB16_SNorm = 36762,
    /// Equivalent to GL_RGBA16_SNORM
    RGBA16_SNorm = 36763,
    /// Equivalent to GL_R8UI
    R8U = 33330,
    /// Equivalent to GL_RG8UI
    RG8U = 33336,
    /// Equivalent to GL_RGB8UI
    RGB8U = 36221,
    /// Equivalent to GL_RGBA8UI
    RGBA8U = 36220,
    /// Equivalent to GL_R16UI
    R16U = 33332,
    /// Equivalent to GL_RG16UI
    RG16U = 33338,
    /// Equivalent to GL_RGB16UI
    RGB16U = 36215,
    /// Equivalent to GL_RGBA16UI
    RGBA16U = 36214,
    /// Equivalent to GL_R32UI
    R32U = 33334,
    /// Equivalent to GL_RG32UI
    RG32U = 33340,
    /// Equivalent to GL_RGB32UI
    RGB32U = 36209,
    /// Equivalent to GL_RGBA32UI
    RGBA32U = 36208,
    /// Equivalent to GL_R8I
    R8I = 33329,
    /// Equivalent to GL_RG8I
    RG8I = 33335,
    /// Equivalent to GL_RGB8I
    RGB8I = 36239,
    /// Equivalent to GL_RGBA8I
    RGBA8I = 36238,
    /// Equivalent to GL_R16I
    R16I = 33331,
    /// Equivalent to GL_RG16I
    RG16I = 33337,
    /// Equivalent to GL_RGB16I
    RGB16I = 36233,
    /// Equivalent to GL_RGBA16I
    RGBA16I = 36232,
    /// Equivalent to GL_R32I
    R32I = 33333,
    /// Equivalent to GL_RG32I
    RG32I = 33339,
    /// Equivalent to GL_RGB32I
    RGB32I = 36227,
    /// Equivalent to GL_RGBA32I
    RGBA32I = 36226,
    /// Equivalent to GL_R16F
    R16F = 33325,
    /// Equivalent to GL_RG16F
    RG16F = 33327,
    /// Equivalent to GL_RGB16F
    RGB16F = 34843,
    /// Equivalent to GL_RGBA16F
    RGBA16F = 34842,
    /// Equivalent to GL_R32F
    R32F = 33326,
    /// Equivalent to GL_RG32F
    RG32F = 33328,
    /// Equivalent to GL_RGB32F
    RGB32F = 34837,
    /// Equivalent to GL_RGBA32F
    RGBA32F = 34836,
    /// Equivalent to GL_RGB9_E5
    RGB9E5 = 35901,
    /// Equivalent to GL_R11F_G11F_B10F
    RG11B10F = 35898,
    /// Equivalent to GL_R3_G3_B2
    RG3B2 = 10768,
    /// Equivalent to GL_RGB565
    R5G6B5 = 36194,
    /// Equivalent to GL_RGB5_A1
    RGB5A1 = 32855,
    /// Equivalent to GL_RGBA4
    RGBA4 = 32854,
    /// Equivalent to GL_RGB10_A2UI
    RGB10A2 = 36975,
    /// Equivalent to GL_DEPTH_COMPONENT16
    D16 = 33189,
    /// Equivalent to GL_DEPTH_COMPONENT24
    D24 = 33190,
    /// Equivalent to GL_DEPTH24_STENCIL8
    D24S8 = 35056,
    /// Equivalent to GL_DEPTH_COMPONENT32
    D32 = 33191,
    /// Equivalent to GL_DEPTH_COMPONENT32F
    D32F = 36012,
    /// Equivalent to GL_DEPTH32F_STENCIL8
    D32FS8X24 = 36013,
    /// Equivalent to GL_STENCIL_INDEX8. Introduced in Qt 5.4
    S8 = 36168,
    /// Equivalent to GL_COMPRESSED_RGB_S3TC_DXT1_EXT
    RGB_DXT1 = 33776,
    /// Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT1_EXT
    RGBA_DXT1 = 33777,
    /// Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT3_EXT
    RGBA_DXT3 = 33778,
    /// Equivalent to GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
    RGBA_DXT5 = 33779,
    /// Equivalent to GL_COMPRESSED_RED_RGTC1
    R_ATI1N_UNorm = 36283,
    /// Equivalent to GL_COMPRESSED_SIGNED_RED_RGTC1
    R_ATI1N_SNorm = 36284,
    /// Equivalent to GL_COMPRESSED_RG_RGTC2
    RG_ATI2N_UNorm = 36285,
    /// Equivalent to GL_COMPRESSED_SIGNED_RG_RGTC2
    RG_ATI2N_SNorm = 36286,
    /// Equivalent to GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB
    RGB_BP_UNSIGNED_FLOAT = 36495,
    /// Equivalent to GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB
    RGB_BP_SIGNED_FLOAT = 36494,
    /// Equivalent to GL_COMPRESSED_RGBA_BPTC_UNORM_ARB
    RGB_BP_UNorm = 36492,
    /// Equivalent to GL_COMPRESSED_R11_EAC
    R11_EAC_UNorm = 37488,
    /// Equivalent to GL_COMPRESSED_SIGNED_R11_EAC
    R11_EAC_SNorm = 37489,
    /// Equivalent to GL_COMPRESSED_RG11_EAC
    RG11_EAC_UNorm = 37490,
    /// Equivalent to GL_COMPRESSED_SIGNED_RG11_EAC
    RG11_EAC_SNorm = 37491,
    /// Equivalent to GL_COMPRESSED_RGB8_ETC2
    RGB8_ETC2 = 37492,
    /// Equivalent to GL_COMPRESSED_SRGB8_ETC2
    SRGB8_ETC2 = 37493,
    /// Equivalent to GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
    RGB8_PunchThrough_Alpha1_ETC2 = 37494,
    /// Equivalent to GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
    SRGB8_PunchThrough_Alpha1_ETC2 = 37495,
    /// Equivalent to GL_COMPRESSED_RGBA8_ETC2_EAC
    RGBA8_ETC2_EAC = 37496,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
    SRGB8_Alpha8_ETC2_EAC = 37497,
    /// Equivalent to GL_ETC1_RGB8_OES
    RGB8_ETC1 = 36196,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_4x4_KHR
    RGBA_ASTC_4x4 = 37808,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_5x4_KHR
    RGBA_ASTC_5x4 = 37809,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_5x5_KHR
    RGBA_ASTC_5x5 = 37810,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_6x5_KHR
    RGBA_ASTC_6x5 = 37811,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_6x6_KHR
    RGBA_ASTC_6x6 = 37812,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_8x5_KHR
    RGBA_ASTC_8x5 = 37813,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_8x6_KHR
    RGBA_ASTC_8x6 = 37814,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_8x8_KHR
    RGBA_ASTC_8x8 = 37815,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_10x5_KHR
    RGBA_ASTC_10x5 = 37816,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_10x6_KHR
    RGBA_ASTC_10x6 = 37817,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_10x8_KHR
    RGBA_ASTC_10x8 = 37818,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_10x10_KHR
    RGBA_ASTC_10x10 = 37819,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_12x10_KHR
    RGBA_ASTC_12x10 = 37820,
    /// Equivalent to GL_COMPRESSED_RGBA_ASTC_12x12_KHR
    RGBA_ASTC_12x12 = 37821,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
    SRGB8_Alpha8_ASTC_4x4 = 37840,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
    SRGB8_Alpha8_ASTC_5x4 = 37841,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
    SRGB8_Alpha8_ASTC_5x5 = 37842,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
    SRGB8_Alpha8_ASTC_6x5 = 37843,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
    SRGB8_Alpha8_ASTC_6x6 = 37844,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
    SRGB8_Alpha8_ASTC_8x5 = 37845,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
    SRGB8_Alpha8_ASTC_8x6 = 37846,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
    SRGB8_Alpha8_ASTC_8x8 = 37847,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
    SRGB8_Alpha8_ASTC_10x5 = 37848,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
    SRGB8_Alpha8_ASTC_10x6 = 37849,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
    SRGB8_Alpha8_ASTC_10x8 = 37850,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
    SRGB8_Alpha8_ASTC_10x10 = 37851,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
    SRGB8_Alpha8_ASTC_12x10 = 37852,
    /// Equivalent to GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
    SRGB8_Alpha8_ASTC_12x12 = 37853,
    /// Equivalent to GL_SRGB8
    SRGB8 = 35905,
    /// Equivalent to GL_SRGB8_ALPHA8
    SRGB8_Alpha8 = 35907,
    /// Equivalent to GL_COMPRESSED_SRGB_S3TC_DXT1_EXT
    SRGB_DXT1 = 35916,
    /// Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
    SRGB_Alpha_DXT1 = 35917,
    /// Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
    SRGB_Alpha_DXT3 = 35918,
    /// Equivalent to GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    SRGB_Alpha_DXT5 = 35919,
    /// Equivalent to GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB
    SRGB_BP_UNorm = 36493,
    /// Equivalent to GL_DEPTH_COMPONENT (only OpenGL ES 3 or ES 2 with OES_depth_texture)
    DepthFormat = 6402,
    /// Equivalent to GL_ALPHA (OpenGL ES 2 only)
    AlphaFormat = 6406,
    /// Equivalent to GL_RGB (OpenGL ES 2 only)
    RGBFormat = 6407,
    /// Equivalent to GL_RGBA (OpenGL ES 2 only)
    RGBAFormat = 6408,
    /// Equivalent to GL_LUMINANCE (OpenGL ES 2 only)
    LuminanceFormat = 6409,
    /// Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)
    LuminanceAlphaFormat = 6410,
}

[org_name(QOpenGLTexture)]
enum TextureFormatClass {
    NoFormatClass = 0,
    FormatClass_128Bit = 1,
    FormatClass_96Bit = 2,
    FormatClass_64Bit = 3,
    FormatClass_48Bit = 4,
    FormatClass_32Bit = 5,
    FormatClass_24Bit = 6,
    FormatClass_16Bit = 7,
    FormatClass_8Bit = 8,
    FormatClass_RGTC1_R = 9,
    FormatClass_RGTC2_RG = 10,
    FormatClass_BPTC_Unorm = 11,
    FormatClass_BPTC_Float = 12,
    FormatClass_S3TC_DXT1_RGB = 13,
    FormatClass_S3TC_DXT1_RGBA = 14,
    FormatClass_S3TC_DXT3_RGBA = 15,
    FormatClass_S3TC_DXT5_RGBA = 16,
    FormatClass_Unique = 17,
}

[org_name(QOpenGLTexture)]
enum CubeMapFace {
    /// Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_X
    CubeMapPositiveX = 34069,
    /// Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_X
    CubeMapNegativeX = 34070,
    /// Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Y
    CubeMapPositiveY = 34071,
    /// Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
    CubeMapNegativeY = 34072,
    /// Equivalent to GL_TEXTURE_CUBE_MAP_POSITIVE_Z
    CubeMapPositiveZ = 34073,
    /// Equivalent to GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
    CubeMapNegativeZ = 34074,
}

[org_name(QOpenGLTexture)]
enum PixelFormat {
    /// Equivalent to GL_NONE
    NoSourceFormat = 0,
    /// Equivalent to GL_RED
    Red = 6403,
    /// Equivalent to GL_RG
    RG = 33319,
    /// Equivalent to GL_RGB
    RGB = 6407,
    /// Equivalent to GL_BGR
    BGR = 32992,
    /// Equivalent to GL_RGBA
    RGBA = 6408,
    /// Equivalent to GL_BGRA
    BGRA = 32993,
    /// Equivalent to GL_RED_INTEGER
    Red_Integer = 36244,
    /// Equivalent to GL_RG_INTEGER
    RG_Integer = 33320,
    /// Equivalent to GL_RGB_INTEGER
    RGB_Integer = 36248,
    /// Equivalent to GL_BGR_INTEGER
    BGR_Integer = 36250,
    /// Equivalent to GL_RGBA_INTEGER
    RGBA_Integer = 36249,
    /// Equivalent to GL_BGRA_INTEGER
    BGRA_Integer = 36251,
    /// Equivalent to GL_STENCIL_INDEX. Introduced in Qt 5.4
    Stencil = 6401,
    /// Equivalent to GL_DEPTH_COMPONENT
    Depth = 6402,
    /// Equivalent to GL_DEPTH_STENCIL
    DepthStencil = 34041,
    /// Equivalent to GL_ALPHA (OpenGL ES 2 only)
    Alpha = 6406,
    /// Equivalent to GL_LUMINANCE (OpenGL ES 2 only)
    Luminance = 6409,
    /// Equivalent to GL_LUMINANCE_ALPHA (OpenGL ES 2 only)
    LuminanceAlpha = 6410,
}

[org_name(QOpenGLTexture)]
enum PixelType {
    /// Equivalent to GL_NONE
    NoPixelType = 0,
    /// Equivalent to GL_BYTE
    Int8 = 5120,
    /// Equivalent to GL_UNSIGNED_BYTE
    UInt8 = 5121,
    /// Equivalent to GL_SHORT
    Int16 = 5122,
    /// Equivalent to GL_UNSIGNED_SHORT
    UInt16 = 5123,
    /// Equivalent to GL_INT
    Int32 = 5124,
    /// Equivalent to GL_UNSIGNED_INT
    UInt32 = 5125,
    /// Equivalent to GL_HALF_FLOAT
    Float16 = 5131,
    /// Equivalent to GL_HALF_FLOAT_OES
    Float16OES = 36193,
    /// Equivalent to GL_FLOAT
    Float32 = 5126,
    /// Equivalent to GL_UNSIGNED_INT_5_9_9_9_REV
    UInt32_RGB9_E5 = 35902,
    /// Equivalent to GL_UNSIGNED_INT_10F_11F_11F_REV
    UInt32_RG11B10F = 35899,
    /// Equivalent to GL_UNSIGNED_BYTE_3_3_2
    UInt8_RG3B2 = 32818,
    /// Equivalent to GL_UNSIGNED_BYTE_2_3_3_REV
    UInt8_RG3B2_Rev = 33634,
    /// Equivalent to GL_UNSIGNED_SHORT_5_5_5_1
    UInt16_RGB5A1 = 32820,
    /// Equivalent to GL_UNSIGNED_SHORT_1_5_5_5_REV
    UInt16_RGB5A1_Rev = 33638,
    /// Equivalent to GL_UNSIGNED_SHORT_5_6_5
    UInt16_R5G6B5 = 33635,
    /// Equivalent to GL_UNSIGNED_SHORT_5_6_5_REV
    UInt16_R5G6B5_Rev = 33636,
    /// Equivalent to GL_UNSIGNED_SHORT_4_4_4_4
    UInt16_RGBA4 = 32819,
    /// Equivalent to GL_UNSIGNED_SHORT_4_4_4_4_REV
    UInt16_RGBA4_Rev = 33637,
    /// Equivalent to GL_UNSIGNED_INT_8_8_8_8
    UInt32_RGBA8 = 32821,
    /// Equivalent to GL_UNSIGNED_INT_8_8_8_8_REV
    UInt32_RGBA8_Rev = 33639,
    /// Equivalent to GL_UNSIGNED_INT_10_10_10_2
    UInt32_RGB10A2 = 32822,
    /// Equivalent to GL_UNSIGNED_INT_2_10_10_10_REV
    UInt32_RGB10A2_Rev = 33640,
    /// Equivalent to GL_UNSIGNED_INT_24_8. Introduced in Qt 5.4
    UInt32_D24S8 = 34042,
    /// Equivalent to GL_FLOAT_32_UNSIGNED_INT_24_8_REV. Introduced in Qt 5.4
    Float32_D32_UInt32_S8_X24 = 36269,
}

[org_name(QOpenGLTexture)]
enum SwizzleComponent {
    /// The red component. Equivalent to GL_TEXTURE_SWIZZLE_R
    SwizzleRed = 36418,
    /// The green component. Equivalent to GL_TEXTURE_SWIZZLE_G
    SwizzleGreen = 36419,
    /// The blue component. Equivalent to GL_TEXTURE_SWIZZLE_B
    SwizzleBlue = 36420,
    /// The alpha component. Equivalent to GL_TEXTURE_SWIZZLE_A
    SwizzleAlpha = 36421,
}

[org_name(QOpenGLTexture)]
enum SwizzleValue {
    /// Maps the component to the red channel. Equivalent to GL_RED
    RedValue = 6403,
    /// Maps the component to the green channel. Equivalent to GL_GREEN
    GreenValue = 6404,
    /// Maps the component to the blue channel. Equivalent to GL_BLUE
    BlueValue = 6405,
    /// Maps the component to the alpha channel. Equivalent to GL_ALPHA
    AlphaValue = 6406,
    /// Maps the component to a fixed value of 0. Equivalent to GL_ZERO
    ZeroValue = 0,
    /// Maps the component to a fixed value of 1. Equivalent to GL_ONE
    OneValue = 1,
}

[org_name(QOpenGLTexture)]
enum WrapMode {
    /// Texture coordinate is repeated. Equivalent to GL_REPEAT
    Repeat = 10497,
    /// Texture coordinate is reflected about 0 and 1. Equivalent to GL_MIRRORED_REPEAT
    MirroredRepeat = 33648,
    /// Clamps the texture coordinates to [0,1]. Equivalent to GL_CLAMP_TO_EDGE
    ClampToEdge = 33071,
    /// As for ClampToEdge but also blends samples at 0 and 1 with a fixed border color. Equivalent to GL_CLAMP_TO_BORDER
    ClampToBorder = 33069,
}

[org_name(QOpenGLTexture)]
enum CoordinateDirection {
    /// The horizontal direction. Equivalent to GL_TEXTURE_WRAP_S
    DirectionS = 10242,
    /// The vertical direction. Equivalent to GL_TEXTURE_WRAP_T
    DirectionT = 10243,
    /// The depth direction. Equivalent to GL_TEXTURE_WRAP_R
    DirectionR = 32882,
}

[org_name(QOpenGLTexture)]
enum Feature {
    /// Support for immutable texture storage
    ImmutableStorage = 1,
    /// Support for immutable texture storage with multisample targets
    ImmutableMultisampleStorage = 2,
    /// Support for the GL_TEXTURE_RECTANGLE target
    TextureRectangle = 4,
    /// Support for texture targets with array layers
    TextureArrays = 8,
    /// Support for the 3 dimensional texture target
    Texture3D = 16,
    /// Support for texture targets that have multisample capabilities
    TextureMultisample = 32,
    /// Support for textures that use OpenGL buffer objects as their data source
    TextureBuffer = 64,
    /// Support for cubemap array texture target
    TextureCubeMapArrays = 128,
    /// Support for texture component swizzle masks
    Swizzle = 256,
    /// Support for stencil texturing (i.e. looking up depth or stencil components of a combined depth/stencil format texture in GLSL shaders).
    StencilTexturing = 512,
    /// Support for anisotropic texture filtering
    AnisotropicFiltering = 1024,
    /// Basic support for non-power-of-two textures
    NPOTTextures = 2048,
    /// Full support for non-power-of-two textures including texture repeat modes
    NPOTTextureRepeat = 4096,
    /// Support for the 1 dimensional texture target
    Texture1D = 8192,
    /// Support for texture comparison operators
    TextureComparisonOperators = 16384,
    /// Support for setting the base and maximum mipmap levels
    TextureMipMapLevel = 32768,
    MaxFeatureFlag = 65536,
}

[org_name(QOpenGLTexture)]
enum DepthStencilMode {
    /// Equivalent to GL_DEPTH_COMPONENT.
    DepthMode = 6402,
    /// Equivalent to GL_STENCIL_INDEX.
    StencilMode = 6401,
}

[org_name(QOpenGLTexture)]
enum ComparisonFunction {
    /// Equivalent to GL_LEQUAL.
    CompareLessEqual = 515,
    /// Equivalent to GL_GEQUAL.
    CompareGreaterEqual = 518,
    /// Equivalent to GL_LESS.
    CompareLess = 513,
    /// Equivalent to GL_GREATER.
    CompareGreater = 516,
    /// Equivalent to GL_EQUAL.
    CompareEqual = 514,
    /// Equivalent to GL_NOTEQUAL.
    CommpareNotEqual = 517,
    /// Equivalent to GL_ALWAYS.
    CompareAlways = 519,
    /// Equivalent to GL_NEVER.
    CompareNever = 512,
}

[org_name(QOpenGLTexture)]
enum ComparisonMode {
    /// Equivalent to GL_COMPARE_REF_TO_TEXTURE.
    CompareRefToTexture = 34894,
    /// Equivalent to GL_NONE.
    CompareNone = 0,
}

[org_name(QOpenGLTexture)]
enum Filter {
    /// Equivalent to GL_NEAREST
    Nearest = 9728,
    /// Equivalent to GL_LINEAR
    Linear = 9729,
    /// Equivalent to GL_NEAREST_MIPMAP_NEAREST
    NearestMipMapNearest = 9984,
    /// Equivalent to GL_NEAREST_MIPMAP_LINEAR
    NearestMipMapLinear = 9986,
    /// Equivalent to GL_LINEAR_MIPMAP_NEAREST
    LinearMipMapNearest = 9985,
    /// Equivalent to GL_LINEAR_MIPMAP_LINEAR
    LinearMipMapLinear = 9987,
}

// vim: syntax=rust expandtab ts=4 sw=4
