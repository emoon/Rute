/// 
/// QOpenGLTexture makes it easy to work with OpenGL textures and the myriad features
/// and targets that they offer depending upon the capabilities of your OpenGL implementation.
/// 
/// The typical usage pattern for QOpenGLTexture is
/// * Instantiate the object specifying the texture target type
/// * Set properties that affect the storage requirements e.g. storage format, dimensions
/// * Allocate the server-side storage
/// * Optionally upload pixel data
/// * Optionally set any additional properties e.g. filtering and border options
/// * Render with texture or render to texture
/// 
/// In the common case of simply using a QImage as the source of texture pixel data
/// most of the above steps are performed automatically.
/// 
/// ```
/// // Prepare texture
/// QOpenGLTexture *texture = new QOpenGLTexture(QImage(fileName).mirrored());
/// texture->setMinificationFilter(QOpenGLTexture::LinearMipMapLinear);
/// texture->setMagnificationFilter(QOpenGLTexture::Linear);
/// ...
/// // Render with texture
/// texture->bind();
/// glDrawArrays(...);
/// ```
/// 
/// Note that the QImage is mirrored vertically to account for the fact that
/// OpenGL and QImage use opposite directions for the y axis. Another option
/// would be to transform your texture coordinates.
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QOpenGLTexture)]
enum Target {
    Target1D,
    Target1DArray,
    Target2D,
    Target2DArray,
    Target3D,
    TargetCubeMap,
    TargetCubeMapArray,
    Target2DMultisample,
    Target2DMultisampleArray,
    TargetRectangle,
    TargetBuffer,
}

[org_name(QOpenGLTexture)]
enum BindingTarget {
    BindingTarget1D,
    BindingTarget1DArray,
    BindingTarget2D,
    BindingTarget2DArray,
    BindingTarget3D,
    BindingTargetCubeMap,
    BindingTargetCubeMapArray,
    BindingTarget2DMultisample,
    BindingTarget2DMultisampleArray,
    BindingTargetRectangle,
    BindingTargetBuffer,
}

[org_name(QOpenGLTexture)]
enum MipMapGeneration {
    GenerateMipMaps,
    DontGenerateMipMaps,
}

[org_name(QOpenGLTexture)]
enum TextureUnitReset {
    ResetTextureUnit,
    DontResetTextureUnit,
}

[org_name(QOpenGLTexture)]
enum TextureFormat {
    NoFormat,
    R8_UNorm,
    RG8_UNorm,
    RGB8_UNorm,
    RGBA8_UNorm,
    R16_UNorm,
    RG16_UNorm,
    RGB16_UNorm,
    RGBA16_UNorm,
    R8_SNorm,
    RG8_SNorm,
    RGB8_SNorm,
    RGBA8_SNorm,
    R16_SNorm,
    RG16_SNorm,
    RGB16_SNorm,
    RGBA16_SNorm,
    R8U,
    RG8U,
    RGB8U,
    RGBA8U,
    R16U,
    RG16U,
    RGB16U,
    RGBA16U,
    R32U,
    RG32U,
    RGB32U,
    RGBA32U,
    R8I,
    RG8I,
    RGB8I,
    RGBA8I,
    R16I,
    RG16I,
    RGB16I,
    RGBA16I,
    R32I,
    RG32I,
    RGB32I,
    RGBA32I,
    R16F,
    RG16F,
    RGB16F,
    RGBA16F,
    R32F,
    RG32F,
    RGB32F,
    RGBA32F,
    RGB9E5,
    RG11B10F,
    RG3B2,
    R5G6B5,
    RGB5A1,
    RGBA4,
    RGB10A2,
    D16,
    D24,
    D24S8,
    D32,
    D32F,
    D32FS8X24,
    S8,
    RGB_DXT1,
    RGBA_DXT1,
    RGBA_DXT3,
    RGBA_DXT5,
    R_ATI1N_UNorm,
    R_ATI1N_SNorm,
    RG_ATI2N_UNorm,
    RG_ATI2N_SNorm,
    RGB_BP_UNSIGNED_FLOAT,
    RGB_BP_SIGNED_FLOAT,
    RGB_BP_UNorm,
    R11_EAC_UNorm,
    R11_EAC_SNorm,
    RG11_EAC_UNorm,
    RG11_EAC_SNorm,
    RGB8_ETC2,
    SRGB8_ETC2,
    RGB8_PunchThrough_Alpha1_ETC2,
    SRGB8_PunchThrough_Alpha1_ETC2,
    RGBA8_ETC2_EAC,
    SRGB8_Alpha8_ETC2_EAC,
    RGB8_ETC1,
    RGBA_ASTC_4x4,
    RGBA_ASTC_5x4,
    RGBA_ASTC_5x5,
    RGBA_ASTC_6x5,
    RGBA_ASTC_6x6,
    RGBA_ASTC_8x5,
    RGBA_ASTC_8x6,
    RGBA_ASTC_8x8,
    RGBA_ASTC_10x5,
    RGBA_ASTC_10x6,
    RGBA_ASTC_10x8,
    RGBA_ASTC_10x10,
    RGBA_ASTC_12x10,
    RGBA_ASTC_12x12,
    SRGB8_Alpha8_ASTC_4x4,
    SRGB8_Alpha8_ASTC_5x4,
    SRGB8_Alpha8_ASTC_5x5,
    SRGB8_Alpha8_ASTC_6x5,
    SRGB8_Alpha8_ASTC_6x6,
    SRGB8_Alpha8_ASTC_8x5,
    SRGB8_Alpha8_ASTC_8x6,
    SRGB8_Alpha8_ASTC_8x8,
    SRGB8_Alpha8_ASTC_10x5,
    SRGB8_Alpha8_ASTC_10x6,
    SRGB8_Alpha8_ASTC_10x8,
    SRGB8_Alpha8_ASTC_10x10,
    SRGB8_Alpha8_ASTC_12x10,
    SRGB8_Alpha8_ASTC_12x12,
    SRGB8,
    SRGB8_Alpha8,
    SRGB_DXT1,
    SRGB_Alpha_DXT1,
    SRGB_Alpha_DXT3,
    SRGB_Alpha_DXT5,
    SRGB_BP_UNorm,
    DepthFormat,
    AlphaFormat,
    RGBFormat,
    RGBAFormat,
    LuminanceFormat,
    LuminanceAlphaFormat,
}

[org_name(QOpenGLTexture)]
enum TextureFormatClass {
    NoFormatClass,
    FormatClass_128Bit,
    FormatClass_96Bit,
    FormatClass_64Bit,
    FormatClass_48Bit,
    FormatClass_32Bit,
    FormatClass_24Bit,
    FormatClass_16Bit,
    FormatClass_8Bit,
    FormatClass_RGTC1_R,
    FormatClass_RGTC2_RG,
    FormatClass_BPTC_Unorm,
    FormatClass_BPTC_Float,
    FormatClass_S3TC_DXT1_RGB,
    FormatClass_S3TC_DXT1_RGBA,
    FormatClass_S3TC_DXT3_RGBA,
    FormatClass_S3TC_DXT5_RGBA,
    FormatClass_Unique,
}

[org_name(QOpenGLTexture)]
enum CubeMapFace {
    CubeMapPositiveX,
    CubeMapNegativeX,
    CubeMapPositiveY,
    CubeMapNegativeY,
    CubeMapPositiveZ,
    CubeMapNegativeZ,
}

[org_name(QOpenGLTexture)]
enum PixelFormat {
    NoSourceFormat,
    Red,
    RG,
    RGB,
    BGR,
    RGBA,
    BGRA,
    Red_Integer,
    RG_Integer,
    RGB_Integer,
    BGR_Integer,
    RGBA_Integer,
    BGRA_Integer,
    Stencil,
    Depth,
    DepthStencil,
    Alpha,
    Luminance,
    LuminanceAlpha,
}

[org_name(QOpenGLTexture)]
enum PixelType {
    NoPixelType,
    Int8,
    UInt8,
    Int16,
    UInt16,
    Int32,
    UInt32,
    Float16,
    Float16OES,
    Float32,
    UInt32_RGB9_E5,
    UInt32_RG11B10F,
    UInt8_RG3B2,
    UInt8_RG3B2_Rev,
    UInt16_RGB5A1,
    UInt16_RGB5A1_Rev,
    UInt16_R5G6B5,
    UInt16_R5G6B5_Rev,
    UInt16_RGBA4,
    UInt16_RGBA4_Rev,
    UInt32_RGBA8,
    UInt32_RGBA8_Rev,
    UInt32_RGB10A2,
    UInt32_RGB10A2_Rev,
    UInt32_D24S8,
    Float32_D32_UInt32_S8_X24,
}

[org_name(QOpenGLTexture)]
enum SwizzleComponent {
    SwizzleRed,
    SwizzleGreen,
    SwizzleBlue,
    SwizzleAlpha,
}

[org_name(QOpenGLTexture)]
enum SwizzleValue {
    RedValue,
    GreenValue,
    BlueValue,
    AlphaValue,
    ZeroValue,
    OneValue,
}

[org_name(QOpenGLTexture)]
enum WrapMode {
    Repeat,
    MirroredRepeat,
    ClampToEdge,
    ClampToBorder,
}

[org_name(QOpenGLTexture)]
enum CoordinateDirection {
    DirectionS,
    DirectionT,
    DirectionR,
}

[org_name(QOpenGLTexture)]
enum Feature {
    ImmutableStorage,
    ImmutableMultisampleStorage,
    TextureRectangle,
    TextureArrays,
    Texture3D,
    TextureMultisample,
    TextureBuffer,
    TextureCubeMapArrays,
    Swizzle,
    StencilTexturing,
    AnisotropicFiltering,
    NPOTTextures,
    NPOTTextureRepeat,
    Texture1D,
    TextureComparisonOperators,
    TextureMipMapLevel,
    MaxFeatureFlag,
}

[org_name(QOpenGLTexture)]
enum DepthStencilMode {
    DepthMode,
    StencilMode,
}

[org_name(QOpenGLTexture)]
enum ComparisonFunction {
    CompareLessEqual,
    CompareGreaterEqual,
    CompareLess,
    CompareGreater,
    CompareEqual,
    CommpareNotEqual,
    CompareAlways,
    CompareNever,
}

[org_name(QOpenGLTexture)]
enum ComparisonMode {
    CompareRefToTexture,
    CompareNone,
}

[org_name(QOpenGLTexture)]
enum Filter {
    Nearest,
    Linear,
    NearestMipMapNearest,
    NearestMipMapLinear,
    LinearMipMapNearest,
    LinearMipMapLinear,
}


struct OpenGLTexture {
    qt_check_for_qgadget_macro(),
    /// 
    /// Returns the binding target of this texture.
    /// 
    target() -> OpenGLTexture::Target,
    /// 
    /// Creates the underlying OpenGL texture object. This requires a current valid
    /// OpenGL context. If the texture object already exists, this function does
    /// nothing.
    /// 
    /// Once the texture object is created you can obtain the object
    /// name from the textureId() function. This may be useful if you wish to make
    /// some raw OpenGL calls related to this texture.
    /// 
    /// Normally it should not be necessary to call this function directly as all
    /// functions that set properties of the texture object implicitly call create()
    /// on your behalf.
    /// 
    /// Returns `true` if the creation succeeded, otherwise returns `false.`
    /// 
    /// **See also:** destroy()
    /// isCreated()
    /// textureId()
    /// 
    /// Attempts to create a texture view onto this texture. A texture
    /// view is somewhat analogous to a view in SQL in that it presents
    /// a restricted or reinterpreted view of the original data. Texture
    /// views do not allocate any more server-side storage, insted relying
    /// on the storage buffer of the source texture.
    /// 
    /// Texture views are only available when using immutable storage. For
    /// more information on texture views see
    /// http://www.opengl.org/wiki/Texture_Storage#Texture_views.
    /// 
    /// The *target* argument specifies the target to use for the view.
    /// Only some targets can be used depending upon the target of the original
    /// target. For e.g. a view onto a Target1DArray texture can specify
    /// either Target1DArray or Target1D but for the latter the number of
    /// array layers specified with *minimumLayer* and *maximumLayer* must
    /// be exactly 1.
    /// 
    /// Simpliar constraints apply for the *viewFormat.* See the above link
    /// and the specification for more details.
    /// 
    /// The *minimumMipmapLevel,* *maximumMipmapLevel,* *minimumLayer,*
    /// and *maximumLayer* arguments serve to restrict the parts of the
    /// texture accessible by the texture view.
    /// 
    /// If creation of the texture view fails this function will return
    /// 0. If the function succeeds it will return a pointer to a new
    /// QOpenGLTexture object that will return `true` from its isTextureView()
    /// function.
    /// 
    /// **See also:** isTextureView()
    create() -> bool,
    /// 
    /// Returns `true` if the underlying OpenGL texture object has been created.
    /// 
    /// **See also:** create()
    /// destroy()
    /// textureId()
    is_created() -> bool,
    /// 
    /// Returns the name of the underlying OpenGL texture object or 0 if it has
    /// not yet been created.
    /// 
    /// **See also:** create()
    /// destroy()
    /// isCreated()
    texture_id() -> i32,
    /// 
    /// Binds this texture to the currently active texture unit ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// **See also:** release()
    /// 
    /// Binds this texture to texture unit *unit* ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// If parameter *reset* is `true` then this function will restore
    /// the active unit to the texture unit that was active upon entry.
    /// 
    /// **See also:** release()
    bind(),
    /// 
    /// Binds this texture to the currently active texture unit ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// **See also:** release()
    /// 
    /// Binds this texture to texture unit *unit* ready for
    /// rendering. Note that you do not need to bind QOpenGLTexture objects
    /// in order to modify them as the implementation makes use of the
    /// EXT_direct_state_access extension where available and simulates it
    /// where it is not.
    /// 
    /// If parameter *reset* is `true` then this function will restore
    /// the active unit to the texture unit that was active upon entry.
    /// 
    /// **See also:** release()
    bind_2(unit: uint, reset: OpenGLTexture::TextureUnitReset),
    /// 
    /// Unbinds this texture from the currently active texture unit.
    /// 
    /// **See also:** bind()
    /// 
    /// Unbinds this texture from texture unit *unit.*
    /// 
    /// If parameter *reset* is `true` then this function
    /// will restore the active unit to the texture unit that was active
    /// upon entry.
    release(),
    /// 
    /// Unbinds this texture from the currently active texture unit.
    /// 
    /// **See also:** bind()
    /// 
    /// Unbinds this texture from texture unit *unit.*
    /// 
    /// If parameter *reset* is `true` then this function
    /// will restore the active unit to the texture unit that was active
    /// upon entry.
    release_2(unit: uint, reset: OpenGLTexture::TextureUnitReset),
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of the currently active texture unit.
    /// 
    /// **See also:** bind()
    /// release()
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of texture unit *unit.*
    /// 
    /// **See also:** bind()
    /// release()
    is_bound() -> bool,
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of the currently active texture unit.
    /// 
    /// **See also:** bind()
    /// release()
    /// 
    /// Returns `true` if this texture is bound to the corresponding target
    /// of texture unit *unit.*
    /// 
    /// **See also:** bind()
    /// release()
    is_bound_2(unit: uint) -> bool,
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the currently active texture unit.
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the texture unit *unit.*
    [static] bound_texture_id(target: OpenGLTexture::BindingTarget) -> i32,
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the currently active texture unit.
    /// 
    /// Returns the textureId of the texture that is bound to the *target*
    /// of the texture unit *unit.*
    [static] bound_texture_id_2(unit: uint, target: OpenGLTexture::BindingTarget) -> i32,
    /// 
    /// Sets the format of this texture object to *format.* This function
    /// must be called before texture storage is allocated.
    /// 
    /// Note that all formats may not be supported. The exact set of supported
    /// formats is dependent upon your OpenGL implementation and version.
    /// 
    /// **See also:** format()
    /// allocateStorage()
    set_format(format: OpenGLTexture::TextureFormat),
    /// 
    /// Returns the format of this texture object.
    /// 
    /// **See also:** setFormat()
    format() -> OpenGLTexture::TextureFormat,
    /// 
    /// Sets the dimensions of this texture object to *width,*
    /// *height,* and *depth.* The default for each dimension is 1.
    /// The maximum allowable texture size is dependent upon your OpenGL
    /// implementation. Allocating storage for a texture less than the
    /// maximum size can still fail if your system is low on resources.
    /// 
    /// If a non-power-of-two *width,* *height* or *depth* is provided and your
    /// OpenGL implementation doesn't have support for repeating non-power-of-two
    /// textures, then the wrap mode is automatically set to ClampToEdge.
    /// 
    /// **See also:** width()
    /// height()
    /// depth()
    set_size(width: i32, height: i32, depth: i32),
    /// 
    /// Returns the width of a 1D, 2D or 3D texture.
    /// 
    /// **See also:** height()
    /// depth()
    /// setSize()
    width() -> i32,
    /// 
    /// Returns the height of a 2D or 3D texture.
    /// 
    /// **See also:** width()
    /// depth()
    /// setSize()
    height() -> i32,
    /// 
    /// Returns the depth of a 3D texture.
    /// 
    /// **See also:** width()
    /// height()
    /// setSize()
    /// 
    /// Returns the depth stencil mode for textures using a combined depth/stencil format.
    /// 
    /// **See also:** setDepthStencilMode()
    depth() -> i32,
    /// 
    /// For texture targets that support mipmaps, this function
    /// sets the requested number of mipmap *levels* to allocate storage
    /// for. This function should be called before storage is allocated
    /// for the texture.
    /// 
    /// If the texture target does not support mipmaps this function
    /// has no effect.
    /// 
    /// **See also:** mipLevels()
    /// maximumMipLevels()
    /// isStorageAllocated()
    set_mip_levels(levels: i32),
    /// 
    /// Returns the number of mipmap levels for this texture. If storage
    /// has not yet been allocated for this texture it returns the
    /// requested number of mipmap levels.
    /// 
    /// **See also:** setMipLevels()
    /// maximumMipLevels()
    /// isStorageAllocated()
    mip_levels() -> i32,
    /// 
    /// Returns the maximum number of mipmap levels that this texture
    /// can have given the current dimensions.
    /// 
    /// **See also:** setMipLevels()
    /// mipLevels()
    /// setSize()
    maximum_mip_levels() -> i32,
    /// 
    /// Sets the number of array *layers* to allocate storage for. This
    /// function should be called before storage is allocated for the texture.
    /// 
    /// For targets that do not support array layers this function has
    /// no effect.
    /// 
    /// **See also:** layers()
    /// isStorageAllocated()
    set_layers(layers: i32),
    /// 
    /// Returns the number of array layers for this texture. If
    /// storage has not yet been allocated for this texture then
    /// this function returns the requested number of array layers.
    /// 
    /// For texture targets that do not support array layers this
    /// will return 1.
    /// 
    /// **See also:** setLayers()
    /// isStorageAllocated()
    layers() -> i32,
    /// 
    /// Returns the number of faces for this texture. For cubemap
    /// and cubemap array type targets this will be 6.
    /// 
    /// For non-cubemap type targets this will return 1.
    faces() -> i32,
    /// 
    /// Sets the number of *samples* to allocate storage for when rendering to
    /// a multisample capable texture target. This function should
    /// be called before storage is allocated for the texture.
    /// 
    /// For targets that do not support multisampling this function has
    /// no effect.
    /// 
    /// **See also:** samples()
    /// isStorageAllocated()
    set_samples(samples: i32),
    /// 
    /// Returns the number of multisample sample points for this texture.
    /// If storage has not yet been allocated for this texture then
    /// this function returns the requested number of samples.
    /// 
    /// For texture targets that do not support multisampling this
    /// will return 0.
    /// 
    /// **See also:** setSamples()
    /// isStorageAllocated()
    samples() -> i32,
    /// 
    /// Sets whether the sample positions and number of samples used with
    /// a multisample capable texture target to *fixed.* If set to `true`
    /// the sample positions and number of samples used are the same for
    /// all texels in the image and will not depend upon the image size or
    /// internal format. This function should be called before storage is allocated
    /// for the texture.
    /// 
    /// For targets that do not support multisampling this function has
    /// no effect.
    /// 
    /// The default value is `true.`
    /// 
    /// **See also:** isFixedSamplePositions()
    /// isStorageAllocated()
    set_fixed_sample_positions(fixed: bool),
    /// 
    /// Returns whether this texture uses a fixed pattern of multisample
    /// samples. If storage has not yet been allocated for this texture then
    /// this function returns the requested fixed sample position setting.
    /// 
    /// For texture targets that do not support multisampling this
    /// will return `true.`
    /// 
    /// **See also:** setFixedSamplePositions()
    /// isStorageAllocated()
    is_fixed_sample_positions() -> bool,
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **Note**: If immutable texture storage is not available,
    /// then a default pixel format and pixel type will be used to
    /// create the mutable storage. You can use the other
    /// allocateStorage() overload to specify exactly the pixel format
    /// and the pixel type to use when allocating mutable storage;
    /// this is particulary useful under certain OpenGL ES implementations
    /// (notably, OpenGL ES 2), where the pixel format and the pixel type
    /// used at allocation time must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// **See also:** isStorageAllocated()
    /// setData()
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage. However, if immutable texture storage is not available,
    /// then the specified *pixelFormat* and *pixelType* will be used
    /// to allocate mutable storage; note that in certain OpenGL implementations
    /// (notably, OpenGL ES 2) they must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **See also:** isStorageAllocated()
    /// setData()
    allocate_storage(),
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **Note**: If immutable texture storage is not available,
    /// then a default pixel format and pixel type will be used to
    /// create the mutable storage. You can use the other
    /// allocateStorage() overload to specify exactly the pixel format
    /// and the pixel type to use when allocating mutable storage;
    /// this is particulary useful under certain OpenGL ES implementations
    /// (notably, OpenGL ES 2), where the pixel format and the pixel type
    /// used at allocation time must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// **See also:** isStorageAllocated()
    /// setData()
    /// 
    /// Allocates server-side storage for this texture object taking
    /// into account, the format, dimensions, mipmap levels, array
    /// layers and cubemap faces.
    /// 
    /// Once storage has been allocated it is no longer possible to change
    /// these properties.
    /// 
    /// If supported QOpenGLTexture makes use of immutable texture
    /// storage. However, if immutable texture storage is not available,
    /// then the specified *pixelFormat* and *pixelType* will be used
    /// to allocate mutable storage; note that in certain OpenGL implementations
    /// (notably, OpenGL ES 2) they must perfectly match the format
    /// and the type passed to any subsequent setData() call.
    /// 
    /// Once storage has been allocated for the texture then pixel data
    /// can be uploaded via one of the setData() overloads.
    /// 
    /// **See also:** isStorageAllocated()
    /// setData()
    allocate_storage_2(pixel_format: OpenGLTexture::PixelFormat, pixel_type: OpenGLTexture::PixelType),
    /// 
    /// Returns `true` if server-side storage for this texture as been
    /// allocated.
    /// 
    /// The texture format, dimensions, mipmap levels and array layers
    /// cannot be altered once storage ihas been allocated.
    /// 
    /// **See also:** allocateStorage()
    /// setSize()
    /// setMipLevels()
    /// setLayers()
    /// setFormat()
    is_storage_allocated() -> bool,
    /// 
    /// Attempts to create a texture view onto this texture. A texture
    /// view is somewhat analogous to a view in SQL in that it presents
    /// a restricted or reinterpreted view of the original data. Texture
    /// views do not allocate any more server-side storage, insted relying
    /// on the storage buffer of the source texture.
    /// 
    /// Texture views are only available when using immutable storage. For
    /// more information on texture views see
    /// http://www.opengl.org/wiki/Texture_Storage#Texture_views.
    /// 
    /// The *target* argument specifies the target to use for the view.
    /// Only some targets can be used depending upon the target of the original
    /// target. For e.g. a view onto a Target1DArray texture can specify
    /// either Target1DArray or Target1D but for the latter the number of
    /// array layers specified with *minimumLayer* and *maximumLayer* must
    /// be exactly 1.
    /// 
    /// Simpliar constraints apply for the *viewFormat.* See the above link
    /// and the specification for more details.
    /// 
    /// The *minimumMipmapLevel,* *maximumMipmapLevel,* *minimumLayer,*
    /// and *maximumLayer* arguments serve to restrict the parts of the
    /// texture accessible by the texture view.
    /// 
    /// If creation of the texture view fails this function will return
    /// 0. If the function succeeds it will return a pointer to a new
    /// QOpenGLTexture object that will return `true` from its isTextureView()
    /// function.
    /// 
    /// **See also:** isTextureView()
    create_texture_view(target: OpenGLTexture::Target, view_format: OpenGLTexture::TextureFormat, minimum_mipmap_level: i32, maximum_mipmap_level: i32, minimum_layer: i32, maximum_layer: i32) -> OpenGLTexture?,
    /// 
    /// Returns `true` if this texture object is actually a view onto another
    /// texture object.
    /// 
    /// **See also:** createTextureView()
    is_texture_view() -> bool,
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_2(mip_level: i32, layer: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_3(mip_level: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_4(source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_5(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_6(mip_level: i32, layer: i32, layer_count: i32, cube_face: OpenGLTexture::CubeMapFace, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_7(mip_level: i32, layer: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_8(mip_level: i32, source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_9(source_format: OpenGLTexture::PixelFormat, source_type: OpenGLTexture::PixelType, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_2(mip_level: i32, layer: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_3(mip_level: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_4(data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_5(mip_level: i32, layer: i32, cube_face: OpenGLTexture::CubeMapFace, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_6(mip_level: i32, layer: i32, layer_count: i32, cube_face: OpenGLTexture::CubeMapFace, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_7(mip_level: i32, layer: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_8(mip_level: i32, data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads compressed pixel *data* to *mipLevel,* array *layer,* and *cubeFace.*
    /// The pixel transfer can optionally be controlled with *options.* The *dataSize*
    /// argument should specify the size of the data pointed to by *data.*
    /// 
    /// If not using a compressed format() then you should use setData() instead of this
    /// function.
    /// 
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    set_compressed_data_9(data_size: i32, data: *void, options: *OpenGLPixelTransferOptionsType),
    /// 
    /// Uploads pixel *data* for this texture object *mipLevel,* array *layer,* and *cubeFace.*
    /// Storage must have been allocated before uploading pixel data. Some overloads of setData()
    /// will set appropriate dimensions, mipmap levels, and array layers and then allocate storage
    /// for you if they have enough information to do so. This will be noted in the function
    /// documentation.
    /// 
    /// The structure of the pixel data pointed to by *data* is specified by *sourceFormat*
    /// and *sourceType.* The pixel data upload can optionally be controlled by *options.*
    /// 
    /// If using a compressed format() then you should use setCompressedData() instead of this
    /// function.
    /// 
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// Parameter *layerCount* is the number of layers in a texture array
    /// that are being uploaded/populated by this call.
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// **See also:** setCompressedData()
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// 
    /// This overload of setData() will allocate storage for you.
    /// The pixel data is contained in *image.* Mipmaps are generated by default.
    /// Set *genMipMaps* to [DontGenerateMipMaps](DontGenerateMipMaps)
    /// to turn off mipmap generation.
    /// 
    /// **Overloads**
    set_data_10(image: &ImageType, gen_mip_maps: OpenGLTexture::MipMapGeneration),
    /// 
    /// Returns `true` if your OpenGL implementation and version supports the texture
    /// feature *feature.*
    [static] has_feature(feature: OpenGLTexture::Feature) -> bool,
    /// 
    /// Sets the base mipmap level used for all texture lookups with this texture to *baseLevel.*
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** mipBaseLevel()
    /// setMipMaxLevel()
    /// setMipLevelRange()
    set_mip_base_level(base_level: i32),
    /// 
    /// Returns the mipmap base level used for all texture lookups with this texture.
    /// The default is 0.
    /// 
    /// **See also:** setMipBaseLevel()
    /// mipMaxLevel()
    /// mipLevelRange()
    mip_base_level() -> i32,
    /// 
    /// Sets the maximum mipmap level used for all texture lookups with this texture to *maxLevel.*
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** mipMaxLevel()
    /// setMipBaseLevel()
    /// setMipLevelRange()
    set_mip_max_level(max_level: i32),
    /// 
    /// Returns the mipmap maximum level used for all texture lookups with this texture.
    /// 
    /// **See also:** setMipMaxLevel()
    /// mipBaseLevel()
    /// mipLevelRange()
    mip_max_level() -> i32,
    /// 
    /// Sets the range of mipmap levels that can be used for texture lookups with this texture
    /// to range from *baseLevel* to *maxLevel.*
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** setMipBaseLevel()
    /// setMipMaxLevel()
    /// mipLevelRange()
    set_mip_level_range(base_level: i32, max_level: i32),
    /// 
    /// Returns the range of mipmap levels that can be used for texture lookups with this texture.
    /// 
    /// **See also:** mipBaseLevel()
    /// mipMaxLevel()
    mip_level_range() -> Pair<int,,
    /// 
    /// If *enabled* is `true,` enables automatic mipmap generation for this texture object
    /// to occur whenever the level 0 mipmap data is set via setData().
    /// 
    /// The automatic mipmap generation is enabled by default.
    /// 
    /// **Note**: Mipmap generation is not supported for compressed textures with OpenGL ES 2.0.
    /// 
    /// **See also:** isAutoMipMapGenerationEnabled()
    /// generateMipMaps()
    set_auto_mip_map_generation_enabled(enabled: bool),
    /// 
    /// Returns whether auto mipmap generation is enabled for this texture object.
    /// 
    /// **See also:** setAutoMipMapGenerationEnabled()
    /// generateMipMaps()
    is_auto_mip_map_generation_enabled() -> bool,
    /// 
    /// Generates mipmaps for this texture object from mipmap level 0. If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// **Note**: Mipmap generation is not supported for compressed textures with OpenGL
    /// ES 2.0.
    /// 
    /// **See also:** setAutoMipMapGenerationEnabled()
    /// setMipLevels()
    /// mipLevels()
    /// 
    /// Generates mipmaps for this texture object from mipmap level *baseLevel.* If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// The generation of mipmaps to above *baseLevel* is achieved by setting the mipmap
    /// base level to *baseLevel* and then generating the mipmap chain. If *resetBaseLevel*
    /// is `true,` then the baseLevel of the texture will be reset to its previous value.
    /// 
    /// **See also:** setAutoMipMapGenerationEnabled()
    /// setMipLevels()
    /// mipLevels()
    generate_mip_maps(),
    /// 
    /// Generates mipmaps for this texture object from mipmap level 0. If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// **Note**: Mipmap generation is not supported for compressed textures with OpenGL
    /// ES 2.0.
    /// 
    /// **See also:** setAutoMipMapGenerationEnabled()
    /// setMipLevels()
    /// mipLevels()
    /// 
    /// Generates mipmaps for this texture object from mipmap level *baseLevel.* If you are
    /// using a texture target and filtering option that requires mipmaps and you
    /// have disabled automatic mipmap generation then you need to call this function
    /// or the overload to create the mipmap chain.
    /// 
    /// The generation of mipmaps to above *baseLevel* is achieved by setting the mipmap
    /// base level to *baseLevel* and then generating the mipmap chain. If *resetBaseLevel*
    /// is `true,` then the baseLevel of the texture will be reset to its previous value.
    /// 
    /// **See also:** setAutoMipMapGenerationEnabled()
    /// setMipLevels()
    /// mipLevels()
    generate_mip_maps_2(base_level: i32, reset_base_level: bool),
    /// 
    /// GLSL shaders are able to reorder the components of the vec4 returned by texture
    /// functions. It is also desirable to be able to control this reordering from CPU
    /// side code. This is made possible by swizzle masks since OpenGL 3.3.
    /// 
    /// Each component of the texture can be mapped to one of the SwizzleValue options.
    /// 
    /// This function maps *component* to the output *value.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** swizzleMask()
    /// 
    /// Parameters *r* , *g* , *b* , and *a* are values used for setting
    /// the colors red, green, blue, and the alpha value.
    /// **Overloads**
    set_swizzle_mask(component: OpenGLTexture::SwizzleComponent, value: OpenGLTexture::SwizzleValue),
    /// 
    /// GLSL shaders are able to reorder the components of the vec4 returned by texture
    /// functions. It is also desirable to be able to control this reordering from CPU
    /// side code. This is made possible by swizzle masks since OpenGL 3.3.
    /// 
    /// Each component of the texture can be mapped to one of the SwizzleValue options.
    /// 
    /// This function maps *component* to the output *value.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** swizzleMask()
    /// 
    /// Parameters *r* , *g* , *b* , and *a* are values used for setting
    /// the colors red, green, blue, and the alpha value.
    /// **Overloads**
    set_swizzle_mask_2(r: OpenGLTexture::SwizzleValue, g: OpenGLTexture::SwizzleValue, b: OpenGLTexture::SwizzleValue, a: OpenGLTexture::SwizzleValue),
    /// 
    /// Returns the swizzle mask for texture *component.*
    swizzle_mask(component: OpenGLTexture::SwizzleComponent) -> OpenGLTexture::SwizzleValue,
    /// 
    /// If using a texture that has a combined depth/stencil format this function sets
    /// which component of the texture is accessed to *mode.*
    /// 
    /// When the parameter is set to DepthMode, then accessing it from the
    /// shader will access the depth component as a single float, as normal. But when
    /// the parameter is set to StencilMode, the shader will access the stencil component.
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** depthStencilMode()
    set_depth_stencil_mode(mode: OpenGLTexture::DepthStencilMode),
    /// 
    /// Returns the depth stencil mode for textures using a combined depth/stencil format.
    /// 
    /// **See also:** setDepthStencilMode()
    depth_stencil_mode() -> OpenGLTexture::DepthStencilMode,
    set_comparison_function(function: OpenGLTexture::ComparisonFunction),
    /// 
    /// Returns the texture comparison operator set on this texture. By default, a
    /// texture has a CompareLessEqual comparison function.
    /// 
    /// **See also:** setComparisonFunction()
    comparison_function() -> OpenGLTexture::ComparisonFunction,
    /// 
    /// Sets the texture comparison mode on this texture to *mode.* The texture
    /// comparison mode is used by shadow samplers when sampling a depth texture.
    /// 
    /// **See also:** comparisonMode()
    set_comparison_mode(mode: OpenGLTexture::ComparisonMode),
    /// 
    /// Returns the texture comparison mode set on this texture. By default, a
    /// texture has a CompareNone comparison mode (i.e. comparisons are disabled).
    /// 
    /// **See also:** setComparisonMode()
    comparison_mode() -> OpenGLTexture::ComparisonMode,
    /// 
    /// Sets the filter used for minification to *filter.*
    /// 
    /// **See also:** minificationFilter()
    /// setMagnificationFilter()
    /// setMinMagFilters()
    set_minification_filter(filter: OpenGLTexture::Filter),
    /// 
    /// Returns the minification filter.
    /// 
    /// **See also:** setMinificationFilter()
    minification_filter() -> OpenGLTexture::Filter,
    /// 
    /// Sets the magnification filter to *filter.*
    /// 
    /// **See also:** magnificationFilter()
    /// setMinificationFilter()
    /// setMinMagFilters()
    set_magnification_filter(filter: OpenGLTexture::Filter),
    /// 
    /// Returns the magnification filter.
    /// 
    /// **See also:** setMagnificationFilter()
    magnification_filter() -> OpenGLTexture::Filter,
    /// 
    /// Sets the minification filter to *minificationFilter* and the magnification filter
    /// to *magnificationFilter.*
    /// 
    /// **See also:** minMagFilters()
    /// setMinificationFilter()
    /// setMagnificationFilter()
    set_min_mag_filters(minification_filter: OpenGLTexture::Filter, magnification_filter: OpenGLTexture::Filter),
    /// 
    /// Returns the current minification and magnification filters.
    /// 
    /// **See also:** setMinMagFilters()
    min_mag_filters() -> Pair<QOpenGLTexture::Filter, QOpenGLTexture::Filter>,
    /// 
    /// Sets the wrap (or repeat mode) for all texture dimentions to *mode.*
    /// 
    /// **See also:** wrapMode()
    /// 
    /// Holds the texture dimension *direction.*
    /// **Overloads**
    set_wrap_mode(mode: OpenGLTexture::WrapMode),
    /// 
    /// Sets the wrap (or repeat mode) for all texture dimentions to *mode.*
    /// 
    /// **See also:** wrapMode()
    /// 
    /// Holds the texture dimension *direction.*
    /// **Overloads**
    set_wrap_mode_2(direction: OpenGLTexture::CoordinateDirection, mode: OpenGLTexture::WrapMode),
    /// 
    /// Returns the wrap mode for the texture dimension *direction.*
    /// 
    /// **See also:** setWrapMode()
    wrap_mode(direction: OpenGLTexture::CoordinateDirection) -> OpenGLTexture::WrapMode,
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** borderColor()
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    set_border_color(color: ColorType),
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** borderColor()
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    set_border_color_2(r: f32, g: f32, b: f32, a: f32),
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** borderColor()
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    set_border_color_3(r: i32, g: i32, b: i32, a: i32),
    /// 
    /// Sets the border color of the texture to *color.*
    /// 
    /// **Note**: This function has no effect on Mac and Qt built for OpenGL ES 2.
    /// **See also:** borderColor()
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and *a* to the
    /// alpha value.
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    /// 
    /// Sets the color red to *r* , green to *g* , blue to *b* , and the alpha
    /// value to *a* .
    /// **Overloads**
    set_border_color_4(r: uint, g: uint, b: uint, a: uint),
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    border_color() -> Color,
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    border_color_2(border: *f32),
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    border_color_3(border: *i32),
    /// 
    /// Returns the borderColor of this texture.
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **See also:** setBorderColor()
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    /// 
    /// Writes the texture border color into the first four elements
    /// of the array pointed to by *border.*
    /// 
    /// **Overloads**
    border_color_4(border: *unsigned),
    /// 
    /// Sets the minimum level of detail to *value.* This limits the selection of highest
    /// resolution mipmap (lowest mipmap level). The default value is -1000.
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** minimumLevelOfDetail()
    /// setMaximumLevelOfDetail()
    /// setLevelOfDetailRange()
    set_minimum_level_of_detail(value: f32),
    /// 
    /// Returns the minimum level of detail parameter.
    /// 
    /// **See also:** setMinimumLevelOfDetail()
    /// maximumLevelOfDetail()
    /// levelOfDetailRange()
    minimum_level_of_detail() -> f32,
    /// 
    /// Sets the maximum level of detail to *value.* This limits the selection of lowest
    /// resolution mipmap (highest mipmap level). The default value is 1000.
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** maximumLevelOfDetail()
    /// setMinimumLevelOfDetail()
    /// setLevelOfDetailRange()
    set_maximum_level_of_detail(value: f32),
    /// 
    /// Returns the maximum level of detail parameter.
    /// 
    /// **See also:** setMaximumLevelOfDetail()
    /// minimumLevelOfDetail()
    /// levelOfDetailRange()
    maximum_level_of_detail() -> f32,
    /// 
    /// Sets the minimum level of detail parameters to *min* and the maximum level
    /// to *max.*
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** levelOfDetailRange()
    /// setMinimumLevelOfDetail()
    /// setMaximumLevelOfDetail()
    set_level_of_detail_range(min: f32, max: f32),
    /// 
    /// Returns the minimum and maximum level of detail parameters.
    /// 
    /// **See also:** setLevelOfDetailRange()
    /// minimumLevelOfDetail()
    /// maximumLevelOfDetail()
    level_of_detail_range() -> Pair<float,,
    /// 
    /// Sets the level of detail bias to *bias.*
    /// Level of detail bias affects the point at which mipmapping levels change.
    /// Increasing values for level of detail bias makes the overall images blurrier
    /// or smoother. Decreasing values make the overall images sharper.
    /// 
    /// **Note**: This function has no effect on Qt built for OpenGL ES 2.
    /// **See also:** levelofDetailBias()
    set_levelof_detail_bias(bias: f32),
    /// 
    /// Returns the level of detail bias parameter.
    /// 
    /// **See also:** setLevelofDetailBias()
    levelof_detail_bias() -> f32,
}

// vim: syntax=rust expandtab ts=4 sw=4
