/// 
/// QFormLayout is a convenience layout class that lays out its
/// children in a two-column form. The left column consists of labels
/// and the right column consists of widgets (line editors,
/// spin boxes, etc.).
/// 
/// Traditionally, such two-column form layouts were achieved using
/// QGridLayout. QFormLayout is a higher-level alternative that
/// provides the following advantages:
/// 
/// * **Adherence to the different platform's look and feel guidelines.** For example, the [\macos Aqua](http://developer.apple.com/library/mac/%23documentation/UserExperience/Conceptual/AppleHIGuidelines/Intro/Intro.html)
/// and KDE guidelines specify that the labels should be right-aligned, whereas Windows and GNOME applications normally use left-alignment.
/// * **Support for wrapping long rows.** For devices with small displays, QFormLayout can be set to [wrap long rows](WrapLongRows)
/// , or even to [wrap all rows](WrapAllRows)
/// 
/// * **Convenient API for creating label--field pairs.** The addRow() overload that takes a QString and a QWidget * creates a QLabel behind the scenes and automatically set up its buddy. We can then write code like this: Compare this with the following code, written using QGridLayout:
/// 
/// The table below shows the default appearance in different styles.
/// 
/// * QCommonStyle derived styles (except QPlastiqueStyle)
/// * QMacStyle
/// * QPlastiqueStyle
/// * Qt Extended styles
/// 
/// * ![qformlayout-win.png](qformlayout-win.png)
/// 
/// * ![qformlayout-mac.png](qformlayout-mac.png)
/// 
/// * ![qformlayout-kde.png](qformlayout-kde.png)
/// 
/// * ![qformlayout-qpe.png](qformlayout-qpe.png)
/// 
/// * Traditional style used for Windows, GNOME, and earlier versions of KDE. Labels are left aligned, and expanding fields grow to fill the available space. (This normally corresponds to what we would get using a two-column QGridLayout.)
/// * Style based on the [\macos Aqua](http://developer.apple.com/library/mac/%23documentation/UserExperience/Conceptual/AppleHIGuidelines/Intro/Intro.html)
/// guidelines. Labels are right-aligned, the fields don't grow beyond their size hint, and the form is horizontally centered.
/// * Recommended style for [KDE applications](KDE%20applications)
/// . Similar to MacStyle, except that the form is left-aligned and all fields grow to fill the available space.
/// * Default style for Qt Extended styles. Labels are right-aligned, expanding fields grow to fill the available space, and row wrapping is enabled for long lines.
/// 
/// The form styles can be also be overridden individually by calling
/// setLabelAlignment(), setFormAlignment(), setFieldGrowthPolicy(),
/// and setRowWrapPolicy(). For example, to simulate the form layout
/// appearance of QMacStyle on all platforms, but with left-aligned
/// labels, you could write:
/// 
/// **See also:** [`GridLayout`]
/// [`BoxLayout`]
/// [`StackedLayout`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct FormLayout : Layout {
    set_field_growth_policy(policy: FormLayout::FieldGrowthPolicy),
    /// 
    /// The default value depends on the widget or application style. For
    /// QMacStyle, the default is FieldsStayAtSizeHint; for QCommonStyle
    /// derived styles (like Plastique and Windows), the default
    /// is ExpandingFieldsGrow; for Qt Extended styles, the default is
    /// AllNonFixedFieldsGrow.
    /// 
    /// If none of the fields can grow and the form is resized, extra
    /// space is distributed according to the current
    /// [form alignment](formAlignment)
    /// 
    /// 
    /// **See also:** formAlignment
    /// rowWrapPolicy
    field_growth_policy() -> FormLayout::FieldGrowthPolicy,
    set_row_wrap_policy(policy: FormLayout::RowWrapPolicy),
    /// 
    /// The default value depends on the widget or application style. For
    /// Qt Extended styles, the default is WrapLongRows;
    /// for the other styles, the default is DontWrapRows.
    /// 
    /// If you want to display each label above its associated field
    /// (instead of next to it), set this property to WrapAllRows.
    /// 
    /// **See also:** fieldGrowthPolicy
    row_wrap_policy() -> FormLayout::RowWrapPolicy,
    set_label_alignment(alignment: Rute::Alignment),
    /// 
    /// The default value depends on the widget or application style. For
    /// QCommonStyle derived styles, except for QPlastiqueStyle, the
    /// default is Qt::AlignLeft; for the other styles, the default is
    /// Qt::AlignRight.
    /// 
    /// **See also:** formAlignment
    label_alignment() -> Rute::Alignment,
    set_form_alignment(alignment: Rute::Alignment),
    /// 
    /// The default value depends on the widget or application style. For
    /// QMacStyle, the default is Qt::AlignHCenter | Qt::AlignTop; for the
    /// other styles, the default is Qt::AlignLeft | Qt::AlignTop.
    /// 
    /// **See also:** labelAlignment
    /// rowWrapPolicy
    form_alignment() -> Rute::Alignment,
    set_horizontal_spacing(spacing: i32),
    /// 
    /// By default, if no value is explicitly set, the layout's horizontal
    /// spacing is inherited from the parent layout, or from the style settings
    /// for the parent widget.
    /// 
    /// **See also:** verticalSpacing
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutHorizontalSpacing}
    horizontal_spacing() -> i32,
    set_vertical_spacing(spacing: i32),
    /// 
    /// By default, if no value is explicitly set, the layout's vertical spacing is
    /// inherited from the parent layout, or from the style settings for the parent
    /// widget.
    /// 
    /// **See also:** horizontalSpacing
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutHorizontalSpacing}
    vertical_spacing() -> i32,
    /// 
    /// If the vertical spacing is equal to the horizontal spacing,
    /// this function returns that value; otherwise it returns -1.
    /// 
    /// **See also:** [`set_spacing()`]
    /// [`vertical_spacing()`]
    /// [`horizontal_spacing()`]
    spacing() -> i32,
    /// 
    /// This function sets both the vertical and horizontal spacing to
    /// *spacing.*
    /// 
    /// **See also:** [`set_vertical_spacing()`]
    /// [`set_horizontal_spacing()`]
    set_spacing(arg0: i32),
    /// 
    /// Adds a new row to the bottom of this form layout, with the given
    /// *label* and *field.*
    /// 
    /// **See also:** [`insert_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Adds the specified *widget* at the end of this form layout. The
    /// *widget* spans both columns.
    /// 
    /// **Overloads**
    /// Adds the specified *layout* at the end of this form layout. The
    /// *layout* spans both columns.
    add_row(label: *WidgetType, field: *WidgetType),
    /// 
    /// Adds a new row to the bottom of this form layout, with the given
    /// *label* and *field.*
    /// 
    /// **See also:** [`insert_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Adds the specified *widget* at the end of this form layout. The
    /// *widget* spans both columns.
    /// 
    /// **Overloads**
    /// Adds the specified *layout* at the end of this form layout. The
    /// *layout* spans both columns.
    [org_name(addRow)]
    add_row_2(label: *WidgetType, field: *LayoutType),
    /// 
    /// Adds a new row to the bottom of this form layout, with the given
    /// *label* and *field.*
    /// 
    /// **See also:** [`insert_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Adds the specified *widget* at the end of this form layout. The
    /// *widget* spans both columns.
    /// 
    /// **Overloads**
    /// Adds the specified *layout* at the end of this form layout. The
    /// *layout* spans both columns.
    [org_name(addRow)]
    add_row_3(label_text: String, field: *WidgetType),
    /// 
    /// Adds a new row to the bottom of this form layout, with the given
    /// *label* and *field.*
    /// 
    /// **See also:** [`insert_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Adds the specified *widget* at the end of this form layout. The
    /// *widget* spans both columns.
    /// 
    /// **Overloads**
    /// Adds the specified *layout* at the end of this form layout. The
    /// *layout* spans both columns.
    [org_name(addRow)]
    add_row_4(label_text: String, field: *LayoutType),
    /// 
    /// Adds a new row to the bottom of this form layout, with the given
    /// *label* and *field.*
    /// 
    /// **See also:** [`insert_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Adds the specified *widget* at the end of this form layout. The
    /// *widget* spans both columns.
    /// 
    /// **Overloads**
    /// Adds the specified *layout* at the end of this form layout. The
    /// *layout* spans both columns.
    [org_name(addRow)]
    add_row_5(widget: *WidgetType),
    /// 
    /// Adds a new row to the bottom of this form layout, with the given
    /// *label* and *field.*
    /// 
    /// **See also:** [`insert_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Adds the specified *widget* at the end of this form layout. The
    /// *widget* spans both columns.
    /// 
    /// **Overloads**
    /// Adds the specified *layout* at the end of this form layout. The
    /// *layout* spans both columns.
    [org_name(addRow)]
    add_row_6(layout: *LayoutType),
    /// 
    /// Inserts a new row at position *row* in this form layout, with
    /// the given *label* and *field.* If *row* is out of bounds, the
    /// new row is added at the end.
    /// 
    /// **See also:** [`add_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Inserts the specified *widget* at position *row* in this form
    /// layout. The *widget* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    /// 
    /// **Overloads**
    /// Inserts the specified *layout* at position *row* in this form
    /// layout. The *layout* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    insert_row(row: i32, label: *WidgetType, field: *WidgetType),
    /// 
    /// Inserts a new row at position *row* in this form layout, with
    /// the given *label* and *field.* If *row* is out of bounds, the
    /// new row is added at the end.
    /// 
    /// **See also:** [`add_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Inserts the specified *widget* at position *row* in this form
    /// layout. The *widget* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    /// 
    /// **Overloads**
    /// Inserts the specified *layout* at position *row* in this form
    /// layout. The *layout* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    [org_name(insertRow)]
    insert_row_2(row: i32, label: *WidgetType, field: *LayoutType),
    /// 
    /// Inserts a new row at position *row* in this form layout, with
    /// the given *label* and *field.* If *row* is out of bounds, the
    /// new row is added at the end.
    /// 
    /// **See also:** [`add_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Inserts the specified *widget* at position *row* in this form
    /// layout. The *widget* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    /// 
    /// **Overloads**
    /// Inserts the specified *layout* at position *row* in this form
    /// layout. The *layout* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    [org_name(insertRow)]
    insert_row_3(row: i32, label_text: String, field: *WidgetType),
    /// 
    /// Inserts a new row at position *row* in this form layout, with
    /// the given *label* and *field.* If *row* is out of bounds, the
    /// new row is added at the end.
    /// 
    /// **See also:** [`add_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Inserts the specified *widget* at position *row* in this form
    /// layout. The *widget* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    /// 
    /// **Overloads**
    /// Inserts the specified *layout* at position *row* in this form
    /// layout. The *layout* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    [org_name(insertRow)]
    insert_row_4(row: i32, label_text: String, field: *LayoutType),
    /// 
    /// Inserts a new row at position *row* in this form layout, with
    /// the given *label* and *field.* If *row* is out of bounds, the
    /// new row is added at the end.
    /// 
    /// **See also:** [`add_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Inserts the specified *widget* at position *row* in this form
    /// layout. The *widget* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    /// 
    /// **Overloads**
    /// Inserts the specified *layout* at position *row* in this form
    /// layout. The *layout* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    [org_name(insertRow)]
    insert_row_5(row: i32, widget: *WidgetType),
    /// 
    /// Inserts a new row at position *row* in this form layout, with
    /// the given *label* and *field.* If *row* is out of bounds, the
    /// new row is added at the end.
    /// 
    /// **See also:** [`add_row()`]
    /// 
    /// **Overloads**
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text. The *field* is set as the new
    /// QLabel's [buddy](QLabel::setBuddy())
    /// 
    /// 
    /// **Overloads**
    /// This overload automatically creates a QLabel behind the scenes
    /// with *labelText* as its text.
    /// 
    /// **Overloads**
    /// Inserts the specified *widget* at position *row* in this form
    /// layout. The *widget* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    /// 
    /// **Overloads**
    /// Inserts the specified *layout* at position *row* in this form
    /// layout. The *layout* spans both columns. If *row* is out of
    /// bounds, the widget is added at the end.
    [org_name(insertRow)]
    insert_row_6(row: i32, layout: *LayoutType),
    /// 
    /// Deletes row *row* from this form layout.
    /// 
    /// *row* must be non-negative and less than rowCount().
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// flay->removeRow(2); // le == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the layout without deleting the widgets, use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    /// 
    /// **Overloads**
    /// Deletes the row corresponding to *widget* from this form layout.
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// flay->removeRow(le); // le == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the layout without deleting the widgets, use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    /// 
    /// **Overloads**
    /// Deletes the row corresponding to *layout* from this form layout.
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    /// flay->insertRow(2, "User:", vbl);
    /// // later:
    /// flay->removeRow(layout); // vbl == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the form layout without deleting the inserted layout,
    /// use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    remove_row(row: i32),
    /// 
    /// Deletes row *row* from this form layout.
    /// 
    /// *row* must be non-negative and less than rowCount().
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// flay->removeRow(2); // le == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the layout without deleting the widgets, use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    /// 
    /// **Overloads**
    /// Deletes the row corresponding to *widget* from this form layout.
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// flay->removeRow(le); // le == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the layout without deleting the widgets, use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    /// 
    /// **Overloads**
    /// Deletes the row corresponding to *layout* from this form layout.
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    /// flay->insertRow(2, "User:", vbl);
    /// // later:
    /// flay->removeRow(layout); // vbl == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the form layout without deleting the inserted layout,
    /// use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    [org_name(removeRow)]
    remove_row_2(widget: *WidgetType),
    /// 
    /// Deletes row *row* from this form layout.
    /// 
    /// *row* must be non-negative and less than rowCount().
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// flay->removeRow(2); // le == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the layout without deleting the widgets, use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    /// 
    /// **Overloads**
    /// Deletes the row corresponding to *widget* from this form layout.
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// flay->removeRow(le); // le == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the layout without deleting the widgets, use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    /// 
    /// **Overloads**
    /// Deletes the row corresponding to *layout* from this form layout.
    /// 
    /// After this call, rowCount() is decremented by one. All widgets and
    /// nested layouts that occupied this row are deleted. That includes both
    /// the field widget(s) and the label, if any. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    /// flay->insertRow(2, "User:", vbl);
    /// // later:
    /// flay->removeRow(layout); // vbl == nullptr at this point
    /// ```
    /// 
    /// If you want to remove the row from the form layout without deleting the inserted layout,
    /// use takeRow() instead.
    /// 
    /// **See also:** [`take_row()`]
    [org_name(removeRow)]
    remove_row_3(layout: *LayoutType),
    /// 
    /// Removes the specified *row* from this form layout.
    /// 
    /// *row* must be non-negative and less than rowCount().
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(2);
    /// ```
    /// 
    /// If you want to remove the row from the layout and delete the widgets, use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    /// 
    /// **Overloads**
    /// Removes the specified *widget* from this form layout.
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(widget);
    /// ```
    /// 
    /// If you want to remove the row from the layout and delete the widgets, use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    /// 
    /// **Overloads**
    /// Removes the specified *layout* from this form layout.
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    /// flay->insertRow(2, "User:", vbl);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(widget);
    /// ```
    /// 
    /// If you want to remove the row from the form layout and delete the inserted layout,
    /// use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    take_row(row: i32) -> FormLayout::TakeRowResult,
    /// 
    /// Removes the specified *row* from this form layout.
    /// 
    /// *row* must be non-negative and less than rowCount().
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(2);
    /// ```
    /// 
    /// If you want to remove the row from the layout and delete the widgets, use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    /// 
    /// **Overloads**
    /// Removes the specified *widget* from this form layout.
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(widget);
    /// ```
    /// 
    /// If you want to remove the row from the layout and delete the widgets, use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    /// 
    /// **Overloads**
    /// Removes the specified *layout* from this form layout.
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    /// flay->insertRow(2, "User:", vbl);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(widget);
    /// ```
    /// 
    /// If you want to remove the row from the form layout and delete the inserted layout,
    /// use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    [org_name(takeRow)]
    take_row_2(widget: *WidgetType) -> FormLayout::TakeRowResult,
    /// 
    /// Removes the specified *row* from this form layout.
    /// 
    /// *row* must be non-negative and less than rowCount().
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// You can use this function to undo a previous addRow() or insertRow():
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(2);
    /// ```
    /// 
    /// If you want to remove the row from the layout and delete the widgets, use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    /// 
    /// **Overloads**
    /// Removes the specified *widget* from this form layout.
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QLineEdit> le = new QLineEdit;
    /// flay->insertRow(2, "User:", le);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(widget);
    /// ```
    /// 
    /// If you want to remove the row from the layout and delete the widgets, use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    /// 
    /// **Overloads**
    /// Removes the specified *layout* from this form layout.
    /// 
    /// **Note**: This function doesn't delete anything.
    /// 
    /// After this call, rowCount() is decremented by one. All following rows are shifted
    /// up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    /// ```
    /// QFormLayout *flay = ...;
    /// QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    /// flay->insertRow(2, "User:", vbl);
    /// // later:
    /// QFormLayout::TakeRowResult result = flay->takeRow(widget);
    /// ```
    /// 
    /// If you want to remove the row from the form layout and delete the inserted layout,
    /// use removeRow() instead.
    /// 
    /// **Returns** A structure containing both the widget and
    /// corresponding label layout items
    /// 
    /// **See also:** [`remove_row()`]
    [org_name(takeRow)]
    take_row_3(layout: *LayoutType) -> FormLayout::TakeRowResult,
    /// 
    /// Sets the item in the given *row* for the given *role* to *item,* extending the
    /// layout with empty rows if necessary.
    /// 
    /// If the cell is already occupied, the *item* is not inserted and an error message is
    /// sent to the console.
    /// The *item* spans both columns.
    /// 
    /// **Warning**: Do not use this function to add child layouts or child
    /// widget items. Use setLayout() or setWidget() instead.
    /// 
    /// **See also:** [`set_layout()`]
    set_item(row: i32, role: FormLayout::ItemRole, item: *LayoutItemType),
    /// 
    /// Sets the widget in the given *row* for the given *role* to *widget,* extending the
    /// layout with empty rows if necessary.
    /// 
    /// If the cell is already occupied, the *widget* is not inserted and an error message is
    /// sent to the console.
    /// 
    /// **Note:** For most applications, addRow() or insertRow() should be used instead of setWidget().
    /// 
    /// **See also:** [`set_layout()`]
    set_widget(row: i32, role: FormLayout::ItemRole, widget: *WidgetType),
    /// 
    /// Sets the sub-layout in the given *row* for the given *role* to *layout,* extending the
    /// form layout with empty rows if necessary.
    /// 
    /// If the cell is already occupied, the *layout* is not inserted and an error message is
    /// sent to the console.
    /// 
    /// **Note:** For most applications, addRow() or insertRow() should be used instead of setLayout().
    /// 
    /// **See also:** [`set_widget()`]
    set_layout(row: i32, role: FormLayout::ItemRole, layout: *LayoutType),
    /// 
    /// 
    /// Returns the layout item in the given *row* with the specified *role* (column). Returns 0 if there is no such item.
    /// 
    /// **See also:** [`Layout::item_at`]
    /// [`set_item()`]
    item_at(row: i32, role: FormLayout::ItemRole) -> LayoutItem?,
    /// 
    /// Retrieves the row and role (column) of the item at the specified
    /// *index.* If *index* is out of bounds, * *rowPtr* is set to -1;
    /// otherwise the row is stored in * *rowPtr* and the role is stored
    /// in * *rolePtr.*
    /// 
    /// **See also:** [`item_at()`]
    /// [`count()`]
    /// [`get_layout_position()`]
    /// [`get_widget_position()`]
    get_item_position(index: i32, row_ptr: *i32, role_ptr: FormLayout::ItemRole *),
    /// 
    /// Retrieves the row and role (column) of the specified *widget* in
    /// the layout. If *widget* is not in the layout, * *rowPtr* is set
    /// to -1; otherwise the row is stored in * *rowPtr* and the role is stored
    /// in * *rolePtr.*
    /// 
    /// **See also:** [`get_item_position()`]
    /// [`item_at()`]
    get_widget_position(widget: *WidgetType, row_ptr: *i32, role_ptr: FormLayout::ItemRole *),
    /// 
    /// Retrieves the row and role (column) of the specified child *layout.* If *layout* is not in the form layout, * *rowPtr* is set
    /// to -1; otherwise the row is stored in * *rowPtr* and the role is stored
    /// in * *rolePtr.*
    get_layout_position(layout: *LayoutType, row_ptr: *i32, role_ptr: FormLayout::ItemRole *),
    /// 
    /// Returns the label associated with the given *field.*
    /// 
    /// **See also:** [`item_at()`]
    /// 
    /// **Overloads**
    label_for_field(field: *WidgetType) -> Widget?,
    /// 
    /// Returns the label associated with the given *field.*
    /// 
    /// **See also:** [`item_at()`]
    /// 
    /// **Overloads**
    [org_name(labelForField)]
    label_for_field_2(field: *LayoutType) -> Widget?,
    /// 
    [event] add_item(item: *LayoutItemType),
    /// 
    /// 
    /// Returns the layout item in the given *row* with the specified *role* (column). Returns 0 if there is no such item.
    /// 
    /// **See also:** [`Layout::item_at`]
    /// [`set_item()`]
    [org_name(itemAt)]
    [event] item_at_2(index: i32) -> LayoutItem?,
    /// 
    [event] take_at(index: i32) -> LayoutItem?,
    /// 
    [event] minimum_size() -> Size,
    /// 
    [event] size_hint() -> Size,
    /// 
    [event] invalidate(),
    /// 
    [event] has_height_for_width() -> bool,
    /// 
    [event] height_for_width(width: i32) -> i32,
    /// 
    [event] expanding_directions() -> Rute::Orientations,
    /// 
    [event] count() -> i32,
    /// 
    /// Returns the number of rows in the form.
    /// 
    /// **See also:** [`Layout::count`]
    row_count() -> i32,
}

[org_name(QFormLayout)]
enum FieldGrowthPolicy {
    /// The fields never grow beyond their [effective size hint](QWidgetItem::sizeHint())
 . This is the default for QMacStyle.
    FieldsStayAtSizeHint = 0,
    /// Fields with an horizontal [size policy](QSizePolicy)
 of [Expanding](QSizePolicy::)
 or [MinimumExpanding](QSizePolicy::)
 will grow to fill the available space. The other fields will not grow beyond their effective size hint. This is the default policy for Plastique.
    ExpandingFieldsGrow = 1,
    /// All fields with a size policy that allows them to grow will grow to fill the available space. This is the default policy for most styles.
    AllNonFixedFieldsGrow = 2,
}

[org_name(QFormLayout)]
enum RowWrapPolicy {
    /// Fields are always laid out next to their label. This is the default policy for all styles except Qt Extended styles.
    DontWrapRows = 0,
    /// Labels are given enough horizontal space to fit the widest label, and the rest of the space is given to the fields. If the minimum size of a field pair is wider than the available space, the field is wrapped to the next line. This is the default policy for Qt Extended styles.
    WrapLongRows = 1,
    /// Fields are always laid out below their label.
    WrapAllRows = 2,
}

[org_name(QFormLayout)]
enum ItemRole {
    /// A label widget.
    LabelRole = 0,
    /// A field widget.
    FieldRole = 1,
    /// A widget that spans label and field columns.
    SpanningRole = 2,
}

// vim: syntax=rust expandtab ts=4 sw=4
