///     \class QFormLayout
///     \since 4.4
///     \brief The QFormLayout class manages forms of input widgets and their associated labels.
/// 
///     \ingroup geomanagement
///     \inmodule QtWidgets
/// 
///     QFormLayout is a convenience layout class that lays out its
///     children in a two-column form. The left column consists of labels
///     and the right column consists of "field" widgets (line editors,
///     spin boxes, etc.).
/// 
///     Traditionally, such two-column form layouts were achieved using
///     QGridLayout. QFormLayout is a higher-level alternative that
///     provides the following advantages:
/// 
///     \list
///     \li \b{Adherence to the different platform's look and feel guidelines.}
/// 
///         For example, the
///         \l{http://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AppleHIGuidelines/Intro/Intro.html}{\macos Aqua} and KDE guidelines specify that the
///         labels should be right-aligned, whereas Windows and GNOME
///         applications normally use left-alignment.
/// 
///     \li \b{Support for wrapping long rows.}
/// 
///        For devices with small displays, QFormLayout can be set to
///        \l{WrapLongRows}{wrap long rows}, or even to
///        \l{WrapAllRows}{wrap all rows}.
/// 
///     \li \b{Convenient API for creating label--field pairs.}
/// 
///        The addRow() overload that takes a QString and a QWidget *
///        creates a QLabel behind the scenes and automatically set up
///        its buddy. We can then write code like this:
/// 
///     \snippet code/src_gui_kernel_qformlayout.cpp 0
/// 
///        Compare this with the following code, written using QGridLayout:
/// 
///     \snippet code/src_gui_kernel_qformlayout.cpp 1
///     \endlist
/// 
///     The table below shows the default appearance in different styles.
/// 
///     \table
///     \header
///         \li QCommonStyle derived styles (except QPlastiqueStyle)
///         \li QMacStyle
///         \li QPlastiqueStyle
///         \li Qt Extended styles
///     \row
///         \li \inlineimage qformlayout-win.png
///         \li \inlineimage qformlayout-mac.png
///         \li \inlineimage qformlayout-kde.png
///         \li \inlineimage qformlayout-qpe.png
///     \row
///         \li Traditional style used for Windows, GNOME, and earlier
///            versions of KDE. Labels are left aligned, and expanding
///            fields grow to fill the available space. (This normally
///            corresponds to what we would get using a two-column
///            QGridLayout.)
///         \li Style based on the
///            \l{http://developer.apple.com/library/mac/#documentation/UserExperience/Conceptual/AppleHIGuidelines/Intro/Intro.html}{\macos Aqua} guidelines. Labels are right-aligned,
///            the fields don't grow beyond their size hint, and the
///            form is horizontally centered.
///         \li Recommended style for
///            \l{KDE applications}. Similar to MacStyle, except that the form
///            is left-aligned and all fields grow to fill the available
///            space.
///         \li Default style for Qt Extended styles. Labels are right-aligned,
///            expanding fields grow to fill the available space, and row
///            wrapping is enabled for long lines.
///     \endtable
/// 
///     The form styles can be also be overridden individually by calling
///     setLabelAlignment(), setFormAlignment(), setFieldGrowthPolicy(),
///     and setRowWrapPolicy().  For example, to simulate the form layout
///     appearance of QMacStyle on all platforms, but with left-aligned
///     labels, you could write:
/// 
///     \snippet code/src_gui_kernel_qformlayout.cpp 2
/// 
///     \sa QGridLayout, QBoxLayout, QStackedLayout
/// The documentation provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QFormLayout)]
enum FieldGrowthPolicy {
    FieldsStayAtSizeHint,
    ExpandingFieldsGrow,
    AllNonFixedFieldsGrow,
}

[org_name(QFormLayout)]
enum RowWrapPolicy {
    DontWrapRows,
    WrapLongRows,
    WrapAllRows,
}

[org_name(QFormLayout)]
enum ItemRole {
    LabelRole,
    FieldRole,
    SpanningRole,
}

struct FormLayout : Layout {
    ///     \property QFormLayout::fieldGrowthPolicy
    ///     \brief the way in which the form's fields grow
    /// 
    ///     The default value depends on the widget or application style. For
    ///     QMacStyle, the default is FieldsStayAtSizeHint; for QCommonStyle
    ///     derived styles (like Plastique and Windows), the default
    ///     is ExpandingFieldsGrow; for Qt Extended styles, the default is
    ///     AllNonFixedFieldsGrow.
    /// 
    ///     If none of the fields can grow and the form is resized, extra
    ///     space is distributed according to the current
    ///     \l{formAlignment}{form alignment}.
    /// 
    ///     \sa formAlignment, rowWrapPolicy
    set_field_growth_policy(policy: FormLayout::FieldGrowthPolicy),
    field_growth_policy() -> FormLayout::FieldGrowthPolicy,
    ///     \property QFormLayout::rowWrapPolicy
    ///     \brief the way in which the form's rows wrap
    /// 
    ///     The default value depends on the widget or application style. For
    ///     Qt Extended styles, the default is WrapLongRows;
    ///     for the other styles, the default is DontWrapRows.
    /// 
    ///     If you want to display each label above its associated field
    ///     (instead of next to it), set this property to WrapAllRows.
    /// 
    ///     \sa fieldGrowthPolicy
    set_row_wrap_policy(policy: FormLayout::RowWrapPolicy),
    row_wrap_policy() -> FormLayout::RowWrapPolicy,
    ///     \property QFormLayout::labelAlignment
    ///     \brief the horizontal alignment of the labels
    /// 
    ///     The default value depends on the widget or application style. For
    ///     QCommonStyle derived styles, except for QPlastiqueStyle, the
    ///     default is Qt::AlignLeft; for the other styles, the default is
    ///     Qt::AlignRight.
    /// 
    ///     \sa formAlignment
    set_label_alignment(alignment: Rute::Alignment),
    label_alignment() -> Rute::Alignment,
    ///     \property QFormLayout::formAlignment
    ///     \brief the alignment of the form layout's contents within the layout's geometry
    /// 
    ///     The default value depends on the widget or application style. For
    ///     QMacStyle, the default is Qt::AlignHCenter | Qt::AlignTop; for the
    ///     other styles, the default is Qt::AlignLeft | Qt::AlignTop.
    /// 
    ///     \sa labelAlignment, rowWrapPolicy
    set_form_alignment(alignment: Rute::Alignment),
    form_alignment() -> Rute::Alignment,
    ///     \property QFormLayout::horizontalSpacing
    ///     \brief the spacing between widgets that are laid out side by side
    /// 
    ///     By default, if no value is explicitly set, the layout's horizontal
    ///     spacing is inherited from the parent layout, or from the style settings
    ///     for the parent widget.
    /// 
    ///     \sa verticalSpacing, QStyle::pixelMetric(), {QStyle::}{PM_LayoutHorizontalSpacing}
    set_horizontal_spacing(spacing: i32),
    horizontal_spacing() -> i32,
    ///     \property QFormLayout::verticalSpacing
    ///     \brief the spacing between widgets that are laid out vertically
    /// 
    ///     By default, if no value is explicitly set, the layout's vertical spacing is
    ///     inherited from the parent layout, or from the style settings for the parent
    ///     widget.
    /// 
    ///     \sa horizontalSpacing, QStyle::pixelMetric(), {QStyle::}{PM_LayoutHorizontalSpacing}
    set_vertical_spacing(spacing: i32),
    vertical_spacing() -> i32,
    ///     If the vertical spacing is equal to the horizontal spacing,
    ///     this function returns that value; otherwise it returns -1.
    /// 
    ///     \sa setSpacing(), verticalSpacing(), horizontalSpacing()
    spacing() -> i32,
    ///     This function sets both the vertical and horizontal spacing to
    ///     \a spacing.
    /// 
    ///     \sa setVerticalSpacing(), setHorizontalSpacing()
    set_spacing(arg0: i32),
    ///     \overload
    /// 
    ///     Adds the specified \a layout at the end of this form layout. The
    ///     \a layout spans both columns.
    add_row(label: *WidgetType, field: *WidgetType),
    ///     \overload
    /// 
    ///     Adds the specified \a layout at the end of this form layout. The
    ///     \a layout spans both columns.
    add_row(label: *WidgetType, field: *LayoutType),
    ///     \overload
    /// 
    ///     Adds the specified \a layout at the end of this form layout. The
    ///     \a layout spans both columns.
    add_row(label_text: String, field: *WidgetType),
    ///     \overload
    /// 
    ///     Adds the specified \a layout at the end of this form layout. The
    ///     \a layout spans both columns.
    add_row(label_text: String, field: *LayoutType),
    ///     \overload
    /// 
    ///     Adds the specified \a layout at the end of this form layout. The
    ///     \a layout spans both columns.
    add_row(widget: *WidgetType),
    ///     \overload
    /// 
    ///     Adds the specified \a layout at the end of this form layout. The
    ///     \a layout spans both columns.
    add_row(layout: *LayoutType),
    ///     \overload
    /// 
    ///     Inserts the specified \a layout at position \a row in this form
    ///     layout. The \a layout spans both columns. If \a row is out of
    ///     bounds, the widget is added at the end.
    insert_row(row: i32, label: *WidgetType, field: *WidgetType),
    ///     \overload
    /// 
    ///     Inserts the specified \a layout at position \a row in this form
    ///     layout. The \a layout spans both columns. If \a row is out of
    ///     bounds, the widget is added at the end.
    insert_row(row: i32, label: *WidgetType, field: *LayoutType),
    ///     \overload
    /// 
    ///     Inserts the specified \a layout at position \a row in this form
    ///     layout. The \a layout spans both columns. If \a row is out of
    ///     bounds, the widget is added at the end.
    insert_row(row: i32, label_text: String, field: *WidgetType),
    ///     \overload
    /// 
    ///     Inserts the specified \a layout at position \a row in this form
    ///     layout. The \a layout spans both columns. If \a row is out of
    ///     bounds, the widget is added at the end.
    insert_row(row: i32, label_text: String, field: *LayoutType),
    ///     \overload
    /// 
    ///     Inserts the specified \a layout at position \a row in this form
    ///     layout. The \a layout spans both columns. If \a row is out of
    ///     bounds, the widget is added at the end.
    insert_row(row: i32, widget: *WidgetType),
    ///     \overload
    /// 
    ///     Inserts the specified \a layout at position \a row in this form
    ///     layout. The \a layout spans both columns. If \a row is out of
    ///     bounds, the widget is added at the end.
    insert_row(row: i32, layout: *LayoutType),
    ///     \since 5.8
    /// 
    ///     \overload
    /// 
    ///     Deletes the row corresponding to \a layout from this form layout.
    /// 
    ///     After this call, rowCount() is decremented by one. All widgets and
    ///     nested layouts that occupied this row are deleted. That includes both
    ///     the field widget(s) and the label, if any. All following rows are shifted
    ///     up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    ///     You can use this function to undo a previous addRow() or insertRow():
    ///     \code
    ///     QFormLayout *flay = ...;
    ///     QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    ///     flay->insertRow(2, "User:", vbl);
    ///     // later:
    ///     flay->removeRow(layout); // vbl == nullptr at this point
    ///     \endcode
    /// 
    ///     If you want to remove the row from the form layout without deleting the inserted layout,
    ///     use takeRow() instead.
    /// 
    ///     \sa takeRow()
    remove_row(row: i32),
    ///     \since 5.8
    /// 
    ///     \overload
    /// 
    ///     Deletes the row corresponding to \a layout from this form layout.
    /// 
    ///     After this call, rowCount() is decremented by one. All widgets and
    ///     nested layouts that occupied this row are deleted. That includes both
    ///     the field widget(s) and the label, if any. All following rows are shifted
    ///     up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    ///     You can use this function to undo a previous addRow() or insertRow():
    ///     \code
    ///     QFormLayout *flay = ...;
    ///     QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    ///     flay->insertRow(2, "User:", vbl);
    ///     // later:
    ///     flay->removeRow(layout); // vbl == nullptr at this point
    ///     \endcode
    /// 
    ///     If you want to remove the row from the form layout without deleting the inserted layout,
    ///     use takeRow() instead.
    /// 
    ///     \sa takeRow()
    remove_row(widget: *WidgetType),
    ///     \since 5.8
    /// 
    ///     \overload
    /// 
    ///     Deletes the row corresponding to \a layout from this form layout.
    /// 
    ///     After this call, rowCount() is decremented by one. All widgets and
    ///     nested layouts that occupied this row are deleted. That includes both
    ///     the field widget(s) and the label, if any. All following rows are shifted
    ///     up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    ///     You can use this function to undo a previous addRow() or insertRow():
    ///     \code
    ///     QFormLayout *flay = ...;
    ///     QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    ///     flay->insertRow(2, "User:", vbl);
    ///     // later:
    ///     flay->removeRow(layout); // vbl == nullptr at this point
    ///     \endcode
    /// 
    ///     If you want to remove the row from the form layout without deleting the inserted layout,
    ///     use takeRow() instead.
    /// 
    ///     \sa takeRow()
    remove_row(layout: *LayoutType),
    ///     \since 5.8
    /// 
    ///     \overload
    /// 
    ///     Removes the specified \a layout from this form layout.
    /// 
    ///     \note This function doesn't delete anything.
    /// 
    ///     After this call, rowCount() is decremented by one. All following rows are shifted
    ///     up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    ///     \code
    ///     QFormLayout *flay = ...;
    ///     QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    ///     flay->insertRow(2, "User:", vbl);
    ///     // later:
    ///     QFormLayout::TakeRowResult result = flay->takeRow(widget);
    ///     \endcode
    /// 
    ///     If you want to remove the row from the form layout and delete the inserted layout,
    ///     use removeRow() instead.
    /// 
    ///     \return A structure containing both the widget and
    ///     corresponding label layout items
    /// 
    ///     \sa removeRow()
    take_row(row: i32) -> FormLayout::TakeRowResult,
    ///     \since 5.8
    /// 
    ///     \overload
    /// 
    ///     Removes the specified \a layout from this form layout.
    /// 
    ///     \note This function doesn't delete anything.
    /// 
    ///     After this call, rowCount() is decremented by one. All following rows are shifted
    ///     up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    ///     \code
    ///     QFormLayout *flay = ...;
    ///     QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    ///     flay->insertRow(2, "User:", vbl);
    ///     // later:
    ///     QFormLayout::TakeRowResult result = flay->takeRow(widget);
    ///     \endcode
    /// 
    ///     If you want to remove the row from the form layout and delete the inserted layout,
    ///     use removeRow() instead.
    /// 
    ///     \return A structure containing both the widget and
    ///     corresponding label layout items
    /// 
    ///     \sa removeRow()
    take_row(widget: *WidgetType) -> FormLayout::TakeRowResult,
    ///     \since 5.8
    /// 
    ///     \overload
    /// 
    ///     Removes the specified \a layout from this form layout.
    /// 
    ///     \note This function doesn't delete anything.
    /// 
    ///     After this call, rowCount() is decremented by one. All following rows are shifted
    ///     up one row and the freed vertical space is redistributed amongst the remaining rows.
    /// 
    ///     \code
    ///     QFormLayout *flay = ...;
    ///     QPointer<QVBoxLayout> vbl = new QVBoxLayout;
    ///     flay->insertRow(2, "User:", vbl);
    ///     // later:
    ///     QFormLayout::TakeRowResult result = flay->takeRow(widget);
    ///     \endcode
    /// 
    ///     If you want to remove the row from the form layout and delete the inserted layout,
    ///     use removeRow() instead.
    /// 
    ///     \return A structure containing both the widget and
    ///     corresponding label layout items
    /// 
    ///     \sa removeRow()
    take_row(layout: *LayoutType) -> FormLayout::TakeRowResult,
    ///     Sets the item in the given \a row for the given \a role to \a item, extending the
    ///     layout with empty rows if necessary.
    /// 
    ///     If the cell is already occupied, the \a item is not inserted and an error message is
    ///     sent to the console.
    ///     The \a item spans both columns.
    /// 
    ///     \warning Do not use this function to add child layouts or child
    ///     widget items. Use setLayout() or setWidget() instead.
    /// 
    ///     \sa setLayout()
    set_item(row: i32, role: FormLayout::ItemRole, item: *LayoutItemType),
    ///     Sets the widget in the given \a row for the given \a role to \a widget, extending the
    ///     layout with empty rows if necessary.
    /// 
    ///     If the cell is already occupied, the \a widget is not inserted and an error message is
    ///     sent to the console.
    /// 
    ///     \b{Note:} For most applications, addRow() or insertRow() should be used instead of setWidget().
    /// 
    ///     \sa setLayout()
    set_widget(row: i32, role: FormLayout::ItemRole, widget: *WidgetType),
    ///     Sets the sub-layout in the given \a row for the given \a role to \a layout, extending the
    ///     form layout with empty rows if necessary.
    /// 
    ///     If the cell is already occupied, the \a layout is not inserted and an error message is
    ///     sent to the console.
    /// 
    ///     \b{Note:} For most applications, addRow() or insertRow() should be used instead of setLayout().
    /// 
    ///     \sa setWidget()
    set_layout(row: i32, role: FormLayout::ItemRole, layout: *LayoutType),
    ///     Returns the layout item in the given \a row with the specified \a
    ///     role (column). Returns 0 if there is no such item.
    /// 
    ///     \sa QLayout::itemAt(), setItem()
    item_at(row: i32, role: FormLayout::ItemRole) -> LayoutItem?,
    ///     Retrieves the row and role (column) of the item at the specified
    ///     \a index. If \a index is out of bounds, *\a rowPtr is set to -1;
    ///     otherwise the row is stored in *\a rowPtr and the role is stored
    ///     in *\a rolePtr.
    /// 
    ///     \sa itemAt(), count(), getLayoutPosition(), getWidgetPosition()
    get_item_position(index: i32, row_ptr: *i32, role_ptr: FormLayout::ItemRole *),
    ///     Retrieves the row and role (column) of the specified \a widget in
    ///     the layout. If \a widget is not in the layout, *\a rowPtr is set
    ///     to -1; otherwise the row is stored in *\a rowPtr and the role is stored
    ///     in *\a rolePtr.
    /// 
    ///     \sa getItemPosition(), itemAt()
    get_widget_position(widget: *WidgetType, row_ptr: *i32, role_ptr: FormLayout::ItemRole *),
    ///     Retrieves the row and role (column) of the specified child \a
    ///     layout. If \a layout is not in the form layout, *\a rowPtr is set
    ///     to -1; otherwise the row is stored in *\a rowPtr and the role is stored
    ///     in *\a rolePtr.
    get_layout_position(layout: *LayoutType, row_ptr: *i32, role_ptr: FormLayout::ItemRole *),
    ///     \overload
    label_for_field(field: *WidgetType) -> Widget?,
    ///     \overload
    label_for_field(field: *LayoutType) -> Widget?,
    ///     \reimp
    [event] add_item(item: *LayoutItemType),
    ///     Returns the layout item in the given \a row with the specified \a
    ///     role (column). Returns 0 if there is no such item.
    /// 
    ///     \sa QLayout::itemAt(), setItem()
    [event] item_at(index: i32) -> LayoutItem?,
    ///     \reimp
    [event] take_at(index: i32) -> LayoutItem?,
    ///     \reimp
    [event] minimum_size() -> Size,
    ///     \reimp
    [event] size_hint() -> Size,
    ///     \reimp
    [event] invalidate(),
    ///     \reimp
    [event] has_height_for_width() -> bool,
    ///     \reimp
    [event] height_for_width(width: i32) -> i32,
    ///     \reimp
    [event] expanding_directions() -> Rute::Orientations,
    ///     \reimp
    [event] count() -> i32,
    ///     Returns the number of rows in the form.
    /// 
    ///     \sa QLayout::count()
    row_count() -> i32,
}

// vim: syntax=rust expandtab ts=4 sw=4
