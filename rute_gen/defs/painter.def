/// 
/// QPainter provides highly optimized functions to do most of the
/// drawing GUI programs require. It can draw everything from simple
/// lines to complex shapes like pies and chords. It can also draw
/// aligned text and pixmaps. Normally, it draws in a
/// coordinate system, but it can also do view and world
/// transformation. QPainter can operate on any object that inherits
/// the QPaintDevice class.
/// 
/// The common use of QPainter is inside a widget's paint event:
/// Construct and customize (e.g. set the pen or the brush) the
/// painter. Then draw. Remember to destroy the QPainter object after
/// drawing. For example:
/// 
/// The core functionality of QPainter is drawing, but the class also
/// provide several functions that allows you to customize QPainter's
/// settings and its rendering quality, and others that enable
/// clipping. In addition you can control how different shapes are
/// merged together by specifying the painter's composition mode.
/// 
/// The isActive() function indicates whether the painter is active. A
/// painter is activated by the begin() function and the constructor
/// that takes a QPaintDevice argument. The end() function, and the
/// destructor, deactivates it.
/// 
/// Together with the QPaintDevice and QPaintEngine classes, QPainter
/// form the basis for Qt's paint system. QPainter is the class used
/// to perform drawing operations. QPaintDevice represents a device
/// that can be painted on using a QPainter. QPaintEngine provides the
/// interface that the painter uses to draw onto different types of
/// devices. If the painter is active, device() returns the paint
/// device on which the painter paints, and paintEngine() returns the
/// paint engine that the painter is currently operating on. For more
/// information, see the [Paint System](Paint%20System)
/// 
/// 
/// Sometimes it is desirable to make someone else paint on an unusual
/// QPaintDevice. QPainter supports a static function to do this,
/// setRedirected().
/// 
/// **Warning**: When the paintdevice is a widget, QPainter can only be
/// used inside a paintEvent() function or in a function called by
/// paintEvent().
/// 
/// # Settings
/// 
/// There are several settings that you can customize to make QPainter
/// draw according to your preferences:
/// 
/// * font() is the font used for drawing text. If the painter isActive(), you can retrieve information about the currently set font, and its metrics, using the fontInfo() and fontMetrics() functions respectively.
/// * brush() defines the color or pattern that is used for filling shapes.
/// * pen() defines the color or stipple that is used for drawing lines or boundaries.
/// * backgroundMode() defines whether there is a background() or not, i.e it is either Qt::OpaqueMode or Qt::TransparentMode.
/// * background() only applies when backgroundMode() is [Qt::OpaqueMode](Qt::OpaqueMode)
/// and pen() is a stipple. In that case, it describes the color of the background pixels in the stipple.
/// * brushOrigin() defines the origin of the tiled brushes, normally the origin of widget's background.
/// * viewport(), window(), worldTransform() make up the painter's coordinate transformation system. For more information, see the [Coordinate Transformations](Coordinate%20Transformations)
/// section and the [Coordinate
/// System](Coordinate%0A%20%20%20%20%20%20%20%20System)
/// documentation.
/// * hasClipping() tells whether the painter clips at all. (The paint device clips, too.) If the painter clips, it clips to clipRegion().
/// * layoutDirection() defines the layout direction used by the painter when drawing text.
/// * worldMatrixEnabled() tells whether world transformation is enabled.
/// * viewTransformEnabled() tells whether view transformation is enabled.
/// 
/// Note that some of these settings mirror settings in some paint
/// devices, e.g. QWidget::font(). The QPainter::begin() function (or
/// equivalently the QPainter constructor) copies these attributes
/// from the paint device.
/// 
/// You can at any time save the QPainter's state by calling the
/// save() function which saves all the available settings on an
/// internal stack. The restore() function pops them back.
/// 
/// # Drawing
/// 
/// QPainter provides functions to draw most primitives: drawPoint(),
/// drawPoints(), drawLine(), drawRect(), drawRoundedRect(),
/// drawEllipse(), drawArc(), drawPie(), drawChord(), drawPolyline(),
/// drawPolygon(), drawConvexPolygon() and drawCubicBezier(). The two
/// convenience functions, drawRects() and drawLines(), draw the given
/// number of rectangles or lines in the given array of [QRects](QRect)
/// or [QLines](QLine)
/// using the current pen and
/// brush.
/// 
/// The QPainter class also provides the fillRect() function which
/// fills the given QRect, with the given QBrush, and the eraseRect()
/// function that erases the area inside the given rectangle.
/// 
/// All of these functions have both integer and floating point
/// versions.
/// 
/// * ![qpainter-basicdrawing.png](qpainter-basicdrawing.png)
/// 
/// * **Basic Drawing Example** The [Basic Drawing](painting/basicdrawing)
/// example shows how to display basic graphics primitives in a variety of styles using the QPainter class.
/// 
/// If you need to draw a complex shape, especially if you need to do
/// so repeatedly, consider creating a QPainterPath and drawing it
/// using drawPath().
/// 
/// * **Painter Paths example** The QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused. The [Painter Paths](painting/painterpaths)
/// example shows how painter paths can be used to build complex shapes for rendering.
/// * ![qpainter-painterpaths.png](qpainter-painterpaths.png)
/// 
/// QPainter also provides the fillPath() function which fills the
/// given QPainterPath with the given QBrush, and the strokePath()
/// function that draws the outline of the given path (i.e. strokes
/// the path).
/// 
/// See also the [Vector Deformation](painting/deform)
/// example which
/// shows how to use advanced vector techniques to draw text using a
/// QPainterPath, the [Gradients](painting/gradients)
/// example which shows
/// the different types of gradients that are available in Qt, and the [Path Stroking](painting/pathstroke)
/// example which shows Qt's built-in
/// dash patterns and shows how custom patterns can be used to extend
/// the range of available patterns.
/// 
/// * [Vector Deformation](painting/deform)
/// 
/// * [Gradients](painting/gradients)
/// 
/// * [Path Stroking](painting/pathstroke)
/// 
/// * ![qpainter-vectordeformation.png](qpainter-vectordeformation.png)
/// 
/// * ![qpainter-gradients.png](qpainter-gradients.png)
/// 
/// * ![qpainter-pathstroking.png](qpainter-pathstroking.png)
/// 
/// Text drawing is done using drawText(). When you need
/// fine-grained positioning, boundingRect() tells you where a given
/// drawText() command will draw.
/// 
/// # Drawing Pixmaps and Images
/// 
/// There are functions to draw pixmaps/images, namely drawPixmap(),
/// drawImage() and drawTiledPixmap(). Both drawPixmap() and drawImage()
/// produce the same result, except that drawPixmap() is faster
/// on-screen while drawImage() may be faster on a QPrinter or other
/// devices.
/// 
/// There is a drawPicture() function that draws the contents of an
/// entire QPicture. The drawPicture() function is the only function
/// that disregards all the painter's settings as QPicture has its own
/// settings.
/// 
/// ## Drawing High Resolution Versions of Pixmaps and Images
/// 
/// High resolution versions of pixmaps have a *device pixel ratio* value larger
/// than 1 (see QImageReader, QPixmap::devicePixelRatio()). Should it match the value
/// of the underlying QPaintDevice, it is drawn directly onto the device with no
/// additional transformation applied.
/// 
/// This is for example the case when drawing a QPixmap of 64x64 pixels size with
/// a device pixel ratio of 2 onto a high DPI screen which also has
/// a device pixel ratio of 2. Note that the pixmap is then effectively 32x32
/// pixels in *user space* . Code paths in Qt that calculate layout geometry
/// based on the pixmap size will use this size. The net effect of this is that
/// the pixmap is displayed as high DPI pixmap rather than a large pixmap.
/// 
/// # Rendering Quality
/// 
/// To get the optimal rendering result using QPainter, you should use
/// the platform independent QImage as paint device; i.e. using QImage
/// will ensure that the result has an identical pixel representation
/// on any platform.
/// 
/// The QPainter class also provides a means of controlling the
/// rendering quality through its RenderHint enum and the support for
/// floating point precision: All the functions for drawing primitives
/// has a floating point version. These are often used in combination
/// with the [QPainter::Antialiasing](RenderHint)
/// render hint.
/// 
/// * ![qpainter-concentriccircles.png](qpainter-concentriccircles.png)
/// 
/// * **Concentric Circles Example** The [Concentric Circles](painting/concentriccircles)
/// example shows the improved rendering quality that can be obtained using floating point precision and anti-aliasing when drawing custom widgets. The application's main window displays several widgets which are drawn using the various combinations of precision and anti-aliasing.
/// 
/// The RenderHint enum specifies flags to QPainter that may or may
/// not be respected by any given engine. [QPainter::Antialiasing](RenderHint)
/// indicates that the engine
/// should antialias edges of primitives if possible, [QPainter::TextAntialiasing](RenderHint)
/// indicates that the engine
/// should antialias text if possible, and the [QPainter::SmoothPixmapTransform](RenderHint)
/// indicates that the
/// engine should use a smooth pixmap transformation algorithm.
/// 
/// The renderHints() function returns a flag that specifies the
/// rendering hints that are set for this painter. Use the
/// setRenderHint() function to set or clear the currently set
/// RenderHints.
/// 
/// # Coordinate Transformations
/// 
/// Normally, the QPainter operates on the device's own coordinate
/// system (usually pixels), but QPainter has good support for
/// coordinate transformations.
/// 
/// * nop
/// * rotate()
/// * scale()
/// * translate()
/// 
/// * ![qpainter-clock.png](qpainter-clock.png)
/// 
/// * ![qpainter-rotation.png](qpainter-rotation.png)
/// 
/// * ![qpainter-scale.png](qpainter-scale.png)
/// 
/// * ![qpainter-translation.png](qpainter-translation.png)
/// 
/// The most commonly used transformations are scaling, rotation,
/// translation and shearing. Use the scale() function to scale the
/// coordinate system by a given offset, the rotate() function to
/// rotate it clockwise and translate() to translate it (i.e. adding a
/// given offset to the points). You can also twist the coordinate
/// system around the origin using the shear() function. See the [Affine Transformations](painting/affine)
/// example for a visualization of
/// a sheared coordinate system.
/// 
/// See also the [Transformations](painting/transformations)
/// 
/// example which shows how transformations influence the way that
/// QPainter renders graphics primitives. In particular it shows how
/// the order of transformations affects the result.
/// 
/// * **Affine Transformations Example** The [Affine Transformations](painting/affine)
/// example shows Qt's ability to perform affine transformations on painting operations. The demo also allows the user to experiment with the transformation operations and see the results immediately.
/// * ![qpainter-affinetransformations.png](qpainter-affinetransformations.png)
/// 
/// All the tranformation operations operate on the transformation
/// worldTransform(). A matrix transforms a point in the plane to another
/// point. For more information about the transformation matrix, see
/// the [Coordinate System](Coordinate%20System)
/// and QTransform documentation.
/// 
/// The setWorldTransform() function can replace or add to the currently
/// set worldTransform(). The resetTransform() function resets any
/// transformations that were made using translate(), scale(),
/// shear(), rotate(), setWorldTransform(), setViewport() and setWindow()
/// functions. The deviceTransform() returns the matrix that transforms
/// from logical coordinates to device coordinates of the platform
/// dependent paint device. The latter function is only needed when
/// using platform painting commands on the platform dependent handle,
/// and the platform does not do transformations nativly.
/// 
/// When drawing with QPainter, we specify points using logical
/// coordinates which then are converted into the physical coordinates
/// of the paint device. The mapping of the logical coordinates to the
/// physical coordinates are handled by QPainter's combinedTransform(), a
/// combination of viewport() and window() and worldTransform(). The
/// viewport() represents the physical coordinates specifying an
/// arbitrary rectangle, the window() describes the same rectangle in
/// logical coordinates, and the worldTransform() is identical with the
/// transformation matrix.
/// 
/// See also [Coordinate System](Coordinate%20System)
/// # Clipping
/// 
/// QPainter can clip any drawing operation to a rectangle, a region,
/// or a vector path. The current clip is available using the
/// functions clipRegion() and clipPath(). Whether paths or regions are
/// preferred (faster) depends on the underlying paintEngine(). For
/// example, the QImage paint engine prefers paths while the X11 paint
/// engine prefers regions. Setting a clip is done in the painters
/// logical coordinates.
/// 
/// After QPainter's clipping, the paint device may also clip. For
/// example, most widgets clip away the pixels used by child widgets,
/// and most printers clip away an area near the edges of the paper.
/// This additional clipping is not reflected by the return value of
/// clipRegion() or hasClipping().
/// 
/// # Composition Modes
/// 
/// QPainter provides the CompositionMode enum which defines the
/// Porter-Duff rules for digital image compositing; it describes a
/// model for combining the pixels in one image, the source, with the
/// pixels in another image, the destination.
/// 
/// The two most common forms of composition are [Source](QPainter::CompositionMode)
/// and [SourceOver](QPainter::CompositionMode)
/// . [Source](QPainter::CompositionMode)
/// is used to draw opaque objects
/// onto a paint device. In this mode, each pixel in the source
/// replaces the corresponding pixel in the destination. In [SourceOver](QPainter::CompositionMode)
/// composition mode, the
/// source object is transparent and is drawn on top of the
/// destination.
/// 
/// Note that composition transformation operates pixelwise. For that
/// reason, there is a difference between using the graphic primitive
/// itself and its bounding rectangle: The bounding rect contains
/// pixels with alpha == 0 (i.e the pixels surrounding the
/// primitive). These pixels will overwrite the other image's pixels,
/// affectively clearing those, while the primitive only overwrites
/// its own area.
/// 
/// * ![qpainter-compositiondemo.png](qpainter-compositiondemo.png)
/// 
/// * **Composition Modes Example** The [Composition Modes](painting/composition)
/// example, available in Qt's examples directory, allows you to experiment with the various composition modes and see the results immediately.
/// 
/// # Limitations
/// 
/// If you are using coordinates with Qt's raster-based paint engine, it is
/// important to note that, while coordinates greater than +/- 2 ^15 can
/// be used, any painting performed with coordinates outside this range is not
/// guaranteed to be shown; the drawing may be clipped. This is due to the
/// use of `short int` in the implementation.
/// 
/// The outlines generated by Qt's stroker are only an approximation when dealing
/// with curved shapes. It is in most cases impossible to represent the outline of
/// a bezier curve segment using another bezier curve segment, and so Qt approximates
/// the curve outlines by using several smaller curves. For performance reasons there
/// is a limit to how many curves Qt uses for these outlines, and thus when using
/// large pen widths or scales the outline error increases. To generate outlines with
/// smaller errors it is possible to use the QPainterPathStroker class, which has the
/// setCurveThreshold member function which let's the user specify the error tolerance.
/// Another workaround is to convert the paths to polygons first and then draw the
/// polygons instead.
/// 
/// # Performance
/// 
/// QPainter is a rich framework that allows developers to do a great
/// variety of graphical operations, such as gradients, composition
/// modes and vector graphics. And QPainter can do this across a
/// variety of different hardware and software stacks. Naturally the
/// underlying combination of hardware and software has some
/// implications for performance, and ensuring that every single
/// operation is fast in combination with all the various combinations
/// of composition modes, brushes, clipping, transformation, etc, is
/// close to an impossible task because of the number of
/// permutations. As a compromise we have selected a subset of the
/// QPainter API and backends, where performance is guaranteed to be as
/// good as we can sensibly get it for the given combination of
/// hardware and software.
/// 
/// The backends we focus on as high-performance engines are:
/// 
/// * Raster - This backend implements all rendering in pure software and is always used to render into QImages. For optimal performance only use the format types QImage::Format_ARGB32_Premultiplied, QImage::Format_RGB32 or QImage::Format_RGB16. Any other format, including QImage::Format_ARGB32, has significantly worse performance. This engine is used by default for QWidget and QPixmap.
/// * OpenGL 2.0 (ES) - This backend is the primary backend for hardware accelerated graphics. It can be run on desktop machines and embedded devices supporting the OpenGL 2.0 or OpenGL/ES 2.0 specification. This includes most graphics chips produced in the last couple of years. The engine can be enabled by using QPainter onto a QOpenGLWidget.
/// 
/// These operations are:
/// 
/// * Simple transformations, meaning translation and scaling, pluss 0, 90, 180, 270 degree rotations.
/// * `drawPixmap()` in combination with simple transformations and opacity with non-smooth transformation mode ( `QPainter::SmoothPixmapTransform` not enabled as a render hint).
/// * Rectangle fills with solid color, two-color linear gradients and simple transforms.
/// * Rectangular clipping with simple transformations and intersect clip.
/// * Composition Modes `QPainter::CompositionMode_Source` and QPainter::CompositionMode_SourceOver
/// * Rounded rectangle filling using solid color and two-color linear gradients fills.
/// * 3x3 patched pixmaps, via qDrawBorderPixmap.
/// 
/// This list gives an indication of which features to safely use in
/// an application where performance is critical. For certain setups,
/// other operations may be fast too, but before making extensive use
/// of them, it is recommended to benchmark and verify them on the
/// system where the software will run in the end. There are also
/// cases where expensive operations are ok to use, for instance when
/// the result is cached in a QPixmap.
/// 
/// **See also:** QPaintDevice
/// QPaintEngine
/// {Qt SVG}
/// {Basic Drawing Example}
/// {Drawing Utility Functions}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[org_name(QPainter)]
enum RenderHint {
    Antialiasing,
    TextAntialiasing,
    SmoothPixmapTransform,
    HighQualityAntialiasing,
    NonCosmeticDefaultPen,
    Qt4CompatiblePainting,
}

[org_name(QPainter)]
enum PixmapFragmentHint {
    OpaqueHint,
}

[org_name(QPainter)]
enum CompositionMode {
    CompositionMode_SourceOver,
    CompositionMode_DestinationOver,
    CompositionMode_Clear,
    CompositionMode_Source,
    CompositionMode_Destination,
    CompositionMode_SourceIn,
    CompositionMode_DestinationIn,
    CompositionMode_SourceOut,
    CompositionMode_DestinationOut,
    CompositionMode_SourceAtop,
    CompositionMode_DestinationAtop,
    CompositionMode_Xor,
    CompositionMode_Plus,
    CompositionMode_Multiply,
    CompositionMode_Screen,
    CompositionMode_Overlay,
    CompositionMode_Darken,
    CompositionMode_Lighten,
    CompositionMode_ColorDodge,
    CompositionMode_ColorBurn,
    CompositionMode_HardLight,
    CompositionMode_SoftLight,
    CompositionMode_Difference,
    CompositionMode_Exclusion,
    RasterOp_SourceOrDestination,
    RasterOp_SourceAndDestination,
    RasterOp_SourceXorDestination,
    RasterOp_NotSourceAndNotDestination,
    RasterOp_NotSourceOrNotDestination,
    RasterOp_NotSourceXorDestination,
    RasterOp_NotSource,
    RasterOp_NotSourceAndDestination,
    RasterOp_SourceAndNotDestination,
    RasterOp_NotSourceOrDestination,
    RasterOp_SourceOrNotDestination,
    RasterOp_ClearDestination,
    RasterOp_SetDestination,
    RasterOp_NotDestination,
}


struct Painter {
    qt_check_for_qgadget_macro(),
    /// 
    /// Returns the paint device on which this painter is currently
    /// painting, or 0 if the painter is not active.
    /// 
    /// **See also:** isActive()
    device() -> PaintDevice?,
    /// 
    /// Begins painting the paint *device* and returns `true` if
    /// successful; otherwise returns `false.`
    /// 
    /// Notice that all painter settings (setPen(), setBrush() etc.) are reset
    /// to default values when begin() is called.
    /// 
    /// The errors that can occur are serious problems, such as these:
    /// 
    /// Note that most of the time, you can use one of the constructors
    /// instead of begin(), and that end() is automatically done at
    /// destruction.
    /// 
    /// **Warning**: A paint device can only be painted by one painter at a
    /// time.
    /// 
    /// **Warning**: Painting on a QImage with the format
    /// QImage::Format_Indexed8 is not supported.
    /// 
    /// **See also:** end()
    /// QPainter()
    /// 
    /// Flushes the painting pipeline and prepares for the user issuing commands
    /// directly to the underlying graphics context. Must be followed by a call to
    /// endNativePainting().
    /// 
    /// Note that only the states the underlying paint engine changes will be reset
    /// to their respective default states. The states we reset may change from
    /// release to release. The following states are currently reset in the OpenGL
    /// 2 engine:
    /// 
    /// * blending is disabled
    /// * the depth, stencil and scissor tests are disabled
    /// * the active texture unit is reset to 0
    /// * the depth mask, depth function and the clear depth are reset to their default values
    /// * the stencil mask, stencil operation and stencil function are reset to their default values
    /// * the current color is reset to solid white
    /// 
    /// If, for example, the OpenGL polygon mode is changed by the user inside a
    /// beginNativePaint()/endNativePainting() block, it will not be reset to the
    /// default state by endNativePainting(). Here is an example that shows
    /// intermixing of painter commands and raw OpenGL commands:
    /// 
    /// **See also:** endNativePainting()
    begin(arg0: *PaintDeviceType) -> bool,
    /// 
    /// Ends painting. Any resources used while painting are released. You
    /// don't normally need to call this since it is called by the
    /// destructor.
    /// 
    /// Returns `true` if the painter is no longer active; otherwise returns `false.`
    /// 
    /// **See also:** begin()
    /// isActive()
    /// 
    /// Restores the painter after manually issuing native painting commands. Lets
    /// the painter restore any native state that it relies on before calling any
    /// other painter commands.
    /// 
    /// **See also:** beginNativePainting()
    end() -> bool,
    /// 
    /// Returns `true` if begin() has been called and end() has not yet been
    /// called; otherwise returns `false.`
    /// 
    /// **See also:** begin()
    /// QPaintDevice::paintingActive()
    is_active() -> bool,
    /// 
    /// Initializes the painters pen, background and font to the same as
    /// the given *device.*
    /// 
    /// **See also:** begin()
    /// {QPainter#Settings}{Settings}
    init_from(device: *PaintDeviceType),
    /// 
    /// Sets the composition mode to the given *mode.*
    /// 
    /// **Warning**: Only a QPainter operating on a QImage fully supports all
    /// composition modes. The RasterOp modes are supported for X11 as
    /// described in compositionMode().
    /// 
    /// **See also:** compositionMode()
    set_composition_mode(mode: Painter::CompositionMode),
    /// 
    /// Returns the current composition mode.
    /// 
    /// **See also:** CompositionMode
    /// setCompositionMode()
    composition_mode() -> Painter::CompositionMode,
    /// 
    /// Returns the font metrics for the painter if the painter is
    /// active. Otherwise, the return value is undefined.
    /// 
    /// **See also:** font()
    /// isActive()
    /// {QPainter#Settings}{Settings}
    /// 
    /// Returns the font info for the painter if the painter is
    /// active. Otherwise, the return value is undefined.
    /// 
    /// **See also:** font()
    /// isActive()
    /// {QPainter#Settings}{Settings}
    /// 
    /// Returns the currently set font used for drawing text.
    /// 
    /// **See also:** setFont()
    /// drawText()
    /// {QPainter#Settings}{Settings}
    font() -> Font?,
    /// 
    /// Sets the painter's font to the given *font.*
    /// 
    /// This font is used by subsequent drawText() functions. The text
    /// color is the same as the pen color.
    /// 
    /// If you set a font that isn't available, Qt finds a close match.
    /// font() will return what you set using setFont() and fontInfo() returns the
    /// font actually being used (which may be the same).
    /// 
    /// **See also:** font()
    /// drawText()
    /// {QPainter#Settings}{Settings}
    set_font(f: &FontType),
    /// 
    /// Returns the font info for the painter if the painter is
    /// active. Otherwise, the return value is undefined.
    /// 
    /// **See also:** font()
    /// isActive()
    /// {QPainter#Settings}{Settings}
    font_info() -> FontInfo,
    /// 
    /// **Overloads**
    /// Sets the painter's pen to have style Qt::SolidLine, width 1 and the
    /// specified *color.*
    /// 
    /// Sets the painter's pen to be the given *pen.*
    /// 
    /// The *pen* defines how to draw lines and outlines, and it also
    /// defines the text color.
    /// 
    /// **See also:** pen()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the painter's pen to have the given *style,* width 1 and
    /// black color.
    set_pen(color: &ColorType),
    /// 
    /// **Overloads**
    /// Sets the painter's pen to have style Qt::SolidLine, width 1 and the
    /// specified *color.*
    /// 
    /// Sets the painter's pen to be the given *pen.*
    /// 
    /// The *pen* defines how to draw lines and outlines, and it also
    /// defines the text color.
    /// 
    /// **See also:** pen()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the painter's pen to have the given *style,* width 1 and
    /// black color.
    set_pen(pen: &PenType),
    /// 
    /// **Overloads**
    /// Sets the painter's pen to have style Qt::SolidLine, width 1 and the
    /// specified *color.*
    /// 
    /// Sets the painter's pen to be the given *pen.*
    /// 
    /// The *pen* defines how to draw lines and outlines, and it also
    /// defines the text color.
    /// 
    /// **See also:** pen()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the painter's pen to have the given *style,* width 1 and
    /// black color.
    set_pen(style: Rute::PenStyle),
    /// 
    /// Returns the painter's current pen.
    /// 
    /// **See also:** setPen()
    /// {QPainter#Settings}{Settings}
    pen() -> Pen?,
    /// 
    /// Sets the brush origin to *position.*
    /// 
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    /// 
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    /// 
    /// **See also:** brushOrigin()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    /// 
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    /// 
    /// Sets the painter's brush to the given *brush.*
    /// 
    /// The painter's brush defines how shapes are filled.
    /// 
    /// **See also:** brush()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the painter's brush to black color and the specified *style.*
    set_brush(brush: &BrushType),
    /// 
    /// Sets the brush origin to *position.*
    /// 
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    /// 
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    /// 
    /// **See also:** brushOrigin()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    /// 
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    /// 
    /// Sets the painter's brush to the given *brush.*
    /// 
    /// The painter's brush defines how shapes are filled.
    /// 
    /// **See also:** brush()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the painter's brush to black color and the specified *style.*
    set_brush(style: Rute::BrushStyle),
    /// 
    /// Returns the currently set brush origin.
    /// 
    /// **See also:** setBrushOrigin()
    /// {QPainter#Settings}{Settings}
    /// 
    /// Returns the painter's current brush.
    /// 
    /// **See also:** QPainter::setBrush()
    /// {QPainter#Settings}{Settings}
    brush() -> Brush?,
    /// 
    /// Sets the background mode of the painter to the given *mode*
    /// 
    /// Qt::TransparentMode (the default) draws stippled lines and text
    /// without setting the background pixels. Qt::OpaqueMode fills these
    /// space with the current background color.
    /// 
    /// Note that in order to draw a bitmap or pixmap transparently, you
    /// must use QPixmap::setMask().
    /// 
    /// **See also:** backgroundMode()
    /// setBackground()
    /// {QPainter#Settings}{Settings}
    set_background_mode(mode: Rute::BGMode),
    /// 
    /// Returns the current background mode.
    /// 
    /// **See also:** setBackgroundMode()
    /// {QPainter#Settings}{Settings}
    background_mode() -> Rute::BGMode,
    /// 
    /// Returns the currently set brush origin.
    /// 
    /// **See also:** setBrushOrigin()
    /// {QPainter#Settings}{Settings}
    brush_origin() -> Point,
    /// 
    /// Sets the brush origin to *position.*
    /// 
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    /// 
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    /// 
    /// **See also:** brushOrigin()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    /// 
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    set_brush_origin(x: i32, y: i32),
    /// 
    /// Sets the brush origin to *position.*
    /// 
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    /// 
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    /// 
    /// **See also:** brushOrigin()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    /// 
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    set_brush_origin(arg0: &PointType),
    /// 
    /// Sets the brush origin to *position.*
    /// 
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    /// 
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    /// 
    /// **See also:** brushOrigin()
    /// {QPainter#Settings}{Settings}
    /// 
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    /// 
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    set_brush_origin(arg0: &PointFType),
    /// 
    /// Sets the background mode of the painter to the given *mode*
    /// 
    /// Qt::TransparentMode (the default) draws stippled lines and text
    /// without setting the background pixels. Qt::OpaqueMode fills these
    /// space with the current background color.
    /// 
    /// Note that in order to draw a bitmap or pixmap transparently, you
    /// must use QPixmap::setMask().
    /// 
    /// **See also:** backgroundMode()
    /// setBackground()
    /// {QPainter#Settings}{Settings}
    /// 
    /// Sets the background brush of the painter to the given *brush.*
    /// 
    /// The background brush is the brush that is filled in when drawing
    /// opaque text, stippled lines and bitmaps. The background brush has
    /// no effect in transparent background mode (which is the default).
    /// 
    /// **See also:** background()
    /// setBackgroundMode()
    /// {QPainter#Settings}{Settings}
    set_background(bg: &BrushType),
    /// 
    /// Returns the current background brush.
    /// 
    /// **See also:** setBackground()
    /// {QPainter#Settings}{Settings}
    /// 
    /// Returns the current background mode.
    /// 
    /// **See also:** setBackgroundMode()
    /// {QPainter#Settings}{Settings}
    background() -> Brush?,
    /// 
    /// Returns the opacity of the painter. The default value is
    /// 1.
    opacity() -> f32,
    /// 
    /// Sets the opacity of the painter to *opacity.* The value should
    /// be in the range 0.0 to 1.0, where 0.0 is fully transparent and
    /// 1.0 is fully opaque.
    /// 
    /// Opacity set on the painter will apply to all drawing operations
    /// individually.
    set_opacity(opacity: f32),
    /// 
    /// Returns the currently set clip region. Note that the clip region
    /// is given in logical coordinates.
    /// 
    /// **Warning**: QPainter does not store the combined clip explicitly as
    /// this is handled by the underlying QPaintEngine, so the path is
    /// recreated on demand and transformed to the current logical
    /// coordinate system. This is potentially an expensive operation.
    /// 
    /// **See also:** setClipRegion()
    /// clipPath()
    /// setClipping()
    clip_region() -> Region,
    /// 
    /// Returns the current clip path in logical coordinates.
    /// 
    /// **Warning**: QPainter does not store the combined clip explicitly as
    /// this is handled by the underlying QPaintEngine, so the path is
    /// recreated on demand and transformed to the current logical
    /// coordinate system. This is potentially an expensive operation.
    /// 
    /// **See also:** setClipPath()
    /// clipRegion()
    /// setClipping()
    clip_path() -> PainterPath,
    /// 
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given clip *operation.* The default operation
    /// is to replace the current clip rectangle.
    /// 
    /// Note that the clip rectangle is specified in logical (painter)
    /// coordinates.
    /// 
    /// **See also:** clipRegion()
    /// setClipping()
    /// {QPainter#Clipping}{Clipping}
    /// 
    /// **Overloads**
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given
    /// clip *operation.*
    /// 
    /// Enables clipping, and sets the clip region to the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    set_clip_rect(arg0: &RectFType, op: Rute::ClipOperation),
    /// 
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given clip *operation.* The default operation
    /// is to replace the current clip rectangle.
    /// 
    /// Note that the clip rectangle is specified in logical (painter)
    /// coordinates.
    /// 
    /// **See also:** clipRegion()
    /// setClipping()
    /// {QPainter#Clipping}{Clipping}
    /// 
    /// **Overloads**
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given
    /// clip *operation.*
    /// 
    /// Enables clipping, and sets the clip region to the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    set_clip_rect(arg0: &RectType, op: Rute::ClipOperation),
    /// 
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given clip *operation.* The default operation
    /// is to replace the current clip rectangle.
    /// 
    /// Note that the clip rectangle is specified in logical (painter)
    /// coordinates.
    /// 
    /// **See also:** clipRegion()
    /// setClipping()
    /// {QPainter#Clipping}{Clipping}
    /// 
    /// **Overloads**
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given
    /// clip *operation.*
    /// 
    /// Enables clipping, and sets the clip region to the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    set_clip_rect(x: i32, y: i32, w: i32, h: i32, op: Rute::ClipOperation),
    /// 
    /// Sets the clip region to the given *region* using the specified clip
    /// *operation.* The default clip operation is to replace the current
    /// clip region.
    /// 
    /// Note that the clip region is given in logical coordinates.
    /// 
    /// **See also:** clipRegion()
    /// setClipRect()
    /// {QPainter#Clipping}{Clipping}
    set_clip_region(arg0: &RegionType, op: Rute::ClipOperation),
    /// 
    /// Enables clipping, and sets the clip path for the painter to the
    /// given *path,* with the clip *operation.*
    /// 
    /// Note that the clip path is specified in logical (painter)
    /// coordinates.
    /// 
    /// **See also:** clipPath()
    /// clipRegion()
    /// {QPainter#Clipping}{Clipping}
    /// 
    set_clip_path(path: &PainterPathType, op: Rute::ClipOperation),
    /// 
    /// Enables clipping if *enable* is true, or disables clipping if *enable* is false.
    /// 
    /// **See also:** hasClipping()
    /// {QPainter#Clipping}{Clipping}
    set_clipping(enable: bool),
    /// 
    /// Returns `true` if clipping has been set; otherwise returns `false.`
    /// 
    /// **See also:** setClipping()
    /// {QPainter#Clipping}{Clipping}
    has_clipping() -> bool,
    /// 
    /// Returns the bounding rectangle of the current clip if there is a clip;
    /// otherwise returns an empty rectangle. Note that the clip region is
    /// given in logical coordinates.
    /// 
    /// The bounding rectangle is not guaranteed to be tight.
    /// 
    /// **See also:** setClipRect()
    /// setClipPath()
    /// setClipRegion()
    /// 
    clip_bounding_rect() -> RectF,
    /// 
    /// Saves the current painter state (pushes the state onto a stack). A
    /// save() must be followed by a corresponding restore(); the end()
    /// function unwinds the stack.
    /// 
    /// **See also:** restore()
    save(),
    /// 
    /// Restores the current painter state (pops a saved state off the
    /// stack).
    /// 
    /// **See also:** save()
    /// 
    /// Using QWidget::render() obsoletes the use of this function.
    /// 
    /// Restores the previous redirection for the given *device* after a
    /// call to setRedirected().
    /// 
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    /// 
    /// **See also:** redirected()
    restore(),
    /// 
    /// Sets the world transformation matrix.
    /// If *combine* is true, the specified *transform* is combined with
    /// the current matrix; otherwise it replaces the current matrix.
    /// 
    /// **See also:** transform()
    /// setWorldTransform()
    set_transform(transform: &TransformType, combine: bool),
    device_transform() -> Transform?,
    /// 
    /// Returns the matrix that transforms from logical coordinates to
    /// device coordinates of the platform dependent paint device.
    /// 
    /// This function is *only* needed when using platform painting
    /// commands on the platform dependent handle (Qt::HANDLE), and the
    /// platform does not do transformations nativly.
    /// 
    /// The QPaintEngine::PaintEngineFeature enum can be queried to
    /// determine whether the platform performs the transformations or
    /// not.
    /// 
    /// **See also:** worldTransform()
    /// QPaintEngine::hasFeature()
    /// */
    /// 
    /// const QTransform & QPainter::deviceTransform() const
    /// 
    /// Q_D(const QPainter);
    /// if (!d->engine) {
    /// qWarning("QPainter::deviceTransform: Painter not active");
    /// return d->fakeState()->transform;
    /// 
    /// return d->state->matrix;
    /// 
    /// 
    /// /*!
    /// Resets any transformations that were made using translate(),
    /// scale(), shear(), rotate(), setWorldTransform(), setViewport()
    /// and setWindow().
    /// 
    /// **See also:** {Coordinate Transformations}
    reset_transform(),
    /// 
    /// Sets the world transformation matrix.
    /// If *combine* is true, the specified *matrix* is combined with the current matrix;
    /// otherwise it replaces the current matrix.
    /// 
    /// **See also:** transform()
    /// setTransform()
    set_world_transform(matrix: &TransformType, combine: bool),
    /// 
    /// Returns the world transformation matrix.
    world_transform() -> Transform?,
    /// 
    /// Returns the transformation matrix combining the current
    /// window/viewport and world transformation.
    /// 
    /// **See also:** setWorldTransform()
    /// setWindow()
    /// setViewport()
    combined_transform() -> Transform,
    /// 
    /// Scales the coordinate system by ( *sx* , *sy* ).
    /// 
    /// **See also:** setWorldTransform()
    /// {QPainter#Coordinate Transformations}{Coordinate Transformations}
    scale(sx: f32, sy: f32),
    /// 
    /// Shears the coordinate system by ( *sh* , *sv* ).
    /// 
    /// **See also:** setWorldTransform()
    /// {QPainter#Coordinate Transformations}{Coordinate Transformations}
    shear(sh: f32, sv: f32),
    /// 
    /// Rotates the coordinate system clockwise. The given *angle* parameter is in degrees.
    /// 
    /// **See also:** setWorldTransform()
    /// {QPainter#Coordinate Transformations}{Coordinate Transformations}
    rotate(a: f32),
    /// 
    /// Returns the window rectangle.
    /// 
    /// **See also:** setWindow()
    /// setViewTransformEnabled()
    window() -> Rect,
    /// 
    /// Sets the painter's window to the given *rectangle,* and enables
    /// view transformations.
    /// 
    /// The window rectangle is part of the view transformation. The
    /// window specifies the logical coordinate system. Its sister, the
    /// viewport(), specifies the device coordinate system.
    /// 
    /// The default window rectangle is the same as the device's
    /// rectangle.
    /// 
    /// **See also:** window()
    /// viewTransformEnabled()
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    /// 
    /// **Overloads**
    /// Sets the painter's window to the rectangle beginning at ( *x,* *y)* and the given *width* and *height.*
    set_window(window: &RectType),
    /// 
    /// Sets the painter's window to the given *rectangle,* and enables
    /// view transformations.
    /// 
    /// The window rectangle is part of the view transformation. The
    /// window specifies the logical coordinate system. Its sister, the
    /// viewport(), specifies the device coordinate system.
    /// 
    /// The default window rectangle is the same as the device's
    /// rectangle.
    /// 
    /// **See also:** window()
    /// viewTransformEnabled()
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    /// 
    /// **Overloads**
    /// Sets the painter's window to the rectangle beginning at ( *x,* *y)* and the given *width* and *height.*
    set_window(x: i32, y: i32, w: i32, h: i32),
    /// 
    /// Returns the viewport rectangle.
    /// 
    /// **See also:** setViewport()
    /// setViewTransformEnabled()
    viewport() -> Rect,
    /// 
    /// Sets the painter's viewport rectangle to the given *rectangle,*
    /// and enables view transformations.
    /// 
    /// The viewport rectangle is part of the view transformation. The
    /// viewport specifies the device coordinate system. Its sister, the
    /// window(), specifies the logical coordinate system.
    /// 
    /// The default viewport rectangle is the same as the device's
    /// rectangle.
    /// 
    /// **See also:** viewport()
    /// viewTransformEnabled()
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    /// 
    /// **Overloads**
    /// Sets the painter's viewport rectangle to be the rectangle
    /// beginning at ( *x,* *y)* with the given *width* and *height.*
    set_viewport(viewport: &RectType),
    /// 
    /// Sets the painter's viewport rectangle to the given *rectangle,*
    /// and enables view transformations.
    /// 
    /// The viewport rectangle is part of the view transformation. The
    /// viewport specifies the device coordinate system. Its sister, the
    /// window(), specifies the logical coordinate system.
    /// 
    /// The default viewport rectangle is the same as the device's
    /// rectangle.
    /// 
    /// **See also:** viewport()
    /// viewTransformEnabled()
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    /// 
    /// **Overloads**
    /// Sets the painter's viewport rectangle to be the rectangle
    /// beginning at ( *x,* *y)* with the given *width* and *height.*
    set_viewport(x: i32, y: i32, w: i32, h: i32),
    /// 
    /// Enables view transformations if *enable* is true, or disables
    /// view transformations if *enable* is false.
    /// 
    /// **See also:** viewTransformEnabled()
    /// {Coordinate System#Window-Viewport
    /// Conversion}{Window-Viewport Conversion}
    set_view_transform_enabled(enable: bool),
    /// 
    /// Returns `true` if view transformation is enabled; otherwise returns
    /// false.
    /// 
    /// **See also:** setViewTransformEnabled()
    /// worldTransform()
    view_transform_enabled() -> bool,
    /// 
    /// Fills the given *path* using the given *brush.* The outline is
    /// not drawn.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawPath()
    fill_path(path: &PainterPathType, brush: &BrushType),
    /// 
    /// Draws the given painter *path* using the current pen for outline
    /// and the current brush for filling.
    /// 
    /// * ![qpainter-path.png](qpainter-path.png)
    /// 
    /// 
    /// 
    /// **See also:** {painting/painterpaths}{the Painter Paths
    /// example},{painting/deform}{the Vector Deformation example}
    draw_path(path: &PainterPathType),
    /// 
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    /// 
    /// **Overloads**
    /// Draws a single point at position ( *x,* *y).*
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_point(pt: &PointFType),
    /// 
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    /// 
    /// **Overloads**
    /// Draws a single point at position ( *x,* *y).*
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_point(p: &PointType),
    /// 
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    /// 
    /// **Overloads**
    /// Draws a single point at position ( *x,* *y).*
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_point(x: i32, y: i32),
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_points(points: *PointFType, point_count: i32),
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_points(points: &PolygonFType),
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_points(points: *PointType, point_count: i32),
    /// 
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **See also:** {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    /// 
    /// **Overloads**
    /// Draws the points in the vector *points.*
    draw_points(points: &PolygonType),
    /// 
    /// Draws a line defined by *line.*
    /// 
    /// * ![qpainter-line.png](qpainter-line.png)
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a line defined by *line.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_line(line: &LineFType),
    /// 
    /// Draws a line defined by *line.*
    /// 
    /// * ![qpainter-line.png](qpainter-line.png)
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a line defined by *line.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_line(line: &LineType),
    /// 
    /// Draws a line defined by *line.*
    /// 
    /// * ![qpainter-line.png](qpainter-line.png)
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a line defined by *line.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_line(x1: i32, y1: i32, x2: i32, y2: i32),
    /// 
    /// Draws a line defined by *line.*
    /// 
    /// * ![qpainter-line.png](qpainter-line.png)
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a line defined by *line.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_line(p1: &PointType, p2: &PointType),
    /// 
    /// Draws a line defined by *line.*
    /// 
    /// * ![qpainter-line.png](qpainter-line.png)
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a line defined by *line.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    /// 
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_line(p1: &PointFType, p2: &PointFType),
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_lines(lines: *LineFType, line_count: i32),
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_lines(point_pairs: *PointFType, line_count: i32),
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_lines(lines: *LineType, line_count: i32),
    /// 
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **See also:** drawLine()
    /// drawPolyline()
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    /// 
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    /// 
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    draw_lines(point_pairs: *PointType, line_count: i32),
    /// 
    /// Draws the current *rectangle* with the current pen and brush.
    /// 
    /// A filled rectangle has a size of *rectangle* .size(). A stroked
    /// rectangle has a size of *rectangle* .size() plus the pen width.
    /// 
    /// * ![qpainter-rectangle.png](qpainter-rectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** drawRects()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the current *rectangle* with the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws a rectangle with upper left corner at ( *x* , *y* ) and
    /// with the given *width* and *height.*
    /// 
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    draw_rect(rect: &RectFType),
    /// 
    /// Draws the current *rectangle* with the current pen and brush.
    /// 
    /// A filled rectangle has a size of *rectangle* .size(). A stroked
    /// rectangle has a size of *rectangle* .size() plus the pen width.
    /// 
    /// * ![qpainter-rectangle.png](qpainter-rectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** drawRects()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the current *rectangle* with the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws a rectangle with upper left corner at ( *x* , *y* ) and
    /// with the given *width* and *height.*
    /// 
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    draw_rect(x1: i32, y1: i32, w: i32, h: i32),
    /// 
    /// Draws the current *rectangle* with the current pen and brush.
    /// 
    /// A filled rectangle has a size of *rectangle* .size(). A stroked
    /// rectangle has a size of *rectangle* .size() plus the pen width.
    /// 
    /// * ![qpainter-rectangle.png](qpainter-rectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** drawRects()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the current *rectangle* with the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws a rectangle with upper left corner at ( *x* , *y* ) and
    /// with the given *width* and *height.*
    /// 
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    draw_rect(rect: &RectType),
    /// 
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    draw_rects(rects: *RectFType, rect_count: i32),
    /// 
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    /// 
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    draw_rects(rects: *RectType, rect_count: i32),
    /// 
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    /// 
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    draw_ellipse(r: &RectFType),
    /// 
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    /// 
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    draw_ellipse(r: &RectType),
    /// 
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    /// 
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    draw_ellipse(x: i32, y: i32, w: i32, h: i32),
    /// 
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    /// 
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    draw_ellipse(center: &PointFType, rx: f32, ry: f32),
    /// 
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    /// 
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    /// 
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    /// 
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    draw_ellipse(center: &PointType, rx: i32, ry: i32),
    /// 
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    draw_polyline(points: *PointFType, point_count: i32),
    /// 
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    draw_polyline(polyline: &PolygonFType),
    /// 
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    draw_polyline(points: *PointType, point_count: i32),
    /// 
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    /// 
    /// 
    /// 
    /// **See also:** drawLines()
    /// drawPolygon()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    /// 
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    draw_polyline(polygon: &PolygonType),
    /// 
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    /// 
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    /// 
    /// **See also:** drawConvexPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    draw_polygon(points: *PointFType, point_count: i32, fill_rule: Rute::FillRule),
    /// 
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    /// 
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    /// 
    /// **See also:** drawConvexPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    draw_polygon(polygon: &PolygonFType, fill_rule: Rute::FillRule),
    /// 
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    /// 
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    /// 
    /// **See also:** drawConvexPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    draw_polygon(points: *PointType, point_count: i32, fill_rule: Rute::FillRule),
    /// 
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    /// 
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    /// 
    /// **See also:** drawConvexPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    /// 
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    draw_polygon(polygon: &PolygonType, fill_rule: Rute::FillRule),
    /// 
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    /// 
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    /// 
    /// **See also:** drawPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    draw_convex_polygon(points: *PointFType, point_count: i32),
    /// 
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    /// 
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    /// 
    /// **See also:** drawPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    draw_convex_polygon(polygon: &PolygonFType),
    /// 
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    /// 
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    /// 
    /// **See also:** drawPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    draw_convex_polygon(points: *PointType, point_count: i32),
    /// 
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    /// 
    /// 
    /// 
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    /// 
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    /// 
    /// **See also:** drawPolygon()
    /// drawPolyline()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    /// 
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    draw_convex_polygon(polygon: &PolygonType),
    /// 
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// The *startAngle* and *spanAngle* must be specified in 1/16th of
    /// a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    /// values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-arc.png](qpainter-arc.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// drawChord()
    /// {Coordinate System}
    /// int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// int startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the arc defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    draw_arc(rect: &RectFType, a: i32, alen: i32),
    /// 
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// The *startAngle* and *spanAngle* must be specified in 1/16th of
    /// a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    /// values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-arc.png](qpainter-arc.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// drawChord()
    /// {Coordinate System}
    /// int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// int startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the arc defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    draw_arc(arg0: &RectType, a: i32, alen: i32),
    /// 
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// The *startAngle* and *spanAngle* must be specified in 1/16th of
    /// a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    /// values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-arc.png](qpainter-arc.png)
    /// 
    /// 
    /// 
    /// **See also:** drawPie()
    /// drawChord()
    /// {Coordinate System}
    /// int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// int startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the arc defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    draw_arc(x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32),
    /// 
    /// Draws a pie defined by the given *rectangle,* *startAngle* and *spanAngle.*
    /// 
    /// The pie is filled with the current brush().
    /// 
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-pie.png](qpainter-pie.png)
    /// 
    /// 
    /// 
    /// **See also:** drawEllipse()
    /// drawChord()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a pie defined by the given *rectangle,* *startAngle* and
    /// and *spanAngle.*
    /// 
    /// startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the pie defined by the rectangle beginning at ( *x,* *y)* with
    /// the specified *width* and *height,* and the given *startAngle* and
    /// *spanAngle.*
    draw_pie(rect: &RectFType, a: i32, alen: i32),
    /// 
    /// Draws a pie defined by the given *rectangle,* *startAngle* and *spanAngle.*
    /// 
    /// The pie is filled with the current brush().
    /// 
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-pie.png](qpainter-pie.png)
    /// 
    /// 
    /// 
    /// **See also:** drawEllipse()
    /// drawChord()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a pie defined by the given *rectangle,* *startAngle* and
    /// and *spanAngle.*
    /// 
    /// startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the pie defined by the rectangle beginning at ( *x,* *y)* with
    /// the specified *width* and *height,* and the given *startAngle* and
    /// *spanAngle.*
    draw_pie(x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32),
    /// 
    /// Draws a pie defined by the given *rectangle,* *startAngle* and *spanAngle.*
    /// 
    /// The pie is filled with the current brush().
    /// 
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-pie.png](qpainter-pie.png)
    /// 
    /// 
    /// 
    /// **See also:** drawEllipse()
    /// drawChord()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws a pie defined by the given *rectangle,* *startAngle* and
    /// and *spanAngle.*
    /// 
    /// startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the pie defined by the rectangle beginning at ( *x,* *y)* with
    /// the specified *width* and *height,* and the given *startAngle* and
    /// *spanAngle.*
    draw_pie(arg0: &RectType, a: i32, alen: i32),
    /// 
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.* The chord is filled with the current brush().
    /// 
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-chord.png](qpainter-chord.png)
    /// 
    /// 
    /// 
    /// **See also:** drawArc()
    /// drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the chord defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    draw_chord(rect: &RectFType, a: i32, alen: i32),
    /// 
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.* The chord is filled with the current brush().
    /// 
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-chord.png](qpainter-chord.png)
    /// 
    /// 
    /// 
    /// **See also:** drawArc()
    /// drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the chord defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    draw_chord(x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32),
    /// 
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.* The chord is filled with the current brush().
    /// 
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    /// 
    /// * ![qpainter-chord.png](qpainter-chord.png)
    /// 
    /// 
    /// 
    /// **See also:** drawArc()
    /// drawPie()
    /// {Coordinate System}
    /// 
    /// **Overloads**
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    /// 
    /// startAngle, int spanAngle)
    /// 
    /// **Overloads**
    /// Draws the chord defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    draw_chord(arg0: &RectType, a: i32, alen: i32),
    /// 
    /// Draws the given rectangle *rect* with rounded corners.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii
    /// of the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range
    /// 0.0 to 100.0.
    /// 
    /// A filled rectangle has a size of rect.size(). A stroked rectangle
    /// has a size of rect.size() plus the pen width.
    /// 
    /// * ![qpainter-roundrect.png](qpainter-roundrect.png)
    /// 
    /// 
    /// 
    /// **See also:** drawRect()
    /// QPen
    /// 
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *rect* with rounded corners.
    /// 
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *x,* *y,* *w,* *h* with rounded corners.
    draw_rounded_rect(rect: &RectFType, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    /// 
    /// Draws the given rectangle *rect* with rounded corners.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii
    /// of the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range
    /// 0.0 to 100.0.
    /// 
    /// A filled rectangle has a size of rect.size(). A stroked rectangle
    /// has a size of rect.size() plus the pen width.
    /// 
    /// * ![qpainter-roundrect.png](qpainter-roundrect.png)
    /// 
    /// 
    /// 
    /// **See also:** drawRect()
    /// QPen
    /// 
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *rect* with rounded corners.
    /// 
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *x,* *y,* *w,* *h* with rounded corners.
    draw_rounded_rect(x: i32, y: i32, w: i32, h: i32, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    /// 
    /// Draws the given rectangle *rect* with rounded corners.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii
    /// of the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range
    /// 0.0 to 100.0.
    /// 
    /// A filled rectangle has a size of rect.size(). A stroked rectangle
    /// has a size of rect.size() plus the pen width.
    /// 
    /// * ![qpainter-roundrect.png](qpainter-roundrect.png)
    /// 
    /// 
    /// 
    /// **See also:** drawRect()
    /// QPen
    /// 
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *rect* with rounded corners.
    /// 
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *x,* *y,* *w,* *h* with rounded corners.
    draw_rounded_rect(rect: &RectType, x_radius: f32, y_radius: f32, mode: Rute::SizeMode),
    /// 
    /// Draws a rectangle *r* with rounded corners.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// A filled rectangle has a size of r.size(). A stroked rectangle
    /// has a size of r.size() plus the pen width.
    /// 
    /// **See also:** drawRoundedRect()
    /// 
    /// **Overloads**
    /// Draws the rectangle *r* with rounded corners.
    /// 
    /// **Overloads**
    /// Draws the rectangle *x,* *y,* *w,* *h* with rounded corners.
    draw_round_rect(r: &RectFType, xround: i32, yround: i32),
    /// 
    /// Draws a rectangle *r* with rounded corners.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// A filled rectangle has a size of r.size(). A stroked rectangle
    /// has a size of r.size() plus the pen width.
    /// 
    /// **See also:** drawRoundedRect()
    /// 
    /// **Overloads**
    /// Draws the rectangle *r* with rounded corners.
    /// 
    /// **Overloads**
    /// Draws the rectangle *x,* *y,* *w,* *h* with rounded corners.
    draw_round_rect(x: i32, y: i32, w: i32, h: i32, arg0: i32, arg1: i32),
    /// 
    /// Draws a rectangle *r* with rounded corners.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// A filled rectangle has a size of r.size(). A stroked rectangle
    /// has a size of r.size() plus the pen width.
    /// 
    /// **See also:** drawRoundedRect()
    /// 
    /// **Overloads**
    /// Draws the rectangle *r* with rounded corners.
    /// 
    /// **Overloads**
    /// Draws the rectangle *x,* *y,* *w,* *h* with rounded corners.
    draw_round_rect(r: &RectType, xround: i32, yround: i32),
    /// 
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    /// 
    /// Calling drawTiledPixmap() is similar to calling drawPixmap()
    /// several times to fill (tile) an area with a pixmap, but is
    /// potentially much more efficient depending on the underlying window
    /// system.
    /// 
    /// **See also:** drawPixmap()
    /// 
    /// const QPoint &position = QPoint())
    /// **Overloads**
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    /// 
    /// QPixmap &pixmap, int sx, int sy);
    /// **Overloads**
    /// Draws a tiled *pixmap* in the specified rectangle.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device
    /// that is to be drawn onto; with the given *width* and *height.* ( *sx* , *sy* ) specifies the top-left point in the *pixmap* that is to be drawn; this defaults to (0, 0).
    draw_tiled_pixmap(rect: &RectFType, pm: &PixmapType, offset: &PointFType),
    /// 
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    /// 
    /// Calling drawTiledPixmap() is similar to calling drawPixmap()
    /// several times to fill (tile) an area with a pixmap, but is
    /// potentially much more efficient depending on the underlying window
    /// system.
    /// 
    /// **See also:** drawPixmap()
    /// 
    /// const QPoint &position = QPoint())
    /// **Overloads**
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    /// 
    /// QPixmap &pixmap, int sx, int sy);
    /// **Overloads**
    /// Draws a tiled *pixmap* in the specified rectangle.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device
    /// that is to be drawn onto; with the given *width* and *height.* ( *sx* , *sy* ) specifies the top-left point in the *pixmap* that is to be drawn; this defaults to (0, 0).
    draw_tiled_pixmap(x: i32, y: i32, w: i32, h: i32, arg0: &PixmapType, sx: i32, sy: i32),
    /// 
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    /// 
    /// Calling drawTiledPixmap() is similar to calling drawPixmap()
    /// several times to fill (tile) an area with a pixmap, but is
    /// potentially much more efficient depending on the underlying window
    /// system.
    /// 
    /// **See also:** drawPixmap()
    /// 
    /// const QPoint &position = QPoint())
    /// **Overloads**
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    /// 
    /// QPixmap &pixmap, int sx, int sy);
    /// **Overloads**
    /// Draws a tiled *pixmap* in the specified rectangle.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device
    /// that is to be drawn onto; with the given *width* and *height.* ( *sx* , *sy* ) specifies the top-left point in the *pixmap* that is to be drawn; this defaults to (0, 0).
    draw_tiled_pixmap(arg0: &RectType, arg1: &PixmapType, arg2: &PointType),
    /// 
    /// Replays the given *picture* at the given *point.*
    /// 
    /// The QPicture class is a paint device that records and replays
    /// QPainter commands. A picture serializes the painter commands to an
    /// IO device in a platform-independent format. Everything that can be
    /// painted on a widget or pixmap can also be stored in a picture.
    /// 
    /// This function does exactly the same as QPicture::play() when
    /// called with *point* = QPoint(0, 0).
    /// 
    /// 
    /// 
    /// **See also:** QPicture::play()
    /// 
    /// **Overloads**
    /// Replays the given *picture* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *picture* at point ( *x,* *y).*
    draw_picture(p: &PointFType, picture: &PictureType),
    /// 
    /// Replays the given *picture* at the given *point.*
    /// 
    /// The QPicture class is a paint device that records and replays
    /// QPainter commands. A picture serializes the painter commands to an
    /// IO device in a platform-independent format. Everything that can be
    /// painted on a widget or pixmap can also be stored in a picture.
    /// 
    /// This function does exactly the same as QPicture::play() when
    /// called with *point* = QPoint(0, 0).
    /// 
    /// 
    /// 
    /// **See also:** QPicture::play()
    /// 
    /// **Overloads**
    /// Replays the given *picture* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *picture* at point ( *x,* *y).*
    draw_picture(x: i32, y: i32, picture: &PictureType),
    /// 
    /// Replays the given *picture* at the given *point.*
    /// 
    /// The QPicture class is a paint device that records and replays
    /// QPainter commands. A picture serializes the painter commands to an
    /// IO device in a platform-independent format. Everything that can be
    /// painted on a widget or pixmap can also be stored in a picture.
    /// 
    /// This function does exactly the same as QPicture::play() when
    /// called with *point* = QPoint(0, 0).
    /// 
    /// 
    /// 
    /// **See also:** QPicture::play()
    /// 
    /// **Overloads**
    /// Replays the given *picture* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *picture* at point ( *x,* *y).*
    draw_picture(p: &PointType, picture: &PictureType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(target_rect: &RectFType, pixmap: &PixmapType, source_rect: &RectFType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(target_rect: &RectType, pixmap: &PixmapType, source_rect: &RectType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(x: i32, y: i32, w: i32, h: i32, pm: &PixmapType, sx: i32, sy: i32, sw: i32, sh: i32),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(x: i32, y: i32, pm: &PixmapType, sx: i32, sy: i32, sw: i32, sh: i32),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(p: &PointFType, pm: &PixmapType, sr: &RectFType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(p: &PointType, pm: &PixmapType, sr: &RectType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(p: &PointFType, pm: &PixmapType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(p: &PointType, pm: &PixmapType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(x: i32, y: i32, pm: &PixmapType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(r: &RectType, pm: &PixmapType),
    /// 
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    /// 
    /// 
    /// 
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    /// 
    /// **See also:** drawImage()
    /// QPixmap::devicePixelRatio()
    /// 
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// const QRect &source)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    /// 
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    /// 
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// 
    /// const QPixmap &pixmap)
    /// 
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    /// 
    /// int sx, int sy, int sw, int sh)
    /// 
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap(x: i32, y: i32, w: i32, h: i32, pm: &PixmapType),
    /// 
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    /// 
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    /// 
    /// **See also:** QPainter::PixmapFragment
    /// QPainter::PixmapFragmentHint
    draw_pixmap_fragments(fragments: QPainter::PixmapFragment, fragment_count: i32, pixmap: &PixmapType, hints: Painter::PixmapFragmentHints),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(target_rect: &RectFType, image: &ImageType, source_rect: &RectFType, flags: Rute::ImageConversionFlags),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(target_rect: &RectType, image: &ImageType, source_rect: &RectType, flags: Rute::ImageConversionFlags),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(p: &PointFType, image: &ImageType, sr: &RectFType, flags: Rute::ImageConversionFlags),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(p: &PointType, image: &ImageType, sr: &RectType, flags: Rute::ImageConversionFlags),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(r: &RectFType, image: &ImageType),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(r: &RectType, image: &ImageType),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(p: &PointFType, image: &ImageType),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(p: &PointType, image: &ImageType),
    /// 
    /// Qt::ImageConversionFlags flags)
    /// 
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    /// 
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    /// 
    /// 
    /// 
    /// **See also:** drawPixmap()
    /// QImage::devicePixelRatio()
    /// 
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// 
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    /// 
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// 
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    /// 
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    /// 
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    draw_image(x: i32, y: i32, image: &ImageType, sx: i32, sy: i32, sw: i32, sh: i32, flags: Rute::ImageConversionFlags),
    /// 
    /// Sets the layout direction used by the painter when drawing text,
    /// to the specified *direction.*
    /// 
    /// The default is Qt::LayoutDirectionAuto, which will implicitly determine the
    /// direction from the text drawn.
    /// 
    /// **See also:** QTextOption::setTextDirection()
    /// layoutDirection()
    /// drawText()
    /// {QPainter#Settings}{Settings}
    set_layout_direction(direction: Rute::LayoutDirection),
    /// 
    /// Returns the layout direction used by the painter when drawing text.
    /// 
    /// **See also:** QTextOption::textDirection()
    /// setLayoutDirection()
    /// drawText()
    /// {QPainter#Settings}{Settings}
    layout_direction() -> Rute::LayoutDirection,
    /// 
    /// Draws the glyphs represented by *glyphs* at *position.* The *position* gives the
    /// edge of the baseline for the string of glyphs. The glyphs will be retrieved from the font
    /// selected on *glyphs* and at offsets given by the positions in *glyphs.*
    /// 
    /// **See also:** QGlyphRun::setRawFont()
    /// QGlyphRun::setPositions()
    /// QGlyphRun::setGlyphIndexes()
    draw_glyph_run(position: &PointFType, glyph_run: &GlyphRunType),
    /// 
    /// **Overloads**
    /// Draws the *staticText* at the *topLeftPosition.*
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// 
    /// **Overloads**
    /// Draws the *staticText* at coordinates *left* and *top.*
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// Draws the given *staticText* at the given *topLeftPosition.*
    /// 
    /// The text will be drawn using the font and the transformation set on the painter. If the
    /// font and/or transformation set on the painter are different from the ones used to initialize
    /// the layout of the QStaticText, then the layout will have to be recalculated. Use
    /// QStaticText::prepare() to initialize *staticText* with the font and transformation with which
    /// it will later be drawn.
    /// 
    /// If *topLeftPosition* is not the same as when *staticText* was initialized, or when it was
    /// last drawn, then there will be a slight overhead when translating the text to its new position.
    /// 
    /// **Note**: If the painter's transformation is not affine, then *staticText* will be drawn using
    /// regular calls to drawText(), losing any potential for performance improvement.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** QStaticText
    draw_static_text(top_left_position: &PointFType, static_text: &StaticTextType),
    /// 
    /// **Overloads**
    /// Draws the *staticText* at the *topLeftPosition.*
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// 
    /// **Overloads**
    /// Draws the *staticText* at coordinates *left* and *top.*
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// Draws the given *staticText* at the given *topLeftPosition.*
    /// 
    /// The text will be drawn using the font and the transformation set on the painter. If the
    /// font and/or transformation set on the painter are different from the ones used to initialize
    /// the layout of the QStaticText, then the layout will have to be recalculated. Use
    /// QStaticText::prepare() to initialize *staticText* with the font and transformation with which
    /// it will later be drawn.
    /// 
    /// If *topLeftPosition* is not the same as when *staticText* was initialized, or when it was
    /// last drawn, then there will be a slight overhead when translating the text to its new position.
    /// 
    /// **Note**: If the painter's transformation is not affine, then *staticText* will be drawn using
    /// regular calls to drawText(), losing any potential for performance improvement.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** QStaticText
    draw_static_text(top_left_position: &PointType, static_text: &StaticTextType),
    /// 
    /// **Overloads**
    /// Draws the *staticText* at the *topLeftPosition.*
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// 
    /// **Overloads**
    /// Draws the *staticText* at coordinates *left* and *top.*
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// Draws the given *staticText* at the given *topLeftPosition.*
    /// 
    /// The text will be drawn using the font and the transformation set on the painter. If the
    /// font and/or transformation set on the painter are different from the ones used to initialize
    /// the layout of the QStaticText, then the layout will have to be recalculated. Use
    /// QStaticText::prepare() to initialize *staticText* with the font and transformation with which
    /// it will later be drawn.
    /// 
    /// If *topLeftPosition* is not the same as when *staticText* was initialized, or when it was
    /// last drawn, then there will be a slight overhead when translating the text to its new position.
    /// 
    /// **Note**: If the painter's transformation is not affine, then *staticText* will be drawn using
    /// regular calls to drawText(), losing any potential for performance improvement.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** QStaticText
    draw_static_text(left: i32, top: i32, static_text: &StaticTextType),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(p: &PointFType, s: String),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(p: &PointType, s: String),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(x: i32, y: i32, s: String),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(p: &PointFType, str: String, tf: i32, justification_padding: i32),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(r: &RectFType, flags: i32, text: String, br: *RectFType),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(r: &RectType, flags: i32, text: String, br: *RectType),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(x: i32, y: i32, w: i32, h: i32, flags: i32, text: String, br: *RectType),
    /// 
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    /// 
    /// * ![qpainter-text.png](qpainter-text.png)
    /// 
    /// 
    /// 
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// boundingRect()
    /// layoutDirection()
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the baseline of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    /// 
    /// const QString &text, QRect *boundingRect)
    /// 
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    /// 
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    /// 
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    /// 
    /// 
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// 
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-position is used as the top of the font.
    /// 
    /// **See also:** Qt::AlignmentFlag
    /// Qt::TextFlag
    /// setFont()
    /// setPen()
    /// 
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    /// 
    /// By default, QPainter draws text anti-aliased.
    /// 
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    /// 
    /// **See also:** setFont()
    /// setPen()
    draw_text(r: &RectFType, text: String, o: &TextOptionType),
    /// 
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    /// 
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    /// 
    /// **See also:** drawText()
    /// Qt::Alignment
    /// Qt::TextFlag
    /// 
    /// const QString &text)
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    /// 
    /// const QString &text);
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    /// 
    /// const QString &text, const QTextOption &option)
    /// 
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    /// 
    /// **See also:** QTextOption
    bounding_rect(rect: &RectFType, flags: i32, text: String) -> RectF,
    /// 
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    /// 
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    /// 
    /// **See also:** drawText()
    /// Qt::Alignment
    /// Qt::TextFlag
    /// 
    /// const QString &text)
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    /// 
    /// const QString &text);
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    /// 
    /// const QString &text, const QTextOption &option)
    /// 
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    /// 
    /// **See also:** QTextOption
    bounding_rect(rect: &RectType, flags: i32, text: String) -> Rect,
    /// 
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    /// 
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    /// 
    /// **See also:** drawText()
    /// Qt::Alignment
    /// Qt::TextFlag
    /// 
    /// const QString &text)
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    /// 
    /// const QString &text);
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    /// 
    /// const QString &text, const QTextOption &option)
    /// 
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    /// 
    /// **See also:** QTextOption
    bounding_rect(x: i32, y: i32, w: i32, h: i32, flags: i32, text: String) -> Rect,
    /// 
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    /// 
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    /// 
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    /// 
    /// **See also:** drawText()
    /// Qt::Alignment
    /// Qt::TextFlag
    /// 
    /// const QString &text)
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    /// 
    /// const QString &text);
    /// 
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    /// 
    /// const QString &text, const QTextOption &option)
    /// 
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    /// 
    /// **See also:** QTextOption
    bounding_rect(rect: &RectFType, text: String, o: &TextOptionType) -> RectF,
    draw_text_item(p: &PointFType, ti: &TextItemType),
    draw_text_item(x: i32, y: i32, ti: &TextItemType),
    draw_text_item(p: &PointType, ti: &TextItemType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(arg0: &RectFType, arg1: &BrushType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(x: i32, y: i32, w: i32, h: i32, arg0: &BrushType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(arg0: &RectType, arg1: &BrushType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(arg0: &RectFType, color: &ColorType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(x: i32, y: i32, w: i32, h: i32, color: &ColorType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(arg0: &RectType, color: &ColorType),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(x: i32, y: i32, w: i32, h: i32, c: Rute::GlobalColor),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(r: &RectType, c: Rute::GlobalColor),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(r: &RectFType, c: Rute::GlobalColor),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(x: i32, y: i32, w: i32, h: i32, style: Rute::BrushStyle),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(r: &RectType, style: Rute::BrushStyle),
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    /// 
    /// 
    /// Fills the given *rectangle* with the *brush* specified.
    /// 
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    /// 
    /// **See also:** drawRect()
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    /// 
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    /// 
    fill_rect(r: &RectFType, style: Rute::BrushStyle),
    /// 
    /// Erases the area inside the given *rectangle.* Equivalent to
    /// calling
    /// 
    /// **See also:** fillRect()
    /// 
    /// **Overloads**
    /// Erases the area inside the given *rectangle.*
    /// 
    /// **Overloads**
    /// Erases the area inside the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    erase_rect(arg0: &RectFType),
    /// 
    /// Erases the area inside the given *rectangle.* Equivalent to
    /// calling
    /// 
    /// **See also:** fillRect()
    /// 
    /// **Overloads**
    /// Erases the area inside the given *rectangle.*
    /// 
    /// **Overloads**
    /// Erases the area inside the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    erase_rect(x: i32, y: i32, w: i32, h: i32),
    /// 
    /// Erases the area inside the given *rectangle.* Equivalent to
    /// calling
    /// 
    /// **See also:** fillRect()
    /// 
    /// **Overloads**
    /// Erases the area inside the given *rectangle.*
    /// 
    /// **Overloads**
    /// Erases the area inside the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    erase_rect(arg0: &RectType),
    /// 
    /// Sets the given render *hint* on the painter if *on* is true;
    /// otherwise clears the render hint.
    /// 
    /// **See also:** setRenderHints()
    /// renderHints()
    /// {QPainter#Rendering
    /// Quality}{Rendering Quality}
    /// 
    /// Sets the given render *hints* on the painter if *on* is true;
    /// otherwise clears the render hints.
    /// 
    /// **See also:** setRenderHint()
    /// renderHints()
    /// {QPainter#Rendering
    /// Quality}{Rendering Quality}
    set_render_hint(hint: Painter::RenderHint, on: bool),
    /// 
    /// Sets the given render *hints* on the painter if *on* is true;
    /// otherwise clears the render hints.
    /// 
    /// **See also:** setRenderHint()
    /// renderHints()
    /// {QPainter#Rendering
    /// Quality}{Rendering Quality}
    set_render_hints(hints: Painter::RenderHints, on: bool),
    /// 
    /// Returns a flag that specifies the rendering hints that are set for
    /// this painter.
    /// 
    /// **See also:** testRenderHint()
    /// {QPainter#Rendering Quality}{Rendering Quality}
    render_hints() -> Painter::RenderHints,
    /// 
    /// Returns `true` if *hint* is set; otherwise returns `false.`
    /// 
    /// **See also:** renderHints()
    /// setRenderHint()
    test_render_hint(hint: Painter::RenderHint) -> bool,
    /// 
    /// Returns the paint engine that the painter is currently operating
    /// on if the painter is active; otherwise 0.
    /// 
    /// **See also:** isActive()
    paint_engine() -> PaintEngine?,
    /// 
    /// Please use QWidget::render() instead.
    /// 
    /// Redirects all paint commands for the given paint *device,* to the
    /// *replacement* device. The optional point *offset* defines an
    /// offset within the source device.
    /// 
    /// The redirection will not be effective until the begin() function
    /// has been called; make sure to call end() for the given *device's* painter (if any) before redirecting. Call
    /// restoreRedirected() to restore the previous redirection.
    /// 
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    /// 
    /// **See also:** redirected()
    /// restoreRedirected()
    [static] set_redirected(device: *PaintDeviceType, replacement: *PaintDeviceType, offset: &PointType),
    /// 
    /// Using QWidget::render() obsoletes the use of this function.
    /// 
    /// Returns the replacement for given *device.* The optional out
    /// parameter *offset* returns the offset within the replaced device.
    /// 
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    /// 
    /// **See also:** setRedirected()
    /// restoreRedirected()
    [static] redirected(device: *PaintDeviceType, offset: *PointType) -> PaintDevice?,
    /// 
    /// Using QWidget::render() obsoletes the use of this function.
    /// 
    /// Restores the previous redirection for the given *device* after a
    /// call to setRedirected().
    /// 
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    /// 
    /// **See also:** redirected()
    [static] restore_redirected(device: *PaintDeviceType),
    /// 
    /// Flushes the painting pipeline and prepares for the user issuing commands
    /// directly to the underlying graphics context. Must be followed by a call to
    /// endNativePainting().
    /// 
    /// Note that only the states the underlying paint engine changes will be reset
    /// to their respective default states. The states we reset may change from
    /// release to release. The following states are currently reset in the OpenGL
    /// 2 engine:
    /// 
    /// * blending is disabled
    /// * the depth, stencil and scissor tests are disabled
    /// * the active texture unit is reset to 0
    /// * the depth mask, depth function and the clear depth are reset to their default values
    /// * the stencil mask, stencil operation and stencil function are reset to their default values
    /// * the current color is reset to solid white
    /// 
    /// If, for example, the OpenGL polygon mode is changed by the user inside a
    /// beginNativePaint()/endNativePainting() block, it will not be reset to the
    /// default state by endNativePainting(). Here is an example that shows
    /// intermixing of painter commands and raw OpenGL commands:
    /// 
    /// **See also:** endNativePainting()
    begin_native_painting(),
    /// 
    /// Restores the painter after manually issuing native painting commands. Lets
    /// the painter restore any native state that it relies on before calling any
    /// other painter commands.
    /// 
    /// **See also:** beginNativePainting()
    end_native_painting(),
}

// vim: syntax=rust expandtab ts=4 sw=4
