///
/// A color is normally specified in terms of RGB (red, green, and
/// blue) components, but it is also possible to specify it in terms
/// of HSV (hue, saturation, and value) and CMYK (cyan, magenta,
/// yellow and black) components. In addition a color can be specified
/// using a color name. The color name can be any of the SVG 1.0 color
/// names.
///
/// * RGB
/// * HSV
/// * CMYK
///
/// * ![qcolor-rgb.png](qcolor-rgb.png)
///
/// * ![qcolor-hsv.png](qcolor-hsv.png)
///
/// * ![qcolor-cmyk.png](qcolor-cmyk.png)
///
/// The QColor constructor creates the color based on RGB values. To
/// create a QColor based on either HSV or CMYK values, use the
/// toHsv() and toCmyk() functions respectively. These functions
/// return a copy of the color using the desired format. In addition
/// the static fromRgb(), fromHsv() and fromCmyk() functions create
/// colors from the specified values. Alternatively, a color can be
/// converted to any of the three formats using the convertTo()
/// function (returning a copy of the color in the desired format), or
/// any of the setRgb(), setHsv() and setCmyk() functions altering *this* color's format. The spec() function tells how the color was
/// specified.
///
/// A color can be set by passing an RGB string (such as ),
/// or an ARGB string (such as ) or a color name (such as ),
/// to the setNamedColor() function.
/// The color names are taken from the SVG 1.0 color names. The name()
/// function returns the name of the color in the format
/// . Colors can also be set using setRgb(), setHsv() and
/// setCmyk(). To get a lighter or darker color use the lighter() and
/// darker() functions respectively.
///
/// The isValid() function indicates whether a QColor is legal at
/// all. For example, a RGB color with RGB values out of range is
/// illegal. For performance reasons, QColor mostly disregards illegal
/// colors, and for that reason, the result of using an invalid color
/// is undefined.
///
/// The color components can be retrieved individually, e.g with
/// red(), hue() and cyan(). The values of the color components can
/// also be retrieved in one go using the getRgb(), getHsv() and
/// getCmyk() functions. Using the RGB color model, the color
/// components can in addition be accessed with rgb().
///
/// There are several related non-members: QRgb is a typdef for an
/// unsigned int representing the RGB value triplet (r, g, b). Note
/// that it also can hold a value for the alpha-channel (for more
/// information, see the [Alpha-Blended Drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
/// section). The qRed(), qBlue() and
/// qGreen() functions return the respective component of the given
/// QRgb value, while the qRgb() and qRgba() functions create and
/// return the QRgb triplet based on the given component
/// values. Finally, the qAlpha() function returns the alpha component
/// of the provided QRgb, and the qGray() function calculates and
/// return a gray value based on the given value.
///
/// QColor is platform and device independent. The QColormap class
/// maps the color to the hardware.
///
/// For more information about painting in general, see the [Paint
/// System](Paint%0A%20%20%20%20System)
/// documentation.
///
/// # Integer vs. Floating Point Precision
///
/// QColor supports floating point precision and provides floating
/// point versions of all the color components functions,
/// e.g. getRgbF(), hueF() and fromCmykF(). Note that since the
/// components are stored using 16-bit integers, there might be minor
/// deviations between the values set using, for example, setRgbF()
/// and the values returned by the getRgbF() function due to rounding.
///
/// While the integer based functions take values in the range 0-255
/// (except hue() which must have values within the range 0-359),
/// the floating point functions accept values in the range 0.0 - 1.0.
///
/// # Alpha-Blended Drawing
///
/// QColor also support alpha-blended outlining and filling. The
/// alpha channel of a color specifies the transparency effect, 0
/// represents a fully transparent color, while 255 represents a fully
/// opaque color. For example:
///
/// The code above produces the following output:
///
/// ![alphafill.png](alphafill.png)
///
/// The alpha channel of a color can be retrieved and set using the
/// alpha() and setAlpha() functions if its value is an integer, and
/// alphaF() and setAlphaF() if its value is qreal (double). By
/// default, the alpha-channel is set to 255 (opaque). To retrieve and
/// set *all* the RGB color components (including the alpha-channel)
/// in one go, use the rgba() and setRgba() functions.
///
/// # Predefined Colors
///
/// There are 20 predefined QColors described by the Qt::GlobalColor enum,
/// including black, white, primary and secondary colors, darker versions
/// of these colors and three shades of gray. QColor also recognizes a
/// variety of color names; the static colorNames() function returns a
/// QStringList color names that QColor knows about.
///
/// ![Qt Colors](qt-colors.png)
///
/// Additionally, the Qt::color0, Qt::color1 and Qt::transparent colors
/// are used for special purposes.
///
/// Qt::color0 (zero pixel value) and Qt::color1 (non-zero pixel value)
/// are special colors for drawing in QBitmaps. Painting with Qt::color0
/// sets the bitmap bits to 0 (transparent; i.e., background), and painting
/// with Qt::color1 sets the bits to 1 (opaque; i.e., foreground).
///
/// Qt::transparent is used to indicate a transparent pixel. When painting
/// with this value, a pixel value will be used that is appropriate for the
/// underlying pixel format in use.
///
/// # The HSV Color Model
///
/// The RGB model is hardware-oriented. Its representation is close to
/// what most monitors show. In contrast, HSV represents color in a way
/// more suited to the human perception of color. For example, the
/// relationships , , and
/// are easily expressed in HSV but are much harder to express in RGB.
///
/// HSV, like RGB, has three components:
///
/// * H, for hue, is in the range 0 to 359 if the color is chromatic (not gray), or meaningless if it is gray. It represents degrees on the color wheel familiar to most people. Red is 0 (degrees), green is 120, and blue is 240. ![qcolor-hue.png](qcolor-hue.png)
///
/// * S, for saturation, is in the range 0 to 255, and the bigger it is, the stronger the color is. Grayish colors have saturation near 0; very strong colors have saturation near 255. ![qcolor-saturation.png](qcolor-saturation.png)
///
/// * V, for value, is in the range 0 to 255 and represents lightness or brightness of the color. 0 is black; 255 is as far from black as possible. ![qcolor-value.png](qcolor-value.png)
///
/// Here are some examples: pure red is H=0, S=255, V=255; a dark red,
/// moving slightly towards the magenta, could be H=350 (equivalent to
/// -10), S=255, V=180; a grayish light red could have H about 0 (say
/// 350-359 or 0-10), S about 50-100, and S=255.
///
/// Qt returns a hue value of -1 for achromatic colors. If you pass a
/// hue value that is too large, Qt forces it into range. Hue 360 or 720 is
/// treated as 0; hue 540 is treated as 180.
///
/// In addition to the standard HSV model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
///
///
/// # The HSL Color Model
///
/// HSL is similar to HSV, however instead of the Value parameter, HSL
/// specifies a Lightness parameter.
///
/// # The CMYK Color Model
///
/// While the RGB and HSV color models are used for display on
/// computer monitors, the CMYK model is used in the four-color
/// printing process of printing presses and some hard-copy
/// devices.
///
/// CMYK has four components, all in the range 0-255: cyan (C),
/// magenta (M), yellow (Y) and black (K). Cyan, magenta and yellow
/// are called subtractive colors; the CMYK color model creates color
/// by starting with a white surface and then subtracting color by
/// applying the appropriate components. While combining cyan, magenta
/// and yellow gives the color black, subtracting one or more will
/// yield any other color. When combined in various percentages, these
/// three colors can create the entire spectrum of colors.
///
/// Mixing 100 percent of cyan, magenta and yellow *does* produce
/// black, but the result is unsatisfactory since it wastes ink,
/// increases drying time, and gives a muddy colour when printing. For
/// that reason, black is added in professional printing to provide a
/// solid black tone; hence the term 'four color process'.
///
/// In addition to the standard CMYK model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
///
///
/// **See also:** [`Palette`]
/// [`Brush`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
struct Color {
    ///
    /// Returns `true` if the color is valid; otherwise returns `false.`
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    is_valid() -> bool,
    ///
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// Returns the name of the color in the specified *format.*
    ///
    /// **See also:** [`set_named_color()`]
    /// NameFormat
    name() -> String,
    ///
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// Returns the name of the color in the specified *format.*
    ///
    /// **See also:** [`set_named_color()`]
    /// NameFormat
    [org_name(name)]
    name_2(format: Color::NameFormat) -> String,
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** [`q_color()`]
    /// [`name()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    set_named_color(name: String),
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** [`q_color()`]
    /// [`name()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    //[org_name(setNamedColor)]
    //set_named_color_2(name: StringViewType),
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** [`q_color()`]
    /// [`name()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    //[org_name(setNamedColor)]
    //set_named_color_3(name: Latin1StringType),
    //
    // Returns a QStringList containing the color names Qt knows about.
    //
    // **See also:** {QColor#Predefined Colors}{Predefined Colors}
    //[static] color_names() -> [String],
    ///
    /// Returns how the color was specified.
    ///
    /// **See also:** Spec
    /// [`convert_to()`]
    spec() -> Color::Spec,
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** [`set_alpha()`]
    /// [`alpha_f()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** [`set_alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    alpha() -> i32,
    ///
    /// Sets the alpha of this color to *alpha.* Integer alpha is specified in the
    /// range 0-255.
    ///
    /// **See also:** [`alpha()`]
    /// [`alpha_f()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    ///
    /// **See also:** [`alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    set_alpha(alpha: i32),
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** [`set_alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    alpha_f() -> f32,
    ///
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    ///
    /// **See also:** [`alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    set_alpha_f(alpha: f32),
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** [`set_red()`]
    /// [`red_f()`]
    /// [`get_rgb()`]
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** [`set_red_f()`]
    /// [`red()`]
    /// [`get_rgb_f()`]
    red() -> i32,
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** [`set_green()`]
    /// [`green_f()`]
    /// [`get_rgb()`]
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** [`set_green_f()`]
    /// [`green()`]
    /// [`get_rgb_f()`]
    green() -> i32,
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** [`set_blue()`]
    /// [`blue_f()`]
    /// [`get_rgb()`]
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** [`set_blue_f()`]
    /// [`blue()`]
    /// [`get_rgb_f()`]
    blue() -> i32,
    ///
    /// Sets the red color component of this color to *red.* Integer components
    /// are specified in the range 0-255.
    ///
    /// **See also:** [`red()`]
    /// [`red_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`red_f()`]
    /// [`red()`]
    /// [`set_rgb_f()`]
    set_red(red: i32),
    ///
    /// Sets the green color component of this color to *green.* Integer
    /// components are specified in the range 0-255.
    ///
    /// **See also:** [`green()`]
    /// [`green_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`green_f()`]
    /// [`green()`]
    /// [`set_rgb_f()`]
    set_green(green: i32),
    ///
    /// Sets the blue color component of this color to *blue.* Integer components
    /// are specified in the range 0-255.
    ///
    /// **See also:** [`blue()`]
    /// [`blue_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`blue_f()`]
    /// [`blue()`]
    /// [`set_rgb_f()`]
    set_blue(blue: i32),
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** [`set_red_f()`]
    /// [`red()`]
    /// [`get_rgb_f()`]
    red_f() -> f32,
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** [`set_green_f()`]
    /// [`green()`]
    /// [`get_rgb_f()`]
    green_f() -> f32,
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** [`set_blue_f()`]
    /// [`blue()`]
    /// [`get_rgb_f()`]
    blue_f() -> f32,
    ///
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`red_f()`]
    /// [`red()`]
    /// [`set_rgb_f()`]
    set_red_f(red: f32),
    ///
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`green_f()`]
    /// [`green()`]
    /// [`set_rgb_f()`]
    set_green_f(green: f32),
    ///
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`blue_f()`]
    /// [`blue()`]
    /// [`set_rgb_f()`]
    set_blue_f(blue: f32),
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    ///
    /// **See also:** [`rgb()`]
    /// [`set_rgb()`]
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the red(), green(),
    /// blue() and alpha() functions.
    ///
    /// **See also:** [`rgb()`]
    /// [`set_rgb()`]
    //get_rgb(r: *i32, g: *i32, b: *i32, a: *i32),
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb()`]
    /// [`set_rgb_f()`]
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** [`rgba()`]
    /// [`rgb()`]
    /// [`set_rgba64()`]
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgba64()`]
    ///
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    set_rgb(r: i32, g: i32, b: i32, a: i32),
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    ///
    /// **See also:** [`rgb()`]
    /// [`set_rgb()`]
    //get_rgb_f(r: *f32, g: *f32, b: *f32, a: *f32),
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb_f()`]
    /// [`set_rgb()`]
    set_rgb_f(r: f32, g: f32, b: f32, a: f32),
    //
    // Returns the RGB64 value of the color, including its alpha.
    //
    // For an invalid color, the alpha value of the returned color is unspecified.
    //
    // **See also:** [`set_rgba64()`]
    // [`rgba()`]
    // [`rgb()`]
    //rgba64() -> Rgba64,
    //
    // Sets the RGB64 value to *rgba,* including its alpha.
    //
    // **See also:** [`set_rgba()`]
    // [`rgba64()`]
    //set_rgba64(rgba: Rgba64Type),
    ///
    /// Returns the RGB value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgb()`]
    /// [`rgba64()`]
    ///
    /// Returns the RGB64 value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba64()`]
    /// [`rgba()`]
    /// [`rgb()`]
    //rgba() -> Rgb,
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** [`rgba()`]
    /// [`rgb()`]
    /// [`set_rgba64()`]
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgba64()`]
    //set_rgba(rgba: RgbType),
    ///
    /// Returns the RGB value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgb()`]
    /// [`rgba64()`]
    ///
    /// Returns the RGB64 value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba64()`]
    /// [`rgba()`]
    /// [`rgb()`]
    ///
    /// Returns the RGB value of the color. The alpha value is opaque.
    ///
    /// **See also:** [`get_rgb()`]
    /// [`rgba()`]
    //rgb() -> Rgb,
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb()`]
    /// [`set_rgb_f()`]
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** [`rgba()`]
    /// [`rgb()`]
    /// [`set_rgba64()`]
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgba64()`]
    ///
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    //[org_name(setRgb)]
    //set_rgb_2(rgb: RgbType),
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_hue()`]
    /// [`hue_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_hue_f()`]
    /// [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hue() -> i32,
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_saturation()`]
    /// [`saturation_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_saturation_f()`]
    /// [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    saturation() -> i32,
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    hsv_hue() -> i32,
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hsv_saturation() -> i32,
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** [`value_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    value() -> i32,
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_hue_f()`]
    /// [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hue_f() -> f32,
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_saturation_f()`]
    /// [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    saturation_f() -> f32,
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    hsv_hue_f() -> f32,
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    hsv_saturation_f() -> f32,
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    value_f() -> f32,
    //
    // Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    // saturation, value, and alpha-channel (transparency) components of the
    // color's HSV value.
    //
    // These components can be retrieved individually using the hueF(),
    // saturationF(), valueF() and alphaF() functions.
    //
    // **See also:** [`set_hsv()`]
    // {QColor#The HSV Color Model}{The HSV Color Model}
    //
    // Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    // saturation, value, and alpha-channel (transparency) components of the
    // color's HSV value.
    //
    // These components can be retrieved individually using the hue(),
    // saturation(), value() and alpha() functions.
    //
    // **See also:** [`set_hsv()`]
    // {QColor#The HSV Color Model}{The HSV Color Model}
    //get_hsv(h: *i32, s: *i32, v: *i32, a: *i32),
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsv_f()`]
    /// [`set_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    ///
    /// **See also:** [`get_hsv()`]
    /// [`set_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    set_hsv(h: i32, s: i32, v: i32, a: i32),
    //
    // Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    // saturation, value, and alpha-channel (transparency) components of the
    // color's HSV value.
    //
    // These components can be retrieved individually using the hueF(),
    // saturationF(), valueF() and alphaF() functions.
    //
    // **See also:** [`set_hsv()`]
    // {QColor#The HSV Color Model}{The HSV Color Model}
    //get_hsv_f(h: *f32, s: *f32, v: *f32, a: *f32),
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsv_f()`]
    /// [`set_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    set_hsv_f(h: f32, s: f32, v: f32, a: f32),
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** [`cyan_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** [`cyan()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    cyan() -> i32,
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** [`magenta_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** [`magenta()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    magenta() -> i32,
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** [`yellow_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** [`yellow()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    yellow() -> i32,
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** [`black_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** [`black()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    black() -> i32,
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** [`cyan()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    cyan_f() -> f32,
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** [`magenta()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    magenta_f() -> f32,
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** [`yellow()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    yellow_f() -> f32,
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** [`black()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    black_f() -> f32,
    //
    // Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    // cyan, magenta, yellow, black, and alpha-channel (transparency) components
    // of the color's CMYK value.
    //
    // These components can be retrieved individually using the cyan(), magenta(),
    // yellow(), black() and alpha() functions.
    //
    // **See also:** [`set_cmyk()`]
    // {QColor#The CMYK Color Model}{The CMYK Color Model}
    //
    // Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    // cyan, magenta, yellow, black, and alpha-channel (transparency) components
    // of the color's CMYK value.
    //
    // These components can be retrieved individually using the cyanF(),
    // magentaF(), yellowF(), blackF() and alphaF() functions.
    //
    // **See also:** [`set_cmyk_f()`]
    // {QColor#The CMYK Color Model}{The CMYK Color Model}
    //get_cmyk(c: *i32, m: *i32, y: *i32, k: *i32, a: *i32),
    ///
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`get_cmyk()`]
    /// [`set_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_cmyk_f()`]
    /// [`set_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    set_cmyk(c: i32, m: i32, y: i32, k: i32, a: i32),
    //
    // Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    // cyan, magenta, yellow, black, and alpha-channel (transparency) components
    // of the color's CMYK value.
    //
    // These components can be retrieved individually using the cyanF(),
    // magentaF(), yellowF(), blackF() and alphaF() functions.
    //
    // **See also:** [`set_cmyk_f()`]
    // {QColor#The CMYK Color Model}{The CMYK Color Model}
    //get_cmyk_f(c: *f32, m: *f32, y: *f32, k: *f32, a: *f32),
    ///
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_cmyk_f()`]
    /// [`set_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    set_cmyk_f(c: f32, m: f32, y: f32, k: f32, a: f32),
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`get_hsl_f()`]
    /// [`get_hsl()`]
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsl_f()`]
    hsl_hue() -> i32,
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsl_f()`]
    hsl_saturation() -> i32,
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`lightness_f()`]
    /// [`get_hsl()`]
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsl_f()`]
    lightness() -> i32,
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsl_f()`]
    hsl_hue_f() -> f32,
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsl_f()`]
    hsl_saturation_f() -> f32,
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsl_f()`]
    lightness_f() -> f32,
    //
    // Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    // saturation, lightness, and alpha-channel (transparency) components of the
    // color's HSL value.
    //
    // These components can be retrieved individually using the hslHueF(),
    // hslSaturationF(), lightnessF() and alphaF() functions.
    //
    // **See also:** [`set_hsl()`]
    //
    // Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    // saturation, lightness, and alpha-channel (transparency) components of the
    // color's HSL value.
    //
    // These components can be retrieved individually using the hslHue(),
    // hslSaturation(), lightness() and alpha() functions.
    //
    // **See also:** [`set_hsl()`]
    //get_hsl(h: *i32, s: *i32, l: *i32, a: *i32),
    ///
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsl_f()`]
    /// [`set_hsl()`]
    ///
    /// Sets a HSL color value; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    ///
    /// **See also:** [`get_hsl()`]
    /// [`set_hsl_f()`]
    set_hsl(h: i32, s: i32, l: i32, a: i32),
    //
    // Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    // saturation, lightness, and alpha-channel (transparency) components of the
    // color's HSL value.
    //
    // These components can be retrieved individually using the hslHueF(),
    // hslSaturationF(), lightnessF() and alphaF() functions.
    //
    // **See also:** [`set_hsl()`]
    //get_hsl_f(h: *f32, s: *f32, l: *f32, a: *f32),
    ///
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsl_f()`]
    /// [`set_hsl()`]
    set_hsl_f(h: f32, s: f32, l: f32, a: f32),
    ///
    /// Create and returns an RGB QColor based on this color.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    to_rgb() -> Color,
    ///
    /// Creates and returns an HSV QColor based on this color.
    ///
    /// **See also:** [`from_hsv()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    to_hsv() -> Color,
    ///
    /// Creates and returns a CMYK QColor based on this color.
    ///
    /// **See also:** [`from_cmyk()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    to_cmyk() -> Color,
    ///
    /// Creates and returns an HSL QColor based on this color.
    ///
    /// **See also:** [`from_hsl()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    to_hsl() -> Color,
    ///
    /// Creates a copy of *this* color in the format specified by *colorSpec.*
    ///
    /// **See also:** [`spec()`]
    /// [`to_cmyk()`]
    /// [`to_hsv()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    convert_to(color_spec: Color::Spec) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    ///
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    ///
    /// **See also:** [`from_rgba()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`to_rgb()`]
    /// [`from_rgba64()`]
    /// [`from_rgb_f()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    //[static] from_rgb(rgb: RgbType) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    //[static] from_rgba(rgba: RgbType) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    ///
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    ///
    /// **See also:** [`from_rgba()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`to_rgb()`]
    /// [`from_rgba64()`]
    /// [`from_rgb_f()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    [org_name(fromRgb)]
    [static] from_rgb_2(r: i32, g: i32, b: i32, a: i32) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    [static] from_rgb_f(r: f32, g: f32, b: f32, a: f32) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    [static] from_rgba64(r: u16, g: u16, b: u16, a: u16) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    //[org_name(fromRgba64)]
    //[static] from_rgba64_2(rgba: Rgba64Type) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// The value of *s,* *v,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    ///
    /// **See also:** [`to_hsv()`]
    /// [`from_hsv_f()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsv()`]
    /// [`from_hsv()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    [static] from_hsv(h: i32, s: i32, v: i32, a: i32) -> Color,
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsv()`]
    /// [`from_hsv()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    [static] from_hsv_f(h: f32, s: f32, v: f32, a: f32) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`to_cmyk()`]
    /// [`from_cmyk_f()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_cmyk()`]
    /// [`from_cmyk()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    [static] from_cmyk(c: i32, m: i32, y: i32, k: i32, a: i32) -> Color,
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_cmyk()`]
    /// [`from_cmyk()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    [static] from_cmyk_f(c: f32, m: f32, y: f32, k: f32, a: f32) -> Color,
    ///
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// The value of *s,* *l,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    ///
    /// **See also:** [`to_hsl()`]
    /// [`from_hsl_f()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsl()`]
    /// [`from_hsl()`]
    /// [`is_valid()`]
    [static] from_hsl(h: i32, s: i32, l: i32, a: i32) -> Color,
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsl()`]
    /// [`from_hsl()`]
    /// [`is_valid()`]
    [static] from_hsl_f(h: f32, s: f32, l: f32, a: f32) -> Color,
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`lightness_f()`]
    /// [`get_hsl()`]
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsl_f()`]
    ///
    /// Returns a lighter (or darker) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`darker()`]
    /// [`is_valid()`]
    ///
    /// Use lighter( *factor)* instead.
    light(f: i32) -> Color,
    ///
    /// Returns a lighter (or darker) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`darker()`]
    /// [`is_valid()`]
    lighter(f: i32) -> Color,
    ///
    /// Returns a darker (or lighter) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`lighter()`]
    /// [`is_valid()`]
    ///
    /// Use darker( *factor)* instead.
    dark(f: i32) -> Color,
    ///
    /// Returns a darker (or lighter) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`lighter()`]
    /// [`is_valid()`]
    darker(f: i32) -> Color,
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    [static] is_valid_color(name: String) -> bool,
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    //[org_name(isValidColor)]
    //[static] is_valid_color_2(arg0: StringViewType) -> bool,
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    //[org_name(isValidColor)]
    //[static] is_valid_color_3(arg0: Latin1StringType) -> bool,
}

[org_name(QColor)]
enum Spec {
    Invalid,
    Rgb,
    Hsv,
    Cmyk,
    Hsl,
}

[org_name(QColor)]
enum NameFormat {
    /// #RRGGBB A "#" character followed by three two-digit hexadecimal numbers (i.e. `#RRGGBB` ).
    HexRgb,
    /// #AARRGGBB A "#" character followed by four two-digit hexadecimal numbers (i.e. `#AARRGGBB` ).
    HexArgb,
}

// vim: syntax=rust expandtab ts=4 sw=4
