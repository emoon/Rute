///
/// Qt contains a set of QStyle subclasses that emulate the styles of
/// the different platforms supported by Qt (QWindowsStyle,
/// QMacStyle etc.). By default, these styles are built
/// into the Qt GUI module. Styles can also be made available as
/// plugins.
///
/// Qt's built-in widgets use QStyle to perform nearly all of their
/// drawing, ensuring that they look exactly like the equivalent
/// native widgets. The diagram below shows a QComboBox in nine
/// different styles.
///
/// ![Nine combo boxes](qstyle-comboboxes.png)
///
/// Topics:
///
/// # Setting a Style
///
/// The style of the entire application can be set using the
/// QApplication::setStyle() function. It can also be specified by the
/// user of the application, using the `-style` command-line option:
///
/// If no style is specified, Qt will choose the most appropriate
/// style for the user's platform or desktop environment.
///
/// A style can also be set on an individual widget using the
/// QWidget::setStyle() function.
///
/// # Developing Style-Aware Custom Widgets
///
/// If you are developing custom widgets and want them to look good on
/// all platforms, you can use QStyle functions to perform parts of
/// the widget drawing, such as drawItemText(), drawItemPixmap(),
/// drawPrimitive(), drawControl(), and drawComplexControl().
///
/// Most QStyle draw functions take four arguments:
/// * an enum value specifying which graphical element to draw
/// * a QStyleOption specifying how and where to render that element
/// * a QPainter that should be used to draw the element
/// * a QWidget on which the drawing is performed (optional)
///
/// For example, if you want to draw a focus rectangle on your
/// widget, you can write:
///
/// QStyle gets all the information it needs to render the graphical
/// element from QStyleOption. The widget is passed as the last
/// argument in case the style needs it to perform special effects
/// (such as animated default buttons on MacOS ), but it isn't
/// mandatory. In fact, you can use QStyle to draw on any paint
/// device, not just widgets, by setting the QPainter properly.
///
/// QStyleOption has various subclasses for the various types of
/// graphical elements that can be drawn. For example,
/// PE_FrameFocusRect expects a QStyleOptionFocusRect argument.
///
/// To ensure that drawing operations are as fast as possible,
/// QStyleOption and its subclasses have public data members. See the
/// QStyleOption class documentation for details on how to use it.
///
/// For convenience, Qt provides the QStylePainter class, which
/// combines a QStyle, a QPainter, and a QWidget. This makes it
/// possible to write
///
/// ...
///
/// instead of
///
/// ...
///
/// # Creating a Custom Style
///
/// You can create a custom look and feel for your application by
/// creating a custom style. There are two approaches to creating a
/// custom style. In the static approach, you either choose an
/// existing QStyle class, subclass it, and reimplement virtual
/// functions to provide the custom behavior, or you create an entire
/// QStyle class from scratch. In the dynamic approach, you modify the
/// behavior of your system style at runtime. The static approach is
/// described below. The dynamic approach is described in QProxyStyle.
///
/// The first step in the static approach is to pick one of the styles
/// provided by Qt from which you will build your custom style. Your
/// choice of QStyle class will depend on which style resembles your
/// desired style the most. The most general class that you can use as
/// a base is QCommonStyle (not QStyle). This is because Qt requires
/// its styles to be [QCommonStyle](QCommonStyle)
/// s.
///
/// Depending on which parts of the base style you want to change,
/// you must reimplement the functions that are used to draw those
/// parts of the interface. To illustrate this, we will modify the
/// look of the spin box arrows drawn by QWindowsStyle. The arrows
/// are *primitive elements* that are drawn by the drawPrimitive()
/// function, so we need to reimplement that function. We need the
/// following class declaration:
///
/// To draw its up and down arrows, QSpinBox uses the
/// PE_IndicatorSpinUp and PE_IndicatorSpinDown primitive elements.
/// Here's how to reimplement the drawPrimitive() function to draw
/// them differently:
///
/// Notice that we don't use the `widget` argument, except to pass it
/// on to the QWindowStyle::drawPrimitive() function. As mentioned
/// earlier, the information about what is to be drawn and how it
/// should be drawn is specified by a QStyleOption object, so there is
/// no need to ask the widget.
///
/// If you need to use the `widget` argument to obtain additional
/// information, be careful to ensure that it isn't 0 and that it is
/// of the correct type before using it. For example:
///
/// ...
///
/// When implementing a custom style, you cannot assume that the
/// widget is a QSpinBox just because the enum value is called
/// PE_IndicatorSpinUp or PE_IndicatorSpinDown.
///
/// The documentation for the [Styles](widgets/styles)
/// example
/// covers this topic in more detail.
///
/// **Warning**: Qt style sheets are currently not supported for custom QStyle
/// subclasses. We plan to address this in some future release.
///
/// # Using a Custom Style
///
/// There are several ways of using a custom style in a Qt
/// application. The simplest way is to pass the custom style to the
/// QApplication::setStyle() static function before creating the
/// QApplication object:
///
/// You can call QApplication::setStyle() at any time, but by calling
/// it before the constructor, you ensure that the user's preference,
/// set using the `-style` command-line option, is respected.
///
/// You may want to make your custom style available for use in other
/// applications, which may not be yours and hence not available for
/// you to recompile. The Qt Plugin system makes it possible to create
/// styles as plugins. Styles created as plugins are loaded as shared
/// objects at runtime by Qt itself. Please refer to the [Qt Plugin](How%20to%20Create%20Qt%20Plugins)
///
/// documentation for more information on how to go about creating a style
/// plugin.
///
/// Compile your plugin and put it into Qt's `plugins/styles`
/// directory. We now have a pluggable style that Qt can load
/// automatically. To use your new style with existing applications,
/// simply start the application with the following argument:
///
/// The application will use the look and feel from the custom style you
/// implemented.
///
/// # Right-to-Left Desktops
///
/// Languages written from right to left (such as Arabic and Hebrew)
/// usually also mirror the whole layout of widgets, and require the
/// light to come from the screen's top-right corner instead of
/// top-left.
///
/// If you create a custom style, you should take special care when
/// drawing asymmetric elements to make sure that they also look
/// correct in a mirrored layout. An easy way to test your styles is
/// to run applications with the `-reverse` command-line option or
/// to call QApplication::setLayoutDirection() in your `main()`
/// function.
///
/// Here are some things to keep in mind when making a style work well in a
/// right-to-left environment:
///
/// * subControlRect() and subElementRect() return rectangles in screen coordinates
/// * QStyleOption::direction indicates in which direction the item should be drawn in
/// * If a style is not right-to-left aware it will display items as if it were left-to-right
/// * visualRect(), visualPos(), and visualAlignment() are helpful functions that will translate from logical to screen representations.
/// * alignedRect() will return a logical rect aligned for the current direction
///
/// # Styles in Item Views
///
/// The painting of items in views is performed by a delegate. Qt's
/// default delegate, QStyledItemDelegate, is also used for calculating bounding
/// rectangles of items, and their sub-elements for the various kind
/// of item [data roles](Qt::ItemDataRole)
///
/// QStyledItemDelegate supports. See the QStyledItemDelegate class
/// description to find out which datatypes and roles are supported. You
/// can read more about item data roles in [Model/View Programming](Model/View%20Programming)
///
///
/// When QStyledItemDelegate paints its items, it draws
/// CE_ItemViewItem, and calculates their size with CT_ItemViewItem.
/// Note also that it uses SE_ItemViewItemText to set the size of
/// editors. When implementing a style to customize drawing of item
/// views, you need to check the implementation of QCommonStyle (and
/// any other subclasses from which your style
/// inherits). This way, you find out which and how
/// other style elements are painted, and you can then reimplement the
/// painting of elements that should be drawn differently.
///
/// We include a small example where we customize the drawing of item
/// backgrounds.
///
/// The primitive element PE_PanelItemViewItem is responsible for
/// painting the background of items, and is called from
/// [QCommonStyle](QCommonStyle)
/// 's implementation of CE_ItemViewItem.
///
/// To add support for drawing of new datatypes and item data roles,
/// it is necessary to create a custom delegate. But if you only
/// need to support the datatypes implemented by the default
/// delegate, a custom style does not need an accompanying
/// delegate. The QStyledItemDelegate class description gives more
/// information on custom delegates.
///
/// The drawing of item view headers is also done by the style, giving
/// control over size of header items and row and column sizes.
///
/// **See also:** [`StyleOption`]
/// [`StylePainter`]
/// {Styles Example}
/// {Styles and Style Aware Widgets}
/// [`StyledItemDelegate`]
/// {Styling}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
[attributes(NoCppClone)]
struct Style : Object {
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    //[event]
    polish(widget: *WidgetType),
    ///
    /// Uninitialize the given *widget* 's appearance.
    ///
    /// This function is the counterpart to polish(). It is called for
    /// every polished widget whenever the style is dynamically changed;
    /// the former style has to unpolish its settings before the new style
    /// can polish them again.
    ///
    /// Note that unpolish() will only be called if the widget is
    /// destroyed. This can cause problems in some cases, e.g, if you
    /// remove a widget from the UI, cache it, and then reinsert it after
    /// the style has changed; some of Qt's classes cache their widgets.
    ///
    /// **See also:** [`polish()`]
    ///
    /// **Overloads**
    /// Uninitialize the given *application.*
    //[event]
    unpolish(widget: *WidgetType),
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    [org_name(polish)]
    //[event]
    polish_2(application: *ApplicationType),
    ///
    /// Uninitialize the given *widget* 's appearance.
    ///
    /// This function is the counterpart to polish(). It is called for
    /// every polished widget whenever the style is dynamically changed;
    /// the former style has to unpolish its settings before the new style
    /// can polish them again.
    ///
    /// Note that unpolish() will only be called if the widget is
    /// destroyed. This can cause problems in some cases, e.g, if you
    /// remove a widget from the UI, cache it, and then reinsert it after
    /// the style has changed; some of Qt's classes cache their widgets.
    ///
    /// **See also:** [`polish()`]
    ///
    /// **Overloads**
    /// Uninitialize the given *application.*
    [org_name(unpolish)]
    //[event]
    unpolish_2(application: *ApplicationType),
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    [org_name(polish)]
    //[event]
    polish_3(palette: &PaletteType),
    ///
    /// Returns the area within the given *rectangle* in which to draw
    /// the provided *text* according to the specified font *metrics*
    /// and *alignment.* The *enabled* parameter indicates whether or
    /// not the associated item is enabled.
    ///
    /// If the given *rectangle* is larger than the area needed to render
    /// the *text,* the rectangle that is returned will be offset within
    /// *rectangle* according to the specified *alignment.* For
    /// example, if *alignment* is Qt::AlignCenter, the returned
    /// rectangle will be centered within *rectangle.* If the given *rectangle* is smaller than the area needed, the returned rectangle
    /// will be the smallest rectangle large enough to render the *text.*
    ///
    /// **See also:** [`t::alignment()`]
    //[event]
    item_text_rect(fm: &FontMetricsType, r: &RectType, flags: i32, enabled: bool, text: String) -> Rect,
    ///
    /// Returns the area within the given *rectangle* in which to draw
    /// the specified *pixmap* according to the defined *alignment.*
    //[event]
    item_pixmap_rect(r: &RectType, flags: i32, pixmap: &PixmapType) -> Rect,
    ///
    /// Draws the given *text* in the specified *rectangle* using the
    /// provided *painter* and *palette.*
    ///
    /// The text is drawn using the painter's pen, and aligned and wrapped
    /// according to the specified *alignment.* If an explicit *textRole* is specified, the text is drawn using the *palette's*
    /// color for the given role. The *enabled* parameter indicates
    /// whether or not the item is enabled; when reimplementing this
    /// function, the *enabled* parameter should influence how the item is
    /// drawn.
    ///
    /// **See also:** [`t::alignment()`]
    /// [`draw_item_pixmap()`]
    //[event]
    draw_item_text(painter: *PainterType, rect: &RectType, flags: i32, pal: &PaletteType, enabled: bool, text: String, text_role: Palette::ColorRole),
    ///
    /// const QPixmap &pixmap) const
    ///
    /// Draws the given *pixmap* in the specified *rectangle,* according
    /// to the specified *alignment,* using the provided *painter.*
    ///
    /// **See also:** [`draw_item_text()`]
    //[event]
    draw_item_pixmap(painter: *PainterType, rect: &RectType, alignment: i32, pixmap: &PixmapType),
    ///
    /// Returns the style's standard palette.
    ///
    /// Note that on systems that support system colors, the style's
    /// standard palette is not used. In particular, the Windows
    /// Vista and Mac styles do not use the standard palette, but make
    /// use of native theme engines. With these styles, you should not set
    /// the palette with QApplication::setPalette().
    ///
    /// **See also:** [`Application::set_palette`]
    //[event]
    standard_palette() -> Palette,
    ///
    /// Draws the given primitive *element* with the provided *painter* using the style
    /// options specified by *option.*
    ///
    /// The *widget* argument is optional and may contain a widget that may
    /// aid in drawing the primitive element.
    ///
    /// The table below is listing the primitive elements and their
    /// associated style option subclasses. The style options contain all
    /// the parameters required to draw the elements, including
    /// QStyleOption::state which holds the style flags that are used when
    /// drawing. The table also describes which flags that are set when
    /// casting the given option to the appropriate subclass.
    ///
    /// Note that if a primitive element is not listed here, it is because
    /// it uses a plain QStyleOption object.
    ///
    /// * Primitive Element
    /// * QStyleOption Subclass
    /// * Style Flag
    /// * Remark
    /// * [PE_FrameFocusRect](PE_FrameFocusRect)
    ///
    /// * [QStyleOptionFocusRect](QStyleOptionFocusRect)
    ///
    /// * [State_FocusAtBorder](State_FocusAtBorder)
    ///
    /// * Whether the focus is is at the border or inside the widget.
    /// * {1,2} [PE_IndicatorCheckBox](PE_IndicatorCheckBox)
    ///
    /// * {1,2} [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_NoChange](State_NoChange)
    ///
    /// * Indicates a "tri-state" checkbox.
    /// * [State_On](State_On)
    ///
    /// * Indicates the indicator is checked.
    /// * [PE_IndicatorRadioButton](PE_IndicatorRadioButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_On](State_On)
    ///
    /// * Indicates that a radio button is selected.
    /// * [State_NoChange](State_NoChange)
    ///
    /// * Indicates a "tri-state" controller.
    /// * [State_Enabled](State_Enabled)
    ///
    /// * Indicates the controller is enabled.
    /// * {1,4} [PE_IndicatorBranch](PE_IndicatorBranch)
    ///
    /// * {1,4} [QStyleOption](QStyleOption)
    ///
    /// * [State_Children](State_Children)
    ///
    /// * Indicates that the control for expanding the tree to show child items, should be drawn.
    /// * [State_Item](State_Item)
    ///
    /// * Indicates that a horizontal branch (to show a child item), should be drawn.
    /// * [State_Open](State_Open)
    ///
    /// * Indicates that the tree branch is expanded.
    /// * [State_Sibling](State_Sibling)
    ///
    /// * Indicates that a vertical line (to show a sibling item), should be drawn.
    /// * [PE_IndicatorHeaderArrow](PE_IndicatorHeaderArrow)
    ///
    /// * [QStyleOptionHeader](QStyleOptionHeader)
    ///
    /// * [State_UpArrow](State_UpArrow)
    ///
    /// * Indicates that the arrow should be drawn up; otherwise it should be down.
    /// * [PE_FrameGroupBox,](PE_FrameGroupBox,)
    /// [PE_Frame,](PE_Frame,)
    /// [PE_FrameLineEdit,](PE_FrameLineEdit,)
    /// [PE_FrameMenu,](PE_FrameMenu,)
    /// [PE_FrameDockWidget,](PE_FrameDockWidget,)
    /// [PE_FrameWindow](PE_FrameWindow)
    ///
    /// * [QStyleOptionFrame](QStyleOptionFrame)
    ///
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Indicates that the Frame should be sunken.
    /// * [PE_IndicatorToolBarHandle](PE_IndicatorToolBarHandle)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [State_Horizontal](State_Horizontal)
    ///
    /// * Indicates that the window handle is horizontal instead of vertical.
    /// * [PE_IndicatorSpinPlus,](PE_IndicatorSpinPlus,)
    /// [PE_IndicatorSpinMinus,](PE_IndicatorSpinMinus,)
    /// [PE_IndicatorSpinUp,](PE_IndicatorSpinUp,)
    /// [PE_IndicatorSpinDown,](PE_IndicatorSpinDown,)
    ///
    /// * [QStyleOptionSpinBox](QStyleOptionSpinBox)
    ///
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Indicates that the button is pressed.
    /// * {1,5} [PE_PanelButtonCommand](PE_PanelButtonCommand)
    ///
    /// * {1,5} [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_Enabled](State_Enabled)
    ///
    /// * Set if the button is enabled.
    /// * [State_HasFocus](State_HasFocus)
    ///
    /// * Set if the button has input focus.
    /// * [State_Raised](State_Raised)
    ///
    /// * Set if the button is not down, not on and not flat.
    /// * [State_On](State_On)
    ///
    /// * Set if the button is a toggle button and is toggled on.
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Set if the button is down (i.e., the mouse button or the space bar is pressed on the button).
    ///
    /// **See also:** [`draw_complex_control()`]
    /// [`draw_control()`]
    //[event]
    draw_primitive(pe: Style::PrimitiveElement, opt: *StyleOptionType, p: *PainterType, w: *WidgetType),
    ///
    /// Returns the sub-area for the given *element* as described in the
    /// provided style *option.* The returned rectangle is defined in
    /// screen coordinates.
    ///
    /// The *widget* argument is optional and can be used to aid
    /// determining the area. The QStyleOption object can be cast to the
    /// appropriate type using the qstyleoption_cast() function. See the
    /// table below for the appropriate *option* casts:
    ///
    /// * Sub Element
    /// * QStyleOption Subclass
    /// * [SE_PushButtonContents](SE_PushButtonContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_PushButtonFocusRect](SE_PushButtonFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxIndicator](SE_CheckBoxIndicator)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxContents](SE_CheckBoxContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxFocusRect](SE_CheckBoxFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonIndicator](SE_RadioButtonIndicator)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonContents](SE_RadioButtonContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonFocusRect](SE_RadioButtonFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_ComboBoxFocusRect](SE_ComboBoxFocusRect)
    ///
    /// * [QStyleOptionComboBox](QStyleOptionComboBox)
    ///
    /// * [SE_ProgressBarGroove](SE_ProgressBarGroove)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [SE_ProgressBarContents](SE_ProgressBarContents)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [SE_ProgressBarLabel](SE_ProgressBarLabel)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    //[event]
    sub_element_rect(sub_element: Style::SubElement, option: *StyleOptionType, widget: *WidgetType) -> Rect,
    ///
    /// Returns the size of the element described by the specified
    /// *option* and *type,* based on the provided *contentsSize.*
    ///
    /// The *option* argument is a pointer to a QStyleOption or one of
    /// its subclasses. The *option* can be cast to the appropriate type
    /// using the qstyleoption_cast() function. The *widget* is an
    /// optional argument and can contain extra information used for
    /// calculating the size.
    ///
    /// See the table below for the appropriate *option* casts:
    ///
    /// * Contents Type
    /// * QStyleOption Subclass
    /// * [CT_CheckBox](CT_CheckBox)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_ComboBox](CT_ComboBox)
    ///
    /// * [QStyleOptionComboBox](QStyleOptionComboBox)
    ///
    /// * [CT_GroupBox](CT_GroupBox)
    ///
    /// * [QStyleOptionGroupBox](QStyleOptionGroupBox)
    ///
    /// * [CT_HeaderSection](CT_HeaderSection)
    ///
    /// * [QStyleOptionHeader](QStyleOptionHeader)
    ///
    /// * [CT_ItemViewItem](CT_ItemViewItem)
    ///
    /// * [QStyleOptionViewItem](QStyleOptionViewItem)
    ///
    /// * [CT_LineEdit](CT_LineEdit)
    ///
    /// * [QStyleOptionFrame](QStyleOptionFrame)
    ///
    /// * [CT_MdiControls](CT_MdiControls)
    ///
    /// * [QStyleOptionComplex](QStyleOptionComplex)
    ///
    /// * [CT_Menu](CT_Menu)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_MenuItem](CT_MenuItem)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_MenuBar](CT_MenuBar)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_MenuBarItem](CT_MenuBarItem)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_ProgressBar](CT_ProgressBar)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [CT_PushButton](CT_PushButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_RadioButton](CT_RadioButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_ScrollBar](CT_ScrollBar)
    ///
    /// * [QStyleOptionSlider](QStyleOptionSlider)
    ///
    /// * [CT_SizeGrip](CT_SizeGrip)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_Slider](CT_Slider)
    ///
    /// * [QStyleOptionSlider](QStyleOptionSlider)
    ///
    /// * [CT_SpinBox](CT_SpinBox)
    ///
    /// * [QStyleOptionSpinBox](QStyleOptionSpinBox)
    ///
    /// * [CT_Splitter](CT_Splitter)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_TabBarTab](CT_TabBarTab)
    ///
    /// * [QStyleOptionTab](QStyleOptionTab)
    ///
    /// * [CT_TabWidget](CT_TabWidget)
    ///
    /// * [QStyleOptionTabWidgetFrame](QStyleOptionTabWidgetFrame)
    ///
    /// * [CT_ToolButton](CT_ToolButton)
    ///
    /// * [QStyleOptionToolButton](QStyleOptionToolButton)
    ///
    /// **See also:** ContentsType
    /// [`StyleOption`]
    //[event]
    size_from_contents(ct: Style::ContentsType, opt: *StyleOptionType, contents_size: &SizeType, w: *WidgetType) -> Size,
    ///
    /// Returns an integer representing the specified style *hint* for
    /// the given *widget* described by the provided style *option.*
    ///
    /// *returnData* is used when the querying widget needs more detailed data than
    /// the integer that styleHint() returns. See the QStyleHintReturn class
    /// description for details.
    //[event]
    style_hint(stylehint: Style::StyleHint, opt: *StyleOptionType, widget: *WidgetType, return_data: *StyleHintReturnType) -> i32,
    ///
    /// Returns a pixmap for the given *standardPixmap.*
    ///
    /// A standard pixmap is a pixmap that can follow some existing GUI
    /// style or guideline. The *option* argument can be used to pass
    /// extra information required when defining the appropriate
    /// pixmap. The *widget* argument is optional and can also be used to
    /// aid the determination of the pixmap.
    ///
    /// Developers calling standardPixmap() should instead call standardIcon()
    /// Developers who re-implemented standardPixmap() should instead re-implement
    /// standardIcon().
    ///
    /// **See also:** [`standard_icon()`]
    //[event]
    standard_pixmap(standard_pixmap: Style::StandardPixmap, opt: *StyleOptionType, widget: *WidgetType) -> Pixmap,
    ///
    /// const QWidget *widget = 0) const = 0;
    ///
    /// Returns an icon for the given *standardIcon.*
    ///
    /// The *standardIcon* is a standard pixmap which can follow some
    /// existing GUI style or guideline. The *option* argument can be
    /// used to pass extra information required when defining the
    /// appropriate icon. The *widget* argument is optional and can also
    /// be used to aid the determination of the icon.
    //[event]
    standard_icon(standard_icon: Style::StandardPixmap, option: *StyleOptionType, widget: *WidgetType) -> Icon,
    ///
    /// const QPixmap &pixmap, const QStyleOption *option) const
    ///
    /// Returns a copy of the given *pixmap,* styled to conform to the
    /// specified *iconMode* and taking into account the palette
    /// specified by *option.*
    ///
    /// The *option* parameter can pass extra information, but
    /// it must contain a palette.
    ///
    /// Note that not all pixmaps will conform, in which case the returned
    /// pixmap is a plain copy.
    ///
    /// **See also:** [`Icon`]
    //[event]
    generated_icon_pixmap(icon_mode: Icon::Mode, pixmap: &PixmapType, opt: *StyleOptionType) -> Pixmap,
    ///
    /// Returns the given *logicalRectangle* converted to screen
    /// coordinates based on the specified *direction.* The *boundingRectangle* is used when performing the translation.
    ///
    /// This function is provided to support right-to-left desktops, and
    /// is typically used in implementations of the subControlRect()
    /// function.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    [static] visual_rect(direction: Rute::LayoutDirection, bounding_rect: &RectType, logical_rect: &RectType) -> Rect,
    ///
    /// Returns the given *logicalPosition* converted to screen
    /// coordinates based on the specified *direction.* The *boundingRectangle* is used when performing the translation.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    [static] visual_pos(direction: Rute::LayoutDirection, bounding_rect: &RectType, logical_pos: &PointType) -> Point,
    ///
    /// Converts the given *logicalValue* to a pixel position. The *min*
    /// parameter maps to 0, *max* maps to *span* and other values are
    /// distributed evenly in-between.
    ///
    /// This function can handle the entire integer range without
    /// overflow, providing that *span* is less than 4096.
    ///
    /// By default, this function assumes that the maximum value is on the
    /// right for horizontal items and on the bottom for vertical items.
    /// Set the *upsideDown* parameter to true to reverse this behavior.
    ///
    /// **See also:** [`slider_value_from_position()`]
    [static] slider_position_from_value(min: i32, max: i32, val: i32, space: i32, upside_down: bool) -> i32,
    ///
    /// Converts the given pixel *position* to a logical value. 0 maps to
    /// the *min* parameter, *span* maps to *max* and other values are
    /// distributed evenly in-between.
    ///
    /// This function can handle the entire integer range without
    /// overflow.
    ///
    /// By default, this function assumes that the maximum value is on the
    /// right for horizontal items and on the bottom for vertical
    /// items. Set the *upsideDown* parameter to true to reverse this
    /// behavior.
    ///
    /// **See also:** [`slider_position_from_value()`]
    [static] slider_value_from_position(min: i32, max: i32, pos: i32, space: i32, upside_down: bool) -> i32,
    ///
    /// Transforms an *alignment* of Qt::AlignLeft or Qt::AlignRight
    /// without Qt::AlignAbsolute into Qt::AlignLeft or Qt::AlignRight with
    /// Qt::AlignAbsolute according to the layout *direction.* The other
    /// alignment flags are left untouched.
    ///
    /// If no horizontal alignment was specified, the function returns the
    /// default alignment for the given layout *direction.*
    ///
    /// QWidget::layoutDirection
    [static] visual_alignment(direction: Rute::LayoutDirection, alignment: Rute::Alignment) -> Rute::Alignment,
    ///
    /// Returns a new rectangle of the specified *size* that is aligned to the given *rectangle* according to the specified *alignment* and *direction.*
    [static] aligned_rect(direction: Rute::LayoutDirection, alignment: Rute::Alignment, size: &SizeType, rectangle: &RectType) -> Rect,
    ///
    /// QSizePolicy::ControlType control2, Qt::Orientation orientation,
    /// const QStyleOption *option = 0, const QWidget *widget = 0) const
    ///
    /// Returns the spacing that should be used between *control1* and
    /// *control2* in a layout. *orientation* specifies whether the
    /// controls are laid out side by side or stacked vertically. The *option* parameter can be used to pass extra information about the
    /// parent widget. The *widget* parameter is optional and can also
    /// be used if *option* is 0.
    ///
    /// This function is called by the layout system. It is used only if
    /// PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
    /// negative value.
    ///
    /// **See also:** [`combined_layout_spacing()`]
    //[event]
    layout_spacing(control1: SizePolicy::ControlType, control2: SizePolicy::ControlType, orientation: Rute::Orientation, option: *StyleOptionType, widget: *WidgetType) -> i32,
    ///
    /// Returns the spacing that should be used between *controls1* and
    /// *controls2* in a layout. *orientation* specifies whether the
    /// controls are laid out side by side or stacked vertically. The *option* parameter can be used to pass extra information about the
    /// parent widget. The *widget* parameter is optional and can also
    /// be used if *option* is 0.
    ///
    /// *controls1* and *controls2* are OR-combination of zero or more
    /// [control types](QSizePolicy::ControlTypes)
    ///
    ///
    /// This function is called by the layout system. It is used only if
    /// PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
    /// negative value.
    ///
    /// **See also:** [`layout_spacing()`]
    combined_layout_spacing(controls1: SizePolicy::ControlTypes, controls2: SizePolicy::ControlTypes, orientation: Rute::Orientation, option: *StyleOptionType, widget: *WidgetType) -> i32,
    ///
    /// This function returns the current proxy for this style.
    /// By default most styles will return themselves. However
    /// when a proxy style is in use, it will allow the style to
    /// call back into its proxy.
    proxy() -> Style?,
}

[org_name(QStyle)]
enum StateFlag {
    State_None,
    State_Enabled,
    State_Raised,
    State_Sunken,
    State_Off,
    State_NoChange,
    State_On,
    State_DownArrow,
    State_Horizontal,
    State_HasFocus,
    State_Top,
    State_Bottom,
    State_FocusAtBorder,
    State_AutoRaise,
    State_MouseOver,
    State_UpArrow,
    State_Selected,
    State_Active,
    State_Window,
    State_Open,
    State_Children,
    State_Item,
    State_Sibling,
    State_Editing,
    State_KeyboardFocusChange,
    State_ReadOnly,
    State_Small,
    State_Mini,
}

[org_name(QStyle)]
enum PrimitiveElement {
    PE_Frame,
    PE_FrameDefaultButton,
    PE_FrameDockWidget,
    PE_FrameFocusRect,
    PE_FrameGroupBox,
    PE_FrameLineEdit,
    PE_FrameMenu,
    PE_FrameStatusBar,
    PE_FrameStatusBarItem,
    PE_FrameTabWidget,
    PE_FrameWindow,
    PE_FrameButtonBevel,
    PE_FrameButtonTool,
    PE_FrameTabBarBase,
    PE_PanelButtonCommand,
    PE_PanelButtonBevel,
    PE_PanelButtonTool,
    PE_PanelMenuBar,
    PE_PanelToolBar,
    PE_PanelLineEdit,
    PE_IndicatorArrowDown,
    PE_IndicatorArrowLeft,
    PE_IndicatorArrowRight,
    PE_IndicatorArrowUp,
    PE_IndicatorBranch,
    PE_IndicatorButtonDropDown,
    PE_IndicatorViewItemCheck,
    PE_IndicatorItemViewItemCheck,
    PE_IndicatorCheckBox,
    PE_IndicatorDockWidgetResizeHandle,
    PE_IndicatorHeaderArrow,
    PE_IndicatorMenuCheckMark,
    PE_IndicatorProgressChunk,
    PE_IndicatorRadioButton,
    PE_IndicatorSpinDown,
    PE_IndicatorSpinMinus,
    PE_IndicatorSpinPlus,
    PE_IndicatorSpinUp,
    PE_IndicatorToolBarHandle,
    PE_IndicatorToolBarSeparator,
    PE_PanelTipLabel,
    PE_IndicatorTabTear,
    PE_IndicatorTabTearLeft,
    PE_PanelScrollAreaCorner,
    PE_Widget,
    PE_IndicatorColumnViewArrow,
    PE_IndicatorItemViewItemDrop,
    PE_PanelItemViewItem,
    PE_PanelItemViewRow,
    PE_PanelStatusBar,
    PE_IndicatorTabClose,
    PE_PanelMenu,
    PE_IndicatorTabTearRight,
    PE_CustomBase,
}

[org_name(QStyle)]
enum ControlElement {
    CE_PushButton,
    CE_PushButtonBevel,
    CE_PushButtonLabel,
    CE_CheckBox,
    CE_CheckBoxLabel,
    CE_RadioButton,
    CE_RadioButtonLabel,
    CE_TabBarTab,
    CE_TabBarTabShape,
    CE_TabBarTabLabel,
    CE_ProgressBar,
    CE_ProgressBarGroove,
    CE_ProgressBarContents,
    CE_ProgressBarLabel,
    CE_MenuItem,
    CE_MenuScroller,
    CE_MenuVMargin,
    CE_MenuHMargin,
    CE_MenuTearoff,
    CE_MenuEmptyArea,
    CE_MenuBarItem,
    CE_MenuBarEmptyArea,
    CE_ToolButtonLabel,
    CE_Header,
    CE_HeaderSection,
    CE_HeaderLabel,
    CE_ToolBoxTab,
    CE_SizeGrip,
    CE_Splitter,
    CE_RubberBand,
    CE_DockWidgetTitle,
    CE_ScrollBarAddLine,
    CE_ScrollBarSubLine,
    CE_ScrollBarAddPage,
    CE_ScrollBarSubPage,
    CE_ScrollBarSlider,
    CE_ScrollBarFirst,
    CE_ScrollBarLast,
    CE_FocusFrame,
    CE_ComboBoxLabel,
    CE_ToolBar,
    CE_ToolBoxTabShape,
    CE_ToolBoxTabLabel,
    CE_HeaderEmptyArea,
    CE_ColumnViewGrip,
    CE_ItemViewItem,
    CE_ShapedFrame,
    CE_CustomBase,
}

[org_name(QStyle)]
enum SubElement {
    SE_PushButtonContents,
    SE_PushButtonFocusRect,
    SE_CheckBoxIndicator,
    SE_CheckBoxContents,
    SE_CheckBoxFocusRect,
    SE_CheckBoxClickRect,
    SE_RadioButtonIndicator,
    SE_RadioButtonContents,
    SE_RadioButtonFocusRect,
    SE_RadioButtonClickRect,
    SE_ComboBoxFocusRect,
    SE_SliderFocusRect,
    SE_ProgressBarGroove,
    SE_ProgressBarContents,
    SE_ProgressBarLabel,
    SE_ToolBoxTabContents,
    SE_HeaderLabel,
    SE_HeaderArrow,
    SE_TabWidgetTabBar,
    SE_TabWidgetTabPane,
    SE_TabWidgetTabContents,
    SE_TabWidgetLeftCorner,
    SE_TabWidgetRightCorner,
    SE_ViewItemCheckIndicator,
    SE_ItemViewItemCheckIndicator,
    SE_TabBarTearIndicator,
    SE_TabBarTearIndicatorLeft,
    SE_TreeViewDisclosureItem,
    SE_LineEditContents,
    SE_FrameContents,
    SE_DockWidgetCloseButton,
    SE_DockWidgetFloatButton,
    SE_DockWidgetTitleBarText,
    SE_DockWidgetIcon,
    SE_CheckBoxLayoutItem,
    SE_ComboBoxLayoutItem,
    SE_DateTimeEditLayoutItem,
    SE_DialogButtonBoxLayoutItem,
    SE_LabelLayoutItem,
    SE_ProgressBarLayoutItem,
    SE_PushButtonLayoutItem,
    SE_RadioButtonLayoutItem,
    SE_SliderLayoutItem,
    SE_SpinBoxLayoutItem,
    SE_ToolButtonLayoutItem,
    SE_FrameLayoutItem,
    SE_GroupBoxLayoutItem,
    SE_TabWidgetLayoutItem,
    SE_ItemViewItemDecoration,
    SE_ItemViewItemText,
    SE_ItemViewItemFocusRect,
    SE_TabBarTabLeftButton,
    SE_TabBarTabRightButton,
    SE_TabBarTabText,
    SE_ShapedFrameContents,
    SE_ToolBarHandle,
    SE_TabBarScrollLeftButton,
    SE_TabBarScrollRightButton,
    SE_TabBarTearIndicatorRight,
    SE_CustomBase,
}

[org_name(QStyle)]
enum ComplexControl {
    CC_SpinBox,
    CC_ComboBox,
    CC_ScrollBar,
    CC_Slider,
    CC_ToolButton,
    CC_TitleBar,
    CC_Dial,
    CC_GroupBox,
    CC_MdiControls,
    CC_CustomBase,
}

[org_name(QStyle)]
enum SubControl {
    SC_None,
    SC_ScrollBarAddLine,
    SC_ScrollBarSubLine,
    SC_ScrollBarAddPage,
    SC_ScrollBarSubPage,
    SC_ScrollBarFirst,
    SC_ScrollBarLast,
    SC_ScrollBarSlider,
    SC_ScrollBarGroove,
    SC_SpinBoxUp,
    SC_SpinBoxDown,
    SC_SpinBoxFrame,
    SC_SpinBoxEditField,
    SC_ComboBoxFrame,
    SC_ComboBoxEditField,
    SC_ComboBoxArrow,
    SC_ComboBoxListBoxPopup,
    SC_SliderGroove,
    SC_SliderHandle,
    SC_SliderTickmarks,
    SC_ToolButton,
    SC_ToolButtonMenu,
    SC_TitleBarSysMenu,
    SC_TitleBarMinButton,
    SC_TitleBarMaxButton,
    SC_TitleBarCloseButton,
    SC_TitleBarNormalButton,
    SC_TitleBarShadeButton,
    SC_TitleBarUnshadeButton,
    SC_TitleBarContextHelpButton,
    SC_TitleBarLabel,
    SC_DialGroove,
    SC_DialHandle,
    SC_DialTickmarks,
    SC_GroupBoxCheckBox,
    SC_GroupBoxLabel,
    SC_GroupBoxContents,
    SC_GroupBoxFrame,
    SC_MdiMinButton,
    SC_MdiNormalButton,
    SC_MdiCloseButton,
    SC_CustomBase,
    SC_All,
}

[org_name(QStyle)]
enum PixelMetric {
    PM_ButtonMargin,
    PM_ButtonDefaultIndicator,
    PM_MenuButtonIndicator,
    PM_ButtonShiftHorizontal,
    PM_ButtonShiftVertical,
    PM_DefaultFrameWidth,
    PM_SpinBoxFrameWidth,
    PM_ComboBoxFrameWidth,
    PM_MaximumDragDistance,
    PM_ScrollBarExtent,
    PM_ScrollBarSliderMin,
    PM_SliderThickness,
    PM_SliderControlThickness,
    PM_SliderLength,
    PM_SliderTickmarkOffset,
    PM_SliderSpaceAvailable,
    PM_DockWidgetSeparatorExtent,
    PM_DockWidgetHandleExtent,
    PM_DockWidgetFrameWidth,
    PM_TabBarTabOverlap,
    PM_TabBarTabHSpace,
    PM_TabBarTabVSpace,
    PM_TabBarBaseHeight,
    PM_TabBarBaseOverlap,
    PM_ProgressBarChunkWidth,
    PM_SplitterWidth,
    PM_TitleBarHeight,
    PM_MenuScrollerHeight,
    PM_MenuHMargin,
    PM_MenuVMargin,
    PM_MenuPanelWidth,
    PM_MenuTearoffHeight,
    PM_MenuDesktopFrameWidth,
    PM_MenuBarPanelWidth,
    PM_MenuBarItemSpacing,
    PM_MenuBarVMargin,
    PM_MenuBarHMargin,
    PM_IndicatorWidth,
    PM_IndicatorHeight,
    PM_ExclusiveIndicatorWidth,
    PM_ExclusiveIndicatorHeight,
    PM_DialogButtonsSeparator,
    PM_DialogButtonsButtonWidth,
    PM_DialogButtonsButtonHeight,
    PM_MdiSubWindowFrameWidth,
    PM_MDIFrameWidth,
    PM_MdiSubWindowMinimizedWidth,
    PM_MDIMinimizedWidth,
    PM_HeaderMargin,
    PM_HeaderMarkSize,
    PM_HeaderGripMargin,
    PM_TabBarTabShiftHorizontal,
    PM_TabBarTabShiftVertical,
    PM_TabBarScrollButtonWidth,
    PM_ToolBarFrameWidth,
    PM_ToolBarHandleExtent,
    PM_ToolBarItemSpacing,
    PM_ToolBarItemMargin,
    PM_ToolBarSeparatorExtent,
    PM_ToolBarExtensionExtent,
    PM_SpinBoxSliderHeight,
    PM_DefaultTopLevelMargin,
    PM_DefaultChildMargin,
    PM_DefaultLayoutSpacing,
    PM_ToolBarIconSize,
    PM_ListViewIconSize,
    PM_IconViewIconSize,
    PM_SmallIconSize,
    PM_LargeIconSize,
    PM_FocusFrameVMargin,
    PM_FocusFrameHMargin,
    PM_ToolTipLabelFrameWidth,
    PM_CheckBoxLabelSpacing,
    PM_TabBarIconSize,
    PM_SizeGripSize,
    PM_DockWidgetTitleMargin,
    PM_MessageBoxIconSize,
    PM_ButtonIconSize,
    PM_DockWidgetTitleBarButtonMargin,
    PM_RadioButtonLabelSpacing,
    PM_LayoutLeftMargin,
    PM_LayoutTopMargin,
    PM_LayoutRightMargin,
    PM_LayoutBottomMargin,
    PM_LayoutHorizontalSpacing,
    PM_LayoutVerticalSpacing,
    PM_TabBar_ScrollButtonOverlap,
    PM_TextCursorWidth,
    PM_TabCloseIndicatorWidth,
    PM_TabCloseIndicatorHeight,
    PM_ScrollView_ScrollBarSpacing,
    PM_ScrollView_ScrollBarOverlap,
    PM_SubMenuOverlap,
    PM_TreeViewIndentation,
    PM_HeaderDefaultSectionSizeHorizontal,
    PM_HeaderDefaultSectionSizeVertical,
    PM_TitleBarButtonIconSize,
    PM_TitleBarButtonSize,
    PM_CustomBase,
}

[org_name(QStyle)]
enum ContentsType {
    CT_PushButton,
    CT_CheckBox,
    CT_RadioButton,
    CT_ToolButton,
    CT_ComboBox,
    CT_Splitter,
    CT_ProgressBar,
    CT_MenuItem,
    CT_MenuBarItem,
    CT_MenuBar,
    CT_Menu,
    CT_TabBarTab,
    CT_Slider,
    CT_ScrollBar,
    CT_LineEdit,
    CT_SpinBox,
    CT_SizeGrip,
    CT_TabWidget,
    CT_DialogButtons,
    CT_HeaderSection,
    CT_GroupBox,
    CT_MdiControls,
    CT_ItemViewItem,
    CT_CustomBase,
}

[org_name(QStyle)]
enum RequestSoftwareInputPanel {
    RSIP_OnMouseClickAndAlreadyFocused,
    RSIP_OnMouseClick,
}

[org_name(QStyle)]
enum StyleHint {
    SH_EtchDisabledText,
    SH_DitherDisabledText,
    SH_ScrollBar_MiddleClickAbsolutePosition,
    SH_ScrollBar_ScrollWhenPointerLeavesControl,
    SH_TabBar_SelectMouseType,
    SH_TabBar_Alignment,
    SH_Header_ArrowAlignment,
    SH_Slider_SnapToValue,
    SH_Slider_SloppyKeyEvents,
    SH_ProgressDialog_CenterCancelButton,
    SH_ProgressDialog_TextLabelAlignment,
    SH_PrintDialog_RightAlignButtons,
    SH_MainWindow_SpaceBelowMenuBar,
    SH_FontDialog_SelectAssociatedText,
    SH_Menu_AllowActiveAndDisabled,
    SH_Menu_SpaceActivatesItem,
    SH_Menu_SubMenuPopupDelay,
    SH_ScrollView_FrameOnlyAroundContents,
    SH_MenuBar_AltKeyNavigation,
    SH_ComboBox_ListMouseTracking,
    SH_Menu_MouseTracking,
    SH_MenuBar_MouseTracking,
    SH_ItemView_ChangeHighlightOnFocus,
    SH_Widget_ShareActivation,
    SH_Workspace_FillSpaceOnMaximize,
    SH_ComboBox_Popup,
    SH_TitleBar_NoBorder,
    SH_Slider_StopMouseOverSlider,
    SH_ScrollBar_StopMouseOverSlider,
    SH_BlinkCursorWhenTextSelected,
    SH_RichText_FullWidthSelection,
    SH_Menu_Scrollable,
    SH_GroupBox_TextLabelVerticalAlignment,
    SH_GroupBox_TextLabelColor,
    SH_Menu_SloppySubMenus,
    SH_Table_GridLineColor,
    SH_LineEdit_PasswordCharacter,
    SH_DialogButtons_DefaultButton,
    SH_ToolBox_SelectedPageTitleBold,
    SH_TabBar_PreferNoArrows,
    SH_ScrollBar_LeftClickAbsolutePosition,
    SH_ListViewExpand_SelectMouseType,
    SH_UnderlineShortcut,
    SH_SpinBox_AnimateButton,
    SH_SpinBox_KeyPressAutoRepeatRate,
    SH_SpinBox_ClickAutoRepeatRate,
    SH_Menu_FillScreenWithScroll,
    SH_ToolTipLabel_Opacity,
    SH_DrawMenuBarSeparator,
    SH_TitleBar_ModifyNotification,
    SH_Button_FocusPolicy,
    SH_MessageBox_UseBorderForButtonSpacing,
    SH_TitleBar_AutoRaise,
    SH_ToolButton_PopupDelay,
    SH_FocusFrame_Mask,
    SH_RubberBand_Mask,
    SH_WindowFrame_Mask,
    SH_SpinControls_DisableOnBounds,
    SH_Dial_BackgroundRole,
    SH_ComboBox_LayoutDirection,
    SH_ItemView_EllipsisLocation,
    SH_ItemView_ShowDecorationSelected,
    SH_ItemView_ActivateItemOnSingleClick,
    SH_ScrollBar_ContextMenu,
    SH_ScrollBar_RollBetweenButtons,
    SH_Slider_AbsoluteSetButtons,
    SH_Slider_PageSetButtons,
    SH_Menu_KeyboardSearch,
    SH_TabBar_ElideMode,
    SH_DialogButtonLayout,
    SH_ComboBox_PopupFrameStyle,
    SH_MessageBox_TextInteractionFlags,
    SH_DialogButtonBox_ButtonsHaveIcons,
    SH_SpellCheckUnderlineStyle,
    SH_MessageBox_CenterButtons,
    SH_Menu_SelectionWrap,
    SH_ItemView_MovementWithoutUpdatingSelection,
    SH_ToolTip_Mask,
    SH_FocusFrame_AboveWidget,
    SH_TextControl_FocusIndicatorTextCharFormat,
    SH_WizardStyle,
    SH_ItemView_ArrowKeysNavigateIntoChildren,
    SH_Menu_Mask,
    SH_Menu_FlashTriggeredItem,
    SH_Menu_FadeOutOnHide,
    SH_SpinBox_ClickAutoRepeatThreshold,
    SH_ItemView_PaintAlternatingRowColorsForEmptyArea,
    SH_FormLayoutWrapPolicy,
    SH_TabWidget_DefaultTabPosition,
    SH_ToolBar_Movable,
    SH_FormLayoutFieldGrowthPolicy,
    SH_FormLayoutFormAlignment,
    SH_FormLayoutLabelAlignment,
    SH_ItemView_DrawDelegateFrame,
    SH_TabBar_CloseButtonPosition,
    SH_DockWidget_ButtonsHaveFrame,
    SH_ToolButtonStyle,
    SH_RequestSoftwareInputPanel,
    SH_ScrollBar_Transient,
    SH_Menu_SupportsSections,
    SH_ToolTip_WakeUpDelay,
    SH_ToolTip_FallAsleepDelay,
    SH_Widget_Animate,
    SH_Splitter_OpaqueResize,
    SH_ComboBox_UseNativePopup,
    SH_LineEdit_PasswordMaskDelay,
    SH_TabBar_ChangeCurrentDelay,
    SH_Menu_SubMenuUniDirection,
    SH_Menu_SubMenuUniDirectionFailCount,
    SH_Menu_SubMenuSloppySelectOtherActions,
    SH_Menu_SubMenuSloppyCloseTimeout,
    SH_Menu_SubMenuResetWhenReenteringParent,
    SH_Menu_SubMenuDontStartSloppyOnLeave,
    SH_ItemView_ScrollMode,
    SH_TitleBar_ShowToolTipsOnButtons,
    SH_Widget_Animation_Duration,
    SH_ComboBox_AllowWheelScrolling,
    SH_SpinBox_ButtonsInsideFrame,
    SH_CustomBase,
}

[org_name(QStyle)]
enum StandardPixmap {
    SP_TitleBarMenuButton,
    SP_TitleBarMinButton,
    SP_TitleBarMaxButton,
    SP_TitleBarCloseButton,
    SP_TitleBarNormalButton,
    SP_TitleBarShadeButton,
    SP_TitleBarUnshadeButton,
    SP_TitleBarContextHelpButton,
    SP_DockWidgetCloseButton,
    SP_MessageBoxInformation,
    SP_MessageBoxWarning,
    SP_MessageBoxCritical,
    SP_MessageBoxQuestion,
    SP_DesktopIcon,
    SP_TrashIcon,
    SP_ComputerIcon,
    SP_DriveFDIcon,
    SP_DriveHDIcon,
    SP_DriveCDIcon,
    SP_DriveDVDIcon,
    SP_DriveNetIcon,
    SP_DirOpenIcon,
    SP_DirClosedIcon,
    SP_DirLinkIcon,
    SP_DirLinkOpenIcon,
    SP_FileIcon,
    SP_FileLinkIcon,
    SP_ToolBarHorizontalExtensionButton,
    SP_ToolBarVerticalExtensionButton,
    SP_FileDialogStart,
    SP_FileDialogEnd,
    SP_FileDialogToParent,
    SP_FileDialogNewFolder,
    SP_FileDialogDetailedView,
    SP_FileDialogInfoView,
    SP_FileDialogContentsView,
    SP_FileDialogListView,
    SP_FileDialogBack,
    SP_DirIcon,
    SP_DialogOkButton,
    SP_DialogCancelButton,
    SP_DialogHelpButton,
    SP_DialogOpenButton,
    SP_DialogSaveButton,
    SP_DialogCloseButton,
    SP_DialogApplyButton,
    SP_DialogResetButton,
    SP_DialogDiscardButton,
    SP_DialogYesButton,
    SP_DialogNoButton,
    SP_ArrowUp,
    SP_ArrowDown,
    SP_ArrowLeft,
    SP_ArrowRight,
    SP_ArrowBack,
    SP_ArrowForward,
    SP_DirHomeIcon,
    SP_CommandLink,
    SP_VistaShield,
    SP_BrowserReload,
    SP_BrowserStop,
    SP_MediaPlay,
    SP_MediaStop,
    SP_MediaPause,
    SP_MediaSkipForward,
    SP_MediaSkipBackward,
    SP_MediaSeekForward,
    SP_MediaSeekBackward,
    SP_MediaVolume,
    SP_MediaVolumeMuted,
    SP_LineEditClearButton,
    SP_CustomBase,
}

// vim: syntax=rust expandtab ts=4 sw=4
