///
/// Written at the start of the header and cpp output
///
pub static HEADER: &'static [u8] = b"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by rute_gen. DO NOT EDIT
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include \"Rute.h\"
#include \"rute_cpp.h\"
#include \"../rute_manual.h\"
";

//
// Used to make CPP generated code a bit easier to read
//
pub static SEPARATOR: &'static [u8] = b"///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n";

pub static CPP_HEADER: &'static [u8] = b"
static char s_temp_string_buffer[1024*1024];\n
#include <map>
std::map<QWidget*, void*> s_widget_lookup;\n
";

///
/// Writen at the end of the cpp output
///
pub static FOOTER: &'static [u8] = b"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef _WIN32
extern \"C\" __declspec(dllexport) struct Rute* rute_get() {
#else
extern \"C\" struct Rute* rute_get() {
#endif
    return (Rute*)&s_rute;
}
";


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static CPP_GEN_WRAPPER_TEMPLATE: &str = "
class WR{{class_name}} : public Q{{class_name}} {
    Q_OBJECT
public:
{% if widget %}
    WR{{class_name}}(Q{{widget_name}}* widget) : Q{{class_name}}(widget) { }
{% else %}
    WR{{class_name}}() : Q{{class_name}}() { }
{% endif %}
    virtual ~WR{{class_name}}() {
        if (m_delete_callback) {
             m_delete_callback(m_private_data);
         }
    }

    {{events}}

    RUDeleteCallback m_delete_callback = nullptr;
    void* m_private_data = nullptr;
};

";
