///
/// Written at the start of the header and cpp output
///
pub static HEADER: &'static [u8] = b"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by rute_gen. DO NOT EDIT
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include \"../rute_base.h\"
#include \"../rute_manual.h\"
";


//
// Tag for auto-gen
//
pub static AUTO_GEN_HEADER: &'static [u8] = b"// This file is auto-generated by rute_gen. DO NOT EDIT\n";

//
// Used to make QT generated code a bit easier to read
//
pub static SEPARATOR: &'static [u8] = b"///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n";
//pub static SEPARATOR_STR: &str = "///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n";

pub static QT_MAIN_HEADER: &str = "// This file is auto-generated by rute_gen. DO NOT EDIT!

#include <map>
#include <stdint.h>
#include \"rute.h\"

static char* s_temp_string_buffer = nullptr;
static int s_largest_string_size = 0;
std::map<void*, void*> s_host_data_lookup;

const char* q_string_to_const_char(const QString& ret_value) {
    QByteArray ba = ret_value.toUtf8();
    const char* c_str = ba.data();

    int size = ba.size() + 1;

    if (size > s_largest_string_size) {
        delete [] s_temp_string_buffer;
        s_temp_string_buffer = new char[size];
        s_largest_string_size = size;
    }

    memcpy(s_temp_string_buffer, c_str, size);
    return s_temp_string_buffer;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RuteFFI s_rute = {
";

///
/// Writen at the end of the cpp output
///
pub static QT_MAIN_FOOTER: &str = "};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//#ifdef _WIN32
//extern \"C\" __declspec(dllexport) struct RuteFFI* rute_static_ffi_get() {
//#else
extern \"C\" struct RuteFFI* rute_static_ffi_get() {
//#endif
    return (RuteFFI*)&s_rute;
}
";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static QT_GEN_WRAPPER_TEMPLATE: &str = "
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

class WR{{struct_name}} : public {{qt_name}} {
    //Q_OBJECT
public:
{%- if widget %}
    WR{{struct_name}}(QWidget* widget) : {{qt_name}}(widget) { }
{%- else %}
    WR{{struct_name}}(const {{qt_name}}& clone) : {{qt_name}}(clone) { }
    WR{{struct_name}}() : {{qt_name}}() { }
{%- endif %}
    virtual ~WR{{struct_name}}() {
        if (m_delete_callback) {
             m_delete_callback(m_private_data);
         }
    }
    {{events}}
    RUDeleteCallback m_delete_callback = nullptr;
    void* m_private_data = nullptr;
};
";

//////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static QT_ENUM_MAPPING_TEMPLATE: &str = "
    static KeyVal {{enum_name}}_vals[] =
    {
    {%- for enum in enums -%}
        {  (int){{qt_class}}::{{enum.name}}, {{enum.id}} },
    {% endfor %}};

    for (int i = 0; i < {{enums | size }}; ++i) {
        s_{{enum_name}}_lookup[{{enum_name}}_vals[i].key] = {{enum_name}}_vals[i].val;
    }
";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static SIGNAL_WRAPPER_TEMPLATE: &str = "
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef void (*Signal_{{signal_func_name}})(void* self_c, void* trampoline_func{{c_args}});

class QSlotWrapperSignal_{{signal_func_name}} : public QObject {
    Q_OBJECT
public:
    QSlotWrapperSignal_{{signal_func_name}}(void* data, Signal_{{signal_func_name}} trampoline_func, void* wrapped_func) {
        m_trampoline_func = trampoline_func;
        m_data = data;
        m_wrapped_func = wrapped_func;
    }

    Q_SLOT void method({{c_args | remove_first: \",\"}}) {
        m_trampoline_func(m_data, m_wrapped_func{{c_call_args}});
    }
private:
    Signal_{{signal_func_name}} m_trampoline_func;
    void* m_data;
    void* m_wrapped_func;
};
";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static SET_SIGNAL_TEMPLATE: &str = "static {{event_def}}) {
    QSlotWrapperSignal_{{signal_type_name}}* wrap = new QSlotWrapperSignal_{{signal_type_name}}(user_data, (Signal_{{signal_type_name}})event, (void*)wrapped_func);
    QObject* q_obj = (QObject*)object;
    QObject::connect(q_obj, SIGNAL({{qt_signal_name}}({{func_def}})), wrap, SLOT(method({{func_def}})));
}

";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub static WRAP_EVENT_TEMPLATE: &str = "{{c_return_type}} {{qt_event_name}}({{qt_event_args}}) {
        if (m_{{event_type_snake}}) {
            {{body_init}}
            {{body_setup}}
        } else {
        {%- if c_return_type == \"void\" %}
            {{qt_class_name}}::{{qt_event_name}}({{event_args | remove_first: \",\"}});
        {%- else %}
            return {{qt_class_name}}::{{qt_event_name}}({{event_args}});
        {%- endif %}
        }
    }

    void (*m_{{event_type_snake}})({{c_event_args}}) = nullptr;
    void* m_{{event_type_snake}}_user_data = nullptr;
    void* m_{{event_type_snake}}_wrapped_func = nullptr;
";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static QT_SET_EVENT_TEMPLATE: &str = "static void set_{{type_name}}_{{event_type_snake}}(void* object, void* user_data, void* wrapped_func, void (*trampoline_func)({{event_args}})) {
    WR{{event_type}}* qt_object = (WR{{event_type}}*)object;
    qt_object->m_{{event_type_snake}} = trampoline_func;
    qt_object->m_{{event_type_snake}}_user_data = user_data;
    qt_object->m_{{event_type_snake}}_wrapped_func = wrapped_func;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void remove_{{type_name}}_{{event_type_snake}}(void* object) {
    WR{{event_type}}* qt_object = (WR{{event_type}}*)object;
    qt_object->m_{{event_type_snake}} = nullptr;
    qt_object->m_{{event_type_snake}}_user_data = nullptr;
    qt_object->m_{{event_type_snake}}_wrapped_func = nullptr;
}

";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static QT_REGULAR_FUNC_DEF_TEMPLATE: &str = "static {{c_return_type}} {{func_name}}({{func_def}}) {
    {{cpp_type_name}}* qt_value = ({{cpp_type_name}}*)self_c;
    {{-body_setup}}
}

";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

pub static QT_TRAIT_TYPE_TEMPLATE: &str = "RU{{type_name}} {{var_name}};
            {{var_name}}.qt_data = (struct RUBase*){{input_var}};
            {{var_name}}.host_data = nullptr;
            {{var_name}}.all_funcs = &s_{{type_name_snake}}_all_funcs;";

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Definition for a Qt wrapping function
pub static QT_FUNC_DEF_TEMPLATE: &str ="{% if c_return_type != 'void' %}
    auto ret_value = {{qt_instance_call}}{{qt_func_name}}({{-extra_args}}{{qt_func_args}});

{%- if array_return %}
{%- case return_type %}
{%- when 'string' %}
    return return_string_array(ret_value);
{%- when 'primitive' %}
    return return_primitive_array<{{c_return_type}}>(ret_value);
{%- when 'regular' %}
    return return_by_value_array<{{qt_type}}>(ret_value);
{%- when 'reference' %}
    return return_pointer_array<{{qt_type}}>(ret_value);
{%- endcase %}

{%- else %}

{%- case return_type %}
{%- when 'string' %}
    return q_string_to_const_char(ret_value);
{%- when 'array' %}
    return build_array(ret_value);
{%- when 'primitive' %}
    return ret_value;
{%- when 'enum_type' %}
    return s_{{enum_type_name}}_lookup[(int)ret_value];
{%- when 'reference' %}
    {{c_return_type}} ctl;
    ctl.qt_data = (struct RUBase*){{qt_ret_value}};
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*){{qt_ret_value}}];
    ctl.all_funcs = &s_{{funcs_name}}_all_funcs;
    return ctl;
{%- else %}
    {{qt_return_type}}* new_val = new {{qt_return_type}}();
    *new_val = {{qt_ret_value}};
    {{c_return_type}} ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_{{funcs_name}}_all_funcs;
    return ctl;
{%- endcase %}

{%- endif %}

{%- else %}
    {{qt_instance_call}}{{qt_func_name}}({{-extra_args}}{{qt_func_args}});
{%- endif %}";


/*
            m_{{event_type}}_trampoline(
                (RU{{event_type}}*)&e,
                m_{{event_type}}_user_data,
                m_{{event_type}}_wrapped_func
                {{-body_setup}}
*/
