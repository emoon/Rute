use api_parser::*;
use heck::SnakeCase;
//use std::fs::File;
///
/// This code is responisble for generating the Rute.h file that allows usage of Rute from C
///
use std::io;
//use std::io::BufWriter;
//use std::io::Write;

use header_ffi_gen::HeaderFFIGen;

///
/// Header that is generated at the start of the Rute.h file
///
static HEADER: &str = "
// This file is auto-generated by rute_gen. DO NOT EDIT!
#pragma once\n
#include <stdint.h>
#include <stdbool.h>\n
#ifdef __cplusplus
extern \"C\" {
#endif\n
struct RUBase;\n
struct RUArray {
    void* priv_data;
    void* elements;
    uint32_t count;
};\n
typedef void (*RUDeleteCallback)(void* data);\n\n";

///
/// Footer that is generated at the end of the the Rute.h
///
static FOOTER: &str = "
#ifdef __cplusplus
}
#endif\n";

pub struct CapiHeaderGen;

impl HeaderFFIGen for CapiHeaderGen {
    ///
    /// Generate the header for the file
    ///
    fn gen_header(dest: &mut String) {
        dest.push_str(HEADER);
    }

    ///
    /// Generate forward declarations
    ///
    fn gen_forward_declaration(dest: &mut String, struct_name: &str) {
        dest.push_str(&format!("struct RU{}Funcs;\n", struct_name));
    }

    ///
    /// Generate enum
    ///
    fn gen_enums(dest: &mut String, enums: &Enum) {
        dest += format!("typedef enum RU{} {{\n", enums.name);

        for entry in enums {
            match *entry {
                EnumEntry::Enum(ref name) => {
                    dest += format!("    RU{}_{},\n", entry.name, name);
                },

                EnumEntry::EnumValue(ref name, ref val) => {
                    dest += format!("    RU{}_{} = {},\n", entry.name, name, val);
                }
            }
        }

        dest += format!("RU{};\n\n", enums.name);
    }

    ///
    /// Generate start of struct declaration
    ///
    fn gen_struct_declaration(dest: &mut String, struct_name: &str) {
        dest += format!("typedef struct RU{} {{\n", struct_name);
    }

    ///
    /// Generate end of struct declaration
    ///
    fn gen_struct_end_declaration(dest: &mut String, struct_name: &str) {
        dest += format!("}} RU{};\n", struct_name);
    }

    //
    // Generate start of struct funcs declaration
    //
    //fn gen_funcs_declaration(dest: &mut String, struct_name: &str) {
    //   dest += format!("struct RU{}Funcs {{\n", sdef.name)
    //}

    ///
    /// Generate destroy function
    ///
    fn gen_destroy_func(dest: &mut String, function_name: &str) {
        dest.push_str("    void (*destroy)(struct RUBase* self);\n")
    }

    ///
    /// Generate create function for owned data function
    ///
    fn gen_owned_data_create(dest: &mut String, struct_name: &str) {
        dest += format!(
                "    struct RU{} (*create_{})(
        struct RUBase* priv_data,
        RUDeleteCallback delete_callback, void* private_user_data);\n",
                struct_name,
                struct_name.to_snake_case()
            );
    }

    ///
    /// Generate create function
    ///
    fn gen_create(dest: &mut String, struct_name: &str) {
        dest += format!(
                "    struct RU{} (*create_{})(
        struct RUBase* priv_data,
        RUDeleteCallback delete_callback, void* private_user_data);\n",
                struct_name,
                struct_name.to_snake_case()
            );
    }

    ///
    /// Generate function
    ///
    fn gen_function(dest: &mut String, func: &Function) {
        match func.func_type {
            FunctionType::Regular => Self::generate_func_def(dest, func)?,
            FunctionType::Static => Self::generate_func_def(dest, func)?,
            FunctionType::Callback => Self::generate_callback_def(dest, func)?,
            _ => (),
        }
    }
    ///
    /// Generate void data entry
    ///
    fn gen_void_ptr_data(dest: &mut String, name: &str) {
        dest += format!("    void* {},", name);
    }

    ///
    /// Generate forward declarations of needed
    ///
    fn generate_post_declarations(dest: &mut String, _api_def: &ApiDef) {
        dest.push_str(FOOTER);
    }
}

impl CapiHeaderGen {
    ///
    /// Generate def for connecting events
    ///
    /// TODO: Cleanup this code
    pub fn callback_fun_def_name(dest: &mut String, def: bool, name: &str, func: &Function) {
        if def {
            dest += format!(
                "void (*set_{}_event)(void* object, void* user_data, void* trampoline_func, void (*event)(",
                name);
        } else {
            dest += format!(
                "void set_{}_event(void* object, void* user_data, void* trampoline_func, void (*event)(",
                name);
        };

        dest += func.gen_c_def_filter(Some(Some("void*")), |_, _| None);

        dest.push_str(")");
    }

    ///
    /// Code to write down callback def
    ///
    fn generate_callback_def(dest: &mut String, func: &Function) -> io::Result<()> {
        dest.push_str("    ");
        Self::callback_fun_def_name(dest, true, &func.name, func);
        dest.push_str(";\n");
    }

    ///
    /// Generate function definition in the style of
    ///
    /// struct Foo (*foobar)(uint32_t x, uint32_t)
    ///
    fn generate_func_def(dest: &mut String, func: &Function) {
        let ret_value = func
            .return_val
            .as_ref()
            .map_or("void".into(), |r| r.get_c_type());

        // write return value and function name
        dest += format!("    {} (*{})({});\n",
            ret_value,
            func.name,
            func.generate_c_function_def(None)
        );
    }
}

