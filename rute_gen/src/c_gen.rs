///
/// This code is responisble for generating the Rute.h file that allows usage of Rute from C
///

use std::io;
use std::fs::File;
use std::io::Write;
use api_parser::*;
use heck::SnakeCase;
use c_helper::*;

///
/// Header that is generated at the start of the Rute.h file
///
static HEADER: &'static [u8] = b"
// This file is auto-generated by rute_gen. DO NOT EDIT!
#pragma once\n
#include <stdint.h>
#include <stdbool.h>\n
#ifdef __cplusplus
extern \"C\" {
#endif\n
struct RUBase;\n
struct RUArray {
    void* priv_data;
    void* elements;
    uint32_t count;
};\n\n";


///
/// Footer that is generated at the end of the the Rute.h
///
static FOOTER: &'static [u8] = b"
#ifdef __cplusplus
}
#endif\n";

pub struct CGenerator;

impl CGenerator {

    ///
    /// Generates the C API definition to the output filename
    ///
    pub fn generate(filename: &str, api_def: &ApiDef) -> io::Result<()> {
        let mut f = File::create(filename)?;

        f.write_all(HEADER)?;

        //
        // Write function structs forward declarations:
        //
        // struct RUWidgetFuncs;
        // struct RUWidget;
        // struct RUPushBUttonFuncs;
        // struct RUPushBUtton;
        // ...

        for sdef in &api_def.class_structs {
            f.write_fmt(format_args!("struct RU{}Funcs;\n", sdef.name))?;
            f.write_fmt(format_args!("struct RU{};\n", sdef.name))?;
        }

        //
        // Write variable structs forward declarations:
        //
        // struct RUWidget;
        // struct RUPushBUtton;
        // ...

        for sdef in &api_def.pod_structs {
            f.write_fmt(format_args!("struct RU{};\n", sdef.name))?;
        }

        //
        // Write traits structs forward declarations:
        //
        // struct RUWidget;
        // struct RUPushBUtton;
        // ...

        for name in api_def.get_all_traits() {
            f.write_fmt(format_args!("struct RU{};\n", name))?;
        }

        f.write_all(b"\n")?;

        //
        // Write all enums in the stype of
        //
        // typedef RUEnumFoobar {
        //     Value,
        //     Value = 2,
        // } RUEnumFoobar;
        //

        for enum_def in &api_def.enums {
            f.write_fmt(format_args!("typedef enum RU{} {{\n", enum_def.name))?;

            for entry in &enum_def.entries {
                match *entry {
                    EnumEntry::Enum(ref name) => f.write_fmt(format_args!("    RU{}_{},\n", enum_def.name, name))?,
                    EnumEntry::EnumValue(ref name, ref val) => f.write_fmt(format_args!("    RU{}_{} = {},\n", enum_def.name, name, val))?,
                }
            }

            f.write_fmt(format_args!("}} RU{};\n\n", enum_def.name))?;
        }

        //
        // Write structs for POD types like:
        //
        // struct RUSphere {
        //    float x;
        //    float y;
        //    ...
        // };
        //

        for sdef in &api_def.pod_structs {
            f.write_fmt(format_args!("struct RU{} {{\n", sdef.name))?;

            for entry in &sdef.variables {
                f.write_fmt(format_args!("    {} {};\n", get_c_type(&entry, UseTypeRef::No), entry.name))?;
            }

            f.write_all(b"};\n\n")?;
        }

        //
        // Write struct defs with functions
        //
        // struct RULayoutFuncs {
        //     struct Foo (*resize)(uint32_t x, uint32_t y);
        //     ...
        // };
        //
        // struct RULayout {
        //   struct RUWidgetFuncs* widget_funcs;
        //   struct RULayoutFuncs* layout_funcs;
        //   ...
        // }
        //

        for sdef in &api_def.class_structs {
            f.write_fmt(format_args!("struct RU{}Funcs {{\n", sdef.name))?;

            for func in &sdef.functions {
                Self::generate_func_def(&mut f, func)?;
            }

            f.write_all(b"};\n\n")?;
            f.write_fmt(format_args!("struct RU{} {{\n", sdef.name))?;

            Self::generate_inherit_structs(&mut f, api_def, &sdef)?;

            f.write_all(b"    struct RUBase* priv_data;\n")?;
            f.write_all(b"};\n\n")?;
        }

        Ok(())
    }

    ///
    /// Recursivly generate inharit structs like:
    ///
    ///   struct RUWidgetFuncs* widget_funcs;
    ///   struct RUButtonFuncs* button_funcs;
    ///   ...
    ///
    fn generate_inherit_structs(f: &mut File, api_def: &ApiDef, sdef: &Struct) -> io::Result<()> {
        if let Some(ref inherit_name) = sdef.inherit {
            for sdef in &api_def.class_structs {
                if &sdef.name == inherit_name {
                    Self::generate_inherit_structs(f, api_def, &sdef)?;
                }
            }
        }

        f.write_fmt(format_args!("    struct RU{}Funcs* {}_funcs;\n", sdef.name, sdef.name.to_snake_case()))
    }

    ///
    /// Generate function definition in the style of
    ///
    /// struct Foo (*foobar)(uint32_t x, uint32_t)
    ///
    fn generate_func_def(f: &mut File, func: &Function) -> io::Result<()> {
        let ret_value = func.return_val
            .as_ref()
            .map_or("void".to_owned(), |r| get_c_type(&r, UseTypeRef::No));

        // write return value and function name
        f.write_fmt(format_args!("    {} (*{})({});\n",
                    ret_value,
                    func.name,
                    generate_c_function_args(func)))
    }
}

