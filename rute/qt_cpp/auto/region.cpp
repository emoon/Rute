////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by rute_gen. DO NOT EDIT
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "../rute_base.h"
#include "../rute_manual.h"
#include <QRegion>
#include "region_ffi.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void region_swap(struct RUBase* self_c, struct RUBase* other) {
    WRRegion* qt_value = (WRRegion*)self_c;
    qt_value->swap(*((QRegion*)other));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool region_is_empty(struct RUBase* self_c) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->isEmpty();
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool region_is_null(struct RUBase* self_c) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->isNull();
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool region_contains(struct RUBase* self_c, struct RUBase* p) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->contains(*((QPoint*)p));
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool region_contains_2(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->contains(*((QRect*)r));
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURegion region_united(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->united(*((QRegion*)r));
    WRRegion* new_val = new WRRegion();
    *new_val = ret_value;
    struct RURegion ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_region_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURegion region_united_2(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->united(*((QRect*)r));
    WRRegion* new_val = new WRRegion();
    *new_val = ret_value;
    struct RURegion ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_region_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURegion region_intersected(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->intersected(*((QRegion*)r));
    WRRegion* new_val = new WRRegion();
    *new_val = ret_value;
    struct RURegion ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_region_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURegion region_intersected_2(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->intersected(*((QRect*)r));
    WRRegion* new_val = new WRRegion();
    *new_val = ret_value;
    struct RURegion ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_region_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURegion region_xored(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->xored(*((QRegion*)r));
    WRRegion* new_val = new WRRegion();
    *new_val = ret_value;
    struct RURegion ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_region_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool region_intersects(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->intersects(*((QRegion*)r));
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static bool region_intersects_2(struct RUBase* self_c, struct RUBase* r) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->intersects(*((QRect*)r));
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURect region_bounding_rect(struct RUBase* self_c) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->boundingRect();
    WRRect* new_val = new WRRect();
    *new_val = ret_value;
    struct RURect ctl;
    ctl.qt_data = (struct RUBase*)new_val;
    ctl.host_data = (struct RUBase*)s_host_data_lookup[(void*)new_val];
    ctl.all_funcs = &s_rect_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void region_set_rects(struct RUBase* self_c, struct RUBase* rect, int num) {
    WRRegion* qt_value = (WRRegion*)self_c;
    qt_value->setRects((QRect*)rect, num);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int region_rect_count(struct RUBase* self_c) {
    WRRegion* qt_value = (WRRegion*)self_c;
    auto ret_value = qt_value->rectCount();
    return ret_value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static struct RURegion create_region(
    struct RUBase* priv_data,
    RUDeleteCallback delete_callback,
    void* private_user_data)
{
    auto ctl = generic_create_func_with_delete<struct RURegion, WRRegion>(priv_data, delete_callback, private_user_data);
    ctl.all_funcs = &s_region_all_funcs;
    return ctl;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void destroy_region(struct RUBase* priv_data) {
    destroy_generic<WRRegion>(priv_data);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct RURegionFuncs s_region_funcs = {
    destroy_region,
    region_swap,
    region_is_empty,
    region_is_null,
    region_contains,
    region_contains_2,
    region_united,
    region_united_2,
    region_intersected,
    region_intersected_2,
    region_xored,
    region_intersects,
    region_intersects_2,
    region_bounding_rect,
    region_set_rects,
    region_rect_count,
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct RURegionAllFuncs s_region_all_funcs = {
    &s_region_funcs,
};

