// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// QGuiApplication contains the main event loop, where all events from the window
/// system and other sources are processed and dispatched. It also handles the
/// application's initialization and finalization, and provides session management.
/// In addition, QGuiApplication handles most of the system-wide and application-wide
/// settings.
///
/// For any GUI application using Qt, there is precisely **one** QGuiApplication
/// object no matter whether the application has 0, 1, 2 or more windows at
/// any given time. For non-GUI Qt applications, use QCoreApplication instead,
/// as it does not depend on the Qt GUI module. For QWidget based Qt applications,
/// use QApplication instead, as it provides some functionality needed for creating
/// QWidget instances.
///
/// The QGuiApplication object is accessible through the instance() function, which
/// returns a pointer equivalent to the global [qApp](qApp)
/// pointer.
///
/// QGuiApplication's main areas of responsibility are:
/// * It initializes the application with the user's desktop settings, such as palette(), font() and styleHints(). It keeps track of these properties in case the user changes the desktop globally, for example, through some kind of control panel.
/// * It performs event handling, meaning that it receives events from the underlying window system and dispatches them to the relevant widgets. You can send your own events to windows by using sendEvent() and postEvent().
/// * It parses common command line arguments and sets its internal state accordingly. See the [constructor documentation](QGuiApplication::QGuiApplication())
/// below for more details.
/// * It provides localization of strings that are visible to the user via translate().
/// * It provides some magical objects like the clipboard().
/// * It knows about the application's windows. You can ask which window is at a certain position using topLevelAt(), get a list of topLevelWindows(), etc.
/// * It manages the application's mouse cursor handling, see setOverrideCursor()
/// * It provides support for sophisticated [session management](Session%20Management)
/// . This makes it possible for applications to terminate gracefully when the user logs out, to cancel a shutdown process if termination isn't possible and even to preserve the entire application's state for a future session. See isSessionRestored(), sessionId() and commitDataRequest() and saveStateRequest() for details.
///
/// Since the QGuiApplication object does so much initialization, it *must* be
/// created before any other objects related to the user interface are created.
/// QGuiApplication also deals with common command line arguments. Hence, it is
/// usually a good idea to create it *before* any interpretation or
/// modification of `argv` is done in the application itself.
///
/// * {2,1} Groups of functions
///
/// * System settings
/// * desktopSettingsAware(), setDesktopSettingsAware(), styleHints(), palette(), setPalette(), font(), setFont().
///
/// * Event handling
/// * exec(), processEvents(), exit(), quit(). sendEvent(), postEvent(), sendPostedEvents(), removePostedEvents(), hasPendingEvents(), notify().
///
/// * Windows
/// * allWindows(), topLevelWindows(), focusWindow(), clipboard(), topLevelAt().
///
/// * Advanced cursor handling
/// * overrideCursor(), setOverrideCursor(), restoreOverrideCursor().
///
/// * Session management
/// * isSessionRestored(), sessionId(), commitDataRequest(), saveStateRequest().
///
/// * Miscellaneous
/// * startingUp(), closingDown().
///
/// **See also:** [`CoreApplication`]
/// [`AbstractEventDispatcher`]
/// [`EventLoop`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct GuiApplication<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUGuiApplicationAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> GuiApplication<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUGuiApplication) -> GuiApplication<'a> {
        GuiApplication {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUGuiApplication) -> GuiApplication<'a> {
        GuiApplication {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUGuiApplication) -> GuiApplication<'a> {
        GuiApplication {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    pub fn set_application_display_name(name: &str) {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_application_display_name)(obj_data, str_in_name_1.as_ptr());
        }
    }
    ///
    /// This name is shown to the user, for instance in window titles.
    /// It can be translated, if necessary.
    ///
    /// If not set, the application display name defaults to the application name.
    ///
    /// **See also:** applicationName
    pub fn application_display_name() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_display_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    pub fn set_desktop_file_name(name: &str) {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_desktop_file_name)(obj_data, str_in_name_1.as_ptr());
        }
    }
    ///
    /// This is the file name, without the full path, of the desktop entry
    /// that represents this application according to the freedesktop desktop
    /// entry specification.
    ///
    /// This property gives a precise indication of what desktop entry represents
    /// the application and it is needed by the windowing system to retrieve
    /// such information without resorting to imprecise heuristics.
    ///
    /// The latest version of the freedesktop desktop entry specification can be obtained
    /// [here](http://standards.freedesktop.org/desktop-entry-spec/latest/)
    ///
    pub fn desktop_file_name() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).desktop_file_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns the top level window at the given position *pos,* if any.
    pub fn top_level_at<P: PointTrait<'a>>(pos: &P) -> Option<Window<'a>> {
        let (obj_pos_1, _funcs) = pos.get_point_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).top_level_at)(obj_data, obj_pos_1);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    pub fn set_window_icon<I: IconTrait<'a>>(icon: &I) {
        let (obj_icon_1, _funcs) = icon.get_icon_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_window_icon)(obj_data, obj_icon_1);
        }
    }
    ///
    /// **See also:** [`Window::set_icon`]
    /// {Setting the Application Icon}
    pub fn window_icon() -> Icon<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).window_icon)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Icon::new_from_rc(t);
            } else {
                ret_val = Icon::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// The QPA platform plugins are located in `qtbase\src\plugins\platforms` .
    /// At the time of writing, the following platform plugin names are supported:
    ///
    /// * `android`
    /// * `cocoa` is a platform plugin for MacOS .
    /// * `directfb`
    /// * `eglfs` is a platform plugin for running Qt5 applications on top of EGL and OpenGL ES 2.0 without an actual windowing system (like X11 or Wayland). For more information, see [EGLFS](EGLFS)
    ///
    /// * `ios` (also used for tvOS)
    /// * `kms` is an experimental platform plugin using kernel modesetting and [DRM](http://dri.freedesktop.org/wiki/DRM)
    /// (Direct Rendering Manager).
    /// * `linuxfb` writes directly to the framebuffer. For more information, see [LinuxFB](LinuxFB)
    ///
    /// * `minimal` is provided as an examples for developers who want to write their own platform plugins. However, you can use the plugin to run GUI applications in environments without a GUI, such as servers.
    /// * `minimalegl` is an example plugin.
    /// * `offscreen`
    /// * `openwfd`
    /// * `qnx`
    /// * `windows`
    /// * `wayland` is a platform plugin for modern Linux desktops and some embedded systems.
    /// * `xcb` is the X11 plugin used on regular desktop Linux platforms.
    ///
    /// For more information about the platform plugins for embedded Linux devices,
    /// see [Qt for Embedded Linux](Qt%20for%20Embedded%20Linux)
    ///
    pub fn platform_name() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).platform_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns the most recently shown modal window. If no modal windows are
    /// visible, this function returns zero.
    ///
    /// A modal window is a window which has its
    /// [modality](QWindow::modality)
    /// property set to Qt::WindowModal
    /// or Qt::ApplicationModal. A modal window must be closed before the user can
    /// continue with other parts of the program.
    ///
    /// Modal window are organized in a stack. This function returns the modal
    /// window at the top of the stack.
    ///
    /// **See also:** [`t::window_modality()`]
    /// [`Window::set_modality`]
    pub fn modal_window() -> Option<Window<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).modal_window)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the QWindow that receives events tied to focus,
    /// such as key events.
    ///
    /// This signal is emitted when the focused window changes.
    /// *focusWindow* is the new focused window.
    ///
    /// **See also:** [`focus_window()`]
    pub fn focus_window() -> Option<Window<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).focus_window)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// This signal is emitted when final receiver of events tied to focus is changed.
    /// *focusObject* is the new receiver.
    ///
    /// **See also:** [`focus_object()`]
    ///
    /// Returns the QObject in currently active window that will be final receiver of events
    /// tied to focus, such as key events.
    pub fn focus_object() -> Option<Object<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).focus_object)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// This will be the screen where QWindows are initially shown, unless otherwise specified.
    ///
    /// The primaryScreenChanged signal was introduced in Qt 5.6.
    ///
    /// **See also:** [`screens()`]
    pub fn primary_screen() -> Option<Screen<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).primary_screen)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Screen::new_from_rc(t);
            } else {
                ret_val = Screen::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns a list of all the screens associated with the
    /// windowing system the application is connected to.
    ///
    /// Returns the screen at *point,* or `nullptr` if outside of any screen.
    ///
    /// The *point* is in relation to the virtualGeometry() of each set of virtual
    /// siblings. If the point maps to more than one set of virtual siblings the first
    /// match is returned.
    ///
    pub fn screen_at<P: PointTrait<'a>>(point: &P) -> Option<Screen<'a>> {
        let (obj_point_1, _funcs) = point.get_point_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).screen_at)(obj_data, obj_point_1);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Screen::new_from_rc(t);
            } else {
                ret_val = Screen::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the highest screen device pixel ratio found on
    /// the system. This is the ratio between physical pixels and
    /// device-independent pixels.
    ///
    /// Use this function only when you don't know which window you are targeting.
    /// If you do know the target window, use QWindow::devicePixelRatio() instead.
    ///
    /// **See also:** [`Window::device_pixel_ratio`]
    pub fn device_pixel_ratio(&self) -> f32 {
        let (obj_data, funcs) = self.get_gui_application_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the active application override cursor.
    ///
    /// This function returns 0 if no application cursor has been defined (i.e. the
    /// internal cursor stack is empty).
    ///
    /// **See also:** [`set_override_cursor()`]
    /// [`restore_override_cursor()`]
    pub fn override_cursor() -> Option<Cursor<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).override_cursor)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Cursor::new_from_rc(t);
            } else {
                ret_val = Cursor::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the application override cursor to *cursor.*
    ///
    /// Application override cursors are intended for showing the user that the
    /// application is in a special state, for example during an operation that
    /// might take some time.
    ///
    /// This cursor will be displayed in all the application's widgets until
    /// restoreOverrideCursor() or another setOverrideCursor() is called.
    ///
    /// Application cursors are stored on an internal stack. setOverrideCursor()
    /// pushes the cursor onto the stack, and restoreOverrideCursor() pops the
    /// active cursor off the stack. changeOverrideCursor() changes the curently
    /// active application override cursor.
    ///
    /// Every setOverrideCursor() must eventually be followed by a corresponding
    /// restoreOverrideCursor(), otherwise the stack will never be emptied.
    ///
    /// Example:
    ///
    /// **See also:** [`override_cursor()`]
    /// [`restore_override_cursor()`]
    /// [`change_override_cursor()`]
    /// [`Widget::set_cursor`]
    pub fn set_override_cursor<C: CursorTrait<'a>>(arg0: &C) {
        let (obj_arg0_1, _funcs) = arg0.get_cursor_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_override_cursor)(obj_data, obj_arg0_1);
        }
    }
    ///
    /// Changes the currently active application override cursor to *cursor.*
    ///
    /// This function has no effect if setOverrideCursor() was not called.
    ///
    /// **See also:** [`set_override_cursor()`]
    /// [`override_cursor()`]
    /// [`restore_override_cursor()`]
    /// [`Widget::set_cursor`]
    pub fn change_override_cursor<C: CursorTrait<'a>>(arg0: &C) {
        let (obj_arg0_1, _funcs) = arg0.get_cursor_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).change_override_cursor)(obj_data, obj_arg0_1);
        }
    }
    ///
    /// Undoes the last setOverrideCursor().
    ///
    /// If setOverrideCursor() has been called twice, calling
    /// restoreOverrideCursor() will activate the first cursor set. Calling this
    /// function a second time restores the original widgets' cursors.
    ///
    /// **See also:** [`set_override_cursor()`]
    /// [`override_cursor()`]
    pub fn restore_override_cursor() {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).restore_override_cursor)(obj_data);
        }
    }
    ///
    /// This signal is emitted when the *font* of the application changes.
    ///
    /// **See also:** [`font()`]
    ///
    /// Returns the default application font.
    ///
    /// **See also:** [`set_font()`]
    ///
    /// This signal is emitted when application fonts are loaded or removed.
    ///
    /// **See also:** [`FontDatabase::add_application_font`]
    /// [`FontDatabase::add_application_font_from_data`]
    /// [`FontDatabase::remove_all_application_fonts`]
    /// [`FontDatabase::remove_application_font`]
    pub fn font() -> Font<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).font)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Font::new_from_rc(t);
            } else {
                ret_val = Font::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Changes the default application font to *font.*
    ///
    /// **See also:** [`font()`]
    pub fn set_font<F: FontTrait<'a>>(arg0: &F) {
        let (obj_arg0_1, _funcs) = arg0.get_font_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_font)(obj_data, obj_arg0_1);
        }
    }
    ///
    /// Returns the object for interacting with the clipboard.
    pub fn clipboard() -> Option<Clipboard<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).clipboard)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Clipboard::new_from_rc(t);
            } else {
                ret_val = Clipboard::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// This signal is emitted when the *palette* of the application changes.
    ///
    /// **See also:** [`palette()`]
    ///
    /// Returns the default application palette.
    ///
    /// **See also:** [`set_palette()`]
    pub fn palette() -> Palette<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).palette)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Palette::new_from_rc(t);
            } else {
                ret_val = Palette::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Changes the default application palette to *pal.*
    ///
    /// **See also:** [`palette()`]
    pub fn set_palette<P: PaletteTrait<'a>>(pal: &P) {
        let (obj_pal_1, _funcs) = pal.get_palette_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_palette)(obj_data, obj_pal_1);
        }
    }
    ///
    /// Returns the current state of the modifier keys on the keyboard. The current
    /// state is updated sychronously as the event queue is emptied of events that
    /// will spontaneously change the keyboard state (QEvent::KeyPress and
    /// QEvent::KeyRelease events).
    ///
    /// It should be noted this may not reflect the actual keys held on the input
    /// device at the time of calling but rather the modifiers as last reported in
    /// one of the above events. If no keys are being held Qt::NoModifier is
    /// returned.
    ///
    /// **See also:** [`mouse_buttons()`]
    /// [`query_keyboard_modifiers()`]
    pub fn keyboard_modifiers() -> KeyboardModifiers {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).keyboard_modifiers)(obj_data);
            let ret_val = { transmute::<i32, KeyboardModifiers>(ret_val) };
            ret_val
        }
    }
    ///
    /// Queries and returns the state of the modifier keys on the keyboard.
    /// Unlike keyboardModifiers, this method returns the actual keys held
    /// on the input device at the time of calling the method.
    ///
    /// It does not rely on the keypress events having been received by this
    /// process, which makes it possible to check the modifiers while moving
    /// a window, for instance. Note that in most cases, you should use
    /// keyboardModifiers(), which is faster and more accurate since it contains
    /// the state of the modifiers as they were when the currently processed
    /// event was received.
    ///
    /// **See also:** [`keyboard_modifiers()`]
    pub fn query_keyboard_modifiers() -> KeyboardModifiers {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).query_keyboard_modifiers)(obj_data);
            let ret_val = { transmute::<i32, KeyboardModifiers>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the current state of the buttons on the mouse. The current state is
    /// updated syncronously as the event queue is emptied of events that will
    /// spontaneously change the mouse state (QEvent::MouseButtonPress and
    /// QEvent::MouseButtonRelease events).
    ///
    /// It should be noted this may not reflect the actual buttons held on the
    /// input device at the time of calling but rather the mouse buttons as last
    /// reported in one of the above events. If no mouse buttons are being held
    /// Qt::NoButton is returned.
    ///
    /// **See also:** [`keyboard_modifiers()`]
    pub fn mouse_buttons() -> MouseButtons {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).mouse_buttons)(obj_data);
            let ret_val = { transmute::<i32, MouseButtons>(ret_val) };
            ret_val
        }
    }
    pub fn set_layout_direction(direction: LayoutDirection) {
        let enum_direction_1 = direction as i32;

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_layout_direction)(obj_data, enum_direction_1);
        }
    }
    ///
    /// On system start-up, the default layout direction depends on the
    /// application's language.
    ///
    /// The notifier signal was introduced in Qt 5.4.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    /// [`is_left_to_right()`]
    /// [`is_right_to_left()`]
    pub fn layout_direction() -> LayoutDirection {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).layout_direction)(obj_data);
            let ret_val = { transmute::<i32, LayoutDirection>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns `true` if the application's layout direction is
    /// Qt::RightToLeft; otherwise returns `false.`
    ///
    /// **See also:** [`layout_direction()`]
    /// [`is_left_to_right()`]
    pub fn is_right_to_left() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_right_to_left)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if the application's layout direction is
    /// Qt::LeftToRight; otherwise returns `false.`
    ///
    /// **See also:** [`layout_direction()`]
    /// [`is_right_to_left()`]
    pub fn is_left_to_right() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_left_to_right)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets whether Qt should use the system's standard colors, fonts, etc., to
    /// *on.* By default, this is `true.`
    ///
    /// This function must be called before creating the QGuiApplication object, like
    /// this:
    ///
    /// **See also:** [`desktop_settings_aware()`]
    pub fn set_desktop_settings_aware(on: bool) {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_desktop_settings_aware)(obj_data, on);
        }
    }
    ///
    /// Returns `true` if Qt is set to use the system's standard colors, fonts, etc.;
    /// otherwise returns `false.` The default is `true.`
    ///
    /// **See also:** [`set_desktop_settings_aware()`]
    pub fn desktop_settings_aware() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).desktop_settings_aware)(obj_data);
            ret_val
        }
    }
    pub fn set_quit_on_last_window_closed(quit: bool) {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_quit_on_last_window_closed)(obj_data, quit);
        }
    }
    ///
    /// The default is `true.`
    ///
    /// If this property is `true,` the applications quits when the last visible
    /// primary window (i.e. window with no parent) is closed.
    ///
    /// **See also:** [`quit()`]
    /// [`Window::close`]
    pub fn quit_on_last_window_closed() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).quit_on_last_window_closed)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the current state of the application.
    ///
    /// You can react to application state changes to perform actions such as
    /// stopping/resuming CPU-intensive tasks, freeing/loading resources or
    /// saving/restoring application data.
    ///
    /// This signal is emitted when the *state* of the application changes.
    ///
    /// **See also:** [`application_state()`]
    pub fn application_state() -> ApplicationState {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_state)(obj_data);
            let ret_val = { transmute::<i32, ApplicationState>(ret_val) };
            ret_val
        }
    }
    ///
    /// Enters the main event loop and waits until exit() is called, and then
    /// returns the value that was set to exit() (which is 0 if exit() is called
    /// via quit()).
    ///
    /// It is necessary to call this function to start event handling. The main
    /// event loop receives events from the window system and dispatches these to
    /// the application widgets.
    ///
    /// Generally, no user interaction can take place before calling exec().
    ///
    /// To make your application perform idle processing, e.g., executing a special
    /// function whenever there are no pending events, use a QTimer with 0 timeout.
    /// More advanced idle processing schemes can be achieved using processEvents().
    ///
    /// We recommend that you connect clean-up code to the
    /// [aboutToQuit()](QCoreApplication::)
    /// signal, instead of putting it in your
    /// application's `main()` function. This is because, on some platforms, the
    /// QApplication::exec() call may not return.
    ///
    /// **See also:** quitOnLastWindowClosed
    /// [`quit()`]
    /// [`exit()`]
    /// [`process_events()`]
    /// [`CoreApplication::exec`]
    pub fn exec() -> i32 {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).exec)(obj_data);
            ret_val
        }
    }
    ///
    ///
    /// Returns `true` if the application has been restored from an earlier
    /// [session](Session%20Management)
    /// ; otherwise returns `false.`
    ///
    /// **See also:** [`session_id()`]
    /// [`commit_data_request()`]
    /// [`save_state_request()`]
    pub fn is_session_restored(&self) -> bool {
        let (obj_data, funcs) = self.get_gui_application_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_session_restored)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the current [session's](Session%20Management)
    /// identifier.
    ///
    /// If the application has been restored from an earlier session, this
    /// identifier is the same as it was in that previous session. The session
    /// identifier is guaranteed to be unique both for different applications
    /// and for different instances of the same application.
    ///
    /// **See also:** [`is_session_restored()`]
    /// [`session_key()`]
    /// [`commit_data_request()`]
    /// [`save_state_request()`]
    pub fn session_id(&self) -> String {
        let (obj_data, funcs) = self.get_gui_application_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).session_id)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns the session key in the current [session](Session%20Management)
    ///
    ///
    /// If the application has been restored from an earlier session, this key is
    /// the same as it was when the previous session ended.
    ///
    /// The session key changes every time the session is saved. If the shutdown process
    /// is cancelled, another session key will be used when shutting down again.
    ///
    /// **See also:** [`is_session_restored()`]
    /// [`session_id()`]
    /// [`commit_data_request()`]
    /// [`save_state_request()`]
    pub fn session_key(&self) -> String {
        let (obj_data, funcs) = self.get_gui_application_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).session_key)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns `true` if the application is currently saving the
    /// [session](Session%20Management)
    /// ; otherwise returns `false.`
    ///
    /// This is `true` when commitDataRequest() and saveStateRequest() are emitted,
    /// but also when the windows are closed afterwards by session management.
    ///
    /// **See also:** [`session_id()`]
    /// [`commit_data_request()`]
    /// [`save_state_request()`]
    pub fn is_saving_session(&self) -> bool {
        let (obj_data, funcs) = self.get_gui_application_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_saving_session)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns whether QGuiApplication will use fallback session management.
    ///
    /// The default is `true.`
    ///
    /// If this is `true` and the session manager allows user interaction,
    /// QGuiApplication will try to close toplevel windows after
    /// commitDataRequest() has been emitted. If a window cannot be closed, session
    /// shutdown will be canceled and the application will keep running.
    ///
    /// Fallback session management only benefits applications that have an
    /// feature or other logic that
    /// prevents closing a toplevel window depending on certain conditions, and
    /// that do nothing to explicitly implement session management. In applications
    /// that *do* implement session management using the proper session management
    /// API, fallback session management interferes and may break session
    /// management logic.
    ///
    /// **Warning**: If all windows *are* closed due to fallback session management
    /// and quitOnLastWindowClosed() is `true,` the application will quit before
    /// it is explicitly instructed to quit through the platform's session
    /// management protocol. That violation of protocol may prevent the platform
    /// session manager from saving application state.
    ///
    /// **See also:** [`set_fallback_session_management_enabled()`]
    /// [`SessionManager::allows_interaction`]
    /// [`save_state_request()`]
    /// [`commit_data_request()`]
    /// {Session Management}
    pub fn is_fallback_session_management_enabled() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_fallback_session_management_enabled)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets whether QGuiApplication will use fallback session management to
    /// *enabled.*
    ///
    /// **See also:** [`is_fallback_session_management_enabled()`]
    pub fn set_fallback_session_management_enabled(arg0: bool) {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_fallback_session_management_enabled)(obj_data, arg0);
        }
    }
    ///
    /// Function that can be used to sync Qt state with the Window Systems state.
    ///
    /// This function will first empty Qts events by calling QCoreApplication::processEvents(),
    /// then the platform plugin will sync up with the windowsystem, and finally Qts events
    /// will be delived by another call to QCoreApplication::processEvents();
    ///
    /// This function is timeconsuming and its use is discouraged.
    pub fn sync() {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_gui_application)(::std::ptr::null()).all_funcs)
                    .gui_application_funcs,
            )
        };
        unsafe {
            ((*funcs).sync)(obj_data);
        }
    }
    #[doc(hidden)]
    pub fn set_organization_domain(org_domain: &str) {
        let str_in_org_domain_1 = CString::new(org_domain).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_organization_domain)(obj_data, str_in_org_domain_1.as_ptr());
        }
    }
    #[doc(hidden)]
    pub fn organization_domain() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).organization_domain)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_organization_name(org_name: &str) {
        let str_in_org_name_1 = CString::new(org_name).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_organization_name)(obj_data, str_in_org_name_1.as_ptr());
        }
    }
    #[doc(hidden)]
    pub fn organization_name() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).organization_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_application_name(application: &str) {
        let str_in_application_1 = CString::new(application).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_application_name)(obj_data, str_in_application_1.as_ptr());
        }
    }
    #[doc(hidden)]
    pub fn application_name() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_application_version(version: &str) {
        let str_in_version_1 = CString::new(version).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_application_version)(obj_data, str_in_version_1.as_ptr());
        }
    }
    #[doc(hidden)]
    pub fn application_version() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_version)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_setuid_allowed(allow: bool) {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_setuid_allowed)(obj_data, allow);
        }
    }
    #[doc(hidden)]
    pub fn is_setuid_allowed() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_setuid_allowed)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn instance() -> Option<CoreApplication<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).instance)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = CoreApplication::new_from_rc(t);
            } else {
                ret_val = CoreApplication::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn exit(retcode: i32) {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).exit)(obj_data, retcode);
        }
    }
    #[doc(hidden)]
    pub fn send_event<E: EventTrait<'a>, O: ObjectTrait<'a>>(receiver: &O, event: &E) -> bool {
        let (obj_receiver_1, _funcs) = receiver.get_object_obj_funcs();
        let (obj_event_2, _funcs) = event.get_event_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).send_event)(obj_data, obj_receiver_1, obj_event_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn post_event<E: EventTrait<'a>, O: ObjectTrait<'a>>(
        receiver: &O,
        event: &E,
        priority: i32,
    ) {
        let (obj_receiver_1, _funcs) = receiver.get_object_obj_funcs();
        let (obj_event_2, _funcs) = event.get_event_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).post_event)(obj_data, obj_receiver_1, obj_event_2, priority);
        }
    }
    #[doc(hidden)]
    pub fn send_posted_events<O: ObjectTrait<'a>>(receiver: &O, event_type: i32) {
        let (obj_receiver_1, _funcs) = receiver.get_object_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).send_posted_events)(obj_data, obj_receiver_1, event_type);
        }
    }
    #[doc(hidden)]
    pub fn remove_posted_events<O: ObjectTrait<'a>>(receiver: &O, event_type: i32) {
        let (obj_receiver_1, _funcs) = receiver.get_object_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).remove_posted_events)(obj_data, obj_receiver_1, event_type);
        }
    }
    #[doc(hidden)]
    pub fn has_pending_events() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).has_pending_events)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn starting_up() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).starting_up)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn closing_down() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).closing_down)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn application_dir_path() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_dir_path)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn application_file_path() -> String {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_file_path)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn application_pid() -> i64 {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).application_pid)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn add_library_path(arg0: &str) {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).add_library_path)(obj_data, str_in_arg0_1.as_ptr());
        }
    }
    #[doc(hidden)]
    pub fn remove_library_path(arg0: &str) {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).remove_library_path)(obj_data, str_in_arg0_1.as_ptr());
        }
    }
    #[doc(hidden)]
    pub fn flush() {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).flush)(obj_data);
        }
    }
    #[doc(hidden)]
    pub fn is_quit_lock_enabled() -> bool {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_quit_lock_enabled)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_quit_lock_enabled(enabled: bool) {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).set_quit_lock_enabled)(obj_data, enabled);
        }
    }
    #[doc(hidden)]
    pub fn quit() {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_core_application)(::std::ptr::null()).all_funcs)
                    .core_application_funcs,
            )
        };
        unsafe {
            ((*funcs).quit)(obj_data);
        }
    }
    #[doc(hidden)]
    pub fn set_about_to_quit_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_core_application_obj_funcs();

        let f: Box<Box<Fn(&T) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_about_to_quit_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(core_application_about_to_quit_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_about_to_quit_event<F>(&self, func: F) -> &Self
    where
        F: Fn() + 'a,
    {
        let (obj_data, funcs) = self.get_core_application_obj_funcs();
        let f: Box<Box<Fn() + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_about_to_quit_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(core_application_about_to_quit_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as i32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as i32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }
}
pub trait GuiApplicationTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_gui_application_obj_funcs(&self) -> (*const RUBase, *const RUGuiApplicationFuncs);
}

impl<'a> ObjectTrait<'a> for GuiApplication<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> CoreApplicationTrait<'a> for GuiApplication<'a> {
    #[doc(hidden)]
    fn get_core_application_obj_funcs(&self) -> (*const RUBase, *const RUCoreApplicationFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).core_application_funcs) }
    }
}

impl<'a> GuiApplicationTrait<'a> for GuiApplication<'a> {
    #[doc(hidden)]
    fn get_gui_application_obj_funcs(&self) -> (*const RUBase, *const RUGuiApplicationFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).gui_application_funcs) }
    }
}
