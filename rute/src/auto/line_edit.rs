// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

pub(crate) unsafe extern "C" fn line_edit_text_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const ::std::os::raw::c_char,
) {
    let f: &&(Fn(&T, &str) + 'static) = transmute(func);
    let str_in_arg0_0 = CStr::from_ptr(arg0);

    let data = self_c as *const T;
    f(&*data, str_in_arg0_0.to_str().unwrap());
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_text_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const ::std::os::raw::c_char,
) {
    let f: &&(Fn(&str) + 'static) = transmute(func);
    let str_in_arg0_0 = CStr::from_ptr(arg0);

    f(str_in_arg0_0.to_str().unwrap());
}

pub(crate) unsafe extern "C" fn line_edit_text_edited_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const ::std::os::raw::c_char,
) {
    let f: &&(Fn(&T, &str) + 'static) = transmute(func);
    let str_in_arg0_0 = CStr::from_ptr(arg0);

    let data = self_c as *const T;
    f(&*data, str_in_arg0_0.to_str().unwrap());
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_text_edited_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const ::std::os::raw::c_char,
) {
    let f: &&(Fn(&str) + 'static) = transmute(func);
    let str_in_arg0_0 = CStr::from_ptr(arg0);

    f(str_in_arg0_0.to_str().unwrap());
}

pub(crate) unsafe extern "C" fn line_edit_cursor_position_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: i32,
    arg1: i32,
) {
    let f: &&(Fn(&T, i32, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg0, arg1);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_cursor_position_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: i32,
    arg1: i32,
) {
    let f: &&(Fn(i32, i32) + 'static) = transmute(func);

    f(arg0, arg1);
}

pub(crate) unsafe extern "C" fn line_edit_return_pressed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn(&T) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_return_pressed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn() + 'static) = transmute(func);

    f();
}

pub(crate) unsafe extern "C" fn line_edit_editing_finished_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn(&T) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_editing_finished_trampoline(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn() + 'static) = transmute(func);

    f();
}

pub(crate) unsafe extern "C" fn line_edit_selection_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn(&T) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_selection_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn() + 'static) = transmute(func);

    f();
}

pub(crate) unsafe extern "C" fn line_edit_mouse_press_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_mouse_press_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_mouse_move_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_mouse_move_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_mouse_release_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_mouse_release_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_mouse_double_click_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_mouse_double_click_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEvent) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_key_press_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &KeyEvent) + 'static) = transmute(func);
    let obj_arg0_0 = KeyEvent::new_from_temporary(*(arg0 as *const RUKeyEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_key_press_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&KeyEvent) + 'static) = transmute(func);
    let obj_arg0_0 = KeyEvent::new_from_temporary(*(arg0 as *const RUKeyEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_focus_in_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &FocusEvent) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_focus_in_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&FocusEvent) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_focus_out_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &FocusEvent) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_focus_out_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&FocusEvent) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_paint_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &PaintEvent) + 'static) = transmute(func);
    let obj_arg0_0 = PaintEvent::new_from_temporary(*(arg0 as *const RUPaintEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_paint_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&PaintEvent) + 'static) = transmute(func);
    let obj_arg0_0 = PaintEvent::new_from_temporary(*(arg0 as *const RUPaintEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_drag_enter_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &DragEnterEvent) + 'static) = transmute(func);
    let obj_arg0_0 = DragEnterEvent::new_from_temporary(*(arg0 as *const RUDragEnterEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_drag_enter_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&DragEnterEvent) + 'static) = transmute(func);
    let obj_arg0_0 = DragEnterEvent::new_from_temporary(*(arg0 as *const RUDragEnterEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_drag_move_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    e: *const RUBase,
) {
    let f: &&(Fn(&T, &DragMoveEvent) + 'static) = transmute(func);
    let obj_e_0 = DragMoveEvent::new_from_temporary(*(e as *const RUDragMoveEvent));
    let data = self_c as *const T;
    f(&*data, &obj_e_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_drag_move_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    e: *const RUBase,
) {
    let f: &&(Fn(&DragMoveEvent) + 'static) = transmute(func);
    let obj_e_0 = DragMoveEvent::new_from_temporary(*(e as *const RUDragMoveEvent));
    f(&obj_e_0);
}

pub(crate) unsafe extern "C" fn line_edit_drag_leave_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    e: *const RUBase,
) {
    let f: &&(Fn(&T, &DragLeaveEvent) + 'static) = transmute(func);
    let obj_e_0 = DragLeaveEvent::new_from_temporary(*(e as *const RUDragLeaveEvent));
    let data = self_c as *const T;
    f(&*data, &obj_e_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_drag_leave_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    e: *const RUBase,
) {
    let f: &&(Fn(&DragLeaveEvent) + 'static) = transmute(func);
    let obj_e_0 = DragLeaveEvent::new_from_temporary(*(e as *const RUDragLeaveEvent));
    f(&obj_e_0);
}

pub(crate) unsafe extern "C" fn line_edit_drop_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &DropEvent) + 'static) = transmute(func);
    let obj_arg0_0 = DropEvent::new_from_temporary(*(arg0 as *const RUDropEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_drop_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&DropEvent) + 'static) = transmute(func);
    let obj_arg0_0 = DropEvent::new_from_temporary(*(arg0 as *const RUDropEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_change_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &Event) + 'static) = transmute(func);
    let obj_arg0_0 = Event::new_from_temporary(*(arg0 as *const RUEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_change_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&Event) + 'static) = transmute(func);
    let obj_arg0_0 = Event::new_from_temporary(*(arg0 as *const RUEvent));
    f(&obj_arg0_0);
}

pub(crate) unsafe extern "C" fn line_edit_context_menu_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &ContextMenuEvent) + 'static) = transmute(func);
    let obj_arg0_0 = ContextMenuEvent::new_from_temporary(*(arg0 as *const RUContextMenuEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn line_edit_context_menu_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&ContextMenuEvent) + 'static) = transmute(func);
    let obj_arg0_0 = ContextMenuEvent::new_from_temporary(*(arg0 as *const RUContextMenuEvent));
    f(&obj_arg0_0);
}

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// ![windows-lineedit.png](windows-lineedit.png)
///
/// A line edit allows the user to enter and edit a single line of
/// plain text with a useful collection of editing functions,
/// including undo and redo, cut and paste, and drag and drop (see
/// [setDragEnabled()).](setDragEnabled()).)
///
/// By changing the echoMode() of a line edit, it can also be used as
/// a field, for inputs such as passwords.
///
/// The length of the text can be constrained to maxLength(). The text
/// can be arbitrarily constrained using a validator() or an
/// inputMask(), or both. When switching between a validator and an input mask
/// on the same line edit, it is best to clear the validator or input mask to
/// prevent undefined behavior.
///
/// A related class is QTextEdit which allows multi-line, rich text
/// editing.
///
/// You can change the text with setText() or insert(). The text is
/// retrieved with text(); the displayed text (which may be different,
/// see [EchoMode](EchoMode)
/// ) is retrieved with displayText(). Text can be
/// selected with setSelection() or selectAll(), and the selection can
/// be cut(), copy()ied and paste()d. The text can be aligned with
/// setAlignment().
///
/// When the text changes the textChanged() signal is emitted; when
/// the text changes other than by calling setText() the textEdited()
/// signal is emitted; when the cursor is moved the
/// cursorPositionChanged() signal is emitted; and when the Return or
/// Enter key is pressed the returnPressed() signal is emitted.
///
/// When editing is finished, either because the line edit lost focus
/// or Return/Enter is pressed the editingFinished() signal is
/// emitted.
///
/// Note that if there is a validator set on the line edit, the
/// returnPressed()/editingFinished() signals will only be emitted if
/// the validator returns QValidator::Acceptable.
///
/// By default, QLineEdits have a frame as specified by platform
/// style guides; you can turn it off by calling
/// setFrame(false).
///
/// The default key bindings are described below. The line edit also
/// provides a context menu (usually invoked by a right mouse click)
/// that presents some of these editing options.
/// * Keypress
/// * Action
/// * Left Arrow
/// * Moves the cursor one character to the left.
/// * Shift+Left Arrow
/// * Moves and selects text one character to the left.
/// * Right Arrow
/// * Moves the cursor one character to the right.
/// * Shift+Right Arrow
/// * Moves and selects text one character to the right.
/// * Home
/// * Moves the cursor to the beginning of the line.
/// * End
/// * Moves the cursor to the end of the line.
/// * Backspace
/// * Deletes the character to the left of the cursor.
/// * Ctrl+Backspace
/// * Deletes the word to the left of the cursor.
/// * Delete
/// * Deletes the character to the right of the cursor.
/// * Ctrl+Delete
/// * Deletes the word to the right of the cursor.
/// * Ctrl+A
/// * Select all.
/// * Ctrl+C
/// * Copies the selected text to the clipboard.
/// * Ctrl+Insert
/// * Copies the selected text to the clipboard.
/// * Ctrl+K
/// * Deletes to the end of the line.
/// * Ctrl+V
/// * Pastes the clipboard text into line edit.
/// * Shift+Insert
/// * Pastes the clipboard text into line edit.
/// * Ctrl+X
/// * Deletes the selected text and copies it to the clipboard.
/// * Shift+Delete
/// * Deletes the selected text and copies it to the clipboard.
/// * Ctrl+Z
/// * Undoes the last operation.
/// * Ctrl+Y
/// * Redoes the last undone operation.
///
/// Any other key sequence that represents a valid character, will
/// cause the character to be inserted into the line edit.
///
/// **See also:** [`TextEdit`]
/// [`Label`]
/// [`ComboBox`]
/// {fowler}{GUI Design Handbook: Field
/// Entry}
/// {Line Edits Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct LineEdit<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RULineEditAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> LineEdit<'a> {
    pub fn new() -> LineEdit<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_line_edit)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        LineEdit {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RULineEdit) -> LineEdit<'a> {
        LineEdit {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RULineEdit) -> LineEdit<'a> {
        LineEdit {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RULineEdit) -> LineEdit<'a> {
        LineEdit {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// This signal is emitted whenever the text changes. The *text*
    /// argument is the new text.
    ///
    /// Unlike textEdited(), this signal is also emitted when the text is
    /// changed programmatically, for example, by calling setText().
    ///
    /// This signal is emitted whenever the text is edited. The *text*
    /// argument is the new text.
    ///
    /// Unlike textChanged(), this signal is not emitted when the text is
    /// changed programmatically, for example, by calling setText().
    ///
    /// Setting this property clears the selection, clears the undo/redo
    /// history, moves the cursor to the end of the line and resets the
    /// [modified](modified)
    /// property to false. The text is not validated when
    /// inserted with setText().
    ///
    /// The text is truncated to maxLength() length.
    ///
    /// By default, this property contains an empty string.
    ///
    /// **See also:** [`insert()`]
    /// [`clear()`]
    ///
    /// Returns the widget's text margins.
    ///
    /// **See also:** [`set_text_margins()`]
    pub fn text(&self) -> String {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).text)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// If [echoMode](echoMode)
    /// is [Normal](Normal)
    /// this returns the same as text(); if
    /// [EchoMode](EchoMode)
    /// is [Password](Password)
    /// or [PasswordEchoOnEdit](PasswordEchoOnEdit)
    /// it returns a string of
    /// platform-dependent password mask characters text().length() in size,
    /// e.g. ; if [EchoMode](EchoMode)
    /// is [NoEcho](NoEcho)
    /// returns an empty string, .
    ///
    /// By default, this property contains an empty string.
    ///
    /// **See also:** [`set_echo_mode()`]
    /// [`text()`]
    /// EchoMode
    pub fn display_text(&self) -> String {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).display_text)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Setting this property makes the line edit display a grayed-out
    /// placeholder text as long as the line edit is empty.
    ///
    /// Normally, an empty line edit shows the placeholder text even
    /// when it has focus. However, if the content is horizontally
    /// centered, the placeholder text is not displayed under
    /// the cursor when the line edit has focus.
    ///
    /// By default, this property contains an empty string.
    ///
    /// **See also:** [`text()`]
    pub fn placeholder_text(&self) -> String {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).placeholder_text)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    pub fn set_placeholder_text(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_placeholder_text)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    ///
    /// If the text is too long, it is truncated at the limit.
    ///
    /// If truncation occurs any selected text will be unselected, the
    /// cursor position is set to 0 and the first part of the string is
    /// shown.
    ///
    /// If the line edit has an input mask, the mask defines the maximum
    /// string length.
    ///
    /// By default, this property contains a value of 32767.
    ///
    /// **See also:** inputMask
    pub fn max_length(&self) -> i32 {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).max_length)(obj_data);
            ret_val
        }
    }
    pub fn set_max_length(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_max_length)(obj_data, arg0);
        }
        self
    }
    pub fn set_frame(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_frame)(obj_data, arg0);
        }
        self
    }
    pub fn has_frame(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_frame)(obj_data);
            ret_val
        }
    }
    pub fn set_clear_button_enabled(&self, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_clear_button_enabled)(obj_data, enable);
        }
        self
    }
    pub fn is_clear_button_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_clear_button_enabled)(obj_data);
            ret_val
        }
    }
    ///
    /// The echo mode determines how the text entered in the line edit is
    /// displayed (or echoed) to the user.
    ///
    /// The most common setting is [Normal,](Normal,)
    /// in which the text entered by the
    /// user is displayed verbatim, but QLineEdit also supports modes that allow
    /// the entered text to be suppressed or obscured: these include [NoEcho,](NoEcho,)
    ///
    /// [Password](Password)
    /// and [PasswordEchoOnEdit.](PasswordEchoOnEdit.)
    ///
    /// The widget's display and the ability to copy or drag the text is
    /// affected by this setting.
    ///
    /// By default, this property is set to [Normal.](Normal.)
    ///
    /// **See also:** EchoMode
    /// [`display_text()`]
    pub fn echo_mode(&self) -> EchoMode {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).echo_mode)(obj_data);
            let ret_val = { transmute::<u32, EchoMode>(ret_val) };
            ret_val
        }
    }
    pub fn set_echo_mode(&self, arg0: EchoMode) -> &Self {
        let enum_arg0_1 = arg0 as u32;

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_echo_mode)(obj_data, enum_arg0_1);
        }
        self
    }
    pub fn is_read_only(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_read_only)(obj_data);
            ret_val
        }
    }
    pub fn set_read_only(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_read_only)(obj_data, arg0);
        }
        self
    }
    ///
    /// This signal is emitted whenever the cursor moves. The previous
    /// position is given by *oldPos,* and the new position by *newPos.*
    ///
    /// **See also:** [`set_cursor_position()`]
    /// [`cursor_position()`]
    ///
    /// Setting the cursor position causes a repaint when appropriate.
    ///
    /// By default, this property contains a value of 0.
    ///
    /// Returns the cursor position under the point *pos.*
    pub fn cursor_position(&self) -> i32 {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cursor_position)(obj_data);
            ret_val
        }
    }
    pub fn set_cursor_position(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_cursor_position)(obj_data, arg0);
        }
        self
    }
    ///
    /// Returns the cursor position under the point *pos.*
    pub fn cursor_position_at<P: PointTrait<'a>>(&self, pos: &P) -> i32 {
        let (obj_pos_1, _funcs) = pos.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cursor_position_at)(obj_data, obj_pos_1);
            ret_val
        }
    }
    pub fn set_alignment(&self, flag: Alignment) -> &Self {
        let enum_flag_1 = flag.bits();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_alignment)(obj_data, enum_flag_1);
        }
        self
    }
    ///
    /// Both horizontal and vertical alignment is allowed here, Qt::AlignJustify
    /// will map to Qt::AlignLeft.
    ///
    /// By default, this property contains a combination of Qt::AlignLeft and Qt::AlignVCenter.
    ///
    /// **See also:** [`t::alignment()`]
    pub fn alignment(&self) -> Alignment {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alignment)(obj_data);
            let ret_val = Alignment::from_bits_truncate(ret_val);
            ret_val
        }
    }
    ///
    /// Moves the cursor forward *steps* characters. If *mark* is true
    /// each character moved over is added to the selection; if *mark* is
    /// false the selection is cleared.
    ///
    /// **See also:** [`cursor_backward()`]
    pub fn cursor_forward(&self, mark: bool, steps: i32) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).cursor_forward)(obj_data, mark, steps);
        }
        self
    }
    ///
    /// Moves the cursor back *steps* characters. If *mark* is true each
    /// character moved over is added to the selection; if *mark* is
    /// false the selection is cleared.
    ///
    /// **See also:** [`cursor_forward()`]
    pub fn cursor_backward(&self, mark: bool, steps: i32) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).cursor_backward)(obj_data, mark, steps);
        }
        self
    }
    ///
    /// Moves the cursor one word forward. If *mark* is true, the word is
    /// also selected.
    ///
    /// **See also:** [`cursor_word_backward()`]
    pub fn cursor_word_forward(&self, mark: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).cursor_word_forward)(obj_data, mark);
        }
        self
    }
    ///
    /// Moves the cursor one word backward. If *mark* is true, the word
    /// is also selected.
    ///
    /// **See also:** [`cursor_word_forward()`]
    pub fn cursor_word_backward(&self, mark: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).cursor_word_backward)(obj_data, mark);
        }
        self
    }
    ///
    /// If no text is selected, deletes the character to the left of the
    /// text cursor and moves the cursor one position to the left. If any
    /// text is selected, the cursor is moved to the beginning of the
    /// selected text and the selected text is deleted.
    ///
    /// **See also:** [`del()`]
    pub fn backspace(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).backspace)(obj_data);
        }
        self
    }
    ///
    /// If no text is selected, deletes the character to the right of the
    /// text cursor. If any text is selected, the cursor is moved to the
    /// beginning of the selected text and the selected text is deleted.
    ///
    /// **See also:** [`backspace()`]
    pub fn del(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).del)(obj_data);
        }
        self
    }
    ///
    /// Moves the text cursor to the beginning of the line unless it is
    /// already there. If *mark* is true, text is selected towards the
    /// first position; otherwise, any selected text is unselected if the
    /// cursor is moved.
    ///
    /// **See also:** [`end()`]
    pub fn home(&self, mark: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).home)(obj_data, mark);
        }
        self
    }
    ///
    /// Moves the text cursor to the end of the line unless it is already
    /// there. If *mark* is true, text is selected towards the last
    /// position; otherwise, any selected text is unselected if the cursor
    /// is moved.
    ///
    /// **See also:** [`home()`]
    pub fn end(&self, mark: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).end)(obj_data, mark);
        }
        self
    }
    pub fn is_modified(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_modified)(obj_data);
            ret_val
        }
    }
    pub fn set_modified(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_modified)(obj_data, arg0);
        }
        self
    }
    ///
    /// Selects text from position *start* and for *length* characters.
    /// Negative lengths are allowed.
    ///
    /// **See also:** [`deselect()`]
    /// [`select_all()`]
    /// [`selected_text()`]
    pub fn set_selection(&self, arg0: i32, arg1: i32) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_selection)(obj_data, arg0, arg1);
        }
        self
    }
    ///
    /// hasSelectedText() returns `true` if some or all of the text has been
    /// selected by the user; otherwise returns `false.`
    ///
    /// By default, this property is `false.`
    ///
    /// **See also:** [`selected_text()`]
    pub fn has_selected_text(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_selected_text)(obj_data);
            ret_val
        }
    }
    ///
    /// If there is no selected text this property's value is
    /// an empty string.
    ///
    /// By default, this property contains an empty string.
    ///
    /// **See also:** [`has_selected_text()`]
    pub fn selected_text(&self) -> String {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).selected_text)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns the index of the first selected character in the
    /// line edit or -1 if no text is selected.
    ///
    /// **See also:** [`selected_text()`]
    /// **See also:** [`selection_end()`]
    /// **See also:** [`selection_length()`]
    pub fn selection_start(&self) -> i32 {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).selection_start)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the index of the character directly after the selection
    /// in the line edit or -1 if no text is selected.
    ///
    /// **See also:** [`selected_text()`]
    /// **See also:** [`selection_start()`]
    /// **See also:** [`selection_length()`]
    pub fn selection_end(&self) -> i32 {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).selection_end)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the length of the selection.
    ///
    /// **See also:** [`selected_text()`]
    /// **See also:** [`selection_start()`]
    /// **See also:** [`selection_end()`]
    pub fn selection_length(&self) -> i32 {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).selection_length)(obj_data);
            ret_val
        }
    }
    pub fn is_undo_available(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_undo_available)(obj_data);
            ret_val
        }
    }
    pub fn is_redo_available(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_redo_available)(obj_data);
            ret_val
        }
    }
    pub fn set_drag_enabled(&self, b: bool) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_drag_enabled)(obj_data, b);
        }
        self
    }
    ///
    /// Dragging is disabled by default.
    pub fn drag_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).drag_enabled)(obj_data);
            ret_val
        }
    }
    pub fn set_cursor_move_style(&self, style: CursorMoveStyle) -> &Self {
        let enum_style_1 = style as u32;

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_cursor_move_style)(obj_data, enum_style_1);
        }
        self
    }
    ///
    /// When this property is set to Qt::VisualMoveStyle, the line edit will use visual
    /// movement style. Pressing the left arrow key will always cause the cursor to move
    /// left, regardless of the text's writing direction. The same behavior applies to
    /// right arrow key.
    ///
    /// When the property is Qt::LogicalMoveStyle (the default), within a LTR text block,
    /// increase cursor position when pressing left arrow key, decrease cursor position
    /// when pressing the right arrow key. If the text block is right to left, the opposite
    /// behavior applies.
    pub fn cursor_move_style(&self) -> CursorMoveStyle {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cursor_move_style)(obj_data);
            let ret_val = { transmute::<u32, CursorMoveStyle>(ret_val) };
            ret_val
        }
    }
    ///
    /// If no mask is set, inputMask() returns an empty string.
    ///
    /// Sets the QLineEdit's validation mask. Validators can be used
    /// instead of, or in conjunction with masks; see setValidator().
    ///
    /// Unset the mask and return to normal QLineEdit operation by passing
    /// an empty string ("").
    ///
    /// The table below shows the characters that can be used in an input mask.
    /// A space character, the default character for a blank, is needed for cases
    /// where a character is *permitted but not required* .
    ///
    /// * Character
    /// * Meaning
    /// * `A`
    /// * ASCII alphabetic character required. A-Z, a-z.
    /// * `a`
    /// * ASCII alphabetic character permitted but not required.
    /// * `N`
    /// * ASCII alphanumeric character required. A-Z, a-z, 0-9.
    /// * `n`
    /// * ASCII alphanumeric character permitted but not required.
    /// * `X`
    /// * Any character required.
    /// * `x`
    /// * Any character permitted but not required.
    /// * `9`
    /// * ASCII digit required. 0-9.
    /// * `0`
    /// * ASCII digit permitted but not required.
    /// * `D`
    /// * ASCII digit required. 1-9.
    /// * `d`
    /// * ASCII digit permitted but not required (1-9).
    /// * `#`
    /// * ASCII digit or plus/minus sign permitted but not required.
    /// * `H`
    /// * Hexadecimal character required. A-F, a-f, 0-9.
    /// * `h`
    /// * Hexadecimal character permitted but not required.
    /// * `B`
    /// * Binary character required. 0-1.
    /// * `b`
    /// * Binary character permitted but not required.
    /// * `>`
    /// * All following alphabetic characters are uppercased.
    /// * `<`
    /// * All following alphabetic characters are lowercased.
    /// * `!`
    /// * Switch off case conversion.
    /// * `[ ] {` }
    /// * Reserved.
    /// * `\\`
    /// * Use `\\` to escape the special characters listed above to use them as separators.
    ///
    /// The mask consists of a string of mask characters and separators,
    /// optionally followed by a semicolon and the character used for
    /// blanks. The blank characters are always removed from the text
    /// after editing.
    ///
    /// Examples:
    /// * Mask
    /// * Notes
    /// * `000.000.000.000;_`
    /// * IP address; blanks are `_` .
    /// * `HH:HH:HH:HH:HH:HH;_`
    /// * MAC address
    /// * `0000-00-00`
    /// * ISO Date; blanks are `space`
    /// * `>AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#`
    /// * License number; blanks are `-` and all (alphabetic) characters are converted to uppercase.
    ///
    /// To get range control (e.g., for an IP address) use masks together
    /// with [validators](setValidator())
    ///
    ///
    /// **See also:** maxLength
    pub fn input_mask(&self) -> String {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).input_mask)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    pub fn set_input_mask(&self, input_mask: &str) -> &Self {
        let str_in_input_mask_1 = CString::new(input_mask).unwrap();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_input_mask)(obj_data, str_in_input_mask_1.as_ptr());
        }
        self
    }
    pub fn has_acceptable_input(&self) -> bool {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_acceptable_input)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the margins around the text inside the frame to have the
    /// sizes *left,* *top,* *right,* and *bottom.*
    ///
    /// See also getTextMargins().
    ///
    /// Sets the *margins* around the text inside the frame.
    ///
    /// See also textMargins().
    pub fn set_text_margins(&self, left: i32, top: i32, right: i32, bottom: i32) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_text_margins)(obj_data, left, top, right, bottom);
        }
        self
    }
    ///
    /// Sets the margins around the text inside the frame to have the
    /// sizes *left,* *top,* *right,* and *bottom.*
    ///
    /// See also getTextMargins().
    ///
    /// Sets the *margins* around the text inside the frame.
    ///
    /// See also textMargins().
    pub fn set_text_margins_2<M: MarginsTrait<'a>>(&self, margins: &M) -> &Self {
        let (obj_margins_1, _funcs) = margins.get_margins_obj_funcs();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_text_margins_2)(obj_data, obj_margins_1);
        }
        self
    }
    ///
    /// Returns the widget's text margins.
    ///
    /// **See also:** [`set_text_margins()`]
    pub fn text_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).text_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the margins around the text inside the frame to have the
    /// sizes *left,* *top,* *right,* and *bottom.*
    ///
    /// See also getTextMargins().
    ///
    /// Sets the *margins* around the text inside the frame.
    ///
    /// See also textMargins().
    pub fn set_text(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).set_text)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    ///
    /// If enabled, the line edit displays a trailing *clear* button when it contains
    /// some text, otherwise the line edit does not show a clear button (the
    /// default).
    ///
    /// **See also:** [`add_action()`]
    /// [`remove_action()`]
    ///
    /// Clears the contents of the line edit.
    ///
    /// **See also:** [`set_text()`]
    /// [`insert()`]
    pub fn clear(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).clear)(obj_data);
        }
        self
    }
    ///
    /// Selects all the text (i.e. highlights it) and moves the cursor to
    /// the end. This is useful when a default value has been inserted
    /// because if the user types before clicking on the widget, the
    /// selected text will be deleted.
    ///
    /// **See also:** [`set_selection()`]
    /// [`deselect()`]
    pub fn select_all(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).select_all)(obj_data);
        }
        self
    }
    ///
    /// Undo becomes available once the user has modified the text in the line edit.
    ///
    /// By default, this property is `false.`
    ///
    /// Undoes the last operation if undo is [available](QLineEdit::undoAvailable)
    /// . Deselects any current
    /// selection, and updates the selection start to the current cursor
    /// position.
    pub fn undo(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).undo)(obj_data);
        }
        self
    }
    ///
    /// Redo becomes available once the user has performed one or more undo operations
    /// on text in the line edit.
    ///
    /// By default, this property is `false.`
    ///
    /// Redoes the last operation if redo is [available](QLineEdit::redoAvailable)
    ///
    pub fn redo(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).redo)(obj_data);
        }
        self
    }
    ///
    /// Copies the selected text to the clipboard and deletes it, if there
    /// is any, and if echoMode() is [Normal.](Normal.)
    ///
    /// If the current validator disallows deleting the selected text,
    /// cut() will copy without deleting.
    ///
    /// **See also:** [`copy()`]
    /// [`paste()`]
    /// [`set_validator()`]
    pub fn cut(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).cut)(obj_data);
        }
        self
    }
    ///
    /// Copies the selected text to the clipboard, if there is any, and if
    /// echoMode() is [Normal.](Normal.)
    ///
    /// **See also:** [`cut()`]
    /// [`paste()`]
    pub fn copy(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).copy)(obj_data);
        }
        self
    }
    ///
    /// Inserts the clipboard's text at the cursor position, deleting any
    /// selected text, providing the line edit is not [read-only](QLineEdit::readOnly)
    ///
    ///
    /// If the end result would not be acceptable to the current
    /// [validator](setValidator())
    /// , nothing happens.
    ///
    /// **See also:** [`copy()`]
    /// [`cut()`]
    pub fn paste(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).paste)(obj_data);
        }
        self
    }
    ///
    /// Deselects any selected text.
    ///
    /// **See also:** [`set_selection()`]
    /// [`select_all()`]
    pub fn deselect(&self) -> &Self {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).deselect)(obj_data);
        }
        self
    }
    ///
    /// Deletes any selected text, inserts *newText,* and validates the
    /// result. If it is valid, it sets it as the new contents of the line
    /// edit.
    ///
    /// **See also:** [`set_text()`]
    /// [`clear()`]
    pub fn insert(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        unsafe {
            ((*funcs).insert)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    ///
    /// This signal is emitted whenever the text changes. The *text*
    /// argument is the new text.
    ///
    /// Unlike textEdited(), this signal is also emitted when the text is
    /// changed programmatically, for example, by calling setText().
    pub fn set_text_changed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &str) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &str) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_text_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_text_changed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_text_changed_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&str) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&str) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_text_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_text_changed_trampoline as usize),
            );
        }

        self
    }
    ///
    /// This signal is emitted whenever the text is edited. The *text*
    /// argument is the new text.
    ///
    /// Unlike textChanged(), this signal is not emitted when the text is
    /// changed programmatically, for example, by calling setText().
    pub fn set_text_edited_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &str) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &str) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_text_edited_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_text_edited_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_text_edited_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&str) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&str) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_text_edited_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_text_edited_trampoline as usize),
            );
        }

        self
    }
    ///
    /// This signal is emitted whenever the cursor moves. The previous
    /// position is given by *oldPos,* and the new position by *newPos.*
    ///
    /// **See also:** [`set_cursor_position()`]
    /// [`cursor_position()`]
    pub fn set_cursor_position_changed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, i32, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, i32, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_cursor_position_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_cursor_position_changed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_cursor_position_changed_event<F>(&self, func: F) -> &Self
    where
        F: Fn(i32, i32) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(i32, i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_cursor_position_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_cursor_position_changed_trampoline as usize),
            );
        }

        self
    }
    ///
    /// This signal is emitted when the Return or Enter key is pressed.
    /// Note that if there is a validator() or inputMask() set on the line
    /// edit, the returnPressed() signal will only be emitted if the input
    /// follows the inputMask() and the validator() returns
    /// QValidator::Acceptable.
    pub fn set_return_pressed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_return_pressed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_return_pressed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_return_pressed_event<F>(&self, func: F) -> &Self
    where
        F: Fn() + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn() + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_return_pressed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_return_pressed_trampoline as usize),
            );
        }

        self
    }
    ///
    /// This signal is emitted when the Return or Enter key is pressed or
    /// the line edit loses focus. Note that if there is a validator() or
    /// inputMask() set on the line edit and enter/return is pressed, the
    /// editingFinished() signal will only be emitted if the input follows
    /// the inputMask() and the validator() returns QValidator::Acceptable.
    pub fn set_editing_finished_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_editing_finished_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_editing_finished_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_editing_finished_event<F>(&self, func: F) -> &Self
    where
        F: Fn() + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn() + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_editing_finished_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_editing_finished_trampoline as usize),
            );
        }

        self
    }
    ///
    /// This signal is emitted whenever the selection changes.
    ///
    /// **See also:** [`has_selected_text()`]
    /// [`selected_text()`]
    pub fn set_selection_changed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_selection_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_selection_changed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_selection_changed_event<F>(&self, func: F) -> &Self
    where
        F: Fn() + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn() + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_selection_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_selection_changed_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_mouse_press_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &MouseEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_press_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_press_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_mouse_press_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&MouseEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&MouseEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_press_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_press_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_mouse_move_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &MouseEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_move_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_move_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_mouse_move_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&MouseEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&MouseEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_move_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_move_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_mouse_release_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &MouseEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_release_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_release_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_mouse_release_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&MouseEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&MouseEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_release_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_release_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_mouse_double_click_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &MouseEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_double_click_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_double_click_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_mouse_double_click_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&MouseEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&MouseEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_double_click_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_mouse_double_click_trampoline as usize),
            );
        }

        self
    }
    ///
    /// Converts the given key press *event* into a line edit action.
    ///
    /// If Return or Enter is pressed and the current text is valid (or
    /// can be [made valid](QValidator::fixup())
    /// by the
    /// validator), the signal returnPressed() is emitted.
    ///
    /// The default key bindings are listed in the class's detailed
    /// description.
    pub fn set_key_press_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &KeyEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &KeyEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_key_press_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_key_press_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_key_press_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&KeyEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&KeyEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_key_press_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_key_press_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_focus_in_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &FocusEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &FocusEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_focus_in_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_focus_in_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_focus_in_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&FocusEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&FocusEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_focus_in_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_focus_in_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_focus_out_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &FocusEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &FocusEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_focus_out_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_focus_out_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_focus_out_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&FocusEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&FocusEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_focus_out_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_focus_out_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_paint_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &PaintEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &PaintEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_paint_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_paint_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_paint_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&PaintEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&PaintEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_paint_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_paint_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_drag_enter_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &DragEnterEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &DragEnterEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_drag_enter_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_drag_enter_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_drag_enter_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&DragEnterEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&DragEnterEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_drag_enter_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_drag_enter_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_drag_move_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &DragMoveEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &DragMoveEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_drag_move_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_drag_move_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_drag_move_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&DragMoveEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&DragMoveEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_drag_move_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_drag_move_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_drag_leave_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &DragLeaveEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &DragLeaveEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_drag_leave_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_drag_leave_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_drag_leave_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&DragLeaveEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&DragLeaveEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_drag_leave_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_drag_leave_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_drop_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &DropEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &DropEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_drop_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_drop_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_drop_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&DropEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&DropEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_drop_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_drop_trampoline as usize),
            );
        }

        self
    }
    ///
    pub fn set_change_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_change_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_change_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_change_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_change_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_change_trampoline as usize),
            );
        }

        self
    }
    ///
    /// Shows the standard context menu created with
    /// createStandardContextMenu().
    ///
    /// If you do not want the line edit to have a context menu, you can set
    /// its [contextMenuPolicy](contextMenuPolicy)
    /// to Qt::NoContextMenu. If you want to
    /// customize the context menu, reimplement this function. If you want
    /// to extend the standard context menu, reimplement this function, call
    /// createStandardContextMenu() and extend the menu returned.
    ///
    /// The *event* parameter is used to obtain the position where
    /// the mouse cursor was when the event was generated.
    ///
    /// **See also:** [`set_context_menu_policy()`]
    pub fn set_context_menu_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &ContextMenuEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();

        let f: Box<Box<Fn(&T, &ContextMenuEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_context_menu_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(line_edit_context_menu_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_context_menu_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&ContextMenuEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_line_edit_obj_funcs();
        let f: Box<Box<Fn(&ContextMenuEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_context_menu_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(line_edit_context_menu_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn win_id(&self) -> u64 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).win_id)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn create_win_id(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).create_win_id)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn internal_win_id(&self) -> u64 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).internal_win_id)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn effective_win_id(&self) -> u64 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).effective_win_id)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn style(&self) -> Option<Style> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).style)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Style::new_from_rc(t);
            } else {
                ret_val = Style::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_style<S: StyleTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_style_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_style)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_top_level(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_top_level)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_modal(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_modal)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn window_modality(&self) -> WindowModality {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_modality)(obj_data);
            let ret_val = { transmute::<u32, WindowModality>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_modality(&self, window_modality: WindowModality) -> &Self {
        let enum_window_modality_1 = window_modality as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_modality)(obj_data, enum_window_modality_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_enabled)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_enabled_to<W: WidgetTrait<'a>>(&self, arg0: &W) -> bool {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_enabled_to)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_enabled(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_enabled)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_disabled(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_disabled)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_window_modified(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_modified)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn x(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn y(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn pos(&self) -> Point {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pos)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn frame_size(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).frame_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn size(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn width(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).width)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn height(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn children_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).children_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn children_region(&self) -> Region {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).children_region)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_width(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_width)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_height(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_height)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn maximum_width(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_width)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn maximum_height(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_height)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_minimum_size<S: SizeTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_size)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_minimum_size_2(&self, minw: i32, minh: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_size_2)(obj_data, minw, minh);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_maximum_size<S: SizeTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_size)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_maximum_size_2(&self, maxw: i32, maxh: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_size_2)(obj_data, maxw, maxh);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_minimum_width(&self, minw: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_width)(obj_data, minw);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_minimum_height(&self, minh: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_height)(obj_data, minh);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_maximum_width(&self, maxw: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_width)(obj_data, maxw);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_maximum_height(&self, maxh: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_height)(obj_data, maxh);
        }
        self
    }
    #[doc(hidden)]
    pub fn size_increment(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_increment)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_size_increment<S: SizeTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_size_increment)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_size_increment_2(&self, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_size_increment_2)(obj_data, w, h);
        }
        self
    }
    #[doc(hidden)]
    pub fn base_size(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).base_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_base_size<S: SizeTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_base_size)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_base_size_2(&self, basew: i32, baseh: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_base_size_2)(obj_data, basew, baseh);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_fixed_size<S: SizeTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_fixed_size)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_fixed_size_2(&self, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_fixed_size_2)(obj_data, w, h);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_fixed_width(&self, w: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_fixed_width)(obj_data, w);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_fixed_height(&self, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_fixed_height)(obj_data, h);
        }
        self
    }
    #[doc(hidden)]
    pub fn map_to_global<P: PointTrait<'a>>(&self, arg0: &P) -> Point {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_to_global)(obj_data, obj_arg0_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn map_from_global<P: PointTrait<'a>>(&self, arg0: &P) -> Point {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_from_global)(obj_data, obj_arg0_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn map_to_parent<P: PointTrait<'a>>(&self, arg0: &P) -> Point {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_to_parent)(obj_data, obj_arg0_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn map_from_parent<P: PointTrait<'a>>(&self, arg0: &P) -> Point {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_from_parent)(obj_data, obj_arg0_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn map_to<P: PointTrait<'a>, W: WidgetTrait<'a>>(&self, arg0: &W, arg1: &P) -> Point {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let (obj_arg1_2, _funcs) = arg1.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_to)(obj_data, obj_arg0_1, obj_arg1_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn map_from<P: PointTrait<'a>, W: WidgetTrait<'a>>(&self, arg0: &W, arg1: &P) -> Point {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let (obj_arg1_2, _funcs) = arg1.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_from)(obj_data, obj_arg0_1, obj_arg1_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn window(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn native_parent_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).native_parent_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn palette(&self) -> Option<Palette> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).palette)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Palette::new_from_rc(t);
            } else {
                ret_val = Palette::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_palette<P: PaletteTrait<'a>>(&self, arg0: &P) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_palette_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_palette)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_background_role(&self, arg0: ColorRole) -> &Self {
        let enum_arg0_1 = arg0.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_background_role)(obj_data, enum_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn background_role(&self) -> ColorRole {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).background_role)(obj_data);
            let ret_val = ColorRole::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_foreground_role(&self, arg0: ColorRole) -> &Self {
        let enum_arg0_1 = arg0.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_foreground_role)(obj_data, enum_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn foreground_role(&self) -> ColorRole {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).foreground_role)(obj_data);
            let ret_val = ColorRole::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn font(&self) -> Option<Font> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).font)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Font::new_from_rc(t);
            } else {
                ret_val = Font::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_font<F: FontTrait<'a>>(&self, arg0: &F) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_font_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_font)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn cursor(&self) -> Cursor {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cursor)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Cursor::new_from_rc(t);
            } else {
                ret_val = Cursor::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_cursor<C: CursorTrait<'a>>(&self, arg0: &C) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_cursor_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_cursor)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn unset_cursor(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).unset_cursor)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_mouse_tracking(&self, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_mouse_tracking)(obj_data, enable);
        }
        self
    }
    #[doc(hidden)]
    pub fn has_mouse_tracking(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_mouse_tracking)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn under_mouse(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).under_mouse)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_tablet_tracking(&self, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_tablet_tracking)(obj_data, enable);
        }
        self
    }
    #[doc(hidden)]
    pub fn has_tablet_tracking(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_tablet_tracking)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_mask<B: BitmapTrait<'a>>(&self, arg0: &B) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_bitmap_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_mask)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_mask_2<R: RegionTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_mask_2)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn mask(&self) -> Region {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mask)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn clear_mask(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).clear_mask)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn render<P: PaintDeviceTrait<'a>, Q: PointTrait<'a>, R: RegionTrait<'a>>(
        &self,
        target: &P,
        target_offset: &Q,
        source_region: &R,
        render_flags: RenderFlags,
    ) -> &Self {
        let (obj_target_1, _funcs) = target.get_paint_device_obj_funcs();
        let (obj_target_offset_2, _funcs) = target_offset.get_point_obj_funcs();
        let (obj_source_region_3, _funcs) = source_region.get_region_obj_funcs();
        let enum_render_flags_4 = render_flags.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).render)(
                obj_data,
                obj_target_1,
                obj_target_offset_2,
                obj_source_region_3,
                enum_render_flags_4,
            );
        }
        self
    }
    #[doc(hidden)]
    pub fn render_2<P: PainterTrait<'a>, Q: PointTrait<'a>, R: RegionTrait<'a>>(
        &self,
        painter: &P,
        target_offset: &Q,
        source_region: &R,
        render_flags: RenderFlags,
    ) -> &Self {
        let (obj_painter_1, _funcs) = painter.get_painter_obj_funcs();
        let (obj_target_offset_2, _funcs) = target_offset.get_point_obj_funcs();
        let (obj_source_region_3, _funcs) = source_region.get_region_obj_funcs();
        let enum_render_flags_4 = render_flags.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).render_2)(
                obj_data,
                obj_painter_1,
                obj_target_offset_2,
                obj_source_region_3,
                enum_render_flags_4,
            );
        }
        self
    }
    #[doc(hidden)]
    pub fn grab<R: RectTrait<'a>>(&self, rectangle: &R) -> Pixmap {
        let (obj_rectangle_1, _funcs) = rectangle.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).grab)(obj_data, obj_rectangle_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn grab_gesture(&self, gtype: GestureType, flags: GestureFlags) -> &Self {
        let enum_gtype_1 = gtype.bits();
        let enum_flags_2 = flags.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).grab_gesture)(obj_data, enum_gtype_1, enum_flags_2);
        }
        self
    }
    #[doc(hidden)]
    pub fn ungrab_gesture(&self, gtype: GestureType) -> &Self {
        let enum_gtype_1 = gtype.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).ungrab_gesture)(obj_data, enum_gtype_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_window_title(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_title)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn set_style_sheet(&self, style_sheet: &str) -> &Self {
        let str_in_style_sheet_1 = CString::new(style_sheet).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_style_sheet)(obj_data, str_in_style_sheet_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn style_sheet(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).style_sheet)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn window_title(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_title)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_icon<I: IconTrait<'a>>(&self, icon: &I) -> &Self {
        let (obj_icon_1, _funcs) = icon.get_icon_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_icon)(obj_data, obj_icon_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn window_icon(&self) -> Icon {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_icon)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Icon::new_from_rc(t);
            } else {
                ret_val = Icon::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_icon_text(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_icon_text)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn window_icon_text(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_icon_text)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_role(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_role)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn window_role(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_role)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_file_path(&self, file_path: &str) -> &Self {
        let str_in_file_path_1 = CString::new(file_path).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_file_path)(obj_data, str_in_file_path_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn window_file_path(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_file_path)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_opacity(&self, level: f32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_opacity)(obj_data, level);
        }
        self
    }
    #[doc(hidden)]
    pub fn window_opacity(&self) -> f32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_opacity)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_modified(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_modified)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_tool_tip(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_tool_tip)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn tool_tip(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).tool_tip)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_tool_tip_duration(&self, msec: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_tool_tip_duration)(obj_data, msec);
        }
        self
    }
    #[doc(hidden)]
    pub fn tool_tip_duration(&self) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).tool_tip_duration)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_status_tip(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_status_tip)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn status_tip(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).status_tip)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_whats_this(&self, arg0: &str) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_whats_this)(obj_data, str_in_arg0_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn whats_this(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).whats_this)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn accessible_name(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).accessible_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_accessible_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_accessible_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn accessible_description(&self) -> String {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).accessible_description)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_accessible_description(&self, description: &str) -> &Self {
        let str_in_description_1 = CString::new(description).unwrap();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_accessible_description)(obj_data, str_in_description_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn set_layout_direction(&self, direction: LayoutDirection) -> &Self {
        let enum_direction_1 = direction as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_layout_direction)(obj_data, enum_direction_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn layout_direction(&self) -> LayoutDirection {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout_direction)(obj_data);
            let ret_val = { transmute::<u32, LayoutDirection>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn unset_layout_direction(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).unset_layout_direction)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_right_to_left(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_right_to_left)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_left_to_right(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_left_to_right)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_focus(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_focus)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_active_window(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_active_window)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn activate_window(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).activate_window)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn clear_focus(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).clear_focus)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_focus_2(&self, reason: FocusReason) -> &Self {
        let enum_reason_1 = reason as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_focus_2)(obj_data, enum_reason_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn focus_policy(&self) -> FocusPolicy {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).focus_policy)(obj_data);
            let ret_val = { transmute::<u32, FocusPolicy>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_focus_policy(&self, policy: FocusPolicy) -> &Self {
        let enum_policy_1 = policy as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_focus_policy)(obj_data, enum_policy_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn has_focus(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_focus)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_tab_order<W: WidgetTrait<'a>>(arg0: &W, arg1: &W) {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let (obj_arg1_2, _funcs) = arg1.get_widget_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_widget)(::std::ptr::null()).all_funcs).widget_funcs,
            )
        };
        unsafe {
            ((*funcs).set_tab_order)(obj_data, obj_arg0_1, obj_arg1_2);
        }
    }
    #[doc(hidden)]
    pub fn set_focus_proxy<W: WidgetTrait<'a>>(&self, arg0: &W) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_focus_proxy)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn focus_proxy(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).focus_proxy)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn context_menu_policy(&self) -> ContextMenuPolicy {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).context_menu_policy)(obj_data);
            let ret_val = { transmute::<u32, ContextMenuPolicy>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_context_menu_policy(&self, policy: ContextMenuPolicy) -> &Self {
        let enum_policy_1 = policy as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_context_menu_policy)(obj_data, enum_policy_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn grab_mouse(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).grab_mouse)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn grab_mouse_2<C: CursorTrait<'a>>(&self, arg0: &C) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_cursor_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).grab_mouse_2)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn release_mouse(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).release_mouse)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn grab_keyboard(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).grab_keyboard)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn release_keyboard(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).release_keyboard)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn grab_shortcut<K: KeySequenceTrait<'a>>(&self, key: &K, context: ShortcutContext) -> i32 {
        let (obj_key_1, _funcs) = key.get_key_sequence_obj_funcs();
        let enum_context_2 = context as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).grab_shortcut)(obj_data, obj_key_1, enum_context_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn release_shortcut(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).release_shortcut)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_shortcut_enabled(&self, id: i32, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_shortcut_enabled)(obj_data, id, enable);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_shortcut_auto_repeat(&self, id: i32, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_shortcut_auto_repeat)(obj_data, id, enable);
        }
        self
    }
    #[doc(hidden)]
    pub fn mouse_grabber() -> Option<Widget<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_widget)(::std::ptr::null()).all_funcs).widget_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).mouse_grabber)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn keyboard_grabber() -> Option<Widget<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_widget)(::std::ptr::null()).all_funcs).widget_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).keyboard_grabber)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn updates_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).updates_enabled)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_updates_enabled(&self, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_updates_enabled)(obj_data, enable);
        }
        self
    }
    #[doc(hidden)]
    pub fn update(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).update)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn repaint(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).repaint)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn update_2(&self, x: i32, y: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).update_2)(obj_data, x, y, w, h);
        }
        self
    }
    #[doc(hidden)]
    pub fn update_3<R: RectTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).update_3)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn update_4<R: RegionTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).update_4)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn repaint_2(&self, x: i32, y: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).repaint_2)(obj_data, x, y, w, h);
        }
        self
    }
    #[doc(hidden)]
    pub fn repaint_3<R: RectTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).repaint_3)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn repaint_4<R: RegionTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).repaint_4)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_hidden(&self, hidden: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_hidden)(obj_data, hidden);
        }
        self
    }
    #[doc(hidden)]
    pub fn show(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).show)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn hide(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).hide)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn show_minimized(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).show_minimized)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn show_maximized(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).show_maximized)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn show_full_screen(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).show_full_screen)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn show_normal(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).show_normal)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn close(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).close)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn raise(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).raise)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn lower(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).lower)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn stack_under<W: WidgetTrait<'a>>(&self, arg0: &W) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).stack_under)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn move_widget(&self, x: i32, y: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).move_widget)(obj_data, x, y);
        }
        self
    }
    #[doc(hidden)]
    pub fn move_2<P: PointTrait<'a>>(&self, arg0: &P) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).move_2)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn resize(&self, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).resize)(obj_data, w, h);
        }
        self
    }
    #[doc(hidden)]
    pub fn resize_2<S: SizeTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).resize_2)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn adjust_size(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).adjust_size)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_visible(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_visible)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_visible_to<W: WidgetTrait<'a>>(&self, arg0: &W) -> bool {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_visible_to)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_hidden(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_hidden)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_minimized(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_minimized)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_maximized(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_maximized)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_full_screen(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_full_screen)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn window_state(&self) -> WindowStates {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_state)(obj_data);
            let ret_val = WindowStates::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_window_state(&self, state: WindowStates) -> &Self {
        let enum_state_1 = state.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_state)(obj_data, enum_state_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn override_window_state(&self, state: WindowStates) -> &Self {
        let enum_state_1 = state.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).override_window_state)(obj_data, enum_state_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn size_policy(&self) -> SizePolicy {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_policy)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = SizePolicy::new_from_rc(t);
            } else {
                ret_val = SizePolicy::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_size_policy<S: SizePolicyTrait<'a>>(&self, arg0: &S) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_size_policy_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_size_policy)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_size_policy_2(&self, horizontal: Policy, vertical: Policy) -> &Self {
        let enum_horizontal_1 = horizontal as u32;
        let enum_vertical_2 = vertical as u32;

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_size_policy_2)(obj_data, enum_horizontal_1, enum_vertical_2);
        }
        self
    }
    #[doc(hidden)]
    pub fn height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn has_height_for_width(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_height_for_width)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn visible_region(&self) -> Region {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).visible_region)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_contents_margins(&self, left: i32, top: i32, right: i32, bottom: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins)(obj_data, left, top, right, bottom);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins_2<M: MarginsTrait<'a>>(&self, margins: &M) -> &Self {
        let (obj_margins_1, _funcs) = margins.get_margins_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins_2)(obj_data, obj_margins_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn contents_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn contents_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn layout(&self) -> Option<Layout> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Layout::new_from_rc(t);
            } else {
                ret_val = Layout::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_layout<L: LayoutTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_layout)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<W: WidgetTrait<'a>>(&self, parent: &W) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent_2<W: WidgetTrait<'a>>(&self, parent: &W, f: WindowFlags) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_widget_obj_funcs();
        let enum_f_2 = f.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_parent_2)(obj_data, obj_parent_1, enum_f_2);
        }
        self
    }
    #[doc(hidden)]
    pub fn scroll(&self, dx: i32, dy: i32) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).scroll)(obj_data, dx, dy);
        }
        self
    }
    #[doc(hidden)]
    pub fn scroll_2<R: RectTrait<'a>>(&self, dx: i32, dy: i32, arg0: &R) -> &Self {
        let (obj_arg0_3, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).scroll_2)(obj_data, dx, dy, obj_arg0_3);
        }
        self
    }
    #[doc(hidden)]
    pub fn focus_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).focus_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn next_in_focus_chain(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).next_in_focus_chain)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn previous_in_focus_chain(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).previous_in_focus_chain)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn accept_drops(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).accept_drops)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_accept_drops(&self, on: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_accept_drops)(obj_data, on);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_window_flags(&self, gtype: WindowFlags) -> &Self {
        let enum_gtype_1 = gtype.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_window_flags)(obj_data, enum_gtype_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn window_flags(&self) -> WindowFlags {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_flags)(obj_data);
            let ret_val = WindowFlags::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn override_window_flags(&self, wtype: WindowFlags) -> &Self {
        let enum_wtype_1 = wtype.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).override_window_flags)(obj_data, enum_wtype_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn find(arg0: u64) -> Option<Widget<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_widget)(::std::ptr::null()).all_funcs).widget_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).find)(obj_data, arg0);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn child_at(&self, x: i32, y: i32) -> Option<Widget> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).child_at)(obj_data, x, y);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn child_at_2<P: PointTrait<'a>>(&self, p: &P) -> Option<Widget> {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).child_at_2)(obj_data, obj_p_1);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn paint_engine(&self) -> Option<PaintEngine> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_engine)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintEngine::new_from_rc(t);
            } else {
                ret_val = PaintEngine::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn ensure_polished(&self) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).ensure_polished)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_ancestor_of<W: WidgetTrait<'a>>(&self, child: &W) -> bool {
        let (obj_child_1, _funcs) = child.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_ancestor_of)(obj_data, obj_child_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn auto_fill_background(&self) -> bool {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).auto_fill_background)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_auto_fill_background(&self, enabled: bool) -> &Self {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_auto_fill_background)(obj_data, enabled);
        }
        self
    }
    #[doc(hidden)]
    pub fn backing_store(&self) -> Option<BackingStore> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).backing_store)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = BackingStore::new_from_rc(t);
            } else {
                ret_val = BackingStore::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn window_handle(&self) -> Option<Window> {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_handle)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn create_window_container<A: WidgetTrait<'a>, W: WindowTrait<'a>>(
        window: &W,
        parent: &A,
        flags: WindowFlags,
    ) -> Option<Widget<'a>> {
        let (obj_window_1, _funcs) = window.get_window_obj_funcs();
        let (obj_parent_2, _funcs) = parent.get_widget_obj_funcs();
        let enum_flags_3 = flags.bits();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_widget)(::std::ptr::null()).all_funcs).widget_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).create_window_container)(
                obj_data,
                obj_window_1,
                obj_parent_2,
                enum_flags_3,
            );
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_window_title_changed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &str) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &str) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_window_title_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_window_title_changed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_window_title_changed_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&str) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&str) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_window_title_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_window_title_changed_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_window_icon_changed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Icon) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &Icon) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_window_icon_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_window_icon_changed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_window_icon_changed_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Icon) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&Icon) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_window_icon_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_window_icon_changed_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_window_icon_text_changed_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &str) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &str) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_window_icon_text_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_window_icon_text_changed_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_window_icon_text_changed_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&str) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&str) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_window_icon_text_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_window_icon_text_changed_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_custom_context_menu_requested_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Point) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &Point) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_context_menu_requested_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_custom_context_menu_requested_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_context_menu_requested_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Point) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&Point) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_context_menu_requested_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_custom_context_menu_requested_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_wheel_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &WheelEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &WheelEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_wheel_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_wheel_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_wheel_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&WheelEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&WheelEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_wheel_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_wheel_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_key_release_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &KeyEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &KeyEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_key_release_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_key_release_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_key_release_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&KeyEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&KeyEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_key_release_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_key_release_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_enter_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_enter_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_enter_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_enter_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_enter_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_enter_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_leave_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_leave_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_leave_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_leave_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_leave_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_leave_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_move_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &MoveEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &MoveEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_move_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_move_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_move_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&MoveEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&MoveEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_move_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_move_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_resize_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &ResizeEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &ResizeEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_resize_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_resize_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_resize_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&ResizeEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&ResizeEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_resize_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_resize_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_close_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &CloseEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &CloseEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_close_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_close_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_close_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&CloseEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&CloseEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_close_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_close_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_tablet_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &TabletEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &TabletEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_tablet_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_tablet_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_tablet_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&TabletEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&TabletEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_tablet_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_tablet_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_show_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &ShowEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &ShowEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_show_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_show_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_show_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&ShowEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&ShowEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_show_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_show_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn set_hide_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &HideEvent) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();

        let f: Box<Box<Fn(&T, &HideEvent) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_hide_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(widget_hide_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_hide_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&HideEvent) + 'a,
    {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        let f: Box<Box<Fn(&HideEvent) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_hide_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(widget_hide_trampoline as usize),
            );
        }

        self
    }
    #[doc(hidden)]
    pub fn input_method_hints(&self) -> InputMethodHints {
        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).input_method_hints)(obj_data);
            let ret_val = InputMethodHints::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_input_method_hints(&self, hints: InputMethodHints) -> &Self {
        let enum_hints_1 = hints.bits();

        let (obj_data, funcs) = self.get_widget_obj_funcs();
        unsafe {
            ((*funcs).set_input_method_hints)(obj_data, enum_hints_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn painting_active(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).painting_active)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn logical_dpi_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).logical_dpi_x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn logical_dpi_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).logical_dpi_y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn physical_dpi_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).physical_dpi_x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn physical_dpi_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).physical_dpi_y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn device_pixel_ratio(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn device_pixel_ratio_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio_f)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn color_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).color_count)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn depth(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).depth)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<WrapperRcOwn> for LineEdit<'a> {
    fn from(t: WrapperRcOwn) -> Self {
        let mut data = RULineEdit {
            qt_data: ::std::ptr::null(),
            host_data: ::std::ptr::null(),
            all_funcs: t.all_funcs as *const RULineEditAllFuncs,
        };

        if t.owned {
            data.host_data = t.data as *const RUBase;
            LineEdit::new_from_rc(data)
        } else {
            data.qt_data = t.data as *const RUBase;
            LineEdit::new_from_temporary(data)
        }
    }
}

pub trait LineEditTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_line_edit_obj_funcs(&self) -> (*const RUBase, *const RULineEditFuncs);
}

impl<'a> ObjectTrait<'a> for LineEdit<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> PaintDeviceTrait<'a> for LineEdit<'a> {
    #[doc(hidden)]
    fn get_paint_device_obj_funcs(&self) -> (*const RUBase, *const RUPaintDeviceFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).paint_device_funcs) }
    }
}

impl<'a> WidgetTrait<'a> for LineEdit<'a> {
    #[doc(hidden)]
    fn get_widget_obj_funcs(&self) -> (*const RUBase, *const RUWidgetFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).widget_funcs) }
    }
}

impl<'a> LineEditTrait<'a> for LineEdit<'a> {
    #[doc(hidden)]
    fn get_line_edit_obj_funcs(&self) -> (*const RUBase, *const RULineEditFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).line_edit_funcs) }
    }
}
#[repr(u32)]
pub enum ActionPosition {
    LeadingPosition = 0,
    TrailingPosition = 1,
}

#[repr(u32)]
pub enum EchoMode {
    Normal = 0,
    NoEcho = 1,
    Password = 2,
    PasswordEchoOnEdit = 3,
}
