// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// When a widget [accepts drop events](QWidget::setAcceptDrops())
/// , it will
/// receive this event if it has accepted the most recent QDragEnterEvent or
/// QDragMoveEvent sent to it.
///
/// The drop event contains a proposed action, available from proposedAction(), for
/// the widget to either accept or ignore. If the action can be handled by the
/// widget, you should call the acceptProposedAction() function. Since the
/// proposed action can be a combination of [Qt::DropAction](Qt::DropAction)
/// values, it may be
/// useful to either select one of these values as a default action or ask
/// the user to select their preferred action.
///
/// If the proposed drop action is not suitable, perhaps because your custom
/// widget does not support that action, you can replace it with any of the
/// [possible drop actions](possibleActions())
/// by calling setDropAction()
/// with your preferred action. If you set a value that is not present in the
/// bitwise OR combination of values returned by possibleActions(), the default
/// copy action will be used. Once a replacement drop action has been set, call
/// accept() instead of acceptProposedAction() to complete the drop operation.
///
/// The mimeData() function provides the data dropped on the widget in a QMimeData
/// object. This contains information about the MIME type of the data in addition to
/// the data itself.
///
/// **See also:** [`MimeData`]
/// [`Drag`]
/// {Drag and Drop}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct DropEvent<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUDropEventAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> DropEvent<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUDropEvent) -> DropEvent<'a> {
        DropEvent {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUDropEvent) -> DropEvent<'a> {
        DropEvent {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUDropEvent) -> DropEvent<'a> {
        DropEvent {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Returns the position where the drop was made.
    ///
    /// **See also:** [`drop_action()`]
    pub fn pos(&self) -> Point {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pos)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the position where the drop was made.
    pub fn pos_f(&self) -> Option<PointF> {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pos_f)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PointF::new_from_rc(t);
            } else {
                ret_val = PointF::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the mouse buttons that are pressed..
    pub fn mouse_buttons(&self) -> MouseButtons {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mouse_buttons)(obj_data);
            let ret_val = MouseButtons::from_bits_truncate(ret_val);
            ret_val
        }
    }
    ///
    /// Returns the modifier keys that are pressed.
    pub fn keyboard_modifiers(&self) -> KeyboardModifiers {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).keyboard_modifiers)(obj_data);
            let ret_val = KeyboardModifiers::from_bits_truncate(ret_val);
            ret_val
        }
    }
    ///
    /// Returns an OR-combination of possible drop actions.
    ///
    /// **See also:** [`drop_action()`]
    pub fn possible_actions(&self) -> DropActions {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).possible_actions)(obj_data);
            let ret_val = DropActions::from_bits_truncate(ret_val);
            ret_val
        }
    }
    ///
    /// Returns the proposed drop action.
    ///
    /// **See also:** [`drop_action()`]
    pub fn proposed_action(&self) -> DropAction {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).proposed_action)(obj_data);
            let ret_val = { transmute::<u32, DropAction>(ret_val) };
            ret_val
        }
    }
    ///
    /// Sets the drop action to be the proposed action.
    ///
    /// **See also:** [`set_drop_action()`]
    /// [`proposed_action()`]
    /// {QEvent::accept()}{accept()}
    pub fn accept_proposed_action(&self) -> &Self {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            ((*funcs).accept_proposed_action)(obj_data);
        }
        self
    }
    ///
    /// Returns the action to be performed on the data by the target. This may be
    /// different from the action supplied in proposedAction() if you have called
    /// setDropAction() to explicitly choose a drop action.
    ///
    /// **See also:** [`set_drop_action()`]
    pub fn drop_action(&self) -> DropAction {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).drop_action)(obj_data);
            let ret_val = { transmute::<u32, DropAction>(ret_val) };
            ret_val
        }
    }
    ///
    /// Sets the *action* to be performed on the data by the target.
    /// Use this to override the [proposed action](proposedAction())
    ///
    /// with one of the [possible actions](possibleActions())
    ///
    ///
    /// If you set a drop action that is not one of the possible actions, the
    /// drag and drop operation will default to a copy operation.
    ///
    /// Once you have supplied a replacement drop action, call accept()
    /// instead of acceptProposedAction().
    ///
    /// **See also:** [`drop_action()`]
    pub fn set_drop_action(&self, action: DropAction) -> &Self {
        let enum_action_1 = action as u32;

        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            ((*funcs).set_drop_action)(obj_data, enum_action_1);
        }
        self
    }
    ///
    /// If the source of the drag operation is a widget in this
    /// application, this function returns that source; otherwise it
    /// returns 0. The source of the operation is the first parameter to
    /// the QDrag object used instantiate the drag.
    ///
    /// This is useful if your widget needs special behavior when dragging
    /// to itself.
    ///
    /// **See also:** [`Drag::q_drag`]
    pub fn source(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).source)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the data that was dropped on the widget and its associated MIME
    /// type information.
    pub fn mime_data(&self) -> Option<MimeData> {
        let (obj_data, funcs) = self.get_drop_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mime_data)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = MimeData::new_from_rc(t);
            } else {
                ret_val = MimeData::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn spontaneous(&self) -> bool {
        let (obj_data, funcs) = self.get_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spontaneous)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_accepted(&self, accepted: bool) -> &Self {
        let (obj_data, funcs) = self.get_event_obj_funcs();
        unsafe {
            ((*funcs).set_accepted)(obj_data, accepted);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_accepted(&self) -> bool {
        let (obj_data, funcs) = self.get_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_accepted)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn accept(&self) -> &Self {
        let (obj_data, funcs) = self.get_event_obj_funcs();
        unsafe {
            ((*funcs).accept)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn ignore(&self) -> &Self {
        let (obj_data, funcs) = self.get_event_obj_funcs();
        unsafe {
            ((*funcs).ignore)(obj_data);
        }
        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<(WrapperRcOwn, bool)> for DropEvent<'a> {
    fn from(t: (WrapperRcOwn, bool)) -> Self {
        if t.1 {
            DropEvent::new_from_rc(t.0 as *const RUDropEvent)
        } else {
            DropEvent::new_from_temporary(t.0 as *const RUDropEvent)
        }
    }
}

pub trait DropEventTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_drop_event_obj_funcs(&self) -> (*const RUBase, *const RUDropEventFuncs);
}

impl<'a> EventTrait<'a> for DropEvent<'a> {
    #[doc(hidden)]
    fn get_event_obj_funcs(&self) -> (*const RUBase, *const RUEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).event_funcs) }
    }
}

impl<'a> DropEventTrait<'a> for DropEvent<'a> {
    #[doc(hidden)]
    fn get_drop_event_obj_funcs(&self) -> (*const RUBase, *const RUDropEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).drop_event_funcs) }
    }
}
