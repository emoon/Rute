// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// A color is normally specified in terms of RGB (red, green, and
/// blue) components, but it is also possible to specify it in terms
/// of HSV (hue, saturation, and value) and CMYK (cyan, magenta,
/// yellow and black) components. In addition a color can be specified
/// using a color name. The color name can be any of the SVG 1.0 color
/// names.
///
/// * RGB
/// * HSV
/// * CMYK
///
/// * ![qcolor-rgb.png](qcolor-rgb.png)
///
/// * ![qcolor-hsv.png](qcolor-hsv.png)
///
/// * ![qcolor-cmyk.png](qcolor-cmyk.png)
///
/// The QColor constructor creates the color based on RGB values. To
/// create a QColor based on either HSV or CMYK values, use the
/// toHsv() and toCmyk() functions respectively. These functions
/// return a copy of the color using the desired format. In addition
/// the static fromRgb(), fromHsv() and fromCmyk() functions create
/// colors from the specified values. Alternatively, a color can be
/// converted to any of the three formats using the convertTo()
/// function (returning a copy of the color in the desired format), or
/// any of the setRgb(), setHsv() and setCmyk() functions altering *this* color's format. The spec() function tells how the color was
/// specified.
///
/// A color can be set by passing an RGB string (such as ),
/// or an ARGB string (such as ) or a color name (such as ),
/// to the setNamedColor() function.
/// The color names are taken from the SVG 1.0 color names. The name()
/// function returns the name of the color in the format
/// . Colors can also be set using setRgb(), setHsv() and
/// setCmyk(). To get a lighter or darker color use the lighter() and
/// darker() functions respectively.
///
/// The isValid() function indicates whether a QColor is legal at
/// all. For example, a RGB color with RGB values out of range is
/// illegal. For performance reasons, QColor mostly disregards illegal
/// colors, and for that reason, the result of using an invalid color
/// is undefined.
///
/// The color components can be retrieved individually, e.g with
/// red(), hue() and cyan(). The values of the color components can
/// also be retrieved in one go using the getRgb(), getHsv() and
/// getCmyk() functions. Using the RGB color model, the color
/// components can in addition be accessed with rgb().
///
/// There are several related non-members: QRgb is a typdef for an
/// unsigned int representing the RGB value triplet (r, g, b). Note
/// that it also can hold a value for the alpha-channel (for more
/// information, see the [Alpha-Blended Drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
/// section). The qRed(), qBlue() and
/// qGreen() functions return the respective component of the given
/// QRgb value, while the qRgb() and qRgba() functions create and
/// return the QRgb triplet based on the given component
/// values. Finally, the qAlpha() function returns the alpha component
/// of the provided QRgb, and the qGray() function calculates and
/// return a gray value based on the given value.
///
/// QColor is platform and device independent. The QColormap class
/// maps the color to the hardware.
///
/// For more information about painting in general, see the [Paint
/// System](Paint%0A%20%20%20%20System)
/// documentation.
///
/// # Integer vs. Floating Point Precision
///
/// QColor supports floating point precision and provides floating
/// point versions of all the color components functions,
/// e.g. getRgbF(), hueF() and fromCmykF(). Note that since the
/// components are stored using 16-bit integers, there might be minor
/// deviations between the values set using, for example, setRgbF()
/// and the values returned by the getRgbF() function due to rounding.
///
/// While the integer based functions take values in the range 0-255
/// (except hue() which must have values within the range 0-359),
/// the floating point functions accept values in the range 0.0 - 1.0.
///
/// # Alpha-Blended Drawing
///
/// QColor also support alpha-blended outlining and filling. The
/// alpha channel of a color specifies the transparency effect, 0
/// represents a fully transparent color, while 255 represents a fully
/// opaque color. For example:
///
/// The code above produces the following output:
///
/// ![alphafill.png](alphafill.png)
///
/// The alpha channel of a color can be retrieved and set using the
/// alpha() and setAlpha() functions if its value is an integer, and
/// alphaF() and setAlphaF() if its value is qreal (double). By
/// default, the alpha-channel is set to 255 (opaque). To retrieve and
/// set *all* the RGB color components (including the alpha-channel)
/// in one go, use the rgba() and setRgba() functions.
///
/// # Predefined Colors
///
/// There are 20 predefined QColors described by the Qt::GlobalColor enum,
/// including black, white, primary and secondary colors, darker versions
/// of these colors and three shades of gray. QColor also recognizes a
/// variety of color names; the static colorNames() function returns a
/// QStringList color names that QColor knows about.
///
/// ![Qt Colors](qt-colors.png)
///
/// Additionally, the Qt::color0, Qt::color1 and Qt::transparent colors
/// are used for special purposes.
///
/// Qt::color0 (zero pixel value) and Qt::color1 (non-zero pixel value)
/// are special colors for drawing in QBitmaps. Painting with Qt::color0
/// sets the bitmap bits to 0 (transparent; i.e., background), and painting
/// with Qt::color1 sets the bits to 1 (opaque; i.e., foreground).
///
/// Qt::transparent is used to indicate a transparent pixel. When painting
/// with this value, a pixel value will be used that is appropriate for the
/// underlying pixel format in use.
///
/// # The HSV Color Model
///
/// The RGB model is hardware-oriented. Its representation is close to
/// what most monitors show. In contrast, HSV represents color in a way
/// more suited to the human perception of color. For example, the
/// relationships , , and
/// are easily expressed in HSV but are much harder to express in RGB.
///
/// HSV, like RGB, has three components:
///
/// * H, for hue, is in the range 0 to 359 if the color is chromatic (not gray), or meaningless if it is gray. It represents degrees on the color wheel familiar to most people. Red is 0 (degrees), green is 120, and blue is 240. ![qcolor-hue.png](qcolor-hue.png)
///
/// * S, for saturation, is in the range 0 to 255, and the bigger it is, the stronger the color is. Grayish colors have saturation near 0; very strong colors have saturation near 255. ![qcolor-saturation.png](qcolor-saturation.png)
///
/// * V, for value, is in the range 0 to 255 and represents lightness or brightness of the color. 0 is black; 255 is as far from black as possible. ![qcolor-value.png](qcolor-value.png)
///
/// Here are some examples: pure red is H=0, S=255, V=255; a dark red,
/// moving slightly towards the magenta, could be H=350 (equivalent to
/// -10), S=255, V=180; a grayish light red could have H about 0 (say
/// 350-359 or 0-10), S about 50-100, and S=255.
///
/// Qt returns a hue value of -1 for achromatic colors. If you pass a
/// hue value that is too large, Qt forces it into range. Hue 360 or 720 is
/// treated as 0; hue 540 is treated as 180.
///
/// In addition to the standard HSV model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
///
///
/// # The HSL Color Model
///
/// HSL is similar to HSV, however instead of the Value parameter, HSL
/// specifies a Lightness parameter.
///
/// # The CMYK Color Model
///
/// While the RGB and HSV color models are used for display on
/// computer monitors, the CMYK model is used in the four-color
/// printing process of printing presses and some hard-copy
/// devices.
///
/// CMYK has four components, all in the range 0-255: cyan (C),
/// magenta (M), yellow (Y) and black (K). Cyan, magenta and yellow
/// are called subtractive colors; the CMYK color model creates color
/// by starting with a white surface and then subtracting color by
/// applying the appropriate components. While combining cyan, magenta
/// and yellow gives the color black, subtracting one or more will
/// yield any other color. When combined in various percentages, these
/// three colors can create the entire spectrum of colors.
///
/// Mixing 100 percent of cyan, magenta and yellow *does* produce
/// black, but the result is unsatisfactory since it wastes ink,
/// increases drying time, and gives a muddy colour when printing. For
/// that reason, black is added in professional printing to provide a
/// solid black tone; hence the term 'four color process'.
///
/// In addition to the standard CMYK model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
///
///
/// **See also:** [`Palette`]
/// [`Brush`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Color<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUColorAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Color<'a> {
    pub fn new() -> Color<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_color)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Color {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUColor) -> Color<'a> {
        Color {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUColor) -> Color<'a> {
        Color {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUColor) -> Color<'a> {
        Color {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Returns `true` if the color is valid; otherwise returns `false.`
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    pub fn is_valid(&self) -> bool {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_valid)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// Returns the name of the color in the specified *format.*
    ///
    /// **See also:** [`set_named_color()`]
    /// NameFormat
    pub fn name(&self) -> String {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// Returns the name of the color in the specified *format.*
    ///
    /// **See also:** [`set_named_color()`]
    /// NameFormat
    pub fn name_2(&self, format: NameFormat) -> String {
        let enum_format_1 = format as u32;

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).name_2)(obj_data, enum_format_1);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** [`q_color()`]
    /// [`name()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    pub fn set_named_color(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_named_color)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** [`q_color()`]
    /// [`name()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** [`q_color()`]
    /// [`name()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    ///
    /// Returns how the color was specified.
    ///
    /// **See also:** Spec
    /// [`convert_to()`]
    pub fn spec(&self) -> Spec {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spec)(obj_data);
            let ret_val = { transmute::<u32, Spec>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** [`set_alpha()`]
    /// [`alpha_f()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** [`set_alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    pub fn alpha(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alpha)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the alpha of this color to *alpha.* Integer alpha is specified in the
    /// range 0-255.
    ///
    /// **See also:** [`alpha()`]
    /// [`alpha_f()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    ///
    /// **See also:** [`alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    pub fn set_alpha(&self, alpha: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_alpha)(obj_data, alpha);
        }
        self
    }
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** [`set_alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    pub fn alpha_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alpha_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    ///
    /// **See also:** [`alpha_f()`]
    /// [`alpha()`]
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    pub fn set_alpha_f(&self, alpha: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_alpha_f)(obj_data, alpha);
        }
        self
    }
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** [`set_red()`]
    /// [`red_f()`]
    /// [`get_rgb()`]
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** [`set_red_f()`]
    /// [`red()`]
    /// [`get_rgb_f()`]
    pub fn red(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).red)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** [`set_green()`]
    /// [`green_f()`]
    /// [`get_rgb()`]
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** [`set_green_f()`]
    /// [`green()`]
    /// [`get_rgb_f()`]
    pub fn green(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).green)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** [`set_blue()`]
    /// [`blue_f()`]
    /// [`get_rgb()`]
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** [`set_blue_f()`]
    /// [`blue()`]
    /// [`get_rgb_f()`]
    pub fn blue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).blue)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the red color component of this color to *red.* Integer components
    /// are specified in the range 0-255.
    ///
    /// **See also:** [`red()`]
    /// [`red_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`red_f()`]
    /// [`red()`]
    /// [`set_rgb_f()`]
    pub fn set_red(&self, red: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_red)(obj_data, red);
        }
        self
    }
    ///
    /// Sets the green color component of this color to *green.* Integer
    /// components are specified in the range 0-255.
    ///
    /// **See also:** [`green()`]
    /// [`green_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`green_f()`]
    /// [`green()`]
    /// [`set_rgb_f()`]
    pub fn set_green(&self, green: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_green)(obj_data, green);
        }
        self
    }
    ///
    /// Sets the blue color component of this color to *blue.* Integer components
    /// are specified in the range 0-255.
    ///
    /// **See also:** [`blue()`]
    /// [`blue_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`blue_f()`]
    /// [`blue()`]
    /// [`set_rgb_f()`]
    pub fn set_blue(&self, blue: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_blue)(obj_data, blue);
        }
        self
    }
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** [`set_red_f()`]
    /// [`red()`]
    /// [`get_rgb_f()`]
    pub fn red_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).red_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** [`set_green_f()`]
    /// [`green()`]
    /// [`get_rgb_f()`]
    pub fn green_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).green_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** [`set_blue_f()`]
    /// [`blue()`]
    /// [`get_rgb_f()`]
    pub fn blue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).blue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`red_f()`]
    /// [`red()`]
    /// [`set_rgb_f()`]
    pub fn set_red_f(&self, red: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_red_f)(obj_data, red);
        }
        self
    }
    ///
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`green_f()`]
    /// [`green()`]
    /// [`set_rgb_f()`]
    pub fn set_green_f(&self, green: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_green_f)(obj_data, green);
        }
        self
    }
    ///
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** [`blue_f()`]
    /// [`blue()`]
    /// [`set_rgb_f()`]
    pub fn set_blue_f(&self, blue: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_blue_f)(obj_data, blue);
        }
        self
    }
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    ///
    /// **See also:** [`rgb()`]
    /// [`set_rgb()`]
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the red(), green(),
    /// blue() and alpha() functions.
    ///
    /// **See also:** [`rgb()`]
    /// [`set_rgb()`]
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb()`]
    /// [`set_rgb_f()`]
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** [`rgba()`]
    /// [`rgb()`]
    /// [`set_rgba64()`]
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgba64()`]
    ///
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    pub fn set_rgb(&self, r: i32, g: i32, b: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_rgb)(obj_data, r, g, b, a);
        }
        self
    }
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    ///
    /// **See also:** [`rgb()`]
    /// [`set_rgb()`]
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb_f()`]
    /// [`set_rgb()`]
    pub fn set_rgb_f(&self, r: f32, g: f32, b: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_rgb_f)(obj_data, r, g, b, a);
        }
        self
    }
    ///
    /// Returns the RGB value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgb()`]
    /// [`rgba64()`]
    ///
    /// Returns the RGB64 value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba64()`]
    /// [`rgba()`]
    /// [`rgb()`]
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** [`rgba()`]
    /// [`rgb()`]
    /// [`set_rgba64()`]
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgba64()`]
    ///
    /// Returns the RGB value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgb()`]
    /// [`rgba64()`]
    ///
    /// Returns the RGB64 value of the color, including its alpha.
    ///
    /// For an invalid color, the alpha value of the returned color is unspecified.
    ///
    /// **See also:** [`set_rgba64()`]
    /// [`rgba()`]
    /// [`rgb()`]
    ///
    /// Returns the RGB value of the color. The alpha value is opaque.
    ///
    /// **See also:** [`get_rgb()`]
    /// [`rgba()`]
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb_f()`]
    /// [`set_rgb()`]
    ///
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`rgb()`]
    /// [`get_rgb()`]
    /// [`set_rgb_f()`]
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** [`rgba()`]
    /// [`rgb()`]
    /// [`set_rgba64()`]
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** [`set_rgba()`]
    /// [`rgba64()`]
    ///
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_hue()`]
    /// [`hue_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_hue_f()`]
    /// [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn hue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hue)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_saturation()`]
    /// [`saturation_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_saturation_f()`]
    /// [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    pub fn saturation(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).saturation)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    pub fn hsv_hue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_hue)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn hsv_saturation(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_saturation)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** [`value_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn value(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).value)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_hue_f()`]
    /// [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn hue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** [`hsv_saturation_f()`]
    /// [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    pub fn saturation_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).saturation_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    pub fn hsv_hue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_hue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn hsv_saturation_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_saturation_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn value_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).value_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsv_f()`]
    /// [`set_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    ///
    /// **See also:** [`get_hsv()`]
    /// [`set_hsv_f()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn set_hsv(&self, h: i32, s: i32, v: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsv)(obj_data, h, s, v, a);
        }
        self
    }
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsv_f()`]
    /// [`set_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn set_hsv_f(&self, h: f32, s: f32, v: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsv_f)(obj_data, h, s, v, a);
        }
        self
    }
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** [`cyan_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** [`cyan()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn cyan(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cyan)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** [`magenta_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** [`magenta()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn magenta(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).magenta)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** [`yellow_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** [`yellow()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn yellow(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).yellow)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** [`black_f()`]
    /// [`get_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** [`black()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn black(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).black)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** [`cyan()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn cyan_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cyan_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** [`magenta()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn magenta_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).magenta_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** [`yellow()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn yellow_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).yellow_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** [`black()`]
    /// [`get_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn black_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).black_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`get_cmyk()`]
    /// [`set_cmyk_f()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_cmyk_f()`]
    /// [`set_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn set_cmyk(&self, c: i32, m: i32, y: i32, k: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_cmyk)(obj_data, c, m, y, k, a);
        }
        self
    }
    ///
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_cmyk_f()`]
    /// [`set_cmyk()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn set_cmyk_f(&self, c: f32, m: f32, y: f32, k: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_cmyk_f)(obj_data, c, m, y, k, a);
        }
        self
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`get_hsl_f()`]
    /// [`get_hsl()`]
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsl_f()`]
    pub fn hsl_hue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_hue)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsv()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsl_f()`]
    pub fn hsl_saturation(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_saturation)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`lightness_f()`]
    /// [`get_hsl()`]
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsl_f()`]
    pub fn lightness(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).lightness)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** [`hue()`]
    /// [`get_hsl_f()`]
    pub fn hsl_hue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_hue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** [`saturation_f()`]
    /// [`get_hsl_f()`]
    pub fn hsl_saturation_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_saturation_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsl_f()`]
    pub fn lightness_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).lightness_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsl_f()`]
    /// [`set_hsl()`]
    ///
    /// Sets a HSL color value; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    ///
    /// **See also:** [`get_hsl()`]
    /// [`set_hsl_f()`]
    pub fn set_hsl(&self, h: i32, s: i32, l: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsl)(obj_data, h, s, l, a);
        }
        self
    }
    ///
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`get_hsl_f()`]
    /// [`set_hsl()`]
    pub fn set_hsl_f(&self, h: f32, s: f32, l: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsl_f)(obj_data, h, s, l, a);
        }
        self
    }
    ///
    /// Create and returns an RGB QColor based on this color.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    pub fn to_rgb(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_rgb)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns an HSV QColor based on this color.
    ///
    /// **See also:** [`from_hsv()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn to_hsv(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_hsv)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns a CMYK QColor based on this color.
    ///
    /// **See also:** [`from_cmyk()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn to_cmyk(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_cmyk)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns an HSL QColor based on this color.
    ///
    /// **See also:** [`from_hsl()`]
    /// [`convert_to()`]
    /// [`is_valid()`]
    pub fn to_hsl(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_hsl)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates a copy of *this* color in the format specified by *colorSpec.*
    ///
    /// **See also:** [`spec()`]
    /// [`to_cmyk()`]
    /// [`to_hsv()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    pub fn convert_to(&self, color_spec: Spec) -> Color {
        let enum_color_spec_1 = color_spec as u32;

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).convert_to)(obj_data, enum_color_spec_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    ///
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    ///
    /// **See also:** [`from_rgba()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`to_rgb()`]
    /// [`from_rgba64()`]
    /// [`from_rgb_f()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    ///
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    ///
    /// **See also:** [`from_rgba()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`to_rgb()`]
    /// [`from_rgba64()`]
    /// [`from_rgb_f()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    pub fn from_rgb_2(r: i32, g: i32, b: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_rgb_2)(obj_data, r, g, b, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgba64()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    pub fn from_rgb_f(r: f32, g: f32, b: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_rgb_f)(obj_data, r, g, b, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    pub fn from_rgba64(r: u16, g: u16, b: u16, a: u16) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_rgba64)(obj_data, r, g, b, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** [`from_rgb()`]
    /// [`from_rgb_f()`]
    /// [`to_rgb()`]
    /// [`is_valid()`]
    ///
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// The value of *s,* *v,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    ///
    /// **See also:** [`to_hsv()`]
    /// [`from_hsv_f()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsv()`]
    /// [`from_hsv()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn from_hsv(h: i32, s: i32, v: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsv)(obj_data, h, s, v, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsv()`]
    /// [`from_hsv()`]
    /// [`is_valid()`]
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    pub fn from_hsv_f(h: f32, s: f32, v: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsv_f)(obj_data, h, s, v, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** [`to_cmyk()`]
    /// [`from_cmyk_f()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_cmyk()`]
    /// [`from_cmyk()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn from_cmyk(c: i32, m: i32, y: i32, k: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_cmyk)(obj_data, c, m, y, k, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_cmyk()`]
    /// [`from_cmyk()`]
    /// [`is_valid()`]
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    pub fn from_cmyk_f(c: f32, m: f32, y: f32, k: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_cmyk_f)(obj_data, c, m, y, k, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// The value of *s,* *l,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    ///
    /// **See also:** [`to_hsl()`]
    /// [`from_hsl_f()`]
    /// [`is_valid()`]
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsl()`]
    /// [`from_hsl()`]
    /// [`is_valid()`]
    pub fn from_hsl(h: i32, s: i32, l: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsl)(obj_data, h, s, l, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** [`to_hsl()`]
    /// [`from_hsl()`]
    /// [`is_valid()`]
    pub fn from_hsl_f(h: f32, s: f32, l: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsl_f)(obj_data, h, s, l, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`lightness_f()`]
    /// [`get_hsl()`]
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** [`value()`]
    /// [`get_hsl_f()`]
    ///
    /// Returns a lighter (or darker) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`darker()`]
    /// [`is_valid()`]
    ///
    /// Use lighter( *factor)* instead.
    pub fn light(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).light)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a lighter (or darker) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`darker()`]
    /// [`is_valid()`]
    pub fn lighter(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).lighter)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a darker (or lighter) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`lighter()`]
    /// [`is_valid()`]
    ///
    /// Use darker( *factor)* instead.
    pub fn dark(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).dark)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a darker (or lighter) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** [`lighter()`]
    /// [`is_valid()`]
    pub fn darker(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).darker)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** [`set_named_color()`]
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    pub fn is_valid_color(name: &str) -> bool {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_valid_color)(obj_data, str_in_name_1.as_ptr());
            ret_val
        }
    }
}
pub trait ColorTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_color_obj_funcs(&self) -> (*const RUBase, *const RUColorFuncs);
}

impl<'a> ColorTrait<'a> for Color<'a> {
    #[doc(hidden)]
    fn get_color_obj_funcs(&self) -> (*const RUBase, *const RUColorFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).color_funcs) }
    }
}
#[repr(u32)]
pub enum Spec {
    Invalid = 0,
    Rgb = 1,
    Hsv = 2,
    Cmyk = 3,
    Hsl = 4,
}

#[repr(u32)]
pub enum NameFormat {
    HexRgb = 0,
    HexArgb = 1,
}
