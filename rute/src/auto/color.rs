// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

///
/// A color is normally specified in terms of RGB (red, green, and
/// blue) components, but it is also possible to specify it in terms
/// of HSV (hue, saturation, and value) and CMYK (cyan, magenta,
/// yellow and black) components. In addition a color can be specified
/// using a color name. The color name can be any of the SVG 1.0 color
/// names.
///
/// * RGB
/// * HSV
/// * CMYK
///
/// * ![qcolor-rgb.png](qcolor-rgb.png)
///
/// * ![qcolor-hsv.png](qcolor-hsv.png)
///
/// * ![qcolor-cmyk.png](qcolor-cmyk.png)
///
/// The QColor constructor creates the color based on RGB values. To
/// create a QColor based on either HSV or CMYK values, use the
/// toHsv() and toCmyk() functions respectively. These functions
/// return a copy of the color using the desired format. In addition
/// the static fromRgb(), fromHsv() and fromCmyk() functions create
/// colors from the specified values. Alternatively, a color can be
/// converted to any of the three formats using the convertTo()
/// function (returning a copy of the color in the desired format), or
/// any of the setRgb(), setHsv() and setCmyk() functions altering *this* color's format. The spec() function tells how the color was
/// specified.
///
/// A color can be set by passing an RGB string (such as ),
/// or an ARGB string (such as ) or a color name (such as ),
/// to the setNamedColor() function.
/// The color names are taken from the SVG 1.0 color names. The name()
/// function returns the name of the color in the format
/// . Colors can also be set using setRgb(), setHsv() and
/// setCmyk(). To get a lighter or darker color use the lighter() and
/// darker() functions respectively.
///
/// The isValid() function indicates whether a QColor is legal at
/// all. For example, a RGB color with RGB values out of range is
/// illegal. For performance reasons, QColor mostly disregards illegal
/// colors, and for that reason, the result of using an invalid color
/// is undefined.
///
/// The color components can be retrieved individually, e.g with
/// red(), hue() and cyan(). The values of the color components can
/// also be retrieved in one go using the getRgb(), getHsv() and
/// getCmyk() functions. Using the RGB color model, the color
/// components can in addition be accessed with rgb().
///
/// There are several related non-members: QRgb is a typdef for an
/// unsigned int representing the RGB value triplet (r, g, b). Note
/// that it also can hold a value for the alpha-channel (for more
/// information, see the [Alpha-Blended Drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
/// section). The qRed(), qBlue() and
/// qGreen() functions return the respective component of the given
/// QRgb value, while the qRgb() and qRgba() functions create and
/// return the QRgb triplet based on the given component
/// values. Finally, the qAlpha() function returns the alpha component
/// of the provided QRgb, and the qGray() function calculates and
/// return a gray value based on the given value.
///
/// QColor is platform and device independent. The QColormap class
/// maps the color to the hardware.
///
/// For more information about painting in general, see the [Paint
/// System](Paint%0A%20%20%20%20System)
/// documentation.
///
/// # Integer vs. Floating Point Precision
///
/// QColor supports floating point precision and provides floating
/// point versions of all the color components functions,
/// e.g. getRgbF(), hueF() and fromCmykF(). Note that since the
/// components are stored using 16-bit integers, there might be minor
/// deviations between the values set using, for example, setRgbF()
/// and the values returned by the getRgbF() function due to rounding.
///
/// While the integer based functions take values in the range 0-255
/// (except hue() which must have values within the range 0-359),
/// the floating point functions accept values in the range 0.0 - 1.0.
///
/// # Alpha-Blended Drawing
///
/// QColor also support alpha-blended outlining and filling. The
/// alpha channel of a color specifies the transparency effect, 0
/// represents a fully transparent color, while 255 represents a fully
/// opaque color. For example:
///
/// The code above produces the following output:
///
/// ![alphafill.png](alphafill.png)
///
/// The alpha channel of a color can be retrieved and set using the
/// alpha() and setAlpha() functions if its value is an integer, and
/// alphaF() and setAlphaF() if its value is qreal (double). By
/// default, the alpha-channel is set to 255 (opaque). To retrieve and
/// set *all* the RGB color components (including the alpha-channel)
/// in one go, use the rgba() and setRgba() functions.
///
/// # Predefined Colors
///
/// There are 20 predefined QColors described by the Qt::GlobalColor enum,
/// including black, white, primary and secondary colors, darker versions
/// of these colors and three shades of gray. QColor also recognizes a
/// variety of color names; the static colorNames() function returns a
/// QStringList color names that QColor knows about.
///
/// ![Qt Colors](qt-colors.png)
///
/// Additionally, the Qt::color0, Qt::color1 and Qt::transparent colors
/// are used for special purposes.
///
/// Qt::color0 (zero pixel value) and Qt::color1 (non-zero pixel value)
/// are special colors for drawing in QBitmaps. Painting with Qt::color0
/// sets the bitmap bits to 0 (transparent; i.e., background), and painting
/// with Qt::color1 sets the bits to 1 (opaque; i.e., foreground).
///
/// Qt::transparent is used to indicate a transparent pixel. When painting
/// with this value, a pixel value will be used that is appropriate for the
/// underlying pixel format in use.
///
/// # The HSV Color Model
///
/// The RGB model is hardware-oriented. Its representation is close to
/// what most monitors show. In contrast, HSV represents color in a way
/// more suited to the human perception of color. For example, the
/// relationships , , and
/// are easily expressed in HSV but are much harder to express in RGB.
///
/// HSV, like RGB, has three components:
///
/// * H, for hue, is in the range 0 to 359 if the color is chromatic (not gray), or meaningless if it is gray. It represents degrees on the color wheel familiar to most people. Red is 0 (degrees), green is 120, and blue is 240. ![qcolor-hue.png](qcolor-hue.png)
///
/// * S, for saturation, is in the range 0 to 255, and the bigger it is, the stronger the color is. Grayish colors have saturation near 0; very strong colors have saturation near 255. ![qcolor-saturation.png](qcolor-saturation.png)
///
/// * V, for value, is in the range 0 to 255 and represents lightness or brightness of the color. 0 is black; 255 is as far from black as possible. ![qcolor-value.png](qcolor-value.png)
///
/// Here are some examples: pure red is H=0, S=255, V=255; a dark red,
/// moving slightly towards the magenta, could be H=350 (equivalent to
/// -10), S=255, V=180; a grayish light red could have H about 0 (say
/// 350-359 or 0-10), S about 50-100, and S=255.
///
/// Qt returns a hue value of -1 for achromatic colors. If you pass a
/// hue value that is too large, Qt forces it into range. Hue 360 or 720 is
/// treated as 0; hue 540 is treated as 180.
///
/// In addition to the standard HSV model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
///
///
/// # The HSL Color Model
///
/// HSL is similar to HSV, however instead of the Value parameter, HSL
/// specifies a Lightness parameter.
///
/// # The CMYK Color Model
///
/// While the RGB and HSV color models are used for display on
/// computer monitors, the CMYK model is used in the four-color
/// printing process of printing presses and some hard-copy
/// devices.
///
/// CMYK has four components, all in the range 0-255: cyan (C),
/// magenta (M), yellow (Y) and black (K). Cyan, magenta and yellow
/// are called subtractive colors; the CMYK color model creates color
/// by starting with a white surface and then subtracting color by
/// applying the appropriate components. While combining cyan, magenta
/// and yellow gives the color black, subtracting one or more will
/// yield any other color. When combined in various percentages, these
/// three colors can create the entire spectrum of colors.
///
/// Mixing 100 percent of cyan, magenta and yellow *does* produce
/// black, but the result is unsatisfactory since it wastes ink,
/// increases drying time, and gives a muddy colour when printing. For
/// that reason, black is added in professional printing to provide a
/// solid black tone; hence the term 'four color process'.
///
/// In addition to the standard CMYK model, Qt provides an
/// alpha-channel to feature [alpha-blended drawing](QColor%23Alpha-Blended%0A%20%20%20%20Drawing)
///
///
/// **See also:** QPalette
/// QBrush
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Color<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUColorAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Color<'a> {
    pub fn new() -> Color<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_color)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Color {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    pub fn new_from_rc(ffi_data: RUColor) -> Color<'a> {
        Color {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUColor) -> Color<'a> {
        Color {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUColor) -> Color<'a> {
        Color {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}

pub struct ColorStatic<'a> {
    pub all_funcs: *const RUColorAllFuncs,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}
pub trait ColorType<'a> {
    ///
    /// Returns `true` if the color is valid; otherwise returns `false.`
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** setNamedColor()
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    fn is_valid(&self) -> bool {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_valid)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    ///
    /// **See also:** setNamedColor()
    ///
    /// Returns the name of the color in the specified *format.*
    ///
    /// **See also:** setNamedColor()
    /// NameFormat
    fn name(&self) -> String {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Returns the name of the color in the format ; i.e. a
    /// character followed by three two-digit hexadecimal numbers.
    ///
    /// **See also:** setNamedColor()
    ///
    /// Returns the name of the color in the specified *format.*
    ///
    /// **See also:** setNamedColor()
    /// NameFormat
    fn name(&self, format: NameFormat) -> String {
        let enum_format_1 = format as i32;

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).name)(obj_data, enum_format_1);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** QColor()
    /// name()
    /// isValid()
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    fn set_named_color(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_named_color)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** QColor()
    /// name()
    /// isValid()
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    fn set_named_color<S: StringViewType<'a>>(&self, name: &S) -> &Self {
        let (obj_name_1, _funcs) = name.get_string_view_obj_funcs();

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_named_color)(obj_data, obj_name_1);
        }
        self
    }
    ///
    /// Sets the RGB value of this QColor to *name,* which may be in one
    /// of these formats:
    ///
    /// * #RGB (each of R, G, and B is a single hex digit)
    /// * #RRGGBB
    /// * #AARRGGBB (Since 5.2)
    /// * #RRRGGGBBB
    /// * #RRRRGGGGBBBB
    /// * A name from the list of colors defined in the list of [SVG color keyword names](http://www.w3.org/TR/SVG/types.html%23ColorKeywords)
    /// provided by the World Wide Web Consortium; for example, "steelblue" or "gainsboro". These color names work on all platforms. Note that these color names are *not* the same as defined by the Qt::GlobalColor enums, e.g. "green" and Qt::green does not refer to the same color.
    /// * `transparent` - representing the absence of a color.
    ///
    /// The color is invalid if *name* cannot be parsed.
    ///
    /// **See also:** QColor()
    /// name()
    /// isValid()
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    fn set_named_color<L: Latin1StringType<'a>>(&self, name: &L) -> &Self {
        let (obj_name_1, _funcs) = name.get_latin1_string_obj_funcs();

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_named_color)(obj_data, obj_name_1);
        }
        self
    }
    ///
    /// Returns how the color was specified.
    ///
    /// **See also:** Spec
    /// convertTo()
    fn spec(&self) -> Spec {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spec)(obj_data);
            let ret_val = { transmute::<i32, Spec>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** setAlpha()
    /// alphaF()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** setAlphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    fn alpha(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alpha)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the alpha of this color to *alpha.* Integer alpha is specified in the
    /// range 0-255.
    ///
    /// **See also:** alpha()
    /// alphaF()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    ///
    /// **See also:** alphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    fn set_alpha(&self, alpha: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_alpha)(obj_data, alpha);
        }
        self
    }
    ///
    /// Returns the alpha color component of this color.
    ///
    /// **See also:** setAlphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    fn alpha_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alpha_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the alpha of this color to *alpha.* qreal alpha is specified in the
    /// range 0.0-1.0.
    ///
    /// **See also:** alphaF()
    /// alpha()
    /// {QColor#Alpha-Blended Drawing}{Alpha-Blended Drawing}
    ///
    fn set_alpha_f(&self, alpha: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_alpha_f)(obj_data, alpha);
        }
        self
    }
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** setRed()
    /// redF()
    /// getRgb()
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** setRedF()
    /// red()
    /// getRgbF()
    fn red(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).red)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** setGreen()
    /// greenF()
    /// getRgb()
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** setGreenF()
    /// green()
    /// getRgbF()
    fn green(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).green)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** setBlue()
    /// blueF()
    /// getRgb()
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** setBlueF()
    /// blue()
    /// getRgbF()
    fn blue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).blue)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the red color component of this color to *red.* Integer components
    /// are specified in the range 0-255.
    ///
    /// **See also:** red()
    /// redF()
    /// setRgb()
    ///
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** redF()
    /// red()
    /// setRgbF()
    fn set_red(&self, red: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_red)(obj_data, red);
        }
        self
    }
    ///
    /// Sets the green color component of this color to *green.* Integer
    /// components are specified in the range 0-255.
    ///
    /// **See also:** green()
    /// greenF()
    /// setRgb()
    ///
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** greenF()
    /// green()
    /// setRgbF()
    fn set_green(&self, green: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_green)(obj_data, green);
        }
        self
    }
    ///
    /// Sets the blue color component of this color to *blue.* Integer components
    /// are specified in the range 0-255.
    ///
    /// **See also:** blue()
    /// blueF()
    /// setRgb()
    ///
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** blueF()
    /// blue()
    /// setRgbF()
    fn set_blue(&self, blue: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_blue)(obj_data, blue);
        }
        self
    }
    ///
    /// Returns the red color component of this color.
    ///
    /// **See also:** setRedF()
    /// red()
    /// getRgbF()
    fn red_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).red_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the green color component of this color.
    ///
    /// **See also:** setGreenF()
    /// green()
    /// getRgbF()
    fn green_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).green_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the blue color component of this color.
    ///
    /// **See also:** setBlueF()
    /// blue()
    /// getRgbF()
    fn blue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).blue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the red color component of this color to *red.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** redF()
    /// red()
    /// setRgbF()
    fn set_red_f(&self, red: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_red_f)(obj_data, red);
        }
        self
    }
    ///
    /// Sets the green color component of this color to *green.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** greenF()
    /// green()
    /// setRgbF()
    fn set_green_f(&self, green: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_green_f)(obj_data, green);
        }
        self
    }
    ///
    /// Sets the blue color component of this color to *blue.* Float components
    /// are specified in the range 0.0-1.0.
    ///
    /// **See also:** blueF()
    /// blue()
    /// setRgbF()
    fn set_blue_f(&self, blue: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_blue_f)(obj_data, blue);
        }
        self
    }
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** rgb()
    /// getRgbF()
    /// setRgb()
    ///
    /// Sets the RGB value to *r,* *g,* *b* and the alpha value to *a.*
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** rgb()
    /// getRgb()
    /// setRgbF()
    ///
    /// Sets the RGB value to *rgba,* including its alpha.
    ///
    /// **See also:** rgba()
    /// rgb()
    /// setRgba64()
    ///
    /// Sets the RGB64 value to *rgba,* including its alpha.
    ///
    /// **See also:** \setRgba()
    /// rgba64()
    ///
    /// **Overloads**
    /// Sets the RGB value to *rgb.* The alpha value is set to opaque.
    fn set_rgb(&self, r: i32, g: i32, b: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_rgb)(obj_data, r, g, b, a);
        }
        self
    }
    ///
    /// Sets the contents pointed to by *r,* *g,* *b,* and *a,* to the red,
    /// green, blue, and alpha-channel (transparency) components of the color's
    /// RGB value.
    ///
    /// These components can be retrieved individually using the redF(), greenF(),
    /// blueF() and alphaF() functions.
    ///
    /// **See also:** rgb()
    /// setRgb()
    fn get_rgb_f(&self, r: &f32, g: &f32, b: &f32, a: &f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_rgb_f)(obj_data, r, g, b, a);
        }
        self
    }
    ///
    /// Sets the color channels of this color to *r* (red), *g* (green),
    /// *b* (blue) and *a* (alpha, transparency).
    ///
    /// All values must be in the range 0.0-1.0.
    ///
    /// **See also:** rgb()
    /// getRgbF()
    /// setRgb()
    fn set_rgb_f(&self, r: f32, g: f32, b: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_rgb_f)(obj_data, r, g, b, a);
        }
        self
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** hsvHue()
    /// hueF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** hsvHueF()
    /// hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn hue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hue)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** hsvSaturation()
    /// saturationF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** hsvSaturationF()
    /// saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    fn saturation(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).saturation)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** hueF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    fn hsv_hue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_hue)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** saturationF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn hsv_saturation(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_saturation)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** valueF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** value()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn value(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).value)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** hsvHueF()
    /// hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn hue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// The color is implicitly converted to HSV.
    ///
    /// **See also:** hsvSaturationF()
    /// saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    fn saturation_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).saturation_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** hue()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color
    /// Model}
    fn hsv_hue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_hue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** saturation()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn hsv_saturation_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsv_saturation_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the value color component of this color.
    ///
    /// **See also:** value()
    /// getHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn value_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).value_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    /// saturation, value, and alpha-channel (transparency) components of the
    /// color's HSV value.
    ///
    /// These components can be retrieved individually using the hueF(),
    /// saturationF(), valueF() and alphaF() functions.
    ///
    /// **See also:** setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    /// saturation, value, and alpha-channel (transparency) components of the
    /// color's HSV value.
    ///
    /// These components can be retrieved individually using the hue(),
    /// saturation(), value() and alpha() functions.
    ///
    /// **See also:** setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn get_hsv(&self, h: &i32, s: &i32, v: &i32, a: &i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_hsv)(obj_data, h, s, v, a);
        }
        self
    }
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** getHsvF()
    /// setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    ///
    /// **See also:** getHsv()
    /// setHsvF()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn set_hsv(&self, h: i32, s: i32, v: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsv)(obj_data, h, s, v, a);
        }
        self
    }
    ///
    /// Sets the contents pointed to by *h,* *s,* *v,* and *a,* to the hue,
    /// saturation, value, and alpha-channel (transparency) components of the
    /// color's HSV value.
    ///
    /// These components can be retrieved individually using the hueF(),
    /// saturationF(), valueF() and alphaF() functions.
    ///
    /// **See also:** setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn get_hsv_f(&self, h: &f32, s: &f32, v: &f32, a: &f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_hsv_f)(obj_data, h, s, v, a);
        }
        self
    }
    ///
    /// Sets a HSV color value; *h* is the hue, *s* is the saturation, *v* is
    /// the value and *a* is the alpha component of the HSV color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** getHsvF()
    /// setHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn set_hsv_f(&self, h: f32, s: f32, v: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsv_f)(obj_data, h, s, v, a);
        }
        self
    }
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** cyanF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** cyan()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn cyan(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cyan)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** magentaF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** magenta()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn magenta(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).magenta)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** yellowF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** yellow()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn yellow(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).yellow)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** blackF()
    /// getCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** black()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn black(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).black)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the cyan color component of this color.
    ///
    /// **See also:** cyan()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn cyan_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cyan_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the magenta color component of this color.
    ///
    /// **See also:** magenta()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn magenta_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).magenta_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the yellow color component of this color.
    ///
    /// **See also:** yellow()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn yellow_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).yellow_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the black color component of this color.
    ///
    /// **See also:** black()
    /// getCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn black_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).black_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    /// cyan, magenta, yellow, black, and alpha-channel (transparency) components
    /// of the color's CMYK value.
    ///
    /// These components can be retrieved individually using the cyan(), magenta(),
    /// yellow(), black() and alpha() functions.
    ///
    /// **See also:** setCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    /// cyan, magenta, yellow, black, and alpha-channel (transparency) components
    /// of the color's CMYK value.
    ///
    /// These components can be retrieved individually using the cyanF(),
    /// magentaF(), yellowF(), blackF() and alphaF() functions.
    ///
    /// **See also:** setCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn get_cmyk(&self, c: &i32, m: &i32, y: &i32, k: &i32, a: &i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_cmyk)(obj_data, c, m, y, k, a);
        }
        self
    }
    ///
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** getCmyk()
    /// setCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** getCmykF()
    /// setCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn set_cmyk(&self, c: i32, m: i32, y: i32, k: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_cmyk)(obj_data, c, m, y, k, a);
        }
        self
    }
    ///
    /// Sets the contents pointed to by *c,* *m,* *y,* *k,* and *a,* to the
    /// cyan, magenta, yellow, black, and alpha-channel (transparency) components
    /// of the color's CMYK value.
    ///
    /// These components can be retrieved individually using the cyanF(),
    /// magentaF(), yellowF(), blackF() and alphaF() functions.
    ///
    /// **See also:** setCmykF()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn get_cmyk_f(&self, c: &f32, m: &f32, y: &f32, k: &f32, a: &f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_cmyk_f)(obj_data, c, m, y, k, a);
        }
        self
    }
    ///
    /// **Overloads**
    /// Sets the color to CMYK values, *c* (cyan), *m* (magenta), *y* (yellow),
    /// *k* (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** getCmykF()
    /// setCmyk()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn set_cmyk_f(&self, c: f32, m: f32, y: f32, k: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_cmyk_f)(obj_data, c, m, y, k, a);
        }
        self
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** getHslF()
    /// getHsl()
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** hue()
    /// getHslF()
    fn hsl_hue(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_hue)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** saturationF()
    /// getHsv()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** saturationF()
    /// getHslF()
    fn hsl_saturation(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_saturation)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** lightnessF()
    /// getHsl()
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** value()
    /// getHslF()
    fn lightness(&self) -> i32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).lightness)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the hue color component of this color.
    ///
    /// **See also:** hue()
    /// getHslF()
    fn hsl_hue_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_hue_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the saturation color component of this color.
    ///
    /// **See also:** saturationF()
    /// getHslF()
    fn hsl_saturation_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).hsl_saturation_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** value()
    /// getHslF()
    fn lightness_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).lightness_f)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    /// saturation, lightness, and alpha-channel (transparency) components of the
    /// color's HSL value.
    ///
    /// These components can be retrieved individually using the hslHueF(),
    /// hslSaturationF(), lightnessF() and alphaF() functions.
    ///
    /// **See also:** setHsl()
    ///
    /// Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    /// saturation, lightness, and alpha-channel (transparency) components of the
    /// color's HSL value.
    ///
    /// These components can be retrieved individually using the hslHue(),
    /// hslSaturation(), lightness() and alpha() functions.
    ///
    /// **See also:** setHsl()
    fn get_hsl(&self, h: &i32, s: &i32, l: &i32, a: &i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_hsl)(obj_data, h, s, l, a);
        }
        self
    }
    ///
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** getHslF()
    /// setHsl()
    ///
    /// Sets a HSL color value; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// The saturation, value and alpha-channel values must be in the range 0-255,
    /// and the hue value must be greater than -1.
    ///
    /// **See also:** getHsl()
    /// setHslF()
    fn set_hsl(&self, h: i32, s: i32, l: i32, a: i32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsl)(obj_data, h, s, l, a);
        }
        self
    }
    ///
    /// Sets the contents pointed to by *h,* *s,* *l,* and *a,* to the hue,
    /// saturation, lightness, and alpha-channel (transparency) components of the
    /// color's HSL value.
    ///
    /// These components can be retrieved individually using the hslHueF(),
    /// hslSaturationF(), lightnessF() and alphaF() functions.
    ///
    /// **See also:** setHsl()
    fn get_hsl_f(&self, h: &f32, s: &f32, l: &f32, a: &f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).get_hsl_f)(obj_data, h, s, l, a);
        }
        self
    }
    ///
    /// Sets a HSL color lightness; *h* is the hue, *s* is the saturation, *l* is
    /// the lightness and *a* is the alpha component of the HSL color.
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** getHslF()
    /// setHsl()
    fn set_hsl_f(&self, h: f32, s: f32, l: f32, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            ((*funcs).set_hsl_f)(obj_data, h, s, l, a);
        }
        self
    }
    ///
    /// Create and returns an RGB QColor based on this color.
    ///
    /// **See also:** fromRgb()
    /// convertTo()
    /// isValid()
    fn to_rgb(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_rgb)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns an HSV QColor based on this color.
    ///
    /// **See also:** fromHsv()
    /// convertTo()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn to_hsv(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_hsv)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns a CMYK QColor based on this color.
    ///
    /// **See also:** fromCmyk()
    /// convertTo()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn to_cmyk(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_cmyk)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns an HSL QColor based on this color.
    ///
    /// **See also:** fromHsl()
    /// convertTo()
    /// isValid()
    fn to_hsl(&self) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_hsl)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates a copy of *this* color in the format specified by *colorSpec.*
    ///
    /// **See also:** spec()
    /// toCmyk()
    /// toHsv()
    /// toRgb()
    /// isValid()
    fn convert_to(&self, color_spec: Spec) -> Color {
        let enum_color_spec_1 = color_spec as i32;

        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).convert_to)(obj_data, enum_color_spec_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** lightnessF()
    /// getHsl()
    ///
    /// Returns the lightness color component of this color.
    ///
    /// **See also:** value()
    /// getHslF()
    ///
    /// Returns a lighter (or darker) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** darker()
    /// isValid()
    ///
    /// Use lighter( *factor)* instead.
    fn light(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).light)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a lighter (or darker) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a lighter
    /// color. Setting *factor* to 150 returns a color that is 50% brighter. If
    /// the *factor* is less than 100, the return color is darker, but we
    /// recommend using the darker() function for this purpose. If the *factor*
    /// is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, multiplies the value
    /// (V) component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** darker()
    /// isValid()
    fn lighter(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).lighter)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a darker (or lighter) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** lighter()
    /// isValid()
    ///
    /// Use darker( *factor)* instead.
    fn dark(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).dark)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a darker (or lighter) color, but does not change this object.
    ///
    /// If the *factor* is greater than 100, this functions returns a darker
    /// color. Setting *factor* to 300 returns a color that has one-third the
    /// brightness. If the *factor* is less than 100, the return color is lighter,
    /// but we recommend using the lighter() function for this purpose. If the
    /// *factor* is 0 or negative, the return value is unspecified.
    ///
    /// The function converts the current RGB color to HSV, divides the value (V)
    /// component by *factor* and converts the color back to RGB.
    ///
    /// **See also:** lighter()
    /// isValid()
    fn darker(&self, f: i32) -> Color {
        let (obj_data, funcs) = self.get_color_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).darker)(obj_data, f);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }

    #[inline]
    fn get_color_obj_funcs(&self) -> (*const RUBase, *const RUColorFuncs);
}

impl<'a> ColorType<'a> for Color<'a> {
    #[inline]
    fn get_color_obj_funcs(&self) -> (*const RUBase, *const RUColorFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).color_funcs) }
    }
}
pub trait ColorStaticType {
    ///
    /// Returns a QStringList containing the color names Qt knows about.
    ///
    /// **See also:** {QColor#Predefined Colors}{Predefined Colors}
    fn color_names<'a>() -> RefArray<String, WrapperRcOwn> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).color_names)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgb.*
    ///
    /// The alpha component of *rgb* is ignored (i.e. it is automatically set to
    /// 255), use the fromRgba() function to include the alpha-channel specified by
    /// the given QRgb value.
    ///
    /// **See also:** fromRgba()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgb value *rgba.*
    ///
    /// Unlike the fromRgb() function, the alpha-channel specified by the given
    /// QRgb value is included.
    ///
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// isValid()
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** toRgb()
    /// fromRgba64()
    /// fromRgbF()
    /// isValid()
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// toRgb()
    /// isValid()
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    fn from_rgb<'a>(r: i32, g: i32, b: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_rgb)(obj_data, r, g, b, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the RGB
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** fromRgb()
    /// fromRgba64()
    /// toRgb()
    /// isValid()
    fn from_rgb_f<'a>(r: f32, g: f32, b: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_rgb_f)(obj_data, r, g, b, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the RGBA64
    /// color values, *r* (red), *g* (green), *b* (blue), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given QRgba64 value *rgba64.*
    ///
    /// **See also:** fromRgb()
    /// fromRgbF()
    /// toRgb()
    /// isValid()
    fn from_rgba64<'a>(r: u16, g: u16, b: u16, a: u16) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_rgba64)(obj_data, r, g, b, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// The value of *s,* *v,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    ///
    /// **See also:** toHsv()
    /// fromHsvF()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** toHsv()
    /// fromHsv()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn from_hsv<'a>(h: i32, s: i32, v: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsv)(obj_data, h, s, v, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *v* (value), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** toHsv()
    /// fromHsv()
    /// isValid()
    /// {QColor#The HSV Color Model}{The HSV Color Model}
    fn from_hsv_f<'a>(h: f32, s: f32, v: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsv_f)(obj_data, h, s, v, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0-255.
    ///
    /// **See also:** toCmyk()
    /// fromCmykF()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** toCmyk()
    /// fromCmyk()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn from_cmyk<'a>(c: i32, m: i32, y: i32, k: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_cmyk)(obj_data, c, m, y, k, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the
    /// given CMYK color values: *c* (cyan), *m* (magenta), *y* (yellow), *k*
    /// (black), and *a* (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** toCmyk()
    /// fromCmyk()
    /// isValid()
    /// {QColor#The CMYK Color Model}{The CMYK Color Model}
    fn from_cmyk_f<'a>(c: f32, m: f32, y: f32, k: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_cmyk_f)(obj_data, c, m, y, k, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// The value of *s,* *l,* and *a* must all be in the range 0-255; the value
    /// of *h* must be in the range 0-359.
    ///
    /// **See also:** toHsl()
    /// fromHslF()
    /// isValid()
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** toHsl()
    /// fromHsl()
    /// isValid()
    fn from_hsl<'a>(h: i32, s: i32, l: i32, a: i32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsl)(obj_data, h, s, l, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Static convenience function that returns a QColor constructed from the HSV
    /// color values, *h* (hue), *s* (saturation), *l* (lightness), and *a*
    /// (alpha-channel, i.e. transparency).
    ///
    /// All the values must be in the range 0.0-1.0.
    ///
    /// **See also:** toHsl()
    /// fromHsl()
    /// isValid()
    fn from_hsl_f<'a>(h: f32, s: f32, l: f32, a: f32) -> Color<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_hsl_f)(obj_data, h, s, l, a);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** setNamedColor()
    ///
    /// **Overloads**
    ///
    /// **Overloads**
    fn is_valid_color<'a>(name: &str) -> bool {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_valid_color)(obj_data, str_in_name_1.as_ptr());
            ret_val
        }
    }
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** setNamedColor()
    ///
    fn is_valid_color<'a, S: StringViewType<'a>>(arg0: &S) -> bool {
        let (obj_arg0_1, _funcs) = arg0.get_string_view_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_valid_color)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    ///
    /// Returns `true` if the *name* is a valid color name and can
    /// be used to construct a valid QColor object, otherwise returns
    /// false.
    ///
    /// It uses the same algorithm used in setNamedColor().
    ///
    /// **See also:** setNamedColor()
    ///
    fn is_valid_color<'a, L: Latin1StringType<'a>>(arg0: &L) -> bool {
        let (obj_arg0_1, _funcs) = arg0.get_latin1_string_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_color)(::std::ptr::null()).all_funcs).color_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).is_valid_color)(obj_data, obj_arg0_1);
            ret_val
        }
    }
}

impl<'a> ColorStaticType for Color<'a> {}

impl<'a> ColorStaticType for ColorStatic<'a> {}
