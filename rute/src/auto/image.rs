// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// Qt provides four classes for handling image data: QImage, QPixmap,
/// QBitmap and QPicture. QImage is designed and optimized for I/O,
/// and for direct pixel access and manipulation, while QPixmap is
/// designed and optimized for showing images on screen. QBitmap is
/// only a convenience class that inherits QPixmap, ensuring a
/// depth of 1. Finally, the QPicture class is a paint device that
/// records and replays QPainter commands.
///
/// Because QImage is a QPaintDevice subclass, QPainter can be used to
/// draw directly onto images. When using QPainter on a QImage, the
/// painting can be performed in another thread than the current GUI
/// thread.
///
/// The QImage class supports several image formats described by the
/// [Format](Format)
/// enum. These include monochrome, 8-bit, 32-bit and
/// alpha-blended images which are available in all versions of Qt
/// 4.x.
///
/// QImage provides a collection of functions that can be used to
/// obtain a variety of information about the image. There are also
/// several functions that enables transformation of the image.
///
/// QImage objects can be passed around by value since the QImage
/// class uses [implicit data
/// sharing](Implicit%20Data%20Sharing)
/// . QImage objects can also be streamed and compared.
///
/// **Note**: If you would like to load QImage objects in a static build of Qt,
/// refer to the [Plugin HowTo](How%20to%20Create%20Qt%20Plugins)
///
///
/// **Warning**: Painting on a QImage with the format
/// QImage::Format_Indexed8 is not supported.
///
/// # Reading and Writing Image Files
///
/// QImage provides several ways of loading an image file: The file
/// can be loaded when constructing the QImage object, or by using the
/// load() or loadFromData() functions later on. QImage also provides
/// the static fromData() function, constructing a QImage from the
/// given data. When loading an image, the file name can either refer
/// to an actual file on disk or to one of the application's embedded
/// resources. See [The Qt Resource System](The%20Qt%20Resource%20System)
/// overview for details
/// on how to embed images and other resource files in the
/// application's executable.
///
/// Simply call the save() function to save a QImage object.
///
/// The complete list of supported file formats are available through
/// the QImageReader::supportedImageFormats() and
/// QImageWriter::supportedImageFormats() functions. New file formats
/// can be added as plugins. By default, Qt supports the following
/// formats:
///
/// * Format
/// * Description
/// * Qt's support
/// * BMP
/// * Windows Bitmap
/// * Read/write
/// * GIF
/// * Graphic Interchange Format (optional)
/// * Read
/// * JPG
/// * Joint Photographic Experts Group
/// * Read/write
/// * JPEG
/// * Joint Photographic Experts Group
/// * Read/write
/// * PNG
/// * Portable Network Graphics
/// * Read/write
/// * PBM
/// * Portable Bitmap
/// * Read
/// * PGM
/// * Portable Graymap
/// * Read
/// * PPM
/// * Portable Pixmap
/// * Read/write
/// * XBM
/// * X11 Bitmap
/// * Read/write
/// * XPM
/// * X11 Pixmap
/// * Read/write
///
/// # Image Information
///
/// QImage provides a collection of functions that can be used to
/// obtain a variety of information about the image:
///
///
/// * Available Functions
///
/// * Geometry
/// * The size(), width(), height(), dotsPerMeterX(), and dotsPerMeterY() functions provide information about the image size and aspect ratio. The rect() function returns the image's enclosing rectangle. The valid() function tells if a given pair of coordinates is within this rectangle. The offset() function returns the number of pixels by which the image is intended to be offset by when positioned relative to other images, which also can be manipulated using the setOffset() function.
///
/// * Colors
/// * The color of a pixel can be retrieved by passing its coordinates to the pixel() function. The pixel() function returns the color as a QRgb value indepedent of the image's format. In case of monochrome and 8-bit images, the colorCount() and colorTable() functions provide information about the color components used to store the image data: The colorTable() function returns the image's entire color table. To obtain a single entry, use the pixelIndex() function to retrieve the pixel index for a given pair of coordinates, then use the color() function to retrieve the color. Note that if you create an 8-bit image manually, you have to set a valid color table on the image as well. The hasAlphaChannel() function tells if the image's format respects the alpha channel, or not. The allGray() and isGrayscale() functions tell whether an image's colors are all shades of gray. See also the [Pixel Manipulation](QImage%23Pixel%20Manipulation)
/// and [Image Transformations](QImage%23Image%20Transformations)
/// sections.
///
/// * Text
/// * The text() function returns the image text associated with the given text key. An image's text keys can be retrieved using the textKeys() function. Use the setText() function to alter an image's text.
///
/// * Low-level information
/// * The depth() function returns the depth of the image. The supported depths are 1 (monochrome), 8, 16, 24 and 32 bits. The bitPlaneCount() function tells how many of those bits that are used. For more information see the [Image Formats](QImage%23Image%20Formats)
/// section. The format(), bytesPerLine(), and sizeInBytes() functions provide low-level information about the data stored in the image. The cacheKey() function returns a number that uniquely identifies the contents of this QImage object.
///
/// # Pixel Manipulation
///
/// The functions used to manipulate an image's pixels depend on the
/// image format. The reason is that monochrome and 8-bit images are
/// index-based and use a color lookup table, while 32-bit images
/// store ARGB values directly. For more information on image formats,
/// see the [Image Formats](Image%20Formats)
/// section.
///
/// In case of a 32-bit image, the setPixel() function can be used to
/// alter the color of the pixel at the given coordinates to any other
/// color specified as an ARGB quadruplet. To make a suitable QRgb
/// value, use the qRgb() (adding a default alpha component to the
/// given RGB values, i.e. creating an opaque color) or qRgba()
/// function. For example:
///
/// * {2,1}32-bit
///
/// * ![qimage-32bit_scaled.png](qimage-32bit_scaled.png)
///
///
///
/// In case of a 8-bit and monchrome images, the pixel value is only
/// an index from the image's color table. So the setPixel() function
/// can only be used to alter the color of the pixel at the given
/// coordinates to a predefined color from the image's color table,
/// i.e. it can only change the pixel's index value. To alter or add a
/// color to an image's color table, use the setColor() function.
///
/// An entry in the color table is an ARGB quadruplet encoded as an
/// QRgb value. Use the qRgb() and qRgba() functions to make a
/// suitable QRgb value for use with the setColor() function. For
/// example:
///
/// * {2,1} 8-bit
///
/// * ![qimage-8bit_scaled.png](qimage-8bit_scaled.png)
///
///
///
/// For images with more than 8-bit per color-channel. The methods
/// setPixelColor() and pixelColor() can be used to set and get
/// with QColor values.
///
/// QImage also provide the scanLine() function which returns a
/// pointer to the pixel data at the scanline with the given index,
/// and the bits() function which returns a pointer to the first pixel
/// data (this is equivalent to `scanLine(0)).`
///
/// # Image Formats
///
/// Each pixel stored in a QImage is represented by an integer. The
/// size of the integer varies depending on the format. QImage
/// supports several image formats described by the [Format](Format)
///
/// enum.
///
/// Monochrome images are stored using 1-bit indexes into a color table
/// with at most two colors. There are two different types of
/// monochrome images: big endian (MSB first) or little endian (LSB
/// first) bit order.
///
/// 8-bit images are stored using 8-bit indexes into a color table,
/// i.e. they have a single byte per pixel. The color table is a
/// QVector<QRgb>, and the QRgb typedef is equivalent to an unsigned
/// int containing an ARGB quadruplet on the format 0xAARRGGBB.
///
/// 32-bit images have no color table; instead, each pixel contains an
/// QRgb value. There are three different types of 32-bit images
/// storing RGB (i.e. 0xffRRGGBB), ARGB and premultiplied ARGB
/// values respectively. In the premultiplied format the red, green,
/// and blue channels are multiplied by the alpha component divided by
/// 255.
///
/// An image's format can be retrieved using the format()
/// function. Use the convertToFormat() functions to convert an image
/// into another format. The allGray() and isGrayscale() functions
/// tell whether a color image can safely be converted to a grayscale
/// image.
///
/// # Image Transformations
///
/// QImage supports a number of functions for creating a new image
/// that is a transformed version of the original: The
/// createAlphaMask() function builds and returns a 1-bpp mask from
/// the alpha buffer in this image, and the createHeuristicMask()
/// function creates and returns a 1-bpp heuristic mask for this
/// image. The latter function works by selecting a color from one of
/// the corners, then chipping away pixels of that color starting at
/// all the edges.
///
/// The mirrored() function returns a mirror of the image in the
/// desired direction, the scaled() returns a copy of the image scaled
/// to a rectangle of the desired measures, and the rgbSwapped() function
/// constructs a BGR image from a RGB image.
///
/// The scaledToWidth() and scaledToHeight() functions return scaled
/// copies of the image.
///
/// The transformed() function returns a copy of the image that is
/// transformed with the given transformation matrix and
/// transformation mode: Internally, the transformation matrix is
/// adjusted to compensate for unwanted translation,
/// i.e. transformed() returns the smallest image containing all
/// transformed points of the original image. The static trueMatrix()
/// function returns the actual matrix used for transforming the
/// image.
///
/// There are also functions for changing attributes of an image
/// in-place:
///
/// * Function
/// * Description
///
/// * setDotsPerMeterX()
/// * Defines the aspect ratio by setting the number of pixels that fit horizontally in a physical meter.
///
/// * setDotsPerMeterY()
/// * Defines the aspect ratio by setting the number of pixels that fit vertically in a physical meter.
///
/// * fill()
/// * Fills the entire image with the given pixel value.
///
/// * invertPixels()
/// * Inverts all pixel values in the image using the given InvertMode value.
///
/// * setColorTable()
/// * Sets the color table used to translate color indexes. Only monochrome and 8-bit formats.
///
/// * setColorCount()
/// * Resizes the color table. Only monochrome and 8-bit formats.
///
/// **See also:** [`ImageReader`]
/// [`ImageWriter`]
/// [`Pixmap`]
/// [`SvgRenderer`]
/// {Image Composition Example}
/// {Image Viewer Example}
/// {Scribble Example}
/// {Pixelator Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Image<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUImageAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Image<'a> {
    pub fn new() -> Image<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_image)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Image {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUImage) -> Image<'a> {
        Image {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUImage) -> Image<'a> {
        Image {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUImage) -> Image<'a> {
        Image {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Swaps image *other* with this image. This operation is very
    /// fast and never fails.
    pub fn swap<I: ImageTrait<'a>>(&self, other: &I) -> &Self {
        let (obj_other_1, _funcs) = other.get_image_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).swap)(obj_data, obj_other_1);
        }
        self
    }
    ///
    /// Returns `true` if it is a null image, otherwise returns `false.`
    ///
    /// A null image has all parameters set to zero and no allocated data.
    pub fn is_null(&self) -> bool {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_null)(obj_data);
            ret_val
        }
    }
    pub fn dev_type(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).dev_type)(obj_data);
            ret_val
        }
    }
    pub fn detach(&self) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).detach)(obj_data);
        }
        self
    }
    pub fn is_detached(&self) -> bool {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_detached)(obj_data);
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// The returned image is copied from the position ( *x,* *y)* in
    /// this image, and will always have the given *width* and *height.*
    /// In areas beyond this image, pixels are set to 0.
    ///
    ///
    /// Returns a sub-area of the image as a new image.
    ///
    /// The returned image is copied from the position ( *rectangle* .x(), *rectangle* .y()) in this image, and will always
    /// have the size of the given *rectangle.*
    ///
    /// In areas beyond this image, pixels are set to 0. For 32-bit RGB
    /// images, this means black; for 32-bit ARGB images, this means
    /// transparent black; for 8-bit images, this means the color with
    /// index 0 in the color table which can be anything; for 1-bit
    /// images, this means Qt::color0.
    ///
    /// If the given *rectangle* is a null rectangle the entire image is
    /// copied.
    ///
    /// **See also:** [`q_image()`]
    pub fn copy<R: RectTrait<'a>>(&self, rect: &R) -> Image {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).copy)(obj_data, obj_rect_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// The returned image is copied from the position ( *x,* *y)* in
    /// this image, and will always have the given *width* and *height.*
    /// In areas beyond this image, pixels are set to 0.
    ///
    ///
    /// Returns a sub-area of the image as a new image.
    ///
    /// The returned image is copied from the position ( *rectangle* .x(), *rectangle* .y()) in this image, and will always
    /// have the size of the given *rectangle.*
    ///
    /// In areas beyond this image, pixels are set to 0. For 32-bit RGB
    /// images, this means black; for 32-bit ARGB images, this means
    /// transparent black; for 8-bit images, this means the color with
    /// index 0 in the color table which can be anything; for 1-bit
    /// images, this means Qt::color0.
    ///
    /// If the given *rectangle* is a null rectangle the entire image is
    /// copied.
    ///
    /// **See also:** [`q_image()`]
    pub fn copy_2(&self, x: i32, y: i32, w: i32, h: i32) -> Image {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).copy_2)(obj_data, x, y, w, h);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the format of the image.
    ///
    /// **See also:** {QImage#Image Formats}{Image Formats}
    pub fn format(&self) -> Format {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).format)(obj_data);
            let ret_val = { transmute::<u32, Format>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns a copy of the image in the given *format.*
    ///
    /// The specified image conversion *flags* control how the image data
    /// is handled during the conversion process.
    ///
    /// **See also:** {Image Formats}
    ///
    /// **Overloads**
    /// Returns a copy of the image converted to the given *format,*
    /// using the specified *colorTable.*
    ///
    /// Conversion from RGB formats to indexed formats is a slow operation
    /// and will use a straightforward nearest color approach, with no
    /// dithering.
    pub fn convert_to_format(&self, f: Format, flags: ImageConversionFlags) -> Image {
        let enum_f_1 = f as u32;
        let enum_flags_2 = flags.bits();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).convert_to_format)(obj_data, enum_f_1, enum_flags_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a copy of the image in the given *format.*
    ///
    /// The specified image conversion *flags* control how the image data
    /// is handled during the conversion process.
    ///
    /// **See also:** {Image Formats}
    ///
    /// **Overloads**
    /// Returns a copy of the image converted to the given *format,*
    /// using the specified *colorTable.*
    ///
    /// Conversion from RGB formats to indexed formats is a slow operation
    /// and will use a straightforward nearest color approach, with no
    /// dithering.
    pub fn convert_to_format_2(&self, f: Format, flags: ImageConversionFlags) -> Image {
        let enum_f_1 = f as u32;
        let enum_flags_2 = flags.bits();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).convert_to_format_2)(obj_data, enum_f_1, enum_flags_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a copy of the image in the given *format.*
    ///
    /// The specified image conversion *flags* control how the image data
    /// is handled during the conversion process.
    ///
    /// **See also:** {Image Formats}
    ///
    /// **Overloads**
    /// Returns a copy of the image converted to the given *format,*
    /// using the specified *colorTable.*
    ///
    /// Conversion from RGB formats to indexed formats is a slow operation
    /// and will use a straightforward nearest color approach, with no
    /// dithering.
    ///
    /// Changes the format of the image to *format* without changing the
    /// data. Only works between formats of the same depth.
    ///
    /// Returns `true` if successful.
    ///
    /// This function can be used to change images with alpha-channels to
    /// their corresponding opaque formats if the data is known to be opaque-only,
    /// or to change the format of a given image buffer before overwriting
    /// it with new data.
    ///
    /// **Warning**: The function does not check if the image data is valid in the
    /// new format and will still return `true` if the depths are compatible.
    /// Operations on an image with invalid data are undefined.
    ///
    /// **Warning**: If the image is not detached, this will cause the data to be
    /// copied.
    ///
    /// **See also:** [`has_alpha_channel()`]
    /// [`convert_to_format()`]
    pub fn reinterpret_as_format(&self, f: Format) -> bool {
        let enum_f_1 = f as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).reinterpret_as_format)(obj_data, enum_f_1);
            ret_val
        }
    }
    ///
    /// Returns the width of the image.
    ///
    /// **See also:** {QImage#Image Information}{Image Information}
    pub fn width(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).width)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the height of the image.
    ///
    /// **See also:** {QImage#Image Information}{Image Information}
    pub fn height(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the size of the image, i.e. its width() and height().
    ///
    /// **See also:** {QImage#Image Information}{Image Information}
    ///
    /// Returns the image data size in bytes.
    ///
    /// **See also:** [`byte_count()`]
    /// [`bytes_per_line()`]
    /// [`bits()`]
    /// {QImage#Image Information}{Image
    /// Information}
    pub fn size(&self) -> Size {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the enclosing rectangle (0, 0, width(), height()) of the
    /// image.
    ///
    /// **See also:** {QImage#Image Information}{Image Information}
    pub fn rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the depth of the image.
    ///
    /// The image depth is the number of bits used to store a single
    /// pixel, also called bits per pixel (bpp).
    ///
    /// The supported depths are 1, 8, 16, 24 and 32.
    ///
    /// **See also:** [`bit_plane_count()`]
    /// [`convert_to_format()`]
    /// {QImage#Image Formats}{Image Formats}
    /// {QImage#Image Information}{Image Information}
    ///
    pub fn depth(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).depth)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the size of the color table for the image.
    ///
    /// Notice that colorCount() returns 0 for 32-bpp images because these
    /// images do not use color tables, but instead encode pixel values as
    /// ARGB quadruplets.
    ///
    /// **See also:** [`set_color_count()`]
    /// {QImage#Image Information}{Image Information}
    pub fn color_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).color_count)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the number of bit planes in the image.
    ///
    /// The number of bit planes is the number of bits of color and
    /// transparency information for each pixel. This is different from
    /// (i.e. smaller than) the depth when the image format contains
    /// unused bits.
    ///
    /// **See also:** [`depth()`]
    /// [`format()`]
    /// {QImage#Image Formats}{Image Formats}
    pub fn bit_plane_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).bit_plane_count)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the size of the color table for the image.
    ///
    /// Notice that colorCount() returns 0 for 32-bpp images because these
    /// images do not use color tables, but instead encode pixel values as
    /// ARGB quadruplets.
    ///
    /// **See also:** [`set_color_count()`]
    /// {QImage#Image Information}{Image Information}
    ///
    /// Returns a list of the colors contained in the image's color table,
    /// or an empty list if the image does not have a color table
    ///
    /// **See also:** [`set_color_table()`]
    /// [`color_count()`]
    /// [`color()`]
    ///
    /// Returns the color in the color table at index *i.* The first
    /// color is at index 0.
    ///
    /// The colors in an image's color table are specified as ARGB
    /// quadruplets (QRgb). Use the qAlpha(), qRed(), qGreen(), and
    /// qBlue() functions to get the color value components.
    ///
    /// **See also:** [`set_color()`]
    /// [`pixel_index()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// Sets the color at the given *index* in the color table, to the
    /// given to *colorValue.* The color value is an ARGB quadruplet.
    ///
    /// If *index* is outside the current size of the color table, it is
    /// expanded with setColorCount().
    ///
    /// **See also:** [`color()`]
    /// [`color_count()`]
    /// [`set_color_table()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// Resizes the color table to contain *colorCount* entries.
    ///
    /// If the color table is expanded, all the extra colors will be set to
    /// transparent (i.e qRgba(0, 0, 0, 0)).
    ///
    /// When the image is used, the color table must be large enough to
    /// have entries for all the pixel/index values present in the image,
    /// otherwise the results are undefined.
    ///
    /// **See also:** [`color_count()`]
    /// [`color_table()`]
    /// [`set_color()`]
    /// {QImage#Image
    /// Transformations}{Image Transformations}
    ///
    /// Resizes the color table to contain *colorCount* entries.
    ///
    /// If the color table is expanded, all the extra colors will be set to
    /// transparent (i.e qRgba(0, 0, 0, 0)).
    ///
    /// When the image is used, the color table must be large enough to
    /// have entries for all the pixel/index values present in the image,
    /// otherwise the results are undefined.
    ///
    /// **See also:** [`color_count()`]
    /// [`color_table()`]
    /// [`set_color()`]
    /// {QImage#Image
    /// Transformations}{Image Transformations}
    pub fn set_color_count(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_color_count)(obj_data, arg0);
        }
        self
    }
    ///
    /// Returns `true` if all the colors in the image are shades of gray
    /// (i.e. their red, green and blue components are equal); otherwise
    /// false.
    ///
    /// Note that this function is slow for images without color table.
    ///
    /// **See also:** [`is_grayscale()`]
    pub fn all_gray(&self) -> bool {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).all_gray)(obj_data);
            ret_val
        }
    }
    ///
    /// For 32-bit images, this function is equivalent to allGray().
    ///
    /// For color indexed images, this function returns `true` if
    /// color(i) is QRgb(i, i, i) for all indexes of the color table;
    /// otherwise returns `false.`
    ///
    /// **See also:** [`all_gray()`]
    /// {QImage#Image Formats}{Image Formats}
    pub fn is_grayscale(&self) -> bool {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_grayscale)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns a pointer to the first pixel data. This is equivalent to
    /// scanLine(0).
    ///
    /// Note that QImage uses [implicit data
    /// sharing](Implicit%20Data%20Sharing)
    /// . This function performs a deep copy of the shared pixel
    /// data, thus ensuring that this QImage is the only one using the
    /// current return value.
    ///
    /// **See also:** [`scan_line()`]
    /// [`size_in_bytes()`]
    /// [`const_bits()`]
    ///
    /// **Overloads**
    /// Note that QImage uses [implicit data
    /// sharing](Implicit%20Data%20Sharing)
    /// , but this function does *not* perform a deep copy of the
    /// shared pixel data, because the returned data is const.
    ///
    /// Returns a pointer to the first pixel data. This is equivalent to
    /// scanLine(0).
    ///
    /// Note that QImage uses [implicit data
    /// sharing](Implicit%20Data%20Sharing)
    /// . This function performs a deep copy of the shared pixel
    /// data, thus ensuring that this QImage is the only one using the
    /// current return value.
    ///
    /// **See also:** [`scan_line()`]
    /// [`size_in_bytes()`]
    /// [`const_bits()`]
    ///
    /// **Overloads**
    /// Note that QImage uses [implicit data
    /// sharing](Implicit%20Data%20Sharing)
    /// , but this function does *not* perform a deep copy of the
    /// shared pixel data, because the returned data is const.
    ///
    /// Returns a pointer to the first pixel data.
    ///
    /// Note that QImage uses [implicit data
    /// sharing](Implicit%20Data%20Sharing)
    /// , but this function does *not* perform a deep copy of the
    /// shared pixel data, because the returned data is const.
    ///
    /// **See also:** [`bits()`]
    /// [`const_scan_line()`]
    ///
    /// Returns the number of bytes occupied by the image data.
    ///
    /// Note this method should never be called on an image larger than 2 gigabytes.
    /// Instead use sizeInBytes().
    ///
    /// **See also:** [`size_in_bytes()`]
    /// [`bytes_per_line()`]
    /// [`bits()`]
    /// {QImage#Image Information}{Image
    /// Information}
    pub fn byte_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).byte_count)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the image data size in bytes.
    ///
    /// **See also:** [`byte_count()`]
    /// [`bytes_per_line()`]
    /// [`bits()`]
    /// {QImage#Image Information}{Image
    /// Information}
    ///
    /// Returns a pointer to the pixel data at the scanline with index *i.* The first scanline is at index 0.
    ///
    /// The scanline data is aligned on a 32-bit boundary.
    ///
    /// **Warning**: If you are accessing 32-bpp image data, cast the returned
    /// pointer to `QRgb*` (QRgb has a 32-bit size) and use it to
    /// read/write the pixel value. You cannot use the `uchar*` pointer
    /// directly, because the pixel format depends on the byte order on
    /// the underlying platform. Use qRed(), qGreen(), qBlue(), and
    /// qAlpha() to access the pixels.
    ///
    /// **See also:** [`bytes_per_line()`]
    /// [`bits()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}, constScanLine()
    ///
    /// **Overloads**
    ///
    /// Returns a pointer to the pixel data at the scanline with index *i.* The first scanline is at index 0.
    ///
    /// The scanline data is aligned on a 32-bit boundary.
    ///
    /// **Warning**: If you are accessing 32-bpp image data, cast the returned
    /// pointer to `QRgb*` (QRgb has a 32-bit size) and use it to
    /// read/write the pixel value. You cannot use the `uchar*` pointer
    /// directly, because the pixel format depends on the byte order on
    /// the underlying platform. Use qRed(), qGreen(), qBlue(), and
    /// qAlpha() to access the pixels.
    ///
    /// **See also:** [`bytes_per_line()`]
    /// [`bits()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}, constScanLine()
    ///
    /// **Overloads**
    ///
    /// Returns a pointer to the pixel data at the scanline with index *i.* The first scanline is at index 0.
    ///
    /// The scanline data is aligned on a 32-bit boundary.
    ///
    /// Note that QImage uses [implicit data
    /// sharing](Implicit%20Data%20Sharing)
    /// , but this function does *not* perform a deep copy of the
    /// shared pixel data, because the returned data is const.
    ///
    /// **See also:** [`scan_line()`]
    /// [`const_bits()`]
    ///
    /// Returns the number of bytes per image scanline.
    ///
    /// This is equivalent to sizeInBytes() / height() if height() is non-zero.
    ///
    /// **See also:** [`scan_line()`]
    pub fn bytes_per_line(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).bytes_per_line)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if *pos* is a valid coordinate pair within the
    /// image; otherwise returns `false.`
    ///
    /// **See also:** [`rect()`]
    /// [`Rect::contains`]
    ///
    /// **Overloads**
    /// Returns `true` if QPoint( *x,* *y)* is a valid coordinate pair
    /// within the image; otherwise returns `false.`
    pub fn valid(&self, x: i32, y: i32) -> bool {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).valid)(obj_data, x, y);
            ret_val
        }
    }
    ///
    /// Returns `true` if *pos* is a valid coordinate pair within the
    /// image; otherwise returns `false.`
    ///
    /// **See also:** [`rect()`]
    /// [`Rect::contains`]
    ///
    /// **Overloads**
    /// Returns `true` if QPoint( *x,* *y)* is a valid coordinate pair
    /// within the image; otherwise returns `false.`
    pub fn valid_2<P: PointTrait<'a>>(&self, pt: &P) -> bool {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).valid_2)(obj_data, obj_pt_1);
            ret_val
        }
    }
    ///
    /// Returns the pixel index at the given *position.*
    ///
    /// If *position* is not valid, or if the image is not a paletted
    /// image (depth() > 8), the results are undefined.
    ///
    /// **See also:** [`valid()`]
    /// [`depth()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Returns the pixel index at ( *x,* *y).*
    pub fn pixel_index(&self, x: i32, y: i32) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixel_index)(obj_data, x, y);
            ret_val
        }
    }
    ///
    /// Returns the pixel index at the given *position.*
    ///
    /// If *position* is not valid, or if the image is not a paletted
    /// image (depth() > 8), the results are undefined.
    ///
    /// **See also:** [`valid()`]
    /// [`depth()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Returns the pixel index at ( *x,* *y).*
    pub fn pixel_index_2<P: PointTrait<'a>>(&self, pt: &P) -> i32 {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixel_index_2)(obj_data, obj_pt_1);
            ret_val
        }
    }
    ///
    /// Returns the pixel index at the given *position.*
    ///
    /// If *position* is not valid, or if the image is not a paletted
    /// image (depth() > 8), the results are undefined.
    ///
    /// **See also:** [`valid()`]
    /// [`depth()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Returns the pixel index at ( *x,* *y).*
    ///
    /// Returns the color of the pixel at the given *position.*
    ///
    /// If the *position* is not valid, the results are undefined.
    ///
    /// **Warning**: This function is expensive when used for massive pixel
    /// manipulations. Use constBits() or constScanLine() when many
    /// pixels needs to be read.
    ///
    /// **See also:** [`set_pixel()`]
    /// [`valid()`]
    /// [`const_bits()`]
    /// [`const_scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// **Overloads**
    /// Returns the color of the pixel at coordinates ( *x,* *y).*
    ///
    /// Returns the color of the pixel at the given *position* as a QColor.
    ///
    /// If the *position* is not valid, an invalid QColor is returned.
    ///
    /// **Warning**: This function is expensive when used for massive pixel
    /// manipulations. Use constBits() or constScanLine() when many
    /// pixels needs to be read.
    ///
    /// **See also:** [`set_pixel()`]
    /// [`valid()`]
    /// [`const_bits()`]
    /// [`const_scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// **Overloads**
    /// Returns the color of the pixel at coordinates ( *x,* *y)* as a QColor.
    ///
    /// Returns the QImage::Format as a QPixelFormat
    ///
    /// Returns the pixel index at the given *position.*
    ///
    /// If *position* is not valid, or if the image is not a paletted
    /// image (depth() > 8), the results are undefined.
    ///
    /// **See also:** [`valid()`]
    /// [`depth()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Returns the pixel index at ( *x,* *y).*
    ///
    /// Returns the color of the pixel at the given *position.*
    ///
    /// If the *position* is not valid, the results are undefined.
    ///
    /// **Warning**: This function is expensive when used for massive pixel
    /// manipulations. Use constBits() or constScanLine() when many
    /// pixels needs to be read.
    ///
    /// **See also:** [`set_pixel()`]
    /// [`valid()`]
    /// [`const_bits()`]
    /// [`const_scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// **Overloads**
    /// Returns the color of the pixel at coordinates ( *x,* *y).*
    ///
    /// Returns the color of the pixel at the given *position* as a QColor.
    ///
    /// If the *position* is not valid, an invalid QColor is returned.
    ///
    /// **Warning**: This function is expensive when used for massive pixel
    /// manipulations. Use constBits() or constScanLine() when many
    /// pixels needs to be read.
    ///
    /// **See also:** [`set_pixel()`]
    /// [`valid()`]
    /// [`const_bits()`]
    /// [`const_scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// **Overloads**
    /// Returns the color of the pixel at coordinates ( *x,* *y)* as a QColor.
    ///
    /// Returns the QImage::Format as a QPixelFormat
    ///
    /// Sets the pixel index or color at the given *position* to *index_or_rgb.*
    ///
    /// If the image's format is either monochrome or paletted, the given *index_or_rgb* value must be an index in the image's color table,
    /// otherwise the parameter must be a QRgb value.
    ///
    /// If *position* is not a valid coordinate pair in the image, or if
    /// *index_or_rgb* >= colorCount() in the case of monochrome and
    /// paletted images, the result is undefined.
    ///
    /// **Warning**: This function is expensive due to the call of the internal
    /// `detach()` function called within; if performance is a concern, we
    /// recommend the use of scanLine() or bits() to access pixel data directly.
    ///
    /// **See also:** [`pixel()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Sets the pixel index or color at ( *x,* *y)* to *index_or_rgb.*
    ///
    /// Sets the color at the given *position* to *color.*
    ///
    /// If *position* is not a valid coordinate pair in the image, or
    /// the image's format is either monochrome or paletted, the result is undefined.
    ///
    /// **Warning**: This function is expensive due to the call of the internal
    /// `detach()` function called within; if performance is a concern, we
    /// recommend the use of scanLine() or bits() to access pixel data directly.
    ///
    /// **See also:** [`pixel()`]
    /// [`bits()`]
    /// [`scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Sets the pixel color at ( *x,* *y)* to *color.*
    pub fn set_pixel(&self, x: i32, y: i32, index_or_rgb: u32) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_pixel)(obj_data, x, y, index_or_rgb);
        }
        self
    }
    ///
    /// Sets the pixel index or color at the given *position* to *index_or_rgb.*
    ///
    /// If the image's format is either monochrome or paletted, the given *index_or_rgb* value must be an index in the image's color table,
    /// otherwise the parameter must be a QRgb value.
    ///
    /// If *position* is not a valid coordinate pair in the image, or if
    /// *index_or_rgb* >= colorCount() in the case of monochrome and
    /// paletted images, the result is undefined.
    ///
    /// **Warning**: This function is expensive due to the call of the internal
    /// `detach()` function called within; if performance is a concern, we
    /// recommend the use of scanLine() or bits() to access pixel data directly.
    ///
    /// **See also:** [`pixel()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Sets the pixel index or color at ( *x,* *y)* to *index_or_rgb.*
    ///
    /// Sets the color at the given *position* to *color.*
    ///
    /// If *position* is not a valid coordinate pair in the image, or
    /// the image's format is either monochrome or paletted, the result is undefined.
    ///
    /// **Warning**: This function is expensive due to the call of the internal
    /// `detach()` function called within; if performance is a concern, we
    /// recommend the use of scanLine() or bits() to access pixel data directly.
    ///
    /// **See also:** [`pixel()`]
    /// [`bits()`]
    /// [`scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Sets the pixel color at ( *x,* *y)* to *color.*
    pub fn set_pixel_2<P: PointTrait<'a>>(&self, pt: &P, index_or_rgb: u32) -> &Self {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_pixel_2)(obj_data, obj_pt_1, index_or_rgb);
        }
        self
    }
    ///
    /// Returns the color of the pixel at the given *position* as a QColor.
    ///
    /// If the *position* is not valid, an invalid QColor is returned.
    ///
    /// **Warning**: This function is expensive when used for massive pixel
    /// manipulations. Use constBits() or constScanLine() when many
    /// pixels needs to be read.
    ///
    /// **See also:** [`set_pixel()`]
    /// [`valid()`]
    /// [`const_bits()`]
    /// [`const_scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// **Overloads**
    /// Returns the color of the pixel at coordinates ( *x,* *y)* as a QColor.
    pub fn pixel_color(&self, x: i32, y: i32) -> Color {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixel_color)(obj_data, x, y);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the color of the pixel at the given *position* as a QColor.
    ///
    /// If the *position* is not valid, an invalid QColor is returned.
    ///
    /// **Warning**: This function is expensive when used for massive pixel
    /// manipulations. Use constBits() or constScanLine() when many
    /// pixels needs to be read.
    ///
    /// **See also:** [`set_pixel()`]
    /// [`valid()`]
    /// [`const_bits()`]
    /// [`const_scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel
    /// Manipulation}
    ///
    /// **Overloads**
    /// Returns the color of the pixel at coordinates ( *x,* *y)* as a QColor.
    pub fn pixel_color_2<P: PointTrait<'a>>(&self, pt: &P) -> Color {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixel_color_2)(obj_data, obj_pt_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Color::new_from_rc(t);
            } else {
                ret_val = Color::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the color at the given *position* to *color.*
    ///
    /// If *position* is not a valid coordinate pair in the image, or
    /// the image's format is either monochrome or paletted, the result is undefined.
    ///
    /// **Warning**: This function is expensive due to the call of the internal
    /// `detach()` function called within; if performance is a concern, we
    /// recommend the use of scanLine() or bits() to access pixel data directly.
    ///
    /// **See also:** [`pixel()`]
    /// [`bits()`]
    /// [`scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Sets the pixel color at ( *x,* *y)* to *color.*
    pub fn set_pixel_color<C: ColorTrait<'a>>(&self, x: i32, y: i32, c: &C) -> &Self {
        let (obj_c_3, _funcs) = c.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_pixel_color)(obj_data, x, y, obj_c_3);
        }
        self
    }
    ///
    /// Sets the color at the given *position* to *color.*
    ///
    /// If *position* is not a valid coordinate pair in the image, or
    /// the image's format is either monochrome or paletted, the result is undefined.
    ///
    /// **Warning**: This function is expensive due to the call of the internal
    /// `detach()` function called within; if performance is a concern, we
    /// recommend the use of scanLine() or bits() to access pixel data directly.
    ///
    /// **See also:** [`pixel()`]
    /// [`bits()`]
    /// [`scan_line()`]
    /// {QImage#Pixel Manipulation}{Pixel Manipulation}
    ///
    /// **Overloads**
    /// Sets the pixel color at ( *x,* *y)* to *color.*
    pub fn set_pixel_color_2<C: ColorTrait<'a>, P: PointTrait<'a>>(&self, pt: &P, c: &C) -> &Self {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();
        let (obj_c_2, _funcs) = c.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_pixel_color_2)(obj_data, obj_pt_1, obj_c_2);
        }
        self
    }
    ///
    /// Returns a list of the colors contained in the image's color table,
    /// or an empty list if the image does not have a color table
    ///
    /// **See also:** [`set_color_table()`]
    /// [`color_count()`]
    /// [`color()`]
    ///
    /// Returns the device pixel ratio for the image. This is the
    /// ratio between *device pixels* and *device independent pixels* .
    ///
    /// Use this function when calculating layout geometry based on
    /// the image size: QSize layoutSize = image.size() / image.devicePixelRatio()
    ///
    /// The default value is 1.0.
    ///
    /// **See also:** [`set_device_pixel_ratio()`]
    /// [`ImageReader`]
    pub fn device_pixel_ratio(&self) -> f32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the device pixel ratio for the image. This is the
    /// ratio between image pixels and device-independent pixels.
    ///
    /// The default *scaleFactor* is 1.0. Setting it to something else has
    /// two effects:
    ///
    /// QPainters that are opened on the image will be scaled. For
    /// example, painting on a 200x200 image if with a ratio of 2.0
    /// will result in effective (device-independent) painting bounds
    /// of 100x100.
    ///
    /// Code paths in Qt that calculate layout geometry based on the
    /// image size will take the ratio into account:
    /// QSize layoutSize = image.size() / image.devicePixelRatio()
    /// The net effect of this is that the image is displayed as
    /// high-DPI image rather than a large image
    /// (see [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// ).
    ///
    /// **See also:** [`device_pixel_ratio()`]
    pub fn set_device_pixel_ratio(&self, scale_factor: f32) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_device_pixel_ratio)(obj_data, scale_factor);
        }
        self
    }
    ///
    /// Fills the entire image with the given *pixelValue.*
    ///
    /// If the depth of this image is 1, only the lowest bit is used. If
    /// you say fill(0), fill(2), etc., the image is filled with 0s. If
    /// you say fill(1), fill(3), etc., the image is filled with 1s. If
    /// the depth is 8, the lowest 8 bits are used and if the depth is 16
    /// the lowest 16 bits are used.
    ///
    /// Note: QImage::pixel() returns the color of the pixel at the given
    /// coordinates while QColor::pixel() returns the pixel value of the
    /// underlying window system (essentially an index value), so normally
    /// you will want to use QImage::pixel() to use a color from an
    /// existing image or QColor::rgb() to use a specific color.
    ///
    /// **See also:** [`depth()`]
    /// {QImage#Image Transformations}{Image Transformations}
    ///
    /// **Overloads**
    /// Fills the image with the given *color,* described as a standard global
    /// color.
    ///
    /// **Overloads**
    /// Fills the entire image with the given *color.*
    ///
    /// If the depth of the image is 1, the image will be filled with 1 if
    /// *color* equals Qt::color1; it will otherwise be filled with 0.
    ///
    /// If the depth of the image is 8, the image will be filled with the
    /// index corresponding the *color* in the color table if present; it
    /// will otherwise be filled with 0.
    ///
    pub fn fill(&self, pixel: u32) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).fill)(obj_data, pixel);
        }
        self
    }
    ///
    /// Fills the entire image with the given *pixelValue.*
    ///
    /// If the depth of this image is 1, only the lowest bit is used. If
    /// you say fill(0), fill(2), etc., the image is filled with 0s. If
    /// you say fill(1), fill(3), etc., the image is filled with 1s. If
    /// the depth is 8, the lowest 8 bits are used and if the depth is 16
    /// the lowest 16 bits are used.
    ///
    /// Note: QImage::pixel() returns the color of the pixel at the given
    /// coordinates while QColor::pixel() returns the pixel value of the
    /// underlying window system (essentially an index value), so normally
    /// you will want to use QImage::pixel() to use a color from an
    /// existing image or QColor::rgb() to use a specific color.
    ///
    /// **See also:** [`depth()`]
    /// {QImage#Image Transformations}{Image Transformations}
    ///
    /// **Overloads**
    /// Fills the image with the given *color,* described as a standard global
    /// color.
    ///
    /// **Overloads**
    /// Fills the entire image with the given *color.*
    ///
    /// If the depth of the image is 1, the image will be filled with 1 if
    /// *color* equals Qt::color1; it will otherwise be filled with 0.
    ///
    /// If the depth of the image is 8, the image will be filled with the
    /// index corresponding the *color* in the color table if present; it
    /// will otherwise be filled with 0.
    ///
    pub fn fill_2<C: ColorTrait<'a>>(&self, color: &C) -> &Self {
        let (obj_color_1, _funcs) = color.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).fill_2)(obj_data, obj_color_1);
        }
        self
    }
    ///
    /// Fills the entire image with the given *pixelValue.*
    ///
    /// If the depth of this image is 1, only the lowest bit is used. If
    /// you say fill(0), fill(2), etc., the image is filled with 0s. If
    /// you say fill(1), fill(3), etc., the image is filled with 1s. If
    /// the depth is 8, the lowest 8 bits are used and if the depth is 16
    /// the lowest 16 bits are used.
    ///
    /// Note: QImage::pixel() returns the color of the pixel at the given
    /// coordinates while QColor::pixel() returns the pixel value of the
    /// underlying window system (essentially an index value), so normally
    /// you will want to use QImage::pixel() to use a color from an
    /// existing image or QColor::rgb() to use a specific color.
    ///
    /// **See also:** [`depth()`]
    /// {QImage#Image Transformations}{Image Transformations}
    ///
    /// **Overloads**
    /// Fills the image with the given *color,* described as a standard global
    /// color.
    ///
    /// **Overloads**
    /// Fills the entire image with the given *color.*
    ///
    /// If the depth of the image is 1, the image will be filled with 1 if
    /// *color* equals Qt::color1; it will otherwise be filled with 0.
    ///
    /// If the depth of the image is 8, the image will be filled with the
    /// index corresponding the *color* in the color table if present; it
    /// will otherwise be filled with 0.
    ///
    pub fn fill_3(&self, color: GlobalColor) -> &Self {
        let enum_color_1 = color as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).fill_3)(obj_data, enum_color_1);
        }
        self
    }
    ///
    /// Returns `true` if the image has a format that respects the alpha
    /// channel, otherwise returns `false.`
    ///
    /// **See also:** {QImage#Image Information}{Image Information}
    pub fn has_alpha_channel(&self) -> bool {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_alpha_channel)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the alpha channel of this image to the given *alphaChannel.*
    ///
    /// If *alphaChannel* is an 8 bit grayscale image, the intensity values are
    /// written into this buffer directly. Otherwise, *alphaChannel* is converted
    /// to 32 bit and the intensity of the RGB pixel values is used.
    ///
    /// Note that the image will be converted to the Format_ARGB32_Premultiplied
    /// format if the function succeeds.
    ///
    /// Use one of the composition modes in QPainter::CompositionMode instead.
    ///
    /// **Warning**: This function is expensive.
    ///
    /// **See also:** [`alpha_channel()`]
    /// {QImage#Image Transformations}{Image
    /// Transformations}, {QImage#Image Formats}{Image Formats}
    pub fn set_alpha_channel<I: ImageTrait<'a>>(&self, alpha_channel: &I) -> &Self {
        let (obj_alpha_channel_1, _funcs) = alpha_channel.get_image_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_alpha_channel)(obj_data, obj_alpha_channel_1);
        }
        self
    }
    ///
    /// Returns the alpha channel of the image as a new grayscale QImage in which
    /// each pixel's red, green, and blue values are given the alpha value of the
    /// original image. The color depth of the returned image is 8-bit.
    ///
    /// You can see an example of use of this function in QPixmap's
    /// [alphaChannel()](QPixmap::)
    /// , which works in the same way as
    /// this function on QPixmaps.
    ///
    /// Most usecases for this function can be replaced with QPainter and
    /// using composition modes.
    ///
    /// Note this returns a color-indexed image if you want the alpha channel in
    /// the alpha8 format instead use convertToFormat(Format_Alpha8) on the source
    /// image.
    ///
    /// **Warning**: This is an expensive function.
    ///
    /// **See also:** [`set_alpha_channel()`]
    /// [`has_alpha_channel()`]
    /// [`convert_to_format()`]
    /// {QPixmap#Pixmap Information}{Pixmap}
    /// {QImage#Image Transformations}{Image Transformations}
    pub fn alpha_channel(&self) -> Image {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alpha_channel)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Builds and returns a 1-bpp mask from the alpha buffer in this
    /// image. Returns a null image if the image's format is
    /// QImage::Format_RGB32.
    ///
    /// The *flags* argument is a bitwise-OR of the
    /// Qt::ImageConversionFlags, and controls the conversion
    /// process. Passing 0 for flags sets all the default options.
    ///
    /// The returned image has little-endian bit order (i.e. the image's
    /// format is QImage::Format_MonoLSB), which you can convert to
    /// big-endian (QImage::Format_Mono) using the convertToFormat()
    /// function.
    ///
    /// **See also:** [`create_heuristic_mask()`]
    /// {QImage#Image Transformations}{Image
    /// Transformations}
    pub fn create_alpha_mask(&self, flags: ImageConversionFlags) -> Image {
        let enum_flags_1 = flags.bits();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).create_alpha_mask)(obj_data, enum_flags_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns a 1-bpp heuristic mask for this image.
    ///
    /// The function works by selecting a color from one of the corners,
    /// then chipping away pixels of that color starting at all the edges.
    /// The four corners vote for which color is to be masked away. In
    /// case of a draw (this generally means that this function is not
    /// applicable to the image), the result is arbitrary.
    ///
    /// The returned image has little-endian bit order (i.e. the image's
    /// format is QImage::Format_MonoLSB), which you can convert to
    /// big-endian (QImage::Format_Mono) using the convertToFormat()
    /// function.
    ///
    /// If *clipTight* is true (the default) the mask is just large
    /// enough to cover the pixels; otherwise, the mask is larger than the
    /// data pixels.
    ///
    /// Note that this function disregards the alpha buffer.
    ///
    /// **See also:** [`create_alpha_mask()`]
    /// {QImage#Image Transformations}{Image
    /// Transformations}
    pub fn create_heuristic_mask(&self, clip_tight: bool) -> Image {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).create_heuristic_mask)(obj_data, clip_tight);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns a mask for this image based on the given *color* value. If the *mode* is MaskInColor (the default value),
    /// all pixels matching *color* will be opaque pixels in the mask. If
    /// *mode* is MaskOutColor, all pixels matching the given color will
    /// be transparent.
    ///
    /// **See also:** [`create_alpha_mask()`]
    /// [`create_heuristic_mask()`]
    ///
    /// Qt::TransformationMode transformMode) const
    /// **Overloads**
    /// Returns a copy of the image scaled to a rectangle with the given
    /// *width* and *height* according to the given *aspectRatioMode*
    /// and *transformMode.*
    ///
    /// If either the *width* or the *height* is zero or negative, this
    /// function returns a null image.
    ///
    /// Qt::TransformationMode transformMode) const
    ///
    /// Returns a copy of the image scaled to a rectangle defined by the
    /// given *size* according to the given *aspectRatioMode* and *transformMode.*
    ///
    /// ![qimage-scaling.png](qimage-scaling.png)
    ///
    /// * If *aspectRatioMode* is Qt::IgnoreAspectRatio, the image is scaled to *size.*
    /// * If *aspectRatioMode* is Qt::KeepAspectRatio, the image is scaled to a rectangle as large as possible inside *size,* preserving the aspect ratio.
    /// * If *aspectRatioMode* is Qt::KeepAspectRatioByExpanding, the image is scaled to a rectangle as small as possible outside *size,* preserving the aspect ratio.
    ///
    /// If the given *size* is empty, this function returns a null image.
    ///
    /// **See also:** [`is_null()`]
    /// {QImage#Image Transformations}{Image
    /// Transformations}
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *width* using the specified transformation *mode.*
    ///
    /// This function automatically calculates the height of the image so
    /// that its aspect ratio is preserved.
    ///
    /// If the given *width* is 0 or negative, a null image is returned.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *height* using the specified transformation *mode.*
    ///
    /// This function automatically calculates the width of the image so that
    /// the ratio of the image is preserved.
    ///
    /// If the given *height* is 0 or negative, a null image is returned.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn scaled(
        &self,
        w: i32,
        h: i32,
        aspect_mode: AspectRatioMode,
        mode: TransformationMode,
    ) -> Image {
        let enum_aspect_mode_3 = aspect_mode as u32;
        let enum_mode_4 = mode as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled)(obj_data, w, h, enum_aspect_mode_3, enum_mode_4);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Qt::TransformationMode transformMode) const
    /// **Overloads**
    /// Returns a copy of the image scaled to a rectangle with the given
    /// *width* and *height* according to the given *aspectRatioMode*
    /// and *transformMode.*
    ///
    /// If either the *width* or the *height* is zero or negative, this
    /// function returns a null image.
    ///
    /// Qt::TransformationMode transformMode) const
    ///
    /// Returns a copy of the image scaled to a rectangle defined by the
    /// given *size* according to the given *aspectRatioMode* and *transformMode.*
    ///
    /// ![qimage-scaling.png](qimage-scaling.png)
    ///
    /// * If *aspectRatioMode* is Qt::IgnoreAspectRatio, the image is scaled to *size.*
    /// * If *aspectRatioMode* is Qt::KeepAspectRatio, the image is scaled to a rectangle as large as possible inside *size,* preserving the aspect ratio.
    /// * If *aspectRatioMode* is Qt::KeepAspectRatioByExpanding, the image is scaled to a rectangle as small as possible outside *size,* preserving the aspect ratio.
    ///
    /// If the given *size* is empty, this function returns a null image.
    ///
    /// **See also:** [`is_null()`]
    /// {QImage#Image Transformations}{Image
    /// Transformations}
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *width* using the specified transformation *mode.*
    ///
    /// This function automatically calculates the height of the image so
    /// that its aspect ratio is preserved.
    ///
    /// If the given *width* is 0 or negative, a null image is returned.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *height* using the specified transformation *mode.*
    ///
    /// This function automatically calculates the width of the image so that
    /// the ratio of the image is preserved.
    ///
    /// If the given *height* is 0 or negative, a null image is returned.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn scaled_2<S: SizeTrait<'a>>(
        &self,
        s: &S,
        aspect_mode: AspectRatioMode,
        mode: TransformationMode,
    ) -> Image {
        let (obj_s_1, _funcs) = s.get_size_obj_funcs();
        let enum_aspect_mode_2 = aspect_mode as u32;
        let enum_mode_3 = mode as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled_2)(obj_data, obj_s_1, enum_aspect_mode_2, enum_mode_3);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *width* using the specified transformation *mode.*
    ///
    /// This function automatically calculates the height of the image so
    /// that its aspect ratio is preserved.
    ///
    /// If the given *width* is 0 or negative, a null image is returned.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn scaled_to_width(&self, w: i32, mode: TransformationMode) -> Image {
        let enum_mode_2 = mode as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled_to_width)(obj_data, w, enum_mode_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *height* using the specified transformation *mode.*
    ///
    /// This function automatically calculates the width of the image so that
    /// the ratio of the image is preserved.
    ///
    /// If the given *height* is 0 or negative, a null image is returned.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn scaled_to_height(&self, h: i32, mode: TransformationMode) -> Image {
        let enum_mode_2 = mode as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled_to_height)(obj_data, h, enum_mode_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a mirror of the image, mirrored in the horizontal and/or
    /// the vertical direction depending on whether *horizontal* and *vertical* are set to true or false.
    ///
    /// Note that the original image is not changed.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn mirrored(&self, horizontally: bool, vertically: bool) -> Image {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mirrored)(obj_data, horizontally, vertically);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a mirror of the image, mirrored in the horizontal and/or
    /// the vertical direction depending on whether *horizontal* and *vertical* are set to true or false.
    ///
    /// Note that the original image is not changed.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn mirrored_2(&self, horizontally: bool, vertically: bool) -> Option<Image> {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mirrored_2)(obj_data, horizontally, vertically);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns a QImage in which the values of the red and blue
    /// components of all pixels have been swapped, effectively converting
    /// an RGB image to an BGR image.
    ///
    /// The original QImage is not changed.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn rgb_swapped(&self) -> Image {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).rgb_swapped)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a QImage in which the values of the red and blue
    /// components of all pixels have been swapped, effectively converting
    /// an RGB image to an BGR image.
    ///
    /// The original QImage is not changed.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn rgb_swapped_2(&self) -> Option<Image> {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).rgb_swapped_2)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Inverts all pixel values in the image.
    ///
    /// The given invert *mode* only have a meaning when the image's
    /// depth is 32. The default *mode* is InvertRgb, which leaves the
    /// alpha channel unchanged. If the *mode* is InvertRgba, the alpha
    /// bits are also inverted.
    ///
    /// Inverting an 8-bit image means to replace all pixels using color
    /// index *i* with a pixel using color index 255 minus *i.* The same
    /// is the case for a 1-bit image. Note that the color table is *not*
    /// changed.
    ///
    /// If the image has a premultiplied alpha channel, the image is first
    /// converted to ARGB32 to be inverted and then converted back.
    ///
    /// **See also:** {QImage#Image Transformations}{Image Transformations}
    pub fn invert_pixels(&self, arg0: InvertMode) -> &Self {
        let enum_arg0_1 = arg0 as u32;

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).invert_pixels)(obj_data, enum_arg0_1);
        }
        self
    }
    ///
    /// Loads an image from the file with the given *fileName.* Returns `true` if
    /// the image was successfully loaded; otherwise invalidates the image
    /// and returns `false.`
    ///
    /// The loader attempts to read the image using the specified *format,* e.g.,
    /// PNG or JPG. If *format* is not specified (which is the default), it is
    /// auto-detected based on the file's suffix and header. For details, see
    /// {QImageReader::setAutoDetectImageFormat()}{QImageReader}.
    ///
    /// The file name can either refer to an actual file on disk or to one
    /// of the application's embedded resources. See the
    /// [Resource System](resources.html)
    /// overview for details on how to
    /// embed images and other resource files in the application's
    /// executable.
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// This function reads a QImage from the given *device.* This can,
    /// for example, be used to load an image directly into a QByteArray.
    ///
    /// Loads an image from the first *len* bytes of the given binary *data.* Returns `true` if the image was successfully loaded; otherwise
    /// invalidates the image and returns `false.`
    ///
    /// The loader attempts to read the image using the specified *format,* e.g.,
    /// PNG or JPG. If *format* is not specified (which is the default), the
    /// loader probes the file for a header to guess the file format.
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// Loads an image from the given QByteArray *data.*
    ///
    /// Loads an image from the file with the given *fileName.* Returns `true` if
    /// the image was successfully loaded; otherwise invalidates the image
    /// and returns `false.`
    ///
    /// The loader attempts to read the image using the specified *format,* e.g.,
    /// PNG or JPG. If *format* is not specified (which is the default), it is
    /// auto-detected based on the file's suffix and header. For details, see
    /// {QImageReader::setAutoDetectImageFormat()}{QImageReader}.
    ///
    /// The file name can either refer to an actual file on disk or to one
    /// of the application's embedded resources. See the
    /// [Resource System](resources.html)
    /// overview for details on how to
    /// embed images and other resource files in the application's
    /// executable.
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// This function reads a QImage from the given *device.* This can,
    /// for example, be used to load an image directly into a QByteArray.
    ///
    /// Loads an image from the first *len* bytes of the given binary *data.* Returns `true` if the image was successfully loaded; otherwise
    /// invalidates the image and returns `false.`
    ///
    /// The loader attempts to read the image using the specified *format,* e.g.,
    /// PNG or JPG. If *format* is not specified (which is the default), the
    /// loader probes the file for a header to guess the file format.
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// Loads an image from the given QByteArray *data.*
    ///
    /// Loads an image from the first *len* bytes of the given binary *data.* Returns `true` if the image was successfully loaded; otherwise
    /// invalidates the image and returns `false.`
    ///
    /// The loader attempts to read the image using the specified *format,* e.g.,
    /// PNG or JPG. If *format* is not specified (which is the default), the
    /// loader probes the file for a header to guess the file format.
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// Loads an image from the given QByteArray *data.*
    ///
    /// Loads an image from the first *len* bytes of the given binary *data.* Returns `true` if the image was successfully loaded; otherwise
    /// invalidates the image and returns `false.`
    ///
    /// The loader attempts to read the image using the specified *format,* e.g.,
    /// PNG or JPG. If *format* is not specified (which is the default), the
    /// loader probes the file for a header to guess the file format.
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// Loads an image from the given QByteArray *data.*
    ///
    /// Saves the image to the file with the given *fileName,* using the
    /// given image file *format* and *quality* factor. If *format* is
    /// 0, QImage will attempt to guess the format by looking at *fileName's*
    /// suffix.
    ///
    /// The *quality* factor must be in the range 0 to 100 or -1. Specify
    /// 0 to obtain small compressed files, 100 for large uncompressed
    /// files, and -1 (the default) to use the default settings.
    ///
    /// Returns `true` if the image was successfully saved; otherwise
    /// returns `false.`
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing
    /// Image Files}
    ///
    /// **Overloads**
    /// This function writes a QImage to the given *device.*
    ///
    /// This can, for example, be used to save an image directly into a
    /// QByteArray:
    ///
    ///
    /// Saves the image to the file with the given *fileName,* using the
    /// given image file *format* and *quality* factor. If *format* is
    /// 0, QImage will attempt to guess the format by looking at *fileName's*
    /// suffix.
    ///
    /// The *quality* factor must be in the range 0 to 100 or -1. Specify
    /// 0 to obtain small compressed files, 100 for large uncompressed
    /// files, and -1 (the default) to use the default settings.
    ///
    /// Returns `true` if the image was successfully saved; otherwise
    /// returns `false.`
    ///
    /// **See also:** {QImage#Reading and Writing Image Files}{Reading and Writing
    /// Image Files}
    ///
    /// **Overloads**
    /// This function writes a QImage to the given *device.*
    ///
    /// This can, for example, be used to save an image directly into a
    /// QByteArray:
    ///
    ///
    /// Constructs a QImage from the first *size* bytes of the given
    /// binary *data.* The loader attempts to read the image using the
    /// specified *format.* If *format* is not specified (which is the default),
    /// the loader probes the data for a header to guess the file format.
    ///
    /// If *format* is specified, it must be one of the values returned by
    /// QImageReader::supportedImageFormats().
    ///
    /// If the loading of the image fails, the image returned will be a null image.
    ///
    /// **See also:** [`load()`]
    /// [`save()`]
    /// {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// Loads an image from the given QByteArray *data.*
    ///
    /// Constructs a QImage from the first *size* bytes of the given
    /// binary *data.* The loader attempts to read the image using the
    /// specified *format.* If *format* is not specified (which is the default),
    /// the loader probes the data for a header to guess the file format.
    ///
    /// If *format* is specified, it must be one of the values returned by
    /// QImageReader::supportedImageFormats().
    ///
    /// If the loading of the image fails, the image returned will be a null image.
    ///
    /// **See also:** [`load()`]
    /// [`save()`]
    /// {QImage#Reading and Writing Image Files}{Reading and Writing Image Files}
    ///
    /// **Overloads**
    /// Loads an image from the given QByteArray *data.*
    ///
    /// Returns a number that identifies the contents of this QImage
    /// object. Distinct QImage objects can only have the same key if they
    /// refer to the same contents.
    ///
    /// The key will change when the image is altered.
    pub fn cache_key(&self) -> i64 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cache_key)(obj_data);
            ret_val
        }
    }
    pub fn paint_engine(&self) -> Option<PaintEngine> {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_engine)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintEngine::new_from_rc(t);
            } else {
                ret_val = PaintEngine::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the number of pixels that fit horizontally in a physical
    /// meter. Together with dotsPerMeterY(), this number defines the
    /// intended scale and aspect ratio of the image.
    ///
    /// **See also:** [`set_dots_per_meter_x()`]
    /// {QImage#Image Information}{Image
    /// Information}
    pub fn dots_per_meter_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).dots_per_meter_x)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the number of pixels that fit vertically in a physical
    /// meter. Together with dotsPerMeterX(), this number defines the
    /// intended scale and aspect ratio of the image.
    ///
    /// **See also:** [`set_dots_per_meter_y()`]
    /// {QImage#Image Information}{Image
    /// Information}
    pub fn dots_per_meter_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).dots_per_meter_y)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the number of pixels that fit horizontally in a physical
    /// meter, to *x.*
    ///
    /// Together with dotsPerMeterY(), this number defines the intended
    /// scale and aspect ratio of the image, and determines the scale
    /// at which QPainter will draw graphics on the image. It does not
    /// change the scale or aspect ratio of the image when it is rendered
    /// on other paint devices.
    ///
    /// **See also:** [`dots_per_meter_x()`]
    /// {QImage#Image Information}{Image Information}
    pub fn set_dots_per_meter_x(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_dots_per_meter_x)(obj_data, arg0);
        }
        self
    }
    ///
    /// Sets the number of pixels that fit vertically in a physical meter,
    /// to *y.*
    ///
    /// Together with dotsPerMeterX(), this number defines the intended
    /// scale and aspect ratio of the image, and determines the scale
    /// at which QPainter will draw graphics on the image. It does not
    /// change the scale or aspect ratio of the image when it is rendered
    /// on other paint devices.
    ///
    /// **See also:** [`dots_per_meter_y()`]
    /// {QImage#Image Information}{Image Information}
    pub fn set_dots_per_meter_y(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_dots_per_meter_y)(obj_data, arg0);
        }
        self
    }
    ///
    /// Returns the number of pixels by which the image is intended to be
    /// offset by when positioning relative to other images.
    ///
    /// **See also:** [`set_offset()`]
    /// {QImage#Image Information}{Image Information}
    pub fn offset(&self) -> Point {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).offset)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the number of pixels by which the image is intended to be
    /// offset by when positioning relative to other images, to *offset.*
    ///
    /// **See also:** [`offset()`]
    /// {QImage#Image Information}{Image Information}
    pub fn set_offset<P: PointTrait<'a>>(&self, arg0: &P) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_offset)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Returns the text keys for this image.
    ///
    /// You can use these keys with text() to list the image text for a
    /// certain key.
    ///
    /// **See also:** [`text()`]
    ///
    /// Returns the text keys for this image.
    ///
    /// You can use these keys with text() to list the image text for a
    /// certain key.
    ///
    /// **See also:** [`text()`]
    ///
    /// Returns the image text associated with the given *key.* If the
    /// specified *key* is an empty string, the whole image text is
    /// returned, with each key-text pair separated by a newline.
    ///
    /// **See also:** [`set_text()`]
    /// [`text_keys()`]
    ///
    /// Returns the text recorded for the given *key* in the given *language,* or in a default language if *language* is 0.
    ///
    /// Use text() instead.
    ///
    /// The language the text is recorded in is no longer relevant since
    /// the text is always set using QString and UTF-8 representation.
    ///
    /// **Overloads**
    /// Returns the text recorded for the given *keywordAndLanguage.*
    ///
    /// Use text() instead.
    ///
    /// The language the text is recorded in is no longer relevant since
    /// the text is always set using QString and UTF-8 representation.
    ///
    /// Returns the language identifiers for which some texts are recorded.
    /// Note that if you want to iterate over the list, you should iterate over a copy.
    ///
    /// The language the text is recorded in is no longer relevant since the text is
    /// always set using QString and UTF-8 representation.
    ///
    /// **See also:** [`text_keys()`]
    ///
    /// Returns a list of QImageTextKeyLang objects that enumerate all the texts
    /// key/language pairs set for this image.
    ///
    /// The language the text is recorded in is no longer relevant since the text
    /// is always set using QString and UTF-8 representation.
    ///
    /// **See also:** [`text_keys()`]
    pub fn text(&self, key: &str) -> String {
        let str_in_key_1 = CString::new(key).unwrap();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).text)(obj_data, str_in_key_1.as_ptr());
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// Sets the image text to the given *text* and associate it with the
    /// given *key.*
    ///
    /// If you just want to store a single text block (i.e., a
    /// or just a description), you can either pass an empty key, or use a
    /// generic key like .
    ///
    /// The image text is embedded into the image data when you
    /// call save() or QImageWriter::write().
    ///
    /// Not all image formats support embedded text. You can find out
    /// if a specific image or format supports embedding text
    /// by using QImageWriter::supportsOption(). We give an example:
    ///
    /// You can use QImageWriter::supportedImageFormats() to find out
    /// which image formats are available to you.
    ///
    /// **See also:** [`text()`]
    /// [`text_keys()`]
    ///
    /// Sets the image text to the given *text* and associate it with the
    /// given *key.* The text is recorded in the specified *language,*
    /// or in a default language if *language* is 0.
    ///
    /// Use setText() instead.
    ///
    /// The language the text is recorded in is no longer relevant since
    /// the text is always set using QString and UTF-8 representation.
    ///
    pub fn set_text(&self, key: &str, value: &str) -> &Self {
        let str_in_key_1 = CString::new(key).unwrap();
        let str_in_value_2 = CString::new(value).unwrap();

        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            ((*funcs).set_text)(obj_data, str_in_key_1.as_ptr(), str_in_value_2.as_ptr());
        }
        self
    }
    ///
    /// Returns the QImage::Format as a QPixelFormat
    pub fn pixel_format(&self) -> PixelFormat {
        let (obj_data, funcs) = self.get_image_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixel_format)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PixelFormat::new_from_rc(t);
            } else {
                ret_val = PixelFormat::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Converts *format* into a QPixelFormat
    pub fn to_pixel_format(format: Format) -> PixelFormat<'a> {
        let enum_format_1 = format as u32;

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_image)(::std::ptr::null()).all_funcs).image_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).to_pixel_format)(obj_data, enum_format_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PixelFormat::new_from_rc(t);
            } else {
                ret_val = PixelFormat::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn painting_active(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).painting_active)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn logical_dpi_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).logical_dpi_x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn logical_dpi_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).logical_dpi_y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn physical_dpi_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).physical_dpi_x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn physical_dpi_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).physical_dpi_y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn device_pixel_ratio_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio_f)(obj_data);
            ret_val
        }
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<WrapperRcOwn> for Image<'a> {
    fn from(t: WrapperRcOwn) -> Self {
        let mut data = RUImage {
            qt_data: ::std::ptr::null(),
            host_data: ::std::ptr::null(),
            all_funcs: t.all_funcs as *const RUImageAllFuncs,
        };

        if t.owned {
            data.host_data = t.data as *const RUBase;
            Image::new_from_rc(data)
        } else {
            data.qt_data = t.data as *const RUBase;
            Image::new_from_temporary(data)
        }
    }
}

pub trait ImageTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_image_obj_funcs(&self) -> (*const RUBase, *const RUImageFuncs);
}

impl<'a> PaintDeviceTrait<'a> for Image<'a> {
    #[doc(hidden)]
    fn get_paint_device_obj_funcs(&self) -> (*const RUBase, *const RUPaintDeviceFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).paint_device_funcs) }
    }
}

impl<'a> ImageTrait<'a> for Image<'a> {
    #[doc(hidden)]
    fn get_image_obj_funcs(&self) -> (*const RUBase, *const RUImageFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).image_funcs) }
    }
}
#[repr(u32)]
pub enum InvertMode {
    InvertRgb = 0,
    InvertRgba = 1,
}

#[repr(u32)]
pub enum Format {
    FormatInvalid = 0,
    FormatMono = 1,
    FormatMonoLsb = 2,
    FormatIndexed8 = 3,
    FormatRgB32 = 4,
    FormatArgB32 = 5,
    FormatArgB32Premultiplied = 6,
    FormatRgB16 = 7,
    FormatArgB8565Premultiplied = 8,
    FormatRgB666 = 9,
    FormatArgB6666Premultiplied = 10,
    FormatRgB555 = 11,
    FormatArgB8555Premultiplied = 12,
    FormatRgB888 = 13,
    FormatRgB444 = 14,
    FormatArgB4444Premultiplied = 15,
    FormatRgbX8888 = 16,
    FormatRgbA8888 = 17,
    FormatRgbA8888Premultiplied = 18,
    FormatBgR30 = 19,
    FormatA2BgR30Premultiplied = 20,
    FormatRgB30 = 21,
    FormatA2RgB30Premultiplied = 22,
    FormatAlpha8 = 23,
    FormatGrayscale8 = 24,
    NImageFormats = 25,
}
