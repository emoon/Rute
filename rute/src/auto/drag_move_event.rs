// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports

#[allow(unused_imports)]
use auto::drag_move_event_ffi::*;
#[allow(unused_imports)]
use auto::drop_event::*;
#[allow(unused_imports)]
use auto::drop_event_ffi::*;
#[allow(unused_imports)]
use auto::event::*;
#[allow(unused_imports)]
use auto::event_ffi::*;
#[allow(unused_imports)]
use auto::rect::Rect;
#[allow(unused_imports)]
use auto::rect::RectTrait;
#[allow(unused_imports)]
use auto::rect_ffi::*;
#[allow(unused_imports)]
use auto::rute::*;
#[allow(unused_imports)]
use auto::rute_ffi::*;
///
/// A widget will receive drag move events repeatedly while the drag
/// is within its boundaries, if it accepts
/// [drop events](QWidget::setAcceptDrops())
/// and [enter events](QWidget::dragEnterEvent())
/// . The widget should
/// examine the event to see what kind of [data](mimeData())
/// it
/// provides, and call the accept() function to accept the drop if appropriate.
///
/// The rectangle supplied by the answerRect() function can be used to restrict
/// drops to certain parts of the widget. For example, we can check whether the
/// rectangle intersects with the geometry of a certain child widget and only
/// call [acceptProposedAction()](QDropEvent::acceptProposedAction())
/// if that
/// is the case.
///
/// Note that this class inherits most of its functionality from
/// QDropEvent.
///
/// **See also:** [`DragEnterEvent`]
/// [`DragLeaveEvent`]
/// [`DropEvent`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct DragMoveEvent<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUDragMoveEventAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> DragMoveEvent<'a> {
    pub fn new_from_rc(ffi_data: RUDragMoveEvent) -> DragMoveEvent<'a> {
        DragMoveEvent {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUDragMoveEvent) -> DragMoveEvent<'a> {
        DragMoveEvent {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUDragMoveEvent) -> DragMoveEvent<'a> {
        DragMoveEvent {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait DragMoveEventTrait<'a> {
    ///
    /// Returns the rectangle in the widget where the drop will occur if accepted.
    /// You can use this information to restrict drops to certain places on the
    /// widget.
    fn answer_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_drag_move_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).answer_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// The same as accept(), but also notifies that future moves will
    /// also be acceptable if they remain within the *rectangle*
    /// given on the widget. This can improve performance, but may
    /// also be ignored by the underlying system.
    ///
    /// If the rectangle is empty, drag move events will be sent
    /// continuously. This is useful if the source is scrolling in a
    /// timer event.
    ///
    /// **Overloads**
    /// Calls QDropEvent::accept().
    fn accept(&self) {
        let (obj_data, funcs) = self.get_drag_move_event_obj_funcs();
        unsafe {
            ((*funcs).accept)(obj_data);
        }
    }
    ///
    /// **Overloads**
    /// Calls QDropEvent::ignore().
    ///
    /// The opposite of the accept(const QRect&) function.
    /// Moves within the *rectangle* are not acceptable, and will be
    /// ignored.
    fn ignore(&self) {
        let (obj_data, funcs) = self.get_drag_move_event_obj_funcs();
        unsafe {
            ((*funcs).ignore)(obj_data);
        }
    }
    ///
    /// The same as accept(), but also notifies that future moves will
    /// also be acceptable if they remain within the *rectangle*
    /// given on the widget. This can improve performance, but may
    /// also be ignored by the underlying system.
    ///
    /// If the rectangle is empty, drag move events will be sent
    /// continuously. This is useful if the source is scrolling in a
    /// timer event.
    ///
    /// **Overloads**
    /// Calls QDropEvent::accept().
    fn accept_2(&self, r: &RectTrait) {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_drag_move_event_obj_funcs();
        unsafe {
            ((*funcs).accept_2)(obj_data, obj_r_1);
        }
    }
    ///
    /// **Overloads**
    /// Calls QDropEvent::ignore().
    ///
    /// The opposite of the accept(const QRect&) function.
    /// Moves within the *rectangle* are not acceptable, and will be
    /// ignored.
    fn ignore_2(&self, r: &RectTrait) {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_drag_move_event_obj_funcs();
        unsafe {
            ((*funcs).ignore_2)(obj_data, obj_r_1);
        }
    }

    #[inline]
    fn get_drag_move_event_obj_funcs(&self) -> (*const RUBase, *const RUDragMoveEventFuncs);
}

impl<'a> EventTrait<'a> for DragMoveEvent<'a> {
    #[inline]
    fn get_event_obj_funcs(&self) -> (*const RUBase, *const RUEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).event_funcs) }
    }
}

impl<'a> DropEventTrait<'a> for DragMoveEvent<'a> {
    #[inline]
    fn get_drop_event_obj_funcs(&self) -> (*const RUBase, *const RUDropEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).drop_event_funcs) }
    }
}

impl<'a> DragMoveEventTrait<'a> for DragMoveEvent<'a> {
    #[inline]
    fn get_drag_move_event_obj_funcs(&self) -> (*const RUBase, *const RUDragMoveEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).drag_move_event_funcs) }
    }
}
