// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// Qt provides several premade implementations of QPaintEngine for the
/// different painter backends we support. The primary paint engine
/// provided is the raster paint engine, which contains a software
/// rasterizer which supports the full feature set on all supported platforms.
/// This is the default for painting on QWidget-based classes in e.g. on Windows,
/// X11 and MacOS , it is the backend for painting on QImage and it is
/// used as a fallback for paint engines that do not support a certain
/// capability. In addition we provide QPaintEngine implementations for
/// OpenGL (accessible through QGLWidget) and printing (which allows using
/// QPainter to draw on a QPrinter object).
///
/// If one wants to use QPainter to draw to a different backend,
/// one must subclass QPaintEngine and reimplement all its virtual
/// functions. The QPaintEngine implementation is then made available by
/// subclassing QPaintDevice and reimplementing the virtual function
/// QPaintDevice::paintEngine().
///
/// QPaintEngine is created and owned by the QPaintDevice that created it.
///
/// **See also:** [`Painter`]
/// [`PaintDevice::paint_engine`]
/// {Paint System}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct PaintEngine<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUPaintEngineAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> PaintEngine<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUPaintEngine) -> PaintEngine<'a> {
        PaintEngine {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUPaintEngine) -> PaintEngine<'a> {
        PaintEngine {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUPaintEngine) -> PaintEngine<'a> {
        PaintEngine {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Returns `true` if the paint engine is actively drawing; otherwise
    /// returns `false.`
    ///
    /// **See also:** [`set_active()`]
    pub fn is_active(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_active)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the active state of the paint engine to *state.*
    ///
    /// **See also:** [`is_active()`]
    pub fn set_active(&self, new_state: bool) -> &Self {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_active)(obj_data, new_state);
        }
        self
    }
    ///
    /// Reimplement this function to initialise your paint engine when
    /// painting is to start on the paint device *pdev.* Return true if
    /// the initialization was successful; otherwise return false.
    ///
    /// **See also:** [`end()`]
    /// [`is_active()`]
    pub fn begin<P: PaintDeviceTrait<'a>>(&self, pdev: &P) -> bool {
        let (obj_pdev_1, _funcs) = pdev.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).begin)(obj_data, obj_pdev_1);
            ret_val
        }
    }
    ///
    /// Reimplement this function to finish painting on the current paint
    /// device. Return true if painting was finished successfully;
    /// otherwise return false.
    ///
    /// **See also:** [`begin()`]
    /// [`is_active()`]
    pub fn end(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).end)(obj_data);
            ret_val
        }
    }
    ///
    /// Reimplement this function to update the state of a paint engine.
    ///
    /// When implemented, this function is responsible for checking the
    /// paint engine's current *state* and update the properties that are
    /// changed. Use the QPaintEngineState::state() function to find out
    /// which properties that must be updated, then use the corresponding
    /// [get function](GetFunction)
    /// to retrieve the current values for
    /// the given properties.
    ///
    /// **See also:** [`PaintEngineState`]
    pub fn update_state<P: PaintEngineStateTrait<'a>>(&self, state: &P) -> &Self {
        let (obj_state_1, _funcs) = state.get_paint_engine_state_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).update_state)(obj_data, obj_state_1);
        }
        self
    }
    ///
    /// **Overloads**
    /// The default implementation converts the first *rectCount*
    /// rectangles in the buffer *rects* to a QRectF and calls the
    /// floating point version of this function.
    ///
    /// Draws the first *rectCount* rectangles in the buffer *rects.* The default implementation of this function calls drawPath()
    /// or drawPolygon() depending on the feature set of the paint engine.
    pub fn draw_rects<R: RectTrait<'a>>(&self, rects: &R, rect_count: i32) -> &Self {
        let (obj_rects_1, _funcs) = rects.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_rects)(obj_data, obj_rects_1, rect_count);
        }
        self
    }
    ///
    /// **Overloads**
    /// The default implementation converts the first *rectCount*
    /// rectangles in the buffer *rects* to a QRectF and calls the
    /// floating point version of this function.
    ///
    /// Draws the first *rectCount* rectangles in the buffer *rects.* The default implementation of this function calls drawPath()
    /// or drawPolygon() depending on the feature set of the paint engine.
    pub fn draw_rects_2<R: RectFTrait<'a>>(&self, rects: &R, rect_count: i32) -> &Self {
        let (obj_rects_1, _funcs) = rects.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_rects_2)(obj_data, obj_rects_1, rect_count);
        }
        self
    }
    ///
    /// The default implementation splits the list of lines in *lines*
    /// into *lineCount* separate calls to drawPath() or drawPolygon()
    /// depending on the feature set of the paint engine.
    ///
    /// **Overloads**
    /// The default implementation converts the first *lineCount* lines
    /// in *lines* to a QLineF and calls the floating point version of
    /// this function.
    pub fn draw_lines<L: LineTrait<'a>>(&self, lines: &L, line_count: i32) -> &Self {
        let (obj_lines_1, _funcs) = lines.get_line_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_lines)(obj_data, obj_lines_1, line_count);
        }
        self
    }
    ///
    /// The default implementation splits the list of lines in *lines*
    /// into *lineCount* separate calls to drawPath() or drawPolygon()
    /// depending on the feature set of the paint engine.
    ///
    /// **Overloads**
    /// The default implementation converts the first *lineCount* lines
    /// in *lines* to a QLineF and calls the floating point version of
    /// this function.
    pub fn draw_lines_2<L: LineFTrait<'a>>(&self, lines: &L, line_count: i32) -> &Self {
        let (obj_lines_1, _funcs) = lines.get_line_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_lines_2)(obj_data, obj_lines_1, line_count);
        }
        self
    }
    ///
    /// Reimplement this function to draw the largest ellipse that can be
    /// contained within rectangle *rect.*
    ///
    /// The default implementation calls drawPolygon().
    ///
    /// The default implementation of this function calls the floating
    /// point version of this function
    pub fn draw_ellipse<R: RectFTrait<'a>>(&self, r: &R) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse)(obj_data, obj_r_1);
        }
        self
    }
    ///
    /// Reimplement this function to draw the largest ellipse that can be
    /// contained within rectangle *rect.*
    ///
    /// The default implementation calls drawPolygon().
    ///
    /// The default implementation of this function calls the floating
    /// point version of this function
    pub fn draw_ellipse_2<R: RectTrait<'a>>(&self, r: &R) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse_2)(obj_data, obj_r_1);
        }
        self
    }
    ///
    /// The default implementation ignores the *path* and does nothing.
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// The default implementation converts the first *pointCount* QPoints in *points*
    /// to QPointFs and calls the floating point version of drawPoints.
    ///
    pub fn draw_points<P: PointFTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_points)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// The default implementation converts the first *pointCount* QPoints in *points*
    /// to QPointFs and calls the floating point version of drawPoints.
    ///
    pub fn draw_points_2<P: PointTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_points_2)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// PolygonDrawMode mode)
    ///
    /// Reimplement this virtual function to draw the polygon defined
    /// by the *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    ///
    /// **Overloads**
    /// Reimplement this virtual function to draw the polygon defined by the
    /// *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    pub fn draw_polygon<P: PointFTrait<'a>>(
        &self,
        points: &P,
        point_count: i32,
        mode: PolygonDrawMode,
    ) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();
        let enum_mode_3 = mode as u32;

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon)(obj_data, obj_points_1, point_count, enum_mode_3);
        }
        self
    }
    ///
    /// PolygonDrawMode mode)
    ///
    /// Reimplement this virtual function to draw the polygon defined
    /// by the *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    ///
    /// **Overloads**
    /// Reimplement this virtual function to draw the polygon defined by the
    /// *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    pub fn draw_polygon_2<P: PointTrait<'a>>(
        &self,
        points: &P,
        point_count: i32,
        mode: PolygonDrawMode,
    ) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();
        let enum_mode_3 = mode as u32;

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon_2)(obj_data, obj_points_1, point_count, enum_mode_3);
        }
        self
    }
    ///
    /// &pm, const QRectF &sr)
    ///
    /// Reimplement this function to draw the part of the *pm*
    /// specified by the *sr* rectangle in the given *r.*
    pub fn draw_pixmap<P: PixmapTrait<'a>, R: RectFTrait<'a>>(
        &self,
        r: &R,
        pm: &P,
        sr: &R,
    ) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap)(obj_data, obj_r_1, obj_pm_2, obj_sr_3);
        }
        self
    }
    ///
    /// This function draws the text item *textItem* at position *p.* The
    /// default implementation of this function converts the text to a
    /// QPainterPath and paints the resulting path.
    ///
    /// Reimplement this function to draw the *pixmap* in the given *rect,* starting at the given *p.* The pixmap will be
    /// drawn repeatedly until the *rect* is filled.
    pub fn draw_tiled_pixmap<P: PixmapTrait<'a>, Q: PointFTrait<'a>, R: RectFTrait<'a>>(
        &self,
        r: &R,
        pixmap: &P,
        s: &Q,
    ) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_pixmap_2, _funcs) = pixmap.get_pixmap_obj_funcs();
        let (obj_s_3, _funcs) = s.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_tiled_pixmap)(obj_data, obj_r_1, obj_pixmap_2, obj_s_3);
        }
        self
    }
    ///
    /// &image, const QRectF &sr, Qt::ImageConversionFlags flags)
    ///
    /// Reimplement this function to draw the part of the *image*
    /// specified by the *sr* rectangle in the given *rectangle* using
    /// the given conversion flags *flags,* to convert it to a pixmap.
    pub fn draw_image<I: ImageTrait<'a>, R: RectFTrait<'a>>(
        &self,
        r: &R,
        pm: &I,
        sr: &R,
        flags: ImageConversionFlags,
    ) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_image_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_f_obj_funcs();
        let enum_flags_4 = flags.bits();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_image)(obj_data, obj_r_1, obj_pm_2, obj_sr_3, enum_flags_4);
        }
        self
    }
    pub fn set_paint_device<P: PaintDeviceTrait<'a>>(&self, device: &P) -> &Self {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_paint_device)(obj_data, obj_device_1);
        }
        self
    }
    ///
    /// Returns the device that this engine is painting on, if painting is
    /// active; otherwise returns 0.
    pub fn paint_device(&self) -> Option<PaintDevice> {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_device)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintDevice::new_from_rc(t);
            } else {
                ret_val = PaintDevice::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    pub fn set_system_clip<R: RegionTrait<'a>>(&self, base_clip: &R) -> &Self {
        let (obj_base_clip_1, _funcs) = base_clip.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_system_clip)(obj_data, obj_base_clip_1);
        }
        self
    }
    pub fn system_clip(&self) -> Region {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).system_clip)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    pub fn set_system_rect<R: RectTrait<'a>>(&self, rect: &R) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_system_rect)(obj_data, obj_rect_1);
        }
        self
    }
    pub fn system_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).system_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    pub fn coordinate_offset(&self) -> Point {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).coordinate_offset)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
}
pub trait PaintEngineTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_paint_engine_obj_funcs(&self) -> (*const RUBase, *const RUPaintEngineFuncs);
}

impl<'a> PaintEngineTrait<'a> for PaintEngine<'a> {
    #[doc(hidden)]
    fn get_paint_engine_obj_funcs(&self) -> (*const RUBase, *const RUPaintEngineFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).paint_engine_funcs) }
    }
}
bitflags! {
    pub struct PaintEngineFeature: u32 {
        const PrimitiveTransform = 0x1;
        const PatternTransform = 0x2;
        const PixmapTransform = 0x4;
        const PatternBrush = 0x8;
        const LinearGradientFill = 0x10;
        const RadialGradientFill = 0x20;
        const ConicalGradientFill = 0x40;
        const AlphaBlend = 0x80;
        const PorterDuff = 0x100;
        const PainterPaths = 0x200;
        const Antialiasing = 0x400;
        const BrushStroke = 0x800;
        const ConstantOpacity = 0x1000;
        const MaskedBrush = 0x2000;
        const PerspectiveTransform = 0x4000;
        const BlendModes = 0x8000;
        const ObjectBoundingModeGradients = 0x10000;
        const RasterOpModes = 0x20000;
        const PaintOutsidePaintEvent = 0x20000000;
        const AllFeatures = 0xffffffff;
    }
}

bitflags! {
    pub struct DirtyFlag: u32 {
        const DirtyPen = 0x1;
        const DirtyBrush = 0x2;
        const DirtyBrushOrigin = 0x4;
        const DirtyFont = 0x8;
        const DirtyBackground = 0x10;
        const DirtyBackgroundMode = 0x20;
        const DirtyTransform = 0x40;
        const DirtyClipRegion = 0x80;
        const DirtyClipPath = 0x100;
        const DirtyHints = 0x200;
        const DirtyCompositionMode = 0x400;
        const DirtyClipEnabled = 0x800;
        const DirtyOpacity = 0x1000;
        const AllDirty = 0xffff;
    }
}

pub type DirtyFlags = DirtyFlag;

#[repr(u32)]
pub enum PolygonDrawMode {
    OddEvenMode = 0,
    WindingMode = 1,
    ConvexMode = 2,
    PolylineMode = 3,
}

#[repr(u32)]
pub enum Type {
    X11 = 0,
    Windows = 1,
    QuickDraw = 2,
    CoreGraphics = 3,
    MacPrinter = 4,
    QWindowSystem = 5,
    PostScript = 6,
    OpenGl = 7,
    Picture = 8,
    Svg = 9,
    Raster = 10,
    Direct3D = 11,
    Pdf = 12,
    OpenVg = 13,
    OpenGL2 = 14,
    PaintBuffer = 15,
    Blitter = 16,
    Direct2D = 17,
    User = 50,
    MaxUser = 100,
}
