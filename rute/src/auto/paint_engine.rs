// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports

#[allow(unused_imports)]
use auto::image::Image;
#[allow(unused_imports)]
use auto::image::ImageTrait;
#[allow(unused_imports)]
use auto::image_ffi::*;
#[allow(unused_imports)]
use auto::line::Line;
#[allow(unused_imports)]
use auto::line::LineTrait;
#[allow(unused_imports)]
use auto::line_f::LineF;
#[allow(unused_imports)]
use auto::line_f::LineFTrait;
#[allow(unused_imports)]
use auto::line_f_ffi::*;
#[allow(unused_imports)]
use auto::line_ffi::*;
#[allow(unused_imports)]
use auto::paint_device::PaintDevice;
#[allow(unused_imports)]
use auto::paint_device::PaintDeviceTrait;
#[allow(unused_imports)]
use auto::paint_device_ffi::*;
#[allow(unused_imports)]
use auto::paint_engine_ffi::*;
#[allow(unused_imports)]
use auto::paint_engine_state::PaintEngineState;
#[allow(unused_imports)]
use auto::paint_engine_state::PaintEngineStateTrait;
#[allow(unused_imports)]
use auto::paint_engine_state_ffi::*;
#[allow(unused_imports)]
use auto::pixmap::Pixmap;
#[allow(unused_imports)]
use auto::pixmap::PixmapTrait;
#[allow(unused_imports)]
use auto::pixmap_ffi::*;
#[allow(unused_imports)]
use auto::point::Point;
#[allow(unused_imports)]
use auto::point::PointTrait;
#[allow(unused_imports)]
use auto::point_f::PointF;
#[allow(unused_imports)]
use auto::point_f::PointFTrait;
#[allow(unused_imports)]
use auto::point_f_ffi::*;
#[allow(unused_imports)]
use auto::point_ffi::*;
#[allow(unused_imports)]
use auto::rect::Rect;
#[allow(unused_imports)]
use auto::rect::RectTrait;
#[allow(unused_imports)]
use auto::rect_f::RectF;
#[allow(unused_imports)]
use auto::rect_f::RectFTrait;
#[allow(unused_imports)]
use auto::rect_f_ffi::*;
#[allow(unused_imports)]
use auto::rect_ffi::*;
#[allow(unused_imports)]
use auto::region::Region;
#[allow(unused_imports)]
use auto::region::RegionTrait;
#[allow(unused_imports)]
use auto::region_ffi::*;
#[allow(unused_imports)]
use auto::rute::*;
#[allow(unused_imports)]
use auto::rute_enums::ImageConversionFlags;
#[allow(unused_imports)]
use auto::rute_ffi::*;
///
/// Qt provides several premade implementations of QPaintEngine for the
/// different painter backends we support. The primary paint engine
/// provided is the raster paint engine, which contains a software
/// rasterizer which supports the full feature set on all supported platforms.
/// This is the default for painting on QWidget-based classes in e.g. on Windows,
/// X11 and MacOS , it is the backend for painting on QImage and it is
/// used as a fallback for paint engines that do not support a certain
/// capability. In addition we provide QPaintEngine implementations for
/// OpenGL (accessible through QGLWidget) and printing (which allows using
/// QPainter to draw on a QPrinter object).
///
/// If one wants to use QPainter to draw to a different backend,
/// one must subclass QPaintEngine and reimplement all its virtual
/// functions. The QPaintEngine implementation is then made available by
/// subclassing QPaintDevice and reimplementing the virtual function
/// QPaintDevice::paintEngine().
///
/// QPaintEngine is created and owned by the QPaintDevice that created it.
///
/// **See also:** [`Painter`]
/// [`PaintDevice::paint_engine`]
/// {Paint System}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct PaintEngine<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUPaintEngineAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> PaintEngine<'a> {
    pub fn new_from_rc(ffi_data: RUPaintEngine) -> PaintEngine<'a> {
        PaintEngine {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUPaintEngine) -> PaintEngine<'a> {
        PaintEngine {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUPaintEngine) -> PaintEngine<'a> {
        PaintEngine {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait PaintEngineTrait<'a> {
    ///
    /// Returns `true` if the paint engine is actively drawing; otherwise
    /// returns `false.`
    ///
    /// **See also:** [`set_active()`]
    fn is_active(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_active)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the active state of the paint engine to *state.*
    ///
    /// **See also:** [`is_active()`]
    fn set_active(&self, new_state: bool) {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_active)(obj_data, new_state);
        }
    }
    ///
    /// Reimplement this function to initialise your paint engine when
    /// painting is to start on the paint device *pdev.* Return true if
    /// the initialization was successful; otherwise return false.
    ///
    /// **See also:** [`end()`]
    /// [`is_active()`]
    fn begin(&self, pdev: &PaintDeviceTrait) -> bool {
        let (obj_pdev_1, _funcs) = pdev.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).begin)(obj_data, obj_pdev_1);
            ret_val
        }
    }
    ///
    /// Reimplement this function to finish painting on the current paint
    /// device. Return true if painting was finished successfully;
    /// otherwise return false.
    ///
    /// **See also:** [`begin()`]
    /// [`is_active()`]
    fn end(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).end)(obj_data);
            ret_val
        }
    }
    ///
    /// Reimplement this function to update the state of a paint engine.
    ///
    /// When implemented, this function is responsible for checking the
    /// paint engine's current *state* and update the properties that are
    /// changed. Use the QPaintEngineState::state() function to find out
    /// which properties that must be updated, then use the corresponding
    /// [get function](GetFunction)
    /// to retrieve the current values for
    /// the given properties.
    ///
    /// **See also:** [`PaintEngineState`]
    fn update_state(&self, state: &PaintEngineStateTrait) {
        let (obj_state_1, _funcs) = state.get_paint_engine_state_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).update_state)(obj_data, obj_state_1);
        }
    }
    ///
    /// **Overloads**
    /// The default implementation converts the first *rectCount*
    /// rectangles in the buffer *rects* to a QRectF and calls the
    /// floating point version of this function.
    ///
    /// Draws the first *rectCount* rectangles in the buffer *rects.* The default implementation of this function calls drawPath()
    /// or drawPolygon() depending on the feature set of the paint engine.
    fn draw_rects(&self, rects: &RectTrait, rect_count: i32) {
        let (obj_rects_1, _funcs) = rects.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_rects)(obj_data, obj_rects_1, rect_count);
        }
    }
    ///
    /// **Overloads**
    /// The default implementation converts the first *rectCount*
    /// rectangles in the buffer *rects* to a QRectF and calls the
    /// floating point version of this function.
    ///
    /// Draws the first *rectCount* rectangles in the buffer *rects.* The default implementation of this function calls drawPath()
    /// or drawPolygon() depending on the feature set of the paint engine.
    fn draw_rects_2(&self, rects: &RectFTrait, rect_count: i32) {
        let (obj_rects_1, _funcs) = rects.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_rects_2)(obj_data, obj_rects_1, rect_count);
        }
    }
    ///
    /// The default implementation splits the list of lines in *lines*
    /// into *lineCount* separate calls to drawPath() or drawPolygon()
    /// depending on the feature set of the paint engine.
    ///
    /// **Overloads**
    /// The default implementation converts the first *lineCount* lines
    /// in *lines* to a QLineF and calls the floating point version of
    /// this function.
    fn draw_lines(&self, lines: &LineTrait, line_count: i32) {
        let (obj_lines_1, _funcs) = lines.get_line_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_lines)(obj_data, obj_lines_1, line_count);
        }
    }
    ///
    /// The default implementation splits the list of lines in *lines*
    /// into *lineCount* separate calls to drawPath() or drawPolygon()
    /// depending on the feature set of the paint engine.
    ///
    /// **Overloads**
    /// The default implementation converts the first *lineCount* lines
    /// in *lines* to a QLineF and calls the floating point version of
    /// this function.
    fn draw_lines_2(&self, lines: &LineFTrait, line_count: i32) {
        let (obj_lines_1, _funcs) = lines.get_line_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_lines_2)(obj_data, obj_lines_1, line_count);
        }
    }
    ///
    /// Reimplement this function to draw the largest ellipse that can be
    /// contained within rectangle *rect.*
    ///
    /// The default implementation calls drawPolygon().
    ///
    /// The default implementation of this function calls the floating
    /// point version of this function
    fn draw_ellipse(&self, r: &RectFTrait) {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse)(obj_data, obj_r_1);
        }
    }
    ///
    /// Reimplement this function to draw the largest ellipse that can be
    /// contained within rectangle *rect.*
    ///
    /// The default implementation calls drawPolygon().
    ///
    /// The default implementation of this function calls the floating
    /// point version of this function
    fn draw_ellipse_2(&self, r: &RectTrait) {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse_2)(obj_data, obj_r_1);
        }
    }
    ///
    /// The default implementation ignores the *path* and does nothing.
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// The default implementation converts the first *pointCount* QPoints in *points*
    /// to QPointFs and calls the floating point version of drawPoints.
    ///
    fn draw_points(&self, points: &PointFTrait, point_count: i32) {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_points)(obj_data, obj_points_1, point_count);
        }
    }
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// Draws the first *pointCount* points in the buffer *points*
    ///
    /// The default implementation converts the first *pointCount* QPoints in *points*
    /// to QPointFs and calls the floating point version of drawPoints.
    ///
    fn draw_points_2(&self, points: &PointTrait, point_count: i32) {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_points_2)(obj_data, obj_points_1, point_count);
        }
    }
    ///
    /// PolygonDrawMode mode)
    ///
    /// Reimplement this virtual function to draw the polygon defined
    /// by the *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    ///
    /// **Overloads**
    /// Reimplement this virtual function to draw the polygon defined by the
    /// *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    fn draw_polygon(&self, points: &PointFTrait, point_count: i32, mode: PolygonDrawMode) {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();
        let enum_mode_3 = mode as i32;

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon)(obj_data, obj_points_1, point_count, enum_mode_3);
        }
    }
    ///
    /// PolygonDrawMode mode)
    ///
    /// Reimplement this virtual function to draw the polygon defined
    /// by the *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    ///
    /// **Overloads**
    /// Reimplement this virtual function to draw the polygon defined by the
    /// *pointCount* first points in *points,* using mode *mode.*
    ///
    /// **Note**: At least one of the drawPolygon() functions must be reimplemented.
    fn draw_polygon_2(&self, points: &PointTrait, point_count: i32, mode: PolygonDrawMode) {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();
        let enum_mode_3 = mode as i32;

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon_2)(obj_data, obj_points_1, point_count, enum_mode_3);
        }
    }
    ///
    /// &pm, const QRectF &sr)
    ///
    /// Reimplement this function to draw the part of the *pm*
    /// specified by the *sr* rectangle in the given *r.*
    fn draw_pixmap(&self, r: &RectFTrait, pm: &PixmapTrait, sr: &RectFTrait) {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap)(obj_data, obj_r_1, obj_pm_2, obj_sr_3);
        }
    }
    ///
    /// This function draws the text item *textItem* at position *p.* The
    /// default implementation of this function converts the text to a
    /// QPainterPath and paints the resulting path.
    ///
    /// Reimplement this function to draw the *pixmap* in the given *rect,* starting at the given *p.* The pixmap will be
    /// drawn repeatedly until the *rect* is filled.
    fn draw_tiled_pixmap(&self, r: &RectFTrait, pixmap: &PixmapTrait, s: &PointFTrait) {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_pixmap_2, _funcs) = pixmap.get_pixmap_obj_funcs();
        let (obj_s_3, _funcs) = s.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_tiled_pixmap)(obj_data, obj_r_1, obj_pixmap_2, obj_s_3);
        }
    }
    ///
    /// &image, const QRectF &sr, Qt::ImageConversionFlags flags)
    ///
    /// Reimplement this function to draw the part of the *image*
    /// specified by the *sr* rectangle in the given *rectangle* using
    /// the given conversion flags *flags,* to convert it to a pixmap.
    fn draw_image(
        &self,
        r: &RectFTrait,
        pm: &ImageTrait,
        sr: &RectFTrait,
        flags: ImageConversionFlags,
    ) {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_image_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_f_obj_funcs();
        let enum_flags_4 = flags as i32;

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).draw_image)(obj_data, obj_r_1, obj_pm_2, obj_sr_3, enum_flags_4);
        }
    }
    fn set_paint_device(&self, device: &PaintDeviceTrait) {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_paint_device)(obj_data, obj_device_1);
        }
    }
    ///
    /// Returns the device that this engine is painting on, if painting is
    /// active; otherwise returns 0.
    fn paint_device(&self) -> Option<PaintDevice> {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_device)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintDevice::new_from_rc(t);
            } else {
                ret_val = PaintDevice::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    fn set_system_clip(&self, base_clip: &RegionTrait) {
        let (obj_base_clip_1, _funcs) = base_clip.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_system_clip)(obj_data, obj_base_clip_1);
        }
    }
    fn system_clip(&self) -> Region {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).system_clip)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    fn set_system_rect(&self, rect: &RectTrait) {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            ((*funcs).set_system_rect)(obj_data, obj_rect_1);
        }
    }
    fn system_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).system_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    fn coordinate_offset(&self) -> Point {
        let (obj_data, funcs) = self.get_paint_engine_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).coordinate_offset)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }

    #[inline]
    fn get_paint_engine_obj_funcs(&self) -> (*const RUBase, *const RUPaintEngineFuncs);
}

impl<'a> PaintEngineTrait<'a> for PaintEngine<'a> {
    #[inline]
    fn get_paint_engine_obj_funcs(&self) -> (*const RUBase, *const RUPaintEngineFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).paint_engine_funcs) }
    }
}
#[repr(u32)]
pub enum PaintEngineFeature {
    PrimitiveTransform,
    PatternTransform,
    PixmapTransform,
    PatternBrush,
    LinearGradientFill,
    RadialGradientFill,
    ConicalGradientFill,
    AlphaBlend,
    PorterDuff,
    PainterPaths,
    Antialiasing,
    BrushStroke,
    ConstantOpacity,
    MaskedBrush,
    PerspectiveTransform,
    BlendModes,
    ObjectBoundingModeGradients,
    RasterOpModes,
    PaintOutsidePaintEvent,
    AllFeatures,
}

#[repr(u32)]
pub enum DirtyFlag {
    DirtyPen,
    DirtyBrush,
    DirtyBrushOrigin,
    DirtyFont,
    DirtyBackground,
    DirtyBackgroundMode,
    DirtyTransform,
    DirtyClipRegion,
    DirtyClipPath,
    DirtyHints,
    DirtyCompositionMode,
    DirtyClipEnabled,
    DirtyOpacity,
    AllDirty,
}

pub type DirtyFlags = DirtyFlag;

#[repr(u32)]
pub enum PolygonDrawMode {
    OddEvenMode,
    WindingMode,
    ConvexMode,
    PolylineMode,
}

#[repr(u32)]
pub enum Type {
    X11,
    Windows,
    QuickDraw,
    CoreGraphics,
    MacPrinter,
    QWindowSystem,
    PostScript,
    OpenGl,
    Picture,
    Svg,
    Raster,
    Direct3D,
    Pdf,
    OpenVg,
    OpenGL2,
    PaintBuffer,
    Blitter,
    Direct2D,
    User,
    MaxUser,
}
