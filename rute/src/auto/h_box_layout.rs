// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// This class is used to construct horizontal box layout objects. See
/// QBoxLayout for details.
///
/// The simplest use of the class is like this:
///
/// First, we create the widgets we want in the layout. Then, we
/// create the QHBoxLayout object and add the widgets into the
/// layout. Finally, we call QWidget::setLayout() to install the
/// QHBoxLayout object onto the widget. At that point, the widgets in
/// the layout are reparented to have `window` as their parent.
///
/// ![Horizontal box layout with five child widgets](qhboxlayout-with-5-children.png)
///
/// **See also:** [`VBoxLayout`]
/// [`GridLayout`]
/// [`StackedLayout`]
/// {Layout Management}
/// {Basic Layouts Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct HBoxLayout<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUHBoxLayoutAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> HBoxLayout<'a> {
    pub fn new() -> HBoxLayout<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_h_box_layout)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        HBoxLayout {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUHBoxLayout) -> HBoxLayout<'a> {
        HBoxLayout {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUHBoxLayout) -> HBoxLayout<'a> {
        HBoxLayout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUHBoxLayout) -> HBoxLayout<'a> {
        HBoxLayout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    #[doc(hidden)]
    pub fn direction(&self) -> Direction {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).direction)(obj_data);
            let ret_val = Direction::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_direction(&self, arg0: Direction) -> &Self {
        let enum_arg0_1 = arg0.bits();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).set_direction)(obj_data, enum_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_spacing(&self, size: i32) -> &Self {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_spacing)(obj_data, size);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_spacer_item<S: SpacerItemTrait<'a>>(&self, spacer_item: &S) -> &Self {
        let (obj_spacer_item_1, _funcs) = spacer_item.get_spacer_item_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_spacer_item)(obj_data, obj_spacer_item_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_widget<W: WidgetTrait<'a>>(
        &self,
        arg0: &W,
        stretch: i32,
        alignment: Alignment,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let enum_alignment_3 = alignment.bits();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_widget)(obj_data, obj_arg0_1, stretch, enum_alignment_3);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_layout<L: LayoutTrait<'a>>(&self, layout: &L, stretch: i32) -> &Self {
        let (obj_layout_1, _funcs) = layout.get_layout_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_layout)(obj_data, obj_layout_1, stretch);
        }
        self
    }
    #[doc(hidden)]
    pub fn insert_spacing(&self, index: i32, size: i32) -> &Self {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_spacing)(obj_data, index, size);
        }
        self
    }
    #[doc(hidden)]
    pub fn insert_widget<W: WidgetTrait<'a>>(
        &self,
        index: i32,
        widget: &W,
        stretch: i32,
        alignment: Alignment,
    ) -> &Self {
        let (obj_widget_2, _funcs) = widget.get_widget_obj_funcs();
        let enum_alignment_4 = alignment.bits();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_widget)(obj_data, index, obj_widget_2, stretch, enum_alignment_4);
        }
        self
    }
    #[doc(hidden)]
    pub fn insert_layout<L: LayoutTrait<'a>>(&self, index: i32, layout: &L, stretch: i32) -> &Self {
        let (obj_layout_2, _funcs) = layout.get_layout_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_layout)(obj_data, index, obj_layout_2, stretch);
        }
        self
    }
    #[doc(hidden)]
    pub fn insert_item<L: LayoutItemTrait<'a>>(&self, index: i32, arg0: &L) -> &Self {
        let (obj_arg0_2, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_item)(obj_data, index, obj_arg0_2);
        }
        self
    }
    #[doc(hidden)]
    pub fn spacing(&self) -> i32 {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacing)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_spacing(&self, spacing: i32) -> &Self {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).set_spacing)(obj_data, spacing);
        }
        self
    }
    #[doc(hidden)]
    pub fn margin(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).margin)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_margin(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_margin)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins(&self, left: i32, top: i32, right: i32, bottom: i32) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins)(obj_data, left, top, right, bottom);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins_2<M: MarginsTrait<'a>>(&self, margins: &M) -> &Self {
        let (obj_margins_1, _funcs) = margins.get_margins_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins_2)(obj_data, obj_margins_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn contents_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn contents_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_alignment<W: WidgetTrait<'a>>(&self, w: &W, alignment: Alignment) -> bool {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();
        let enum_alignment_2 = alignment.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment)(obj_data, obj_w_1, enum_alignment_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_alignment_2<L: LayoutTrait<'a>>(&self, l: &L, alignment: Alignment) -> bool {
        let (obj_l_1, _funcs) = l.get_layout_obj_funcs();
        let enum_alignment_2 = alignment.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment_2)(obj_data, obj_l_1, enum_alignment_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_menu_bar<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_menu_bar)(obj_data, obj_w_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn menu_bar(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).menu_bar)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn parent_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn invalidate(&self) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).invalidate)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn activate(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).activate)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn update(&self) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).update)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_item<L: LayoutItemTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).add_item)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn remove_widget<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_widget)(obj_data, obj_w_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn remove_item<L: LayoutItemTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_item)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn expanding_directions(&self) -> Orientations {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).expanding_directions)(obj_data);
            let ret_val = Orientations::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn item_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn take_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).take_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn index_of<W: WidgetTrait<'a>>(&self, arg0: &W) -> i32 {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).index_of)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn count(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).count)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_empty(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_empty)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn replace_widget<W: WidgetTrait<'a>>(
        &self,
        from: &W,
        to: &W,
        options: FindChildOptions,
    ) -> Option<LayoutItem> {
        let (obj_from_1, _funcs) = from.get_widget_obj_funcs();
        let (obj_to_2, _funcs) = to.get_widget_obj_funcs();
        let enum_options_3 = options.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).replace_widget)(obj_data, obj_from_1, obj_to_2, enum_options_3);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn total_height_for_width(&self, w: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_height_for_width)(obj_data, w);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn layout(&self) -> Option<Layout> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Layout::new_from_rc(t);
            } else {
                ret_val = Layout::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_size_constraint(&self, constraint: SizeConstraint) -> &Self {
        let enum_constraint_1 = constraint as u32;

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_size_constraint)(obj_data, enum_constraint_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn size_constraint(&self) -> SizeConstraint {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_constraint)(obj_data);
            let ret_val = { transmute::<u32, SizeConstraint>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_enabled(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_enabled)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_enabled)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn has_height_for_width(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_height_for_width)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn spacer_item(&self) -> Option<SpacerItem> {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacer_item)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = SpacerItem::new_from_rc(t);
            } else {
                ret_val = SpacerItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn alignment(&self) -> Alignment {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alignment)(obj_data);
            let ret_val = Alignment::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<WrapperRcOwn> for HBoxLayout<'a> {
    fn from(t: WrapperRcOwn) -> Self {
        let mut data = RUHBoxLayout {
            qt_data: ::std::ptr::null(),
            host_data: ::std::ptr::null(),
            all_funcs: t.all_funcs as *const RUHBoxLayoutAllFuncs,
        };

        if t.owned {
            data.host_data = t.data as *const RUBase;
            HBoxLayout::new_from_rc(data)
        } else {
            data.qt_data = t.data as *const RUBase;
            HBoxLayout::new_from_temporary(data)
        }
    }
}

pub trait HBoxLayoutTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_h_box_layout_obj_funcs(&self) -> (*const RUBase, *const RUHBoxLayoutFuncs);
}

impl<'a> ObjectTrait<'a> for HBoxLayout<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> LayoutItemTrait<'a> for HBoxLayout<'a> {
    #[doc(hidden)]
    fn get_layout_item_obj_funcs(&self) -> (*const RUBase, *const RULayoutItemFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_item_funcs) }
    }
}

impl<'a> LayoutTrait<'a> for HBoxLayout<'a> {
    #[doc(hidden)]
    fn get_layout_obj_funcs(&self) -> (*const RUBase, *const RULayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_funcs) }
    }
}

impl<'a> BoxLayoutTrait<'a> for HBoxLayout<'a> {
    #[doc(hidden)]
    fn get_box_layout_obj_funcs(&self) -> (*const RUBase, *const RUBoxLayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).box_layout_funcs) }
    }
}

impl<'a> HBoxLayoutTrait<'a> for HBoxLayout<'a> {
    #[doc(hidden)]
    fn get_h_box_layout_obj_funcs(&self) -> (*const RUBase, *const RUHBoxLayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).h_box_layout_funcs) }
    }
}
