// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

pub(crate) unsafe extern "C" fn grid_layout_has_height_for_width_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
) -> bool {
    let f: &&(Fn(&T) -> bool + 'static) = transmute(func);

    let data = self_c as *const T;
    let ret_val = f(&*data);
    ret_val
}

#[allow(unused_variables)]
pub(crate) unsafe extern "C" fn grid_layout_has_height_for_width_trampoline(
    self_c: *const c_void,
    func: *const c_void,
) -> bool {
    let f: &&(Fn() -> bool + 'static) = transmute(func);

    let ret_val = f();
    ret_val
}

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// QGridLayout takes the space made available to it (by its parent
/// layout or by the parentWidget()), divides it up into rows and
/// columns, and puts each widget it manages into the correct cell.
///
/// Columns and rows behave identically; we will discuss columns, but
/// there are equivalent functions for rows.
///
/// Each column has a minimum width and a stretch factor. The minimum
/// width is the greatest of that set using setColumnMinimumWidth() and the
/// minimum width of each widget in that column. The stretch factor is
/// set using setColumnStretch() and determines how much of the available
/// space the column will get over and above its necessary minimum.
///
/// Normally, each managed widget or layout is put into a cell of its
/// own using addWidget(). It is also possible for a widget to occupy
/// multiple cells using the row and column spanning overloads of
/// addItem() and addWidget(). If you do this, QGridLayout will guess
/// how to distribute the size over the columns/rows (based on the
/// stretch factors).
///
/// To remove a widget from a layout, call removeWidget(). Calling
/// QWidget::hide() on a widget also effectively removes the widget
/// from the layout until QWidget::show() is called.
///
/// This illustration shows a fragment of a dialog with a five-column,
/// three-row grid (the grid is shown overlaid in magenta):
///
/// ![A grid layout](gridlayout.png)
///
/// Columns 0, 2 and 4 in this dialog fragment are made up of a
/// QLabel, a QLineEdit, and a QListBox. Columns 1 and 3 are
/// placeholders made with setColumnMinimumWidth(). Row 0 consists of three
/// QLabel objects, row 1 of three QLineEdit objects and row 2 of
/// three QListBox objects. We used placeholder columns (1 and 3) to
/// get the right amount of space between the columns.
///
/// Note that the columns and rows are not equally wide or tall. If
/// you want two columns to have the same width, you must set their
/// minimum widths and stretch factors to be the same yourself. You do
/// this using setColumnMinimumWidth() and setColumnStretch().
///
/// If the QGridLayout is not the top-level layout (i.e. does not
/// manage all of the widget's area and children), you must add it to
/// its parent layout when you create it, but before you do anything
/// with it. The normal way to add a layout is by calling
/// addLayout() on the parent layout.
///
/// Once you have added your layout you can start putting widgets and
/// other layouts into the cells of your grid layout using
/// addWidget(), addItem(), and addLayout().
///
/// QGridLayout also includes two margin widths:
/// the [contents margin](getContentsMargins())
/// and the spacing().
/// The contents margin is the width of the reserved space along each
/// of the QGridLayout's four sides. The spacing() is the width of the
/// automatically allocated spacing between neighboring boxes.
///
/// The default contents margin values are provided by the
/// [style](QStyle::pixelMetric())
/// . The default value Qt styles specify
/// is 9 for child widgets and 11 for windows. The spacing defaults to the same as
/// the margin width for a top-level layout, or to the same as the
/// parent layout.
///
/// **See also:** [`BoxLayout`]
/// [`StackedLayout`]
/// {Layout Management}
/// {Basic Layouts Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct GridLayout<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUGridLayoutAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> GridLayout<'a> {
    pub fn new() -> GridLayout<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_grid_layout)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        GridLayout {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUGridLayout) -> GridLayout<'a> {
        let data =
            unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) };
        let t = GridLayout {
            data: data.clone(),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        };

        // this is to allow us to clone inside instead of the outside in iterators and such
        // as this is always used in that context
        ::std::mem::forget(data);

        t
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUGridLayout) -> GridLayout<'a> {
        GridLayout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUGridLayout) -> GridLayout<'a> {
        GridLayout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    pub fn set_horizontal_spacing(&self, spacing: i32) -> &Self {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_horizontal_spacing)(obj_data, spacing);
        }
        self
    }
    ///
    /// If no value is explicitly set, the layout's horizontal spacing is
    /// inherited from the parent layout, or from the style settings for
    /// the parent widget.
    ///
    /// **See also:** verticalSpacing
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutHorizontalSpacing}
    pub fn horizontal_spacing(&self) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).horizontal_spacing)(obj_data);
            ret_val
        }
    }
    pub fn set_vertical_spacing(&self, spacing: i32) -> &Self {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_vertical_spacing)(obj_data, spacing);
        }
        self
    }
    ///
    /// If no value is explicitly set, the layout's vertical spacing is
    /// inherited from the parent layout, or from the style settings for
    /// the parent widget.
    ///
    /// **See also:** horizontalSpacing
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutHorizontalSpacing}
    pub fn vertical_spacing(&self) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).vertical_spacing)(obj_data);
            ret_val
        }
    }
    ///
    /// This function sets both the vertical and horizontal spacing to
    /// *spacing.*
    ///
    /// **See also:** [`set_vertical_spacing()`]
    /// [`set_horizontal_spacing()`]
    pub fn set_spacing(&self, spacing: i32) -> &Self {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_spacing)(obj_data, spacing);
        }
        self
    }
    ///
    /// If the vertical spacing is equal to the horizontal spacing,
    /// this function returns that value; otherwise it return -1.
    ///
    /// **See also:** [`set_spacing()`]
    /// [`vertical_spacing()`]
    /// [`horizontal_spacing()`]
    pub fn spacing(&self) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacing)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the minimum height of row *row* to *minSize* pixels.
    ///
    /// **See also:** [`row_minimum_height()`]
    /// [`set_column_minimum_width()`]
    pub fn set_row_minimum_height(&self, row: i32, min_size: i32) -> &Self {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_row_minimum_height)(obj_data, row, min_size);
        }
        self
    }
    ///
    /// Sets the minimum width of column *column* to *minSize* pixels.
    ///
    /// **See also:** [`column_minimum_width()`]
    /// [`set_row_minimum_height()`]
    pub fn set_column_minimum_width(&self, column: i32, min_size: i32) -> &Self {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_column_minimum_width)(obj_data, column, min_size);
        }
        self
    }
    ///
    /// Returns the minimum width set for row *row.*
    ///
    /// **See also:** [`set_row_minimum_height()`]
    pub fn row_minimum_height(&self, row: i32) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).row_minimum_height)(obj_data, row);
            ret_val
        }
    }
    ///
    /// Returns the column spacing for column *column.*
    ///
    /// **See also:** [`set_column_minimum_width()`]
    pub fn column_minimum_width(&self, column: i32) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).column_minimum_width)(obj_data, column);
            ret_val
        }
    }
    ///
    /// Returns the number of columns in this grid.
    pub fn column_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).column_count)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the number of rows in this grid.
    pub fn row_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).row_count)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the geometry of the cell with row *row* and column *column*
    /// in the grid. Returns an invalid rectangle if *row* or *column* is
    /// outside the grid.
    ///
    /// **Warning**: in the current version of Qt this function does not
    /// return valid results until setGeometry() has been called, i.e.
    /// after the parentWidget() is visible.
    pub fn cell_rect(&self, row: i32, column: i32) -> Rect {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cell_rect)(obj_data, row, column);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    pub fn set_has_height_for_width_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T) -> bool + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();

        let f: Box<Box<Fn(&T) -> bool + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_has_height_for_width_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(grid_layout_has_height_for_width_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_has_height_for_width_event<F>(&self, func: F) -> &Self
    where
        F: Fn() -> bool + 'a,
    {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        let f: Box<Box<Fn() -> bool + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_has_height_for_width_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(grid_layout_has_height_for_width_trampoline as usize),
            );
        }

        self
    }
    ///
    /// Adds the given *widget* to the cell grid at *row,* *column.* The
    /// top-left position is (0, 0) by default.
    ///
    /// The alignment is specified by *alignment.* The default
    /// alignment is 0, which means that the widget fills the entire cell.
    ///
    ///
    /// **Overloads**
    /// This version adds the given *widget* to the cell grid, spanning
    /// multiple rows/columns. The cell will start at *fromRow,* *fromColumn* spanning *rowSpan* rows and *columnSpan* columns. The
    /// *widget* will have the given *alignment.*
    ///
    /// If *rowSpan* and/or *columnSpan* is -1, then the widget will
    /// extend to the bottom and/or right edge, respectively.
    ///
    pub fn add_widget<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).add_widget)(obj_data, obj_w_1);
        }
        self
    }
    ///
    /// Adds the given *widget* to the cell grid at *row,* *column.* The
    /// top-left position is (0, 0) by default.
    ///
    /// The alignment is specified by *alignment.* The default
    /// alignment is 0, which means that the widget fills the entire cell.
    ///
    ///
    /// **Overloads**
    /// This version adds the given *widget* to the cell grid, spanning
    /// multiple rows/columns. The cell will start at *fromRow,* *fromColumn* spanning *rowSpan* rows and *columnSpan* columns. The
    /// *widget* will have the given *alignment.*
    ///
    /// If *rowSpan* and/or *columnSpan* is -1, then the widget will
    /// extend to the bottom and/or right edge, respectively.
    ///
    pub fn add_widget_row_column<W: WidgetTrait<'a>>(
        &self,
        arg0: &W,
        row: i32,
        column: i32,
        arg1: Alignment,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let enum_arg1_4 = arg1.bits();

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).add_widget_row_column)(obj_data, obj_arg0_1, row, column, enum_arg1_4);
        }
        self
    }
    ///
    /// Adds the given *widget* to the cell grid at *row,* *column.* The
    /// top-left position is (0, 0) by default.
    ///
    /// The alignment is specified by *alignment.* The default
    /// alignment is 0, which means that the widget fills the entire cell.
    ///
    ///
    /// **Overloads**
    /// This version adds the given *widget* to the cell grid, spanning
    /// multiple rows/columns. The cell will start at *fromRow,* *fromColumn* spanning *rowSpan* rows and *columnSpan* columns. The
    /// *widget* will have the given *alignment.*
    ///
    /// If *rowSpan* and/or *columnSpan* is -1, then the widget will
    /// extend to the bottom and/or right edge, respectively.
    ///
    pub fn add_widget_row_column_span<W: WidgetTrait<'a>>(
        &self,
        arg0: &W,
        row: i32,
        column: i32,
        row_span: i32,
        column_span: i32,
        arg1: Alignment,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let enum_arg1_6 = arg1.bits();

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).add_widget_row_column_span)(
                obj_data,
                obj_arg0_1,
                row,
                column,
                row_span,
                column_span,
                enum_arg1_6,
            );
        }
        self
    }
    ///
    /// Places the *layout* at position ( *row,* *column)* in the grid. The
    /// top-left position is (0, 0).
    ///
    /// The alignment is specified by *alignment.* The default
    /// alignment is 0, which means that the widget fills the entire cell.
    ///
    /// A non-zero alignment indicates that the layout should not grow to
    /// fill the available space but should be sized according to
    /// sizeHint().
    ///
    /// *layout* becomes a child of the grid layout.
    ///
    /// **Overloads**  This version adds the layout *layout* to the cell grid, spanning multiple
    /// rows/columns. The cell will start at *row,* *column* spanning *rowSpan* rows and *columnSpan* columns.
    ///
    /// If *rowSpan* and/or *columnSpan* is -1, then the layout will extend to the bottom
    /// and/or right edge, respectively.
    pub fn add_layout<L: LayoutTrait<'a>>(
        &self,
        arg0: &L,
        row: i32,
        column: i32,
        arg1: Alignment,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_obj_funcs();
        let enum_arg1_4 = arg1.bits();

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).add_layout)(obj_data, obj_arg0_1, row, column, enum_arg1_4);
        }
        self
    }
    ///
    /// Places the *layout* at position ( *row,* *column)* in the grid. The
    /// top-left position is (0, 0).
    ///
    /// The alignment is specified by *alignment.* The default
    /// alignment is 0, which means that the widget fills the entire cell.
    ///
    /// A non-zero alignment indicates that the layout should not grow to
    /// fill the available space but should be sized according to
    /// sizeHint().
    ///
    /// *layout* becomes a child of the grid layout.
    ///
    /// **Overloads**  This version adds the layout *layout* to the cell grid, spanning multiple
    /// rows/columns. The cell will start at *row,* *column* spanning *rowSpan* rows and *columnSpan* columns.
    ///
    /// If *rowSpan* and/or *columnSpan* is -1, then the layout will extend to the bottom
    /// and/or right edge, respectively.
    pub fn add_layout_2<L: LayoutTrait<'a>>(
        &self,
        arg0: &L,
        row: i32,
        column: i32,
        row_span: i32,
        column_span: i32,
        arg1: Alignment,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_obj_funcs();
        let enum_arg1_6 = arg1.bits();

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).add_layout_2)(
                obj_data,
                obj_arg0_1,
                row,
                column,
                row_span,
                column_span,
                enum_arg1_6,
            );
        }
        self
    }
    ///
    /// Sets the grid's origin corner, i.e. position (0, 0), to *corner.*
    pub fn set_origin_corner(&self, arg0: Corner) -> &Self {
        let enum_arg0_1 = arg0 as u32;

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_origin_corner)(obj_data, enum_arg0_1);
        }
        self
    }
    ///
    /// Returns the corner that's used for the grid's origin, i.e. for
    /// position (0, 0).
    pub fn origin_corner(&self) -> Corner {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).origin_corner)(obj_data);
            let ret_val = { transmute::<u32, Corner>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the layout item that occupies cell ( *row,* *column),* or 0 if
    /// the cell is empty.
    ///
    /// **See also:** [`get_item_position()`]
    /// [`index_of()`]
    pub fn item_at_position(&self, row: i32, column: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_at_position)(obj_data, row, column);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    pub fn count(&self) -> i32 {
        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).count)(obj_data);
            ret_val
        }
    }
    pub fn set_default_positioning(&self, n: i32, orient: Orientation) -> &Self {
        let enum_orient_2 = orient as u32;

        let (obj_data, funcs) = self.get_grid_layout_obj_funcs();
        unsafe {
            ((*funcs).set_default_positioning)(obj_data, n, enum_orient_2);
        }
        self
    }
    #[doc(hidden)]
    pub fn margin(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).margin)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_margin(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_margin)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins(&self, left: i32, top: i32, right: i32, bottom: i32) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins)(obj_data, left, top, right, bottom);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins_2<M: MarginsTrait<'a>>(&self, margins: &M) -> &Self {
        let (obj_margins_1, _funcs) = margins.get_margins_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins_2)(obj_data, obj_margins_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn contents_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn contents_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_alignment<W: WidgetTrait<'a>>(&self, w: &W, alignment: Alignment) -> bool {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();
        let enum_alignment_2 = alignment.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment)(obj_data, obj_w_1, enum_alignment_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_alignment_2<L: LayoutTrait<'a>>(&self, l: &L, alignment: Alignment) -> bool {
        let (obj_l_1, _funcs) = l.get_layout_obj_funcs();
        let enum_alignment_2 = alignment.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment_2)(obj_data, obj_l_1, enum_alignment_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_menu_bar<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_menu_bar)(obj_data, obj_w_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn menu_bar(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).menu_bar)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn parent_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn invalidate(&self) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).invalidate)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn activate(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).activate)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn update(&self) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).update)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_item<L: LayoutItemTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).add_item)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn remove_widget<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_widget)(obj_data, obj_w_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn remove_item<L: LayoutItemTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_item)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn expanding_directions(&self) -> Orientations {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).expanding_directions)(obj_data);
            let ret_val = Orientations::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn item_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn take_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).take_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn index_of<W: WidgetTrait<'a>>(&self, arg0: &W) -> i32 {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).index_of)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_empty(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_empty)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn replace_widget<W: WidgetTrait<'a>>(
        &self,
        from: &W,
        to: &W,
        options: FindChildOptions,
    ) -> Option<LayoutItem> {
        let (obj_from_1, _funcs) = from.get_widget_obj_funcs();
        let (obj_to_2, _funcs) = to.get_widget_obj_funcs();
        let enum_options_3 = options.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).replace_widget)(obj_data, obj_from_1, obj_to_2, enum_options_3);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn total_height_for_width(&self, w: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_height_for_width)(obj_data, w);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn layout(&self) -> Option<Layout> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Layout::new_from_rc(t);
            } else {
                ret_val = Layout::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_size_constraint(&self, constraint: SizeConstraint) -> &Self {
        let enum_constraint_1 = constraint as u32;

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_size_constraint)(obj_data, enum_constraint_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn size_constraint(&self) -> SizeConstraint {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_constraint)(obj_data);
            let ret_val = { transmute::<u32, SizeConstraint>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_enabled(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_enabled)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_enabled)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn spacer_item(&self) -> Option<SpacerItem> {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacer_item)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = SpacerItem::new_from_rc(t);
            } else {
                ret_val = SpacerItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn alignment(&self) -> Alignment {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alignment)(obj_data);
            let ret_val = Alignment::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<WrapperRcOwn> for GridLayout<'a> {
    fn from(t: WrapperRcOwn) -> Self {
        let mut data = RUGridLayout {
            qt_data: ::std::ptr::null(),
            host_data: ::std::ptr::null(),
            all_funcs: t.all_funcs as *const RUGridLayoutAllFuncs,
        };

        if t.owned {
            data.host_data = t.data as *const RUBase;
            GridLayout::new_from_rc(data)
        } else {
            data.qt_data = t.data as *const RUBase;
            GridLayout::new_from_temporary(data)
        }
    }
}

pub trait GridLayoutTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_grid_layout_obj_funcs(&self) -> (*const RUBase, *const RUGridLayoutFuncs);
}

impl<'a> ObjectTrait<'a> for GridLayout<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> LayoutItemTrait<'a> for GridLayout<'a> {
    #[doc(hidden)]
    fn get_layout_item_obj_funcs(&self) -> (*const RUBase, *const RULayoutItemFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_item_funcs) }
    }
}

impl<'a> LayoutTrait<'a> for GridLayout<'a> {
    #[doc(hidden)]
    fn get_layout_obj_funcs(&self) -> (*const RUBase, *const RULayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_funcs) }
    }
}

impl<'a> GridLayoutTrait<'a> for GridLayout<'a> {
    #[doc(hidden)]
    fn get_grid_layout_obj_funcs(&self) -> (*const RUBase, *const RUGridLayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).grid_layout_funcs) }
    }
}
