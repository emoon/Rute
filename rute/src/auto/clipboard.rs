// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// The clipboard offers a simple mechanism to copy and paste data
/// between applications.
///
/// QClipboard supports the same data types that QDrag does, and uses
/// similar mechanisms. For advanced clipboard usage read [Drag and
/// Drop](Drag%20and%0A%20%20%20%20Drop)
///
///
/// There is a single QClipboard object in an application, accessible
/// as QGuiApplication::clipboard().
///
/// Example:
///
/// QClipboard features some convenience functions to access common
/// data types: setText() allows the exchange of Unicode text and
/// setPixmap() and setImage() allows the exchange of QPixmaps and
/// QImages between applications. The setMimeData() function is the
/// ultimate in flexibility: it allows you to add any QMimeData into
/// the clipboard. There are corresponding getters for each of these,
/// e.g. text(), image() and pixmap(). You can clear the clipboard by
/// calling clear().
///
/// A typical example of the use of these functions follows:
///
/// # Notes for X11 Users
///
/// * The X11 Window System has the concept of a separate selection and clipboard. When text is selected, it is immediately available as the global mouse selection. The global mouse selection may later be copied to the clipboard. By convention, the middle mouse button is used to paste the global mouse selection.
/// * X11 also has the concept of ownership; if you change the selection within a window, X11 will only notify the owner and the previous owner of the change, i.e. it will not notify all applications that the selection or clipboard data changed.
/// * Lastly, the X11 clipboard is event driven, i.e. the clipboard will not function properly if the event loop is not running. Similarly, it is recommended that the contents of the clipboard are stored or retrieved in direct response to user-input events, e.g. mouse button or key presses and releases. You should not store or retrieve the clipboard contents in response to timer or non-user-input events.
/// * Since there is no standard way to copy and paste files between applications on X11, various MIME types and conventions are currently in use. For instance, Nautilus expects files to be supplied with a `x-special/gnome-copied-files` MIME type with data beginning with the cut/copy action, a newline character, and the URL of the file.
///
/// # Notes for \macos Users
///
/// MacOS supports a separate find buffer that holds the current
/// search string in Find operations. This find clipboard can be accessed
/// by specifying the FindBuffer mode.
///
/// # Notes for Windows and \macos Users
///
/// * Windows and MacOS do not support the global mouse selection; they only supports the global clipboard, i.e. they only add text to the clipboard when an explicit copy or cut is made.
/// * Windows and MacOS does not have the concept of ownership; the clipboard is a fully global resource so all applications are notified of changes.
///
/// # Notes for Universal Windows Platform Users
///
/// * The Universal Windows Platform only allows to query the clipboard in case the application is active and an application window has focus. Accessing the clipboard data when in background will fail due to access denial.
///
/// **See also:** [`GuiApplication`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Clipboard<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUClipboardAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Clipboard<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUClipboard) -> Clipboard<'a> {
        Clipboard {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUClipboard) -> Clipboard<'a> {
        Clipboard {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUClipboard) -> Clipboard<'a> {
        Clipboard {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Clear the clipboard contents.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, this
    /// function clears the global clipboard contents. If *mode* is
    /// QClipboard::Selection, this function clears the global mouse
    /// selection contents. If *mode* is QClipboard::FindBuffer, this
    /// function clears the search string buffer.
    ///
    /// **See also:** [`Clipboard::mode()`]
    /// [`supports_selection()`]
    pub fn clear(&self, mode: Mode) -> &Self {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            ((*funcs).clear)(obj_data, enum_mode_1);
        }
        self
    }
    ///
    /// Returns `true` if the clipboard supports mouse selection; otherwise
    /// returns `false.`
    pub fn supports_selection(&self) -> bool {
        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).supports_selection)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if the clipboard supports a separate search buffer; otherwise
    /// returns `false.`
    pub fn supports_find_buffer(&self) -> bool {
        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).supports_find_buffer)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if this clipboard object owns the mouse selection
    /// data; otherwise returns `false.`
    pub fn owns_selection(&self) -> bool {
        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).owns_selection)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if this clipboard object owns the clipboard data;
    /// otherwise returns `false.`
    pub fn owns_clipboard(&self) -> bool {
        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).owns_clipboard)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if this clipboard object owns the find buffer data;
    /// otherwise returns `false.`
    pub fn owns_find_buffer(&self) -> bool {
        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).owns_find_buffer)(obj_data);
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Returns the clipboard text in subtype *subtype,* or an empty string
    /// if the clipboard does not contain any text. If *subtype* is null,
    /// any subtype is acceptable, and *subtype* is set to the chosen
    /// subtype.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// text is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the text is retrieved from the global
    /// mouse selection.
    ///
    /// Common values for *subtype* are and .
    ///
    /// Note that calling this function repeatedly, for instance from a
    /// key event handler, may be slow. In such cases, you should use the
    /// `dataChanged()` signal instead.
    ///
    /// **See also:** [`set_text()`]
    /// [`mime_data()`]
    ///
    /// Returns the clipboard text as plain text, or an empty string if the
    /// clipboard does not contain any text.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// text is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the text is retrieved from the global
    /// mouse selection. If *mode* is QClipboard::FindBuffer, the
    /// text is retrieved from the search string buffer.
    ///
    /// **See also:** [`set_text()`]
    /// [`mime_data()`]
    pub fn text(&self, mode: Mode) -> String {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).text)(obj_data, enum_mode_1);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Returns the clipboard text in subtype *subtype,* or an empty string
    /// if the clipboard does not contain any text. If *subtype* is null,
    /// any subtype is acceptable, and *subtype* is set to the chosen
    /// subtype.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// text is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the text is retrieved from the global
    /// mouse selection.
    ///
    /// Common values for *subtype* are and .
    ///
    /// Note that calling this function repeatedly, for instance from a
    /// key event handler, may be slow. In such cases, you should use the
    /// `dataChanged()` signal instead.
    ///
    /// **See also:** [`set_text()`]
    /// [`mime_data()`]
    ///
    /// Returns the clipboard text as plain text, or an empty string if the
    /// clipboard does not contain any text.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// text is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the text is retrieved from the global
    /// mouse selection. If *mode* is QClipboard::FindBuffer, the
    /// text is retrieved from the search string buffer.
    ///
    /// **See also:** [`set_text()`]
    /// [`mime_data()`]
    ///
    /// Copies *text* into the clipboard as plain text.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// text is stored in the global clipboard. If *mode* is
    /// QClipboard::Selection, the text is stored in the global
    /// mouse selection. If *mode* is QClipboard::FindBuffer, the
    /// text is stored in the search string buffer.
    ///
    /// **See also:** [`text()`]
    /// [`set_mime_data()`]
    pub fn set_text(&self, arg0: &str, mode: Mode) -> &Self {
        let str_in_arg0_1 = CString::new(arg0).unwrap();
        let enum_mode_2 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            ((*funcs).set_text)(obj_data, str_in_arg0_1.as_ptr(), enum_mode_2);
        }
        self
    }
    ///
    /// Returns a pointer to a QMimeData representation of the current
    /// clipboard data (can be NULL if the given *mode* is not
    /// supported by the platform).
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// data is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the data is retrieved from the global
    /// mouse selection. If *mode* is QClipboard::FindBuffer, the
    /// data is retrieved from the search string buffer.
    ///
    /// The text(), image(), and pixmap() functions are simpler
    /// wrappers for retrieving text, image, and pixmap data.
    ///
    /// **Note**: The pointer returned might become invalidated when the contents
    /// of the clipboard changes; either by calling one of the setter functions
    /// or externally by the system clipboard changing.
    ///
    /// **See also:** [`set_mime_data()`]
    pub fn mime_data(&self, mode: Mode) -> Option<MimeData> {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mime_data)(obj_data, enum_mode_1);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = MimeData::new_from_rc(t);
            } else {
                ret_val = MimeData::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the clipboard data to *src.* Ownership of the data is
    /// transferred to the clipboard. If you want to remove the data
    /// either call clear() or call setMimeData() again with new data.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// data is stored in the global clipboard. If *mode* is
    /// QClipboard::Selection, the data is stored in the global
    /// mouse selection. If *mode* is QClipboard::FindBuffer, the
    /// data is stored in the search string buffer.
    ///
    /// The setText(), setImage() and setPixmap() functions are simpler
    /// wrappers for setting text, image and pixmap data respectively.
    ///
    /// **See also:** [`mime_data()`]
    pub fn set_mime_data<M: MimeDataTrait<'a>>(&self, data: &M, mode: Mode) -> &Self {
        let (obj_data_1, _funcs) = data.get_mime_data_obj_funcs();
        let enum_mode_2 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            ((*funcs).set_mime_data)(obj_data, obj_data_1, enum_mode_2);
        }
        self
    }
    ///
    /// Returns the clipboard image, or returns a null image if the
    /// clipboard does not contain an image or if it contains an image in
    /// an unsupported image format.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// image is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the image is retrieved from the global
    /// mouse selection.
    ///
    /// **See also:** [`set_image()`]
    /// [`pixmap()`]
    /// [`mime_data()`]
    /// [`Image::is_null`]
    pub fn image(&self, mode: Mode) -> Image {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).image)(obj_data, enum_mode_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the clipboard pixmap, or null if the clipboard does not
    /// contain a pixmap. Note that this can lose information. For
    /// example, if the image is 24-bit and the display is 8-bit, the
    /// result is converted to 8 bits, and if the image has an alpha
    /// channel, the result just has a mask.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// pixmap is retrieved from the global clipboard. If *mode* is
    /// QClipboard::Selection, the pixmap is retrieved from the global
    /// mouse selection.
    ///
    /// **See also:** [`set_pixmap()`]
    /// [`image()`]
    /// [`mime_data()`]
    /// [`Pixmap::convert_from_image`]
    pub fn pixmap(&self, mode: Mode) -> Pixmap {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixmap)(obj_data, enum_mode_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Copies the *image* into the clipboard.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// image is stored in the global clipboard. If *mode* is
    /// QClipboard::Selection, the data is stored in the global
    /// mouse selection.
    ///
    /// This is shorthand for:
    ///
    /// **See also:** [`image()`]
    /// [`set_pixmap()`]
    /// [`set_mime_data()`]
    pub fn set_image<I: ImageTrait<'a>>(&self, arg0: &I, mode: Mode) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_image_obj_funcs();
        let enum_mode_2 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            ((*funcs).set_image)(obj_data, obj_arg0_1, enum_mode_2);
        }
        self
    }
    ///
    /// Copies *pixmap* into the clipboard. Note that this is slower
    /// than setImage() because it needs to convert the QPixmap to a
    /// QImage first.
    ///
    /// The *mode* argument is used to control which part of the system
    /// clipboard is used. If *mode* is QClipboard::Clipboard, the
    /// pixmap is stored in the global clipboard. If *mode* is
    /// QClipboard::Selection, the pixmap is stored in the global
    /// mouse selection.
    ///
    /// **See also:** [`pixmap()`]
    /// [`set_image()`]
    /// [`set_mime_data()`]
    pub fn set_pixmap<P: PixmapTrait<'a>>(&self, arg0: &P, mode: Mode) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_pixmap_obj_funcs();
        let enum_mode_2 = mode as u32;

        let (obj_data, funcs) = self.get_clipboard_obj_funcs();
        unsafe {
            ((*funcs).set_pixmap)(obj_data, obj_arg0_1, enum_mode_2);
        }
        self
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<(WrapperRcOwn, bool)> for Clipboard<'a> {
    fn from(t: (WrapperRcOwn, bool)) -> Self {
        if t.1 {
            Clipboard::new_from_rc(t.0 as *const RUClipboard)
        } else {
            Clipboard::new_from_temporary(t.0 as *const RUClipboard)
        }
    }
}

pub trait ClipboardTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_clipboard_obj_funcs(&self) -> (*const RUBase, *const RUClipboardFuncs);
}

impl<'a> ObjectTrait<'a> for Clipboard<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> ClipboardTrait<'a> for Clipboard<'a> {
    #[doc(hidden)]
    fn get_clipboard_obj_funcs(&self) -> (*const RUBase, *const RUClipboardFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).clipboard_funcs) }
    }
}
#[repr(u32)]
pub enum Mode {
    Clipboard = 0,
    Selection = 1,
    FindBuffer = 2,
}
