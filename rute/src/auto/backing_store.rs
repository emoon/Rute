// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

///
/// QBackingStore enables the use of QPainter to paint on a QWindow with type
/// RasterSurface. The other way of rendering to a QWindow is through the use
/// of OpenGL with QOpenGLContext.
///
/// A QBackingStore contains a buffered representation of the window contents,
/// and thus supports partial updates by using QPainter to only update a sub
/// region of the window contents.
///
/// QBackingStore might be used by an application that wants to use QPainter
/// without OpenGL acceleration and without the extra overhead of using the
/// QWidget or QGraphicsView UI stacks. For an example of how to use
/// QBackingStore see the [Raster Window Example](Raster%20Window%20Example)
///
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct BackingStore<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUBackingStoreAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> BackingStore<'a> {
    pub fn new() -> BackingStore<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_backing_store)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        BackingStore {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    pub fn new_from_rc(ffi_data: RUBackingStore) -> BackingStore<'a> {
        BackingStore {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUBackingStore) -> BackingStore<'a> {
        BackingStore {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUBackingStore) -> BackingStore<'a> {
        BackingStore {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait BackingStoreType<'a> {
    ///
    /// Returns a pointer to the top-level window associated with this
    /// surface.
    fn window(&self) -> Option<Window> {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the paint device for this surface.
    ///
    /// **Warning**: The device is only valid between calls to beginPaint() and
    /// endPaint(). You should not cache the returned value.
    fn paint_device(&self) -> Option<PaintDevice> {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_device)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintDevice::new_from_rc(t);
            } else {
                ret_val = PaintDevice::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Flushes the given *region* from the specified *window* onto the
    /// screen.
    ///
    /// The *window* must either be the top level window represented by
    /// this backingstore, or a non-transient child of that window. Passing
    /// `nullptr` falls back to using the backingstore's top level window.
    ///
    /// If the *window* is a child window, the *region* should be in child window
    /// coordinates, and the *offset* should be the child window's offset in relation
    /// to the backingstore's top level window.
    ///
    /// You should call this function after ending painting with endPaint().
    ///
    /// **See also:** QWindow::transientParent()
    fn flush<P: PointType<'a>, R: RegionType<'a>, W: WindowType<'a>>(
        &self,
        region: &R,
        window: &W,
        offset: &P,
    ) -> &Self {
        let (obj_region_1, _funcs) = region.get_region_obj_funcs();
        let (obj_window_2, _funcs) = window.get_window_obj_funcs();
        let (obj_offset_3, _funcs) = offset.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).flush)(obj_data, obj_region_1, obj_window_2, obj_offset_3);
        }
        self
    }
    ///
    /// Sets the size of the window surface to *size.*
    ///
    /// **See also:** size()
    fn resize<S: SizeType<'a>>(&self, size: &S) -> &Self {
        let (obj_size_1, _funcs) = size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).resize)(obj_data, obj_size_1);
        }
        self
    }
    ///
    /// Returns the current size of the window surface.
    fn size(&self) -> Size {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Scrolls the given *area* *dx* pixels to the right and *dy*
    /// downward; both *dx* and *dy* may be negative.
    ///
    /// Returns `true` if the area was scrolled successfully; false otherwise.
    fn scroll<R: RegionType<'a>>(&self, area: &R, dx: i32, dy: i32) -> bool {
        let (obj_area_1, _funcs) = area.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scroll)(obj_data, obj_area_1, dx, dy);
            ret_val
        }
    }
    ///
    /// Begins painting on the backing store surface in the given *region.*
    ///
    /// You should call this function before using the paintDevice() to
    /// paint.
    ///
    /// **See also:** endPaint()
    /// paintDevice()
    fn begin_paint<R: RegionType<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).begin_paint)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Ends painting.
    ///
    /// You should call this function after painting with the paintDevice()
    /// has ended.
    ///
    /// **See also:** beginPaint()
    /// paintDevice()
    fn end_paint(&self) -> &Self {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).end_paint)(obj_data);
        }
        self
    }
    ///
    /// Set *region* as the static contents of this window.
    fn set_static_contents<R: RegionType<'a>>(&self, region: &R) -> &Self {
        let (obj_region_1, _funcs) = region.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).set_static_contents)(obj_data, obj_region_1);
        }
        self
    }
    ///
    /// Returns a QRegion representing the area of the window that
    /// has static contents.
    fn static_contents(&self) -> Region {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).static_contents)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a boolean indicating if this window has static contents or not.
    fn has_static_contents(&self) -> bool {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_static_contents)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns a pointer to the QPlatformBackingStore implementation
    fn handle(&self) -> Option<PlatformBackingStore> {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).handle)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PlatformBackingStore::new_from_rc(t);
            } else {
                ret_val = PlatformBackingStore::new_from_owned(t);
            }
            Some(ret_val)
        }
    }

    #[inline]
    fn get_backing_store_obj_funcs(&self) -> (*const RUBase, *const RUBackingStoreFuncs);
}

impl<'a> BackingStoreType<'a> for BackingStore<'a> {
    #[inline]
    fn get_backing_store_obj_funcs(&self) -> (*const RUBase, *const RUBackingStoreFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).backing_store_funcs) }
    }
}
