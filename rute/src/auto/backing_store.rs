// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports

#[allow(unused_imports)]
use auto::backing_store_ffi::*;
#[allow(unused_imports)]
use auto::point::Point;
#[allow(unused_imports)]
use auto::point::PointTrait;
#[allow(unused_imports)]
use auto::point_ffi::*;
#[allow(unused_imports)]
use auto::region::Region;
#[allow(unused_imports)]
use auto::region::RegionTrait;
#[allow(unused_imports)]
use auto::region_ffi::*;
#[allow(unused_imports)]
use auto::rute::*;
#[allow(unused_imports)]
use auto::rute_ffi::*;
#[allow(unused_imports)]
use auto::size::Size;
#[allow(unused_imports)]
use auto::size::SizeTrait;
#[allow(unused_imports)]
use auto::size_ffi::*;
#[allow(unused_imports)]
use auto::window::Window;
#[allow(unused_imports)]
use auto::window::WindowTrait;
#[allow(unused_imports)]
use auto::window_ffi::*;
///
/// QBackingStore enables the use of QPainter to paint on a QWindow with type
/// RasterSurface. The other way of rendering to a QWindow is through the use
/// of OpenGL with QOpenGLContext.
///
/// A QBackingStore contains a buffered representation of the window contents,
/// and thus supports partial updates by using QPainter to only update a sub
/// region of the window contents.
///
/// QBackingStore might be used by an application that wants to use QPainter
/// without OpenGL acceleration and without the extra overhead of using the
/// QWidget or QGraphicsView UI stacks. For an example of how to use
/// QBackingStore see the [Raster Window Example](Raster%20Window%20Example)
///
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct BackingStore<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUBackingStoreAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> BackingStore<'a> {
    pub fn new_from_rc(ffi_data: RUBackingStore) -> BackingStore<'a> {
        BackingStore {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUBackingStore) -> BackingStore<'a> {
        BackingStore {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUBackingStore) -> BackingStore<'a> {
        BackingStore {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait BackingStoreTrait<'a> {
    ///
    /// Returns a pointer to the top-level window associated with this
    /// surface.
    ///
    /// Returns the paint device for this surface.
    ///
    /// **Warning**: The device is only valid between calls to beginPaint() and
    /// endPaint(). You should not cache the returned value.
    ///
    /// Flushes the given *region* from the specified *window* onto the
    /// screen.
    ///
    /// The *window* must either be the top level window represented by
    /// this backingstore, or a non-transient child of that window. Passing
    /// `nullptr` falls back to using the backingstore's top level window.
    ///
    /// If the *window* is a child window, the *region* should be in child window
    /// coordinates, and the *offset* should be the child window's offset in relation
    /// to the backingstore's top level window.
    ///
    /// You should call this function after ending painting with endPaint().
    ///
    /// **See also:** [`Window::transient_parent`]
    fn flush(&self, region: &RegionTrait, window: &WindowTrait, offset: &PointTrait) {
        let (obj_region_1, _funcs) = region.get_region_obj_funcs();
        let (obj_window_2, _funcs) = window.get_window_obj_funcs();
        let (obj_offset_3, _funcs) = offset.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).flush)(obj_data, obj_region_1, obj_window_2, obj_offset_3);
        }
    }
    ///
    /// Sets the size of the window surface to *size.*
    ///
    /// **See also:** [`size()`]
    fn resize(&self, size: &SizeTrait) {
        let (obj_size_1, _funcs) = size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).resize)(obj_data, obj_size_1);
        }
    }
    ///
    /// Returns the current size of the window surface.
    fn size(&self) -> Size {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Scrolls the given *area* *dx* pixels to the right and *dy*
    /// downward; both *dx* and *dy* may be negative.
    ///
    /// Returns `true` if the area was scrolled successfully; false otherwise.
    fn scroll(&self, area: &RegionTrait, dx: i32, dy: i32) -> bool {
        let (obj_area_1, _funcs) = area.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scroll)(obj_data, obj_area_1, dx, dy);
            ret_val
        }
    }
    ///
    /// Begins painting on the backing store surface in the given *region.*
    ///
    /// You should call this function before using the paintDevice() to
    /// paint.
    ///
    /// **See also:** [`end_paint()`]
    /// [`paint_device()`]
    fn begin_paint(&self, arg0: &RegionTrait) {
        let (obj_arg0_1, _funcs) = arg0.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).begin_paint)(obj_data, obj_arg0_1);
        }
    }
    ///
    /// Ends painting.
    ///
    /// You should call this function after painting with the paintDevice()
    /// has ended.
    ///
    /// **See also:** [`begin_paint()`]
    /// [`paint_device()`]
    fn end_paint(&self) {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).end_paint)(obj_data);
        }
    }
    ///
    /// Set *region* as the static contents of this window.
    fn set_static_contents(&self, region: &RegionTrait) {
        let (obj_region_1, _funcs) = region.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            ((*funcs).set_static_contents)(obj_data, obj_region_1);
        }
    }
    ///
    /// Returns a QRegion representing the area of the window that
    /// has static contents.
    fn static_contents(&self) -> Region {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).static_contents)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a boolean indicating if this window has static contents or not.
    fn has_static_contents(&self) -> bool {
        let (obj_data, funcs) = self.get_backing_store_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_static_contents)(obj_data);
            ret_val
        }
    }

    #[inline]
    fn get_backing_store_obj_funcs(&self) -> (*const RUBase, *const RUBackingStoreFuncs);
}

impl<'a> BackingStoreTrait<'a> for BackingStore<'a> {
    #[inline]
    fn get_backing_store_obj_funcs(&self) -> (*const RUBase, *const RUBackingStoreFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).backing_store_funcs) }
    }
}
