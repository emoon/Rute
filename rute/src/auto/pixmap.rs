// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports
use auto::*;

///
/// Qt provides four classes for handling image data: QImage, QPixmap,
/// QBitmap and QPicture. QImage is designed and optimized for I/O,
/// and for direct pixel access and manipulation, while QPixmap is
/// designed and optimized for showing images on screen. QBitmap is
/// only a convenience class that inherits QPixmap, ensuring a depth
/// of 1. The isQBitmap() function returns `true` if a QPixmap object is
/// really a bitmap, otherwise returns `false.` Finally, the QPicture class
/// is a paint device that records and replays QPainter commands.
///
/// A QPixmap can easily be displayed on the screen using QLabel or
/// one of QAbstractButton's subclasses (such as QPushButton and
/// QToolButton). QLabel has a pixmap property, whereas
/// QAbstractButton has an icon property.
///
/// QPixmap objects can be passed around by value since the QPixmap
/// class uses implicit data sharing. For more information, see the [Implicit Data Sharing](Implicit%20Data%20Sharing)
/// documentation. QPixmap objects can also be
/// streamed.
///
/// Note that the pixel data in a pixmap is internal and is managed by
/// the underlying window system. Because QPixmap is a QPaintDevice
/// subclass, QPainter can be used to draw directly onto pixmaps.
/// Pixels can only be accessed through QPainter functions or by
/// converting the QPixmap to a QImage. However, the fill() function
/// is available for initializing the entire pixmap with a given color.
///
/// There are functions to convert between QImage and
/// QPixmap. Typically, the QImage class is used to load an image
/// file, optionally manipulating the image data, before the QImage
/// object is converted into a QPixmap to be shown on
/// screen. Alternatively, if no manipulation is desired, the image
/// file can be loaded directly into a QPixmap.
///
/// QPixmap provides a collection of functions that can be used to
/// obtain a variety of information about the pixmap. In addition,
/// there are several functions that enables transformation of the
/// pixmap.
///
/// # Reading and Writing Image Files
///
/// QPixmap provides several ways of reading an image file: The file
/// can be loaded when constructing the QPixmap object, or by using
/// the load() or loadFromData() functions later on. When loading an
/// image, the file name can either refer to an actual file on disk or
/// to one of the application's embedded resources. See [The Qt
/// Resource System](The%20Qt%0A%20%20%20%20Resource%20System)
/// overview for details on how to embed images and
/// other resource files in the application's executable.
///
/// Simply call the save() function to save a QPixmap object.
///
/// The complete list of supported file formats are available through
/// the QImageReader::supportedImageFormats() and
/// QImageWriter::supportedImageFormats() functions. New file formats
/// can be added as plugins. By default, Qt supports the following
/// formats:
///
/// * Format
/// * Description
/// * Qt's support
/// * BMP
/// * Windows Bitmap
/// * Read/write
/// * GIF
/// * Graphic Interchange Format (optional)
/// * Read
/// * JPG
/// * Joint Photographic Experts Group
/// * Read/write
/// * JPEG
/// * Joint Photographic Experts Group
/// * Read/write
/// * PNG
/// * Portable Network Graphics
/// * Read/write
/// * PBM
/// * Portable Bitmap
/// * Read
/// * PGM
/// * Portable Graymap
/// * Read
/// * PPM
/// * Portable Pixmap
/// * Read/write
/// * XBM
/// * X11 Bitmap
/// * Read/write
/// * XPM
/// * X11 Pixmap
/// * Read/write
///
/// # Pixmap Information
///
/// QPixmap provides a collection of functions that can be used to
/// obtain a variety of information about the pixmap:
///
///
/// * Available Functions
///
/// * Geometry
/// * The size(), width() and height() functions provide information about the pixmap's size. The rect() function returns the image's enclosing rectangle.
///
/// * Alpha component
/// * The hasAlphaChannel() returns `true` if the pixmap has a format that respects the alpha channel, otherwise returns `false.` The hasAlpha(), setMask() and mask() functions are legacy and should not be used. They are potentially very slow. The createHeuristicMask() function creates and returns a 1-bpp heuristic mask (i.e. a QBitmap) for this pixmap. It works by selecting a color from one of the corners and then chipping away pixels of that color, starting at all the edges. The createMaskFromColor() function creates and returns a mask (i.e. a QBitmap) for the pixmap based on a given color.
///
/// * Low-level information
/// * The depth() function returns the depth of the pixmap. The defaultDepth() function returns the default depth, i.e. the depth used by the application on the given screen. The cacheKey() function returns a number that uniquely identifies the contents of the QPixmap object. The x11Info() function returns information about the configuration of the X display used by the screen to which the pixmap currently belongs. The x11PictureHandle() function returns the X11 Picture handle of the pixmap for XRender support. Note that the two latter functions are only available on x11.
///
/// # Pixmap Conversion
///
/// A QPixmap object can be converted into a QImage using the
/// toImage() function. Likewise, a QImage can be converted into a
/// QPixmap using the fromImage(). If this is too expensive an
/// operation, you can use QBitmap::fromImage() instead.
///
/// To convert a QPixmap to and from HICON you can use the QtWinExtras
/// functions QtWin::toHICON() and QtWin::fromHICON() respectively.
///
/// # Pixmap Transformations
///
/// QPixmap supports a number of functions for creating a new pixmap
/// that is a transformed version of the original:
///
/// The scaled(), scaledToWidth() and scaledToHeight() functions
/// return scaled copies of the pixmap, while the copy() function
/// creates a QPixmap that is a plain copy of the original one.
///
/// The transformed() function returns a copy of the pixmap that is
/// transformed with the given transformation matrix and
/// transformation mode: Internally, the transformation matrix is
/// adjusted to compensate for unwanted translation,
/// i.e. transformed() returns the smallest pixmap containing all
/// transformed points of the original pixmap. The static trueMatrix()
/// function returns the actual matrix used for transforming the
/// pixmap.
///
/// **Note**: When using the native X11 graphics system, the pixmap
/// becomes invalid when the QApplication instance is destroyed.
///
/// **See also:** [`Bitmap`]
/// [`Image`]
/// [`ImageReader`]
/// [`ImageWriter`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Pixmap<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUPixmapAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Pixmap<'a> {
    pub fn new() -> Pixmap<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_pixmap)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Pixmap {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUPixmap) -> Pixmap<'a> {
        Pixmap {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUPixmap) -> Pixmap<'a> {
        Pixmap {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUPixmap) -> Pixmap<'a> {
        Pixmap {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Swaps pixmap *other* with this pixmap. This operation is very
    /// fast and never fails.
    pub fn swap<P: PixmapTrait<'a>>(&self, other: &P) -> &Self {
        let (obj_other_1, _funcs) = other.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).swap)(obj_data, obj_other_1);
        }
        self
    }
    ///
    /// Returns `true` if this is a null pixmap; otherwise returns `false.`
    ///
    /// A null pixmap has zero width, zero height and no contents. You
    /// cannot draw in a null pixmap.
    pub fn is_null(&self) -> bool {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_null)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the width of the pixmap.
    ///
    /// **See also:** [`size()`]
    /// {QPixmap#Pixmap Information}{Pixmap Information}
    pub fn width(&self) -> i32 {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).width)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the height of the pixmap.
    ///
    /// **See also:** [`size()`]
    /// {QPixmap#Pixmap Information}{Pixmap Information}
    pub fn height(&self) -> i32 {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the size of the pixmap.
    ///
    /// **See also:** [`width()`]
    /// [`height()`]
    /// {QPixmap#Pixmap Information}{Pixmap
    /// Information}
    pub fn size(&self) -> Size {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the pixmap's enclosing rectangle.
    ///
    /// **See also:** {QPixmap#Pixmap Information}{Pixmap Information}
    pub fn rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the depth of the pixmap.
    ///
    /// The pixmap depth is also called bits per pixel (bpp) or bit planes
    /// of a pixmap. A null pixmap has depth 0.
    ///
    /// **See also:** [`default_depth()`]
    /// {QPixmap#Pixmap Information}{Pixmap
    /// Information}
    pub fn depth(&self) -> i32 {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).depth)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the default pixmap depth used by the application.
    ///
    /// On all platforms the depth of the primary screen will be returned.
    ///
    /// **Note**: QGuiApplication must be created before calling this function.
    ///
    /// **See also:** [`depth()`]
    /// [`Colormap::depth`]
    /// {QPixmap#Pixmap Information}{Pixmap Information}
    ///
    pub fn default_depth() -> i32 {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_pixmap)(::std::ptr::null()).all_funcs).pixmap_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).default_depth)(obj_data);
            ret_val
        }
    }
    ///
    /// Use QPainter or the fill(QColor) overload instead.
    ///
    /// Use QPainter or the fill(QColor) overload instead.
    ///
    /// Fills the pixmap with the given *color.*
    ///
    /// The effect of this function is undefined when the pixmap is
    /// being painted on.
    ///
    /// **See also:** {QPixmap#Pixmap Transformations}{Pixmap Transformations}
    pub fn fill<C: ColorTrait<'a>>(&self, fill_color: &C) -> &Self {
        let (obj_fill_color_1, _funcs) = fill_color.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).fill)(obj_data, obj_fill_color_1);
        }
        self
    }
    ///
    /// Use QPainter or the fill(QColor) overload instead.
    ///
    /// Use QPainter or the fill(QColor) overload instead.
    ///
    /// Fills the pixmap with the given *color.*
    ///
    /// The effect of this function is undefined when the pixmap is
    /// being painted on.
    ///
    /// **See also:** {QPixmap#Pixmap Transformations}{Pixmap Transformations}
    pub fn fill_2<P: PaintDeviceTrait<'a>, Q: PointTrait<'a>>(&self, device: &P, ofs: &Q) -> &Self {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();
        let (obj_ofs_2, _funcs) = ofs.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).fill_2)(obj_data, obj_device_1, obj_ofs_2);
        }
        self
    }
    ///
    /// Use QPainter or the fill(QColor) overload instead.
    ///
    /// Use QPainter or the fill(QColor) overload instead.
    ///
    /// Fills the pixmap with the given *color.*
    ///
    /// The effect of this function is undefined when the pixmap is
    /// being painted on.
    ///
    /// **See also:** {QPixmap#Pixmap Transformations}{Pixmap Transformations}
    pub fn fill_3<P: PaintDeviceTrait<'a>>(&self, device: &P, xofs: i32, yofs: i32) -> &Self {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).fill_3)(obj_data, obj_device_1, xofs, yofs);
        }
        self
    }
    ///
    /// Extracts a bitmap mask from the pixmap's alpha channel.
    ///
    /// **Warning**: This is potentially an expensive operation. The mask of
    /// the pixmap is extracted dynamically from the pixeldata.
    ///
    /// **See also:** [`set_mask()`]
    /// {QPixmap#Pixmap Information}{Pixmap Information}
    pub fn mask(&self) -> Bitmap {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mask)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Bitmap::new_from_rc(t);
            } else {
                ret_val = Bitmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets a mask bitmap.
    ///
    /// This function merges the *mask* with the pixmap's alpha channel. A pixel
    /// value of 1 on the mask means the pixmap's pixel is unchanged; a value of 0
    /// means the pixel is transparent. The mask must have the same size as this
    /// pixmap.
    ///
    /// Setting a null mask resets the mask, leaving the previously transparent
    /// pixels black. The effect of this function is undefined when the pixmap is
    /// being painted on.
    ///
    /// **Warning**: This is potentially an expensive operation.
    ///
    /// **See also:** [`mask()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap Transformations}
    /// [`Bitmap`]
    pub fn set_mask<B: BitmapTrait<'a>>(&self, arg0: &B) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_bitmap_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).set_mask)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Returns the device pixel ratio for the pixmap. This is the
    /// ratio between *device pixels* and *device independent pixels* .
    ///
    /// Use this function when calculating layout geometry based on
    /// the pixmap size: QSize layoutSize = image.size() / image.devicePixelRatio()
    ///
    /// The default value is 1.0.
    ///
    /// **See also:** [`set_device_pixel_ratio()`]
    /// [`ImageReader`]
    pub fn device_pixel_ratio(&self) -> f32 {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the device pixel ratio for the pixmap. This is the
    /// ratio between image pixels and device-independent pixels.
    ///
    /// The default *scaleFactor* is 1.0. Setting it to something else has
    /// two effects:
    ///
    /// QPainters that are opened on the pixmap will be scaled. For
    /// example, painting on a 200x200 image if with a ratio of 2.0
    /// will result in effective (device-independent) painting bounds
    /// of 100x100.
    ///
    /// Code paths in Qt that calculate layout geometry based on the
    /// pixmap size will take the ratio into account:
    /// QSize layoutSize = pixmap.size() / pixmap.devicePixelRatio()
    /// The net effect of this is that the pixmap is displayed as
    /// high-DPI pixmap rather than a large pixmap
    /// (see [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// ).
    ///
    /// **See also:** [`device_pixel_ratio()`]
    pub fn set_device_pixel_ratio(&self, scale_factor: f32) -> &Self {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).set_device_pixel_ratio)(obj_data, scale_factor);
        }
        self
    }
    ///
    /// Returns `true` if this pixmap has an alpha channel, *or* has a
    /// mask, otherwise returns `false.`
    ///
    /// **See also:** [`has_alpha_channel()`]
    /// [`mask()`]
    ///
    /// Returns `true` if the pixmap has a format that respects the alpha
    /// channel, otherwise returns `false.`
    ///
    /// **See also:** [`has_alpha()`]
    pub fn has_alpha(&self) -> bool {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_alpha)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if the pixmap has a format that respects the alpha
    /// channel, otherwise returns `false.`
    ///
    /// **See also:** [`has_alpha()`]
    pub fn has_alpha_channel(&self) -> bool {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_alpha_channel)(obj_data);
            ret_val
        }
    }
    ///
    /// Creates and returns a heuristic mask for this pixmap.
    ///
    /// The function works by selecting a color from one of the corners
    /// and then chipping away pixels of that color, starting at all the
    /// edges. If *clipTight* is true (the default) the mask is just
    /// large enough to cover the pixels; otherwise, the mask is larger
    /// than the data pixels.
    ///
    /// The mask may not be perfect but it should be reasonable, so you
    /// can do things such as the following:
    ///
    /// This function is slow because it involves converting to/from a
    /// QImage, and non-trivial computations.
    ///
    /// **See also:** [`Image::create_heuristic_mask`]
    /// [`create_mask_from_color()`]
    pub fn create_heuristic_mask(&self, clip_tight: bool) -> Bitmap {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).create_heuristic_mask)(obj_data, clip_tight);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Bitmap::new_from_rc(t);
            } else {
                ret_val = Bitmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Creates and returns a mask for this pixmap based on the given *maskColor.* If the *mode* is Qt::MaskInColor, all pixels matching the
    /// maskColor will be transparent. If *mode* is Qt::MaskOutColor, all pixels
    /// matching the maskColor will be opaque.
    ///
    /// This function is slow because it involves converting to/from a
    /// QImage.
    ///
    /// **See also:** [`create_heuristic_mask()`]
    /// [`Image::create_mask_from_color`]
    pub fn create_mask_from_color<C: ColorTrait<'a>>(
        &self,
        mask_color: &C,
        mode: MaskMode,
    ) -> Bitmap {
        let (obj_mask_color_1, _funcs) = mask_color.get_color_obj_funcs();
        let enum_mode_2 = mode as i32;

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val =
                ((*funcs).create_mask_from_color)(obj_data, obj_mask_color_1, enum_mode_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Bitmap::new_from_rc(t);
            } else {
                ret_val = Bitmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// width, int height)
    ///
    /// Creates and returns a pixmap constructed by grabbing the contents
    /// of the given *window* restricted by QRect( *x,* *y,* *width,*
    /// *height).*
    ///
    /// The arguments ( *x* , *y* ) specify the offset in the window,
    /// whereas ( *width* , *height* ) specify the area to be copied. If
    /// *width* is negative, the function copies everything to the right
    /// border of the window. If *height* is negative, the function
    /// copies everything to the bottom of the window.
    ///
    /// The window system identifier ( `WId)` can be retrieved using the
    /// QWidget::winId() function. The rationale for using a window
    /// identifier and not a QWidget, is to enable grabbing of windows
    /// that are not part of the application, window system frames, and so
    /// on.
    ///
    /// The grabWindow() function grabs pixels from the screen, not from
    /// the window, i.e. if there is another window partially or entirely
    /// over the one you grab, you get pixels from the overlying window,
    /// too. The mouse cursor is generally not grabbed.
    ///
    /// Note on X11 that if the given *window* doesn't have the same depth
    /// as the root window, and another window partially or entirely
    /// obscures the one you grab, you will *not* get pixels from the
    /// overlying window. The contents of the obscured areas in the
    /// pixmap will be undefined and uninitialized.
    ///
    /// On Windows Vista and above grabbing a layered window, which is
    /// created by setting the Qt::WA_TranslucentBackground attribute, will
    /// not work. Instead grabbing the desktop widget should work.
    ///
    /// **Warning**: In general, grabbing an area outside the screen is not
    /// safe. This depends on the underlying window system.
    ///
    /// **Warning**: The function is deprecated in Qt 5.0 since there might be
    /// platform plugins in which window system identifiers ( `WId)`
    /// are local to a screen. Use QScreen::grabWindow() instead.
    ///
    /// **See also:** [`grab_widget()`]
    /// {Screenshot Example}
    /// **See also:** [`Screen`]
    pub fn grab_window(arg0: u64, x: i32, y: i32, w: i32, h: i32) -> Pixmap<'a> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_pixmap)(::std::ptr::null()).all_funcs).pixmap_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).grab_window)(obj_data, arg0, x, y, w, h);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Use QWidget::grab() instead.
    ///
    /// Use QWidget::grab() instead.
    pub fn grab_widget<O: ObjectTrait<'a>, R: RectTrait<'a>>(widget: &O, rect: &R) -> Pixmap<'a> {
        let (obj_widget_1, _funcs) = widget.get_object_obj_funcs();
        let (obj_rect_2, _funcs) = rect.get_rect_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_pixmap)(::std::ptr::null()).all_funcs).pixmap_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).grab_widget)(obj_data, obj_widget_1, obj_rect_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Use QWidget::grab() instead.
    ///
    /// Use QWidget::grab() instead.
    pub fn grab_widget_2<O: ObjectTrait<'a>>(
        widget: &O,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
    ) -> Pixmap<'a> {
        let (obj_widget_1, _funcs) = widget.get_object_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_pixmap)(::std::ptr::null()).all_funcs).pixmap_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).grab_widget_2)(obj_data, obj_widget_1, x, y, w, h);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode
    /// transformMode) const
    ///
    /// **Overloads**
    /// Returns a copy of the pixmap scaled to a rectangle with the given
    /// *width* and *height* according to the given *aspectRatioMode* and
    /// *transformMode.*
    ///
    /// If either the *width* or the *height* is zero or negative, this
    /// function returns a null pixmap.
    ///
    /// aspectRatioMode, Qt::TransformationMode transformMode) const
    ///
    /// Scales the pixmap to the given *size,* using the aspect ratio and
    /// transformation modes specified by *aspectRatioMode* and *transformMode.*
    ///
    /// ![qimage-scaling.png](qimage-scaling.png)
    ///
    /// * If *aspectRatioMode* is Qt::IgnoreAspectRatio, the pixmap is scaled to *size.*
    /// * If *aspectRatioMode* is Qt::KeepAspectRatio, the pixmap is scaled to a rectangle as large as possible inside *size,* preserving the aspect ratio.
    /// * If *aspectRatioMode* is Qt::KeepAspectRatioByExpanding, the pixmap is scaled to a rectangle as small as possible outside *size,* preserving the aspect ratio.
    ///
    /// If the given *size* is empty, this function returns a null
    /// pixmap.
    ///
    /// In some cases it can be more beneficial to draw the pixmap to a
    /// painter with a scale set rather than scaling the pixmap. This is
    /// the case when the painter is for instance based on OpenGL or when
    /// the scale factor changes rapidly.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    ///
    ///
    /// mode) const
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *width* using the specified transformation *mode.*
    /// The height of the pixmap is automatically calculated so that the
    /// aspect ratio of the pixmap is preserved.
    ///
    /// If *width* is 0 or negative, a null pixmap is returned.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    ///
    /// Qt::TransformationMode mode) const
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *height* using the specified transformation *mode.*
    /// The width of the pixmap is automatically calculated so that the
    /// aspect ratio of the pixmap is preserved.
    ///
    /// If *height* is 0 or negative, a null pixmap is returned.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    pub fn scaled(
        &self,
        w: i32,
        h: i32,
        aspect_mode: AspectRatioMode,
        mode: TransformationMode,
    ) -> Pixmap {
        let enum_aspect_mode_3 = aspect_mode as i32;
        let enum_mode_4 = mode as i32;

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled)(obj_data, w, h, enum_aspect_mode_3, enum_mode_4);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Qt::AspectRatioMode aspectRatioMode, Qt::TransformationMode
    /// transformMode) const
    ///
    /// **Overloads**
    /// Returns a copy of the pixmap scaled to a rectangle with the given
    /// *width* and *height* according to the given *aspectRatioMode* and
    /// *transformMode.*
    ///
    /// If either the *width* or the *height* is zero or negative, this
    /// function returns a null pixmap.
    ///
    /// aspectRatioMode, Qt::TransformationMode transformMode) const
    ///
    /// Scales the pixmap to the given *size,* using the aspect ratio and
    /// transformation modes specified by *aspectRatioMode* and *transformMode.*
    ///
    /// ![qimage-scaling.png](qimage-scaling.png)
    ///
    /// * If *aspectRatioMode* is Qt::IgnoreAspectRatio, the pixmap is scaled to *size.*
    /// * If *aspectRatioMode* is Qt::KeepAspectRatio, the pixmap is scaled to a rectangle as large as possible inside *size,* preserving the aspect ratio.
    /// * If *aspectRatioMode* is Qt::KeepAspectRatioByExpanding, the pixmap is scaled to a rectangle as small as possible outside *size,* preserving the aspect ratio.
    ///
    /// If the given *size* is empty, this function returns a null
    /// pixmap.
    ///
    /// In some cases it can be more beneficial to draw the pixmap to a
    /// painter with a scale set rather than scaling the pixmap. This is
    /// the case when the painter is for instance based on OpenGL or when
    /// the scale factor changes rapidly.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    ///
    ///
    /// mode) const
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *width* using the specified transformation *mode.*
    /// The height of the pixmap is automatically calculated so that the
    /// aspect ratio of the pixmap is preserved.
    ///
    /// If *width* is 0 or negative, a null pixmap is returned.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    ///
    /// Qt::TransformationMode mode) const
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *height* using the specified transformation *mode.*
    /// The width of the pixmap is automatically calculated so that the
    /// aspect ratio of the pixmap is preserved.
    ///
    /// If *height* is 0 or negative, a null pixmap is returned.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    pub fn scaled_2<S: SizeTrait<'a>>(
        &self,
        s: &S,
        aspect_mode: AspectRatioMode,
        mode: TransformationMode,
    ) -> Pixmap {
        let (obj_s_1, _funcs) = s.get_size_obj_funcs();
        let enum_aspect_mode_2 = aspect_mode as i32;
        let enum_mode_3 = mode as i32;

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled_2)(obj_data, obj_s_1, enum_aspect_mode_2, enum_mode_3);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// mode) const
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *width* using the specified transformation *mode.*
    /// The height of the pixmap is automatically calculated so that the
    /// aspect ratio of the pixmap is preserved.
    ///
    /// If *width* is 0 or negative, a null pixmap is returned.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    pub fn scaled_to_width(&self, w: i32, mode: TransformationMode) -> Pixmap {
        let enum_mode_2 = mode as i32;

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled_to_width)(obj_data, w, enum_mode_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Qt::TransformationMode mode) const
    ///
    /// Returns a scaled copy of the image. The returned image is scaled
    /// to the given *height* using the specified transformation *mode.*
    /// The width of the pixmap is automatically calculated so that the
    /// aspect ratio of the pixmap is preserved.
    ///
    /// If *height* is 0 or negative, a null pixmap is returned.
    ///
    /// **See also:** [`is_null()`]
    /// {QPixmap#Pixmap Transformations}{Pixmap
    /// Transformations}
    pub fn scaled_to_height(&self, h: i32, mode: TransformationMode) -> Pixmap {
        let enum_mode_2 = mode as i32;

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).scaled_to_height)(obj_data, h, enum_mode_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Converts the pixmap to a QImage. Returns a null image if the
    /// conversion fails.
    ///
    /// If the pixmap has 1-bit depth, the returned image will also be 1
    /// bit deep. Images with more bits will be returned in a format
    /// closely represents the underlying system. Usually this will be
    /// QImage::Format_ARGB32_Premultiplied for pixmaps with an alpha and
    /// QImage::Format_RGB32 or QImage::Format_RGB16 for pixmaps without
    /// alpha.
    ///
    /// Note that for the moment, alpha masks on monochrome images are
    /// ignored.
    ///
    /// **See also:** [`from_image()`]
    /// {QImage#Image Formats}{Image Formats}
    pub fn to_image(&self) -> Image {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_image)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Image::new_from_rc(t);
            } else {
                ret_val = Image::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Converts the given *image* to a pixmap using the specified *flags* to control the conversion. The *flags* argument is a
    /// bitwise-OR of the [Qt::ImageConversionFlags](Qt::ImageConversionFlags)
    /// . Passing 0 for *flags* sets all the default options.
    ///
    /// In case of monochrome and 8-bit images, the image is first
    /// converted to a 32-bit pixmap and then filled with the colors in
    /// the color table. If this is too expensive an operation, you can
    /// use QBitmap::fromImage() instead.
    ///
    /// **See also:** [`from_image_reader()`]
    /// [`to_image()`]
    /// {QPixmap#Pixmap Conversion}{Pixmap Conversion}
    ///
    /// **Overloads**
    /// Converts the given *image* to a pixmap without copying if possible.
    ///
    /// Create a QPixmap from an image read directly from an *imageReader.*
    /// The *flags* argument is a bitwise-OR of the [Qt::ImageConversionFlags](Qt::ImageConversionFlags)
    ///
    /// Passing 0 for *flags* sets all the default options.
    ///
    /// On some systems, reading an image directly to QPixmap can use less memory than
    /// reading a QImage to convert it to QPixmap.
    ///
    /// **See also:** [`from_image()`]
    /// [`to_image()`]
    /// {QPixmap#Pixmap Conversion}{Pixmap Conversion}
    pub fn from_image<I: ImageTrait<'a>>(image: &I, flags: ImageConversionFlags) -> Pixmap<'a> {
        let (obj_image_1, _funcs) = image.get_image_obj_funcs();
        let enum_flags_2 = flags as i32;

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_pixmap)(::std::ptr::null()).all_funcs).pixmap_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_image)(obj_data, obj_image_1, enum_flags_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Create a QPixmap from an image read directly from an *imageReader.*
    /// The *flags* argument is a bitwise-OR of the [Qt::ImageConversionFlags](Qt::ImageConversionFlags)
    ///
    /// Passing 0 for *flags* sets all the default options.
    ///
    /// On some systems, reading an image directly to QPixmap can use less memory than
    /// reading a QImage to convert it to QPixmap.
    ///
    /// **See also:** [`from_image()`]
    /// [`to_image()`]
    /// {QPixmap#Pixmap Conversion}{Pixmap Conversion}
    ///
    /// Converts the given *image* to a pixmap using the specified *flags* to control the conversion. The *flags* argument is a
    /// bitwise-OR of the [Qt::ImageConversionFlags](Qt::ImageConversionFlags)
    /// . Passing 0 for *flags* sets all the default options.
    ///
    /// In case of monochrome and 8-bit images, the image is first
    /// converted to a 32-bit pixmap and then filled with the colors in
    /// the color table. If this is too expensive an operation, you can
    /// use QBitmap::fromImage() instead.
    ///
    /// **See also:** [`from_image_reader()`]
    /// [`to_image()`]
    /// {QPixmap#Pixmap Conversion}{Pixmap Conversion}
    ///
    /// **Overloads**
    /// Converts the given *image* to a pixmap without copying if possible.
    ///
    /// Create a QPixmap from an image read directly from an *imageReader.*
    /// The *flags* argument is a bitwise-OR of the [Qt::ImageConversionFlags](Qt::ImageConversionFlags)
    ///
    /// Passing 0 for *flags* sets all the default options.
    ///
    /// On some systems, reading an image directly to QPixmap can use less memory than
    /// reading a QImage to convert it to QPixmap.
    ///
    /// **See also:** [`from_image()`]
    /// [`to_image()`]
    /// {QPixmap#Pixmap Conversion}{Pixmap Conversion}
    pub fn from_image_2<I: ImageTrait<'a>>(image: &I, flags: ImageConversionFlags) -> Pixmap<'a> {
        let (obj_image_1, _funcs) = image.get_image_obj_funcs();
        let enum_flags_2 = flags as i32;

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_pixmap)(::std::ptr::null()).all_funcs).pixmap_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_image_2)(obj_data, obj_image_1, enum_flags_2);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Replaces this pixmap's data with the given *image* using the
    /// specified *flags* to control the conversion. The *flags*
    /// argument is a bitwise-OR of the [Qt::ImageConversionFlags](Qt::ImageConversionFlags)
    ///
    /// Passing 0 for *flags* sets all the default options. Returns `true`
    /// if the result is that this pixmap is not null.
    ///
    /// Note: this function was part of Qt 3 support in Qt 4.6 and earlier.
    /// It has been promoted to official API status in 4.7 to support updating
    /// the pixmap's image without creating a new QPixmap as fromImage() would.
    ///
    /// **See also:** [`from_image()`]
    pub fn convert_from_image<I: ImageTrait<'a>>(
        &self,
        img: &I,
        flags: ImageConversionFlags,
    ) -> bool {
        let (obj_img_1, _funcs) = img.get_image_obj_funcs();
        let enum_flags_2 = flags as i32;

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).convert_from_image)(obj_data, obj_img_1, enum_flags_2);
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Returns a deep copy of the subset of the pixmap that is specified
    /// by the rectangle QRect( *x,* *y,* *width,* *height).*
    ///
    /// Returns a deep copy of the subset of the pixmap that is specified
    /// by the given *rectangle.* For more information on deep copies,
    /// see the [Implicit Data Sharing](Implicit%20Data%20Sharing)
    /// documentation.
    ///
    /// If the given *rectangle* is empty, the whole image is copied.
    ///
    /// **See also:** [`operator()`]
    /// [`q_pixmap()`]
    /// {QPixmap#Pixmap
    /// Transformations}{Pixmap Transformations}
    pub fn copy(&self, x: i32, y: i32, width: i32, height: i32) -> Pixmap {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).copy)(obj_data, x, y, width, height);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Returns a deep copy of the subset of the pixmap that is specified
    /// by the rectangle QRect( *x,* *y,* *width,* *height).*
    ///
    /// Returns a deep copy of the subset of the pixmap that is specified
    /// by the given *rectangle.* For more information on deep copies,
    /// see the [Implicit Data Sharing](Implicit%20Data%20Sharing)
    /// documentation.
    ///
    /// If the given *rectangle* is empty, the whole image is copied.
    ///
    /// **See also:** [`operator()`]
    /// [`q_pixmap()`]
    /// {QPixmap#Pixmap
    /// Transformations}{Pixmap Transformations}
    pub fn copy_2<R: RectTrait<'a>>(&self, rect: &R) -> Pixmap {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).copy_2)(obj_data, obj_rect_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pixmap::new_from_rc(t);
            } else {
                ret_val = Pixmap::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// This convenience function is equivalent to calling QPixmap::scroll( *dx,*
    /// *dy,* QRect( *x,* *y,* *width,* *height),* *exposed).*
    ///
    /// **See also:** [`Widget::scroll`]
    /// [`GraphicsItem::scroll`]
    ///
    /// Scrolls the area *rect* of this pixmap by ( *dx,* *dy).* The exposed
    /// region is left unchanged. You can optionally pass a pointer to an empty
    /// QRegion to get the region that is *exposed* by the scroll operation.
    ///
    /// You cannot scroll while there is an active painter on the pixmap.
    ///
    /// **See also:** [`Widget::scroll`]
    /// [`GraphicsItem::scroll`]
    pub fn scroll<R: RegionTrait<'a>>(
        &self,
        dx: i32,
        dy: i32,
        x: i32,
        y: i32,
        width: i32,
        height: i32,
        exposed: &R,
    ) -> &Self {
        let (obj_exposed_7, _funcs) = exposed.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).scroll)(obj_data, dx, dy, x, y, width, height, obj_exposed_7);
        }
        self
    }
    ///
    /// This convenience function is equivalent to calling QPixmap::scroll( *dx,*
    /// *dy,* QRect( *x,* *y,* *width,* *height),* *exposed).*
    ///
    /// **See also:** [`Widget::scroll`]
    /// [`GraphicsItem::scroll`]
    ///
    /// Scrolls the area *rect* of this pixmap by ( *dx,* *dy).* The exposed
    /// region is left unchanged. You can optionally pass a pointer to an empty
    /// QRegion to get the region that is *exposed* by the scroll operation.
    ///
    /// You cannot scroll while there is an active painter on the pixmap.
    ///
    /// **See also:** [`Widget::scroll`]
    /// [`GraphicsItem::scroll`]
    pub fn scroll_2<R: RectTrait<'a>, S: RegionTrait<'a>>(
        &self,
        dx: i32,
        dy: i32,
        rect: &R,
        exposed: &S,
    ) -> &Self {
        let (obj_rect_3, _funcs) = rect.get_rect_obj_funcs();
        let (obj_exposed_4, _funcs) = exposed.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).scroll_2)(obj_data, dx, dy, obj_rect_3, obj_exposed_4);
        }
        self
    }
    ///
    /// Returns a number that identifies this QPixmap. Distinct QPixmap
    /// objects can only have the same cache key if they refer to the same
    /// contents.
    ///
    /// The cacheKey() will change when the pixmap is altered.
    pub fn cache_key(&self) -> i64 {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cache_key)(obj_data);
            ret_val
        }
    }
    pub fn is_detached(&self) -> bool {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_detached)(obj_data);
            ret_val
        }
    }
    ///
    /// Detaches the pixmap from shared pixmap data.
    ///
    /// A pixmap is automatically detached by Qt whenever its contents are
    /// about to change. This is done in almost all QPixmap member
    /// functions that modify the pixmap (fill(), fromImage(),
    /// load(), etc.), and in QPainter::begin() on a pixmap.
    ///
    /// There are two exceptions in which detach() must be called
    /// explicitly, that is when calling the handle() or the
    /// x11PictureHandle() function (only available on X11). Otherwise,
    /// any modifications done using system calls, will be performed on
    /// the shared data.
    ///
    /// The detach() function returns immediately if there is just a
    /// single reference or if the pixmap has not been initialized yet.
    pub fn detach(&self) -> &Self {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            ((*funcs).detach)(obj_data);
        }
        self
    }
    ///
    /// Returns `true` if this is a QBitmap; otherwise returns `false.`
    pub fn is_q_bitmap(&self) -> bool {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_q_bitmap)(obj_data);
            ret_val
        }
    }
    pub fn paint_engine(&self) -> Option<PaintEngine> {
        let (obj_data, funcs) = self.get_pixmap_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_engine)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintEngine::new_from_rc(t);
            } else {
                ret_val = PaintEngine::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn painting_active(&self) -> bool {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).painting_active)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn logical_dpi_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).logical_dpi_x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn logical_dpi_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).logical_dpi_y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn physical_dpi_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).physical_dpi_x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn physical_dpi_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).physical_dpi_y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn device_pixel_ratio_f(&self) -> f32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio_f)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn color_count(&self) -> i32 {
        let (obj_data, funcs) = self.get_paint_device_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).color_count)(obj_data);
            ret_val
        }
    }
}
pub trait PixmapTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_pixmap_obj_funcs(&self) -> (*const RUBase, *const RUPixmapFuncs);
}

impl<'a> PaintDeviceTrait<'a> for Pixmap<'a> {
    #[doc(hidden)]
    fn get_paint_device_obj_funcs(&self) -> (*const RUBase, *const RUPaintDeviceFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).paint_device_funcs) }
    }
}

impl<'a> PixmapTrait<'a> for Pixmap<'a> {
    #[doc(hidden)]
    fn get_pixmap_obj_funcs(&self) -> (*const RUBase, *const RUPixmapFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).pixmap_funcs) }
    }
}
