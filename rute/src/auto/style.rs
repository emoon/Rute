// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// Qt contains a set of QStyle subclasses that emulate the styles of
/// the different platforms supported by Qt (QWindowsStyle,
/// QMacStyle etc.). By default, these styles are built
/// into the Qt GUI module. Styles can also be made available as
/// plugins.
///
/// Qt's built-in widgets use QStyle to perform nearly all of their
/// drawing, ensuring that they look exactly like the equivalent
/// native widgets. The diagram below shows a QComboBox in nine
/// different styles.
///
/// ![Nine combo boxes](qstyle-comboboxes.png)
///
/// Topics:
///
/// # Setting a Style
///
/// The style of the entire application can be set using the
/// QApplication::setStyle() function. It can also be specified by the
/// user of the application, using the `-style` command-line option:
///
/// If no style is specified, Qt will choose the most appropriate
/// style for the user's platform or desktop environment.
///
/// A style can also be set on an individual widget using the
/// QWidget::setStyle() function.
///
/// # Developing Style-Aware Custom Widgets
///
/// If you are developing custom widgets and want them to look good on
/// all platforms, you can use QStyle functions to perform parts of
/// the widget drawing, such as drawItemText(), drawItemPixmap(),
/// drawPrimitive(), drawControl(), and drawComplexControl().
///
/// Most QStyle draw functions take four arguments:
/// * an enum value specifying which graphical element to draw
/// * a QStyleOption specifying how and where to render that element
/// * a QPainter that should be used to draw the element
/// * a QWidget on which the drawing is performed (optional)
///
/// For example, if you want to draw a focus rectangle on your
/// widget, you can write:
///
/// QStyle gets all the information it needs to render the graphical
/// element from QStyleOption. The widget is passed as the last
/// argument in case the style needs it to perform special effects
/// (such as animated default buttons on MacOS ), but it isn't
/// mandatory. In fact, you can use QStyle to draw on any paint
/// device, not just widgets, by setting the QPainter properly.
///
/// QStyleOption has various subclasses for the various types of
/// graphical elements that can be drawn. For example,
/// PE_FrameFocusRect expects a QStyleOptionFocusRect argument.
///
/// To ensure that drawing operations are as fast as possible,
/// QStyleOption and its subclasses have public data members. See the
/// QStyleOption class documentation for details on how to use it.
///
/// For convenience, Qt provides the QStylePainter class, which
/// combines a QStyle, a QPainter, and a QWidget. This makes it
/// possible to write
///
/// ...
///
/// instead of
///
/// ...
///
/// # Creating a Custom Style
///
/// You can create a custom look and feel for your application by
/// creating a custom style. There are two approaches to creating a
/// custom style. In the static approach, you either choose an
/// existing QStyle class, subclass it, and reimplement virtual
/// functions to provide the custom behavior, or you create an entire
/// QStyle class from scratch. In the dynamic approach, you modify the
/// behavior of your system style at runtime. The static approach is
/// described below. The dynamic approach is described in QProxyStyle.
///
/// The first step in the static approach is to pick one of the styles
/// provided by Qt from which you will build your custom style. Your
/// choice of QStyle class will depend on which style resembles your
/// desired style the most. The most general class that you can use as
/// a base is QCommonStyle (not QStyle). This is because Qt requires
/// its styles to be [QCommonStyle](QCommonStyle)
/// s.
///
/// Depending on which parts of the base style you want to change,
/// you must reimplement the functions that are used to draw those
/// parts of the interface. To illustrate this, we will modify the
/// look of the spin box arrows drawn by QWindowsStyle. The arrows
/// are *primitive elements* that are drawn by the drawPrimitive()
/// function, so we need to reimplement that function. We need the
/// following class declaration:
///
/// To draw its up and down arrows, QSpinBox uses the
/// PE_IndicatorSpinUp and PE_IndicatorSpinDown primitive elements.
/// Here's how to reimplement the drawPrimitive() function to draw
/// them differently:
///
/// Notice that we don't use the `widget` argument, except to pass it
/// on to the QWindowStyle::drawPrimitive() function. As mentioned
/// earlier, the information about what is to be drawn and how it
/// should be drawn is specified by a QStyleOption object, so there is
/// no need to ask the widget.
///
/// If you need to use the `widget` argument to obtain additional
/// information, be careful to ensure that it isn't 0 and that it is
/// of the correct type before using it. For example:
///
/// ...
///
/// When implementing a custom style, you cannot assume that the
/// widget is a QSpinBox just because the enum value is called
/// PE_IndicatorSpinUp or PE_IndicatorSpinDown.
///
/// The documentation for the [Styles](widgets/styles)
/// example
/// covers this topic in more detail.
///
/// **Warning**: Qt style sheets are currently not supported for custom QStyle
/// subclasses. We plan to address this in some future release.
///
/// # Using a Custom Style
///
/// There are several ways of using a custom style in a Qt
/// application. The simplest way is to pass the custom style to the
/// QApplication::setStyle() static function before creating the
/// QApplication object:
///
/// You can call QApplication::setStyle() at any time, but by calling
/// it before the constructor, you ensure that the user's preference,
/// set using the `-style` command-line option, is respected.
///
/// You may want to make your custom style available for use in other
/// applications, which may not be yours and hence not available for
/// you to recompile. The Qt Plugin system makes it possible to create
/// styles as plugins. Styles created as plugins are loaded as shared
/// objects at runtime by Qt itself. Please refer to the [Qt Plugin](How%20to%20Create%20Qt%20Plugins)
///
/// documentation for more information on how to go about creating a style
/// plugin.
///
/// Compile your plugin and put it into Qt's `plugins/styles`
/// directory. We now have a pluggable style that Qt can load
/// automatically. To use your new style with existing applications,
/// simply start the application with the following argument:
///
/// The application will use the look and feel from the custom style you
/// implemented.
///
/// # Right-to-Left Desktops
///
/// Languages written from right to left (such as Arabic and Hebrew)
/// usually also mirror the whole layout of widgets, and require the
/// light to come from the screen's top-right corner instead of
/// top-left.
///
/// If you create a custom style, you should take special care when
/// drawing asymmetric elements to make sure that they also look
/// correct in a mirrored layout. An easy way to test your styles is
/// to run applications with the `-reverse` command-line option or
/// to call QApplication::setLayoutDirection() in your `main()`
/// function.
///
/// Here are some things to keep in mind when making a style work well in a
/// right-to-left environment:
///
/// * subControlRect() and subElementRect() return rectangles in screen coordinates
/// * QStyleOption::direction indicates in which direction the item should be drawn in
/// * If a style is not right-to-left aware it will display items as if it were left-to-right
/// * visualRect(), visualPos(), and visualAlignment() are helpful functions that will translate from logical to screen representations.
/// * alignedRect() will return a logical rect aligned for the current direction
///
/// # Styles in Item Views
///
/// The painting of items in views is performed by a delegate. Qt's
/// default delegate, QStyledItemDelegate, is also used for calculating bounding
/// rectangles of items, and their sub-elements for the various kind
/// of item [data roles](Qt::ItemDataRole)
///
/// QStyledItemDelegate supports. See the QStyledItemDelegate class
/// description to find out which datatypes and roles are supported. You
/// can read more about item data roles in [Model/View Programming](Model/View%20Programming)
///
///
/// When QStyledItemDelegate paints its items, it draws
/// CE_ItemViewItem, and calculates their size with CT_ItemViewItem.
/// Note also that it uses SE_ItemViewItemText to set the size of
/// editors. When implementing a style to customize drawing of item
/// views, you need to check the implementation of QCommonStyle (and
/// any other subclasses from which your style
/// inherits). This way, you find out which and how
/// other style elements are painted, and you can then reimplement the
/// painting of elements that should be drawn differently.
///
/// We include a small example where we customize the drawing of item
/// backgrounds.
///
/// The primitive element PE_PanelItemViewItem is responsible for
/// painting the background of items, and is called from
/// [QCommonStyle](QCommonStyle)
/// 's implementation of CE_ItemViewItem.
///
/// To add support for drawing of new datatypes and item data roles,
/// it is necessary to create a custom delegate. But if you only
/// need to support the datatypes implemented by the default
/// delegate, a custom style does not need an accompanying
/// delegate. The QStyledItemDelegate class description gives more
/// information on custom delegates.
///
/// The drawing of item view headers is also done by the style, giving
/// control over size of header items and row and column sizes.
///
/// **See also:** [`StyleOption`]
/// [`StylePainter`]
/// {Styles Example}
/// {Styles and Style Aware Widgets}
/// [`StyledItemDelegate`]
/// {Styling}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Style<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUStyleAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Style<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUStyle) -> Style<'a> {
        Style {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUStyle) -> Style<'a> {
        Style {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUStyle) -> Style<'a> {
        Style {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    pub fn polish<W: WidgetTrait<'a>>(&self, widget: &W) -> &Self {
        let (obj_widget_1, _funcs) = widget.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).polish)(obj_data, obj_widget_1);
        }
        self
    }
    ///
    /// Uninitialize the given *widget* 's appearance.
    ///
    /// This function is the counterpart to polish(). It is called for
    /// every polished widget whenever the style is dynamically changed;
    /// the former style has to unpolish its settings before the new style
    /// can polish them again.
    ///
    /// Note that unpolish() will only be called if the widget is
    /// destroyed. This can cause problems in some cases, e.g, if you
    /// remove a widget from the UI, cache it, and then reinsert it after
    /// the style has changed; some of Qt's classes cache their widgets.
    ///
    /// **See also:** [`polish()`]
    ///
    /// **Overloads**
    /// Uninitialize the given *application.*
    pub fn unpolish<W: WidgetTrait<'a>>(&self, widget: &W) -> &Self {
        let (obj_widget_1, _funcs) = widget.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).unpolish)(obj_data, obj_widget_1);
        }
        self
    }
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    pub fn polish_2<A: ApplicationTrait<'a>>(&self, application: &A) -> &Self {
        let (obj_application_1, _funcs) = application.get_application_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).polish_2)(obj_data, obj_application_1);
        }
        self
    }
    ///
    /// Uninitialize the given *widget* 's appearance.
    ///
    /// This function is the counterpart to polish(). It is called for
    /// every polished widget whenever the style is dynamically changed;
    /// the former style has to unpolish its settings before the new style
    /// can polish them again.
    ///
    /// Note that unpolish() will only be called if the widget is
    /// destroyed. This can cause problems in some cases, e.g, if you
    /// remove a widget from the UI, cache it, and then reinsert it after
    /// the style has changed; some of Qt's classes cache their widgets.
    ///
    /// **See also:** [`polish()`]
    ///
    /// **Overloads**
    /// Uninitialize the given *application.*
    pub fn unpolish_2<A: ApplicationTrait<'a>>(&self, application: &A) -> &Self {
        let (obj_application_1, _funcs) = application.get_application_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).unpolish_2)(obj_data, obj_application_1);
        }
        self
    }
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    pub fn polish_3<P: PaletteTrait<'a>>(&self, palette: &P) -> &Self {
        let (obj_palette_1, _funcs) = palette.get_palette_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).polish_3)(obj_data, obj_palette_1);
        }
        self
    }
    ///
    /// Returns the area within the given *rectangle* in which to draw
    /// the provided *text* according to the specified font *metrics*
    /// and *alignment.* The *enabled* parameter indicates whether or
    /// not the associated item is enabled.
    ///
    /// If the given *rectangle* is larger than the area needed to render
    /// the *text,* the rectangle that is returned will be offset within
    /// *rectangle* according to the specified *alignment.* For
    /// example, if *alignment* is Qt::AlignCenter, the returned
    /// rectangle will be centered within *rectangle.* If the given *rectangle* is smaller than the area needed, the returned rectangle
    /// will be the smallest rectangle large enough to render the *text.*
    ///
    /// **See also:** [`t::alignment()`]
    ///
    /// Returns the area within the given *rectangle* in which to draw
    /// the specified *pixmap* according to the defined *alignment.*
    pub fn item_pixmap_rect<P: PixmapTrait<'a>, R: RectTrait<'a>>(
        &self,
        r: &R,
        flags: i32,
        pixmap: &P,
    ) -> Rect {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let (obj_pixmap_3, _funcs) = pixmap.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_pixmap_rect)(obj_data, obj_r_1, flags, obj_pixmap_3);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Draws the given *text* in the specified *rectangle* using the
    /// provided *painter* and *palette.*
    ///
    /// The text is drawn using the painter's pen, and aligned and wrapped
    /// according to the specified *alignment.* If an explicit *textRole* is specified, the text is drawn using the *palette's*
    /// color for the given role. The *enabled* parameter indicates
    /// whether or not the item is enabled; when reimplementing this
    /// function, the *enabled* parameter should influence how the item is
    /// drawn.
    ///
    /// **See also:** [`t::alignment()`]
    /// [`draw_item_pixmap()`]
    pub fn draw_item_text<P: PainterTrait<'a>, Q: PaletteTrait<'a>, R: RectTrait<'a>>(
        &self,
        painter: &P,
        rect: &R,
        flags: i32,
        pal: &Q,
        enabled: bool,
        text: &str,
        text_role: ColorRole,
    ) -> &Self {
        let (obj_painter_1, _funcs) = painter.get_painter_obj_funcs();
        let (obj_rect_2, _funcs) = rect.get_rect_obj_funcs();
        let (obj_pal_4, _funcs) = pal.get_palette_obj_funcs();
        let str_in_text_6 = CString::new(text).unwrap();
        let enum_text_role_7 = text_role.bits();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).draw_item_text)(
                obj_data,
                obj_painter_1,
                obj_rect_2,
                flags,
                obj_pal_4,
                enabled,
                str_in_text_6.as_ptr(),
                enum_text_role_7,
            );
        }
        self
    }
    ///
    /// const QPixmap &pixmap) const
    ///
    /// Draws the given *pixmap* in the specified *rectangle,* according
    /// to the specified *alignment,* using the provided *painter.*
    ///
    /// **See also:** [`draw_item_text()`]
    pub fn draw_item_pixmap<P: PainterTrait<'a>, Q: PixmapTrait<'a>, R: RectTrait<'a>>(
        &self,
        painter: &P,
        rect: &R,
        alignment: i32,
        pixmap: &Q,
    ) -> &Self {
        let (obj_painter_1, _funcs) = painter.get_painter_obj_funcs();
        let (obj_rect_2, _funcs) = rect.get_rect_obj_funcs();
        let (obj_pixmap_4, _funcs) = pixmap.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).draw_item_pixmap)(
                obj_data,
                obj_painter_1,
                obj_rect_2,
                alignment,
                obj_pixmap_4,
            );
        }
        self
    }
    ///
    /// Returns the style's standard palette.
    ///
    /// Note that on systems that support system colors, the style's
    /// standard palette is not used. In particular, the Windows
    /// Vista and Mac styles do not use the standard palette, but make
    /// use of native theme engines. With these styles, you should not set
    /// the palette with QApplication::setPalette().
    ///
    /// **See also:** [`Application::set_palette`]
    pub fn standard_palette(&self) -> Palette {
        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).standard_palette)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Palette::new_from_rc(t);
            } else {
                ret_val = Palette::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Draws the given primitive *element* with the provided *painter* using the style
    /// options specified by *option.*
    ///
    /// The *widget* argument is optional and may contain a widget that may
    /// aid in drawing the primitive element.
    ///
    /// The table below is listing the primitive elements and their
    /// associated style option subclasses. The style options contain all
    /// the parameters required to draw the elements, including
    /// QStyleOption::state which holds the style flags that are used when
    /// drawing. The table also describes which flags that are set when
    /// casting the given option to the appropriate subclass.
    ///
    /// Note that if a primitive element is not listed here, it is because
    /// it uses a plain QStyleOption object.
    ///
    /// * Primitive Element
    /// * QStyleOption Subclass
    /// * Style Flag
    /// * Remark
    /// * [PE_FrameFocusRect](PE_FrameFocusRect)
    ///
    /// * [QStyleOptionFocusRect](QStyleOptionFocusRect)
    ///
    /// * [State_FocusAtBorder](State_FocusAtBorder)
    ///
    /// * Whether the focus is is at the border or inside the widget.
    /// * {1,2} [PE_IndicatorCheckBox](PE_IndicatorCheckBox)
    ///
    /// * {1,2} [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_NoChange](State_NoChange)
    ///
    /// * Indicates a "tri-state" checkbox.
    /// * [State_On](State_On)
    ///
    /// * Indicates the indicator is checked.
    /// * [PE_IndicatorRadioButton](PE_IndicatorRadioButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_On](State_On)
    ///
    /// * Indicates that a radio button is selected.
    /// * [State_NoChange](State_NoChange)
    ///
    /// * Indicates a "tri-state" controller.
    /// * [State_Enabled](State_Enabled)
    ///
    /// * Indicates the controller is enabled.
    /// * {1,4} [PE_IndicatorBranch](PE_IndicatorBranch)
    ///
    /// * {1,4} [QStyleOption](QStyleOption)
    ///
    /// * [State_Children](State_Children)
    ///
    /// * Indicates that the control for expanding the tree to show child items, should be drawn.
    /// * [State_Item](State_Item)
    ///
    /// * Indicates that a horizontal branch (to show a child item), should be drawn.
    /// * [State_Open](State_Open)
    ///
    /// * Indicates that the tree branch is expanded.
    /// * [State_Sibling](State_Sibling)
    ///
    /// * Indicates that a vertical line (to show a sibling item), should be drawn.
    /// * [PE_IndicatorHeaderArrow](PE_IndicatorHeaderArrow)
    ///
    /// * [QStyleOptionHeader](QStyleOptionHeader)
    ///
    /// * [State_UpArrow](State_UpArrow)
    ///
    /// * Indicates that the arrow should be drawn up; otherwise it should be down.
    /// * [PE_FrameGroupBox,](PE_FrameGroupBox,)
    /// [PE_Frame,](PE_Frame,)
    /// [PE_FrameLineEdit,](PE_FrameLineEdit,)
    /// [PE_FrameMenu,](PE_FrameMenu,)
    /// [PE_FrameDockWidget,](PE_FrameDockWidget,)
    /// [PE_FrameWindow](PE_FrameWindow)
    ///
    /// * [QStyleOptionFrame](QStyleOptionFrame)
    ///
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Indicates that the Frame should be sunken.
    /// * [PE_IndicatorToolBarHandle](PE_IndicatorToolBarHandle)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [State_Horizontal](State_Horizontal)
    ///
    /// * Indicates that the window handle is horizontal instead of vertical.
    /// * [PE_IndicatorSpinPlus,](PE_IndicatorSpinPlus,)
    /// [PE_IndicatorSpinMinus,](PE_IndicatorSpinMinus,)
    /// [PE_IndicatorSpinUp,](PE_IndicatorSpinUp,)
    /// [PE_IndicatorSpinDown,](PE_IndicatorSpinDown,)
    ///
    /// * [QStyleOptionSpinBox](QStyleOptionSpinBox)
    ///
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Indicates that the button is pressed.
    /// * {1,5} [PE_PanelButtonCommand](PE_PanelButtonCommand)
    ///
    /// * {1,5} [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_Enabled](State_Enabled)
    ///
    /// * Set if the button is enabled.
    /// * [State_HasFocus](State_HasFocus)
    ///
    /// * Set if the button has input focus.
    /// * [State_Raised](State_Raised)
    ///
    /// * Set if the button is not down, not on and not flat.
    /// * [State_On](State_On)
    ///
    /// * Set if the button is a toggle button and is toggled on.
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Set if the button is down (i.e., the mouse button or the space bar is pressed on the button).
    ///
    /// **See also:** [`draw_complex_control()`]
    /// [`draw_control()`]
    ///
    /// Returns the sub-area for the given *element* as described in the
    /// provided style *option.* The returned rectangle is defined in
    /// screen coordinates.
    ///
    /// The *widget* argument is optional and can be used to aid
    /// determining the area. The QStyleOption object can be cast to the
    /// appropriate type using the qstyleoption_cast() function. See the
    /// table below for the appropriate *option* casts:
    ///
    /// * Sub Element
    /// * QStyleOption Subclass
    /// * [SE_PushButtonContents](SE_PushButtonContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_PushButtonFocusRect](SE_PushButtonFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxIndicator](SE_CheckBoxIndicator)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxContents](SE_CheckBoxContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxFocusRect](SE_CheckBoxFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonIndicator](SE_RadioButtonIndicator)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonContents](SE_RadioButtonContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonFocusRect](SE_RadioButtonFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_ComboBoxFocusRect](SE_ComboBoxFocusRect)
    ///
    /// * [QStyleOptionComboBox](QStyleOptionComboBox)
    ///
    /// * [SE_ProgressBarGroove](SE_ProgressBarGroove)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [SE_ProgressBarContents](SE_ProgressBarContents)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [SE_ProgressBarLabel](SE_ProgressBarLabel)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    ///
    /// Returns the size of the element described by the specified
    /// *option* and *type,* based on the provided *contentsSize.*
    ///
    /// The *option* argument is a pointer to a QStyleOption or one of
    /// its subclasses. The *option* can be cast to the appropriate type
    /// using the qstyleoption_cast() function. The *widget* is an
    /// optional argument and can contain extra information used for
    /// calculating the size.
    ///
    /// See the table below for the appropriate *option* casts:
    ///
    /// * Contents Type
    /// * QStyleOption Subclass
    /// * [CT_CheckBox](CT_CheckBox)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_ComboBox](CT_ComboBox)
    ///
    /// * [QStyleOptionComboBox](QStyleOptionComboBox)
    ///
    /// * [CT_GroupBox](CT_GroupBox)
    ///
    /// * [QStyleOptionGroupBox](QStyleOptionGroupBox)
    ///
    /// * [CT_HeaderSection](CT_HeaderSection)
    ///
    /// * [QStyleOptionHeader](QStyleOptionHeader)
    ///
    /// * [CT_ItemViewItem](CT_ItemViewItem)
    ///
    /// * [QStyleOptionViewItem](QStyleOptionViewItem)
    ///
    /// * [CT_LineEdit](CT_LineEdit)
    ///
    /// * [QStyleOptionFrame](QStyleOptionFrame)
    ///
    /// * [CT_MdiControls](CT_MdiControls)
    ///
    /// * [QStyleOptionComplex](QStyleOptionComplex)
    ///
    /// * [CT_Menu](CT_Menu)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_MenuItem](CT_MenuItem)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_MenuBar](CT_MenuBar)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_MenuBarItem](CT_MenuBarItem)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_ProgressBar](CT_ProgressBar)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [CT_PushButton](CT_PushButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_RadioButton](CT_RadioButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_ScrollBar](CT_ScrollBar)
    ///
    /// * [QStyleOptionSlider](QStyleOptionSlider)
    ///
    /// * [CT_SizeGrip](CT_SizeGrip)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_Slider](CT_Slider)
    ///
    /// * [QStyleOptionSlider](QStyleOptionSlider)
    ///
    /// * [CT_SpinBox](CT_SpinBox)
    ///
    /// * [QStyleOptionSpinBox](QStyleOptionSpinBox)
    ///
    /// * [CT_Splitter](CT_Splitter)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_TabBarTab](CT_TabBarTab)
    ///
    /// * [QStyleOptionTab](QStyleOptionTab)
    ///
    /// * [CT_TabWidget](CT_TabWidget)
    ///
    /// * [QStyleOptionTabWidgetFrame](QStyleOptionTabWidgetFrame)
    ///
    /// * [CT_ToolButton](CT_ToolButton)
    ///
    /// * [QStyleOptionToolButton](QStyleOptionToolButton)
    ///
    /// **See also:** ContentsType
    /// [`StyleOption`]
    ///
    /// Returns an integer representing the specified style *hint* for
    /// the given *widget* described by the provided style *option.*
    ///
    /// *returnData* is used when the querying widget needs more detailed data than
    /// the integer that styleHint() returns. See the QStyleHintReturn class
    /// description for details.
    ///
    /// Returns a pixmap for the given *standardPixmap.*
    ///
    /// A standard pixmap is a pixmap that can follow some existing GUI
    /// style or guideline. The *option* argument can be used to pass
    /// extra information required when defining the appropriate
    /// pixmap. The *widget* argument is optional and can also be used to
    /// aid the determination of the pixmap.
    ///
    /// Developers calling standardPixmap() should instead call standardIcon()
    /// Developers who re-implemented standardPixmap() should instead re-implement
    /// standardIcon().
    ///
    /// **See also:** [`standard_icon()`]
    ///
    /// const QWidget *widget = 0) const = 0;
    ///
    /// Returns an icon for the given *standardIcon.*
    ///
    /// The *standardIcon* is a standard pixmap which can follow some
    /// existing GUI style or guideline. The *option* argument can be
    /// used to pass extra information required when defining the
    /// appropriate icon. The *widget* argument is optional and can also
    /// be used to aid the determination of the icon.
    ///
    /// const QPixmap &pixmap, const QStyleOption *option) const
    ///
    /// Returns a copy of the given *pixmap,* styled to conform to the
    /// specified *iconMode* and taking into account the palette
    /// specified by *option.*
    ///
    /// The *option* parameter can pass extra information, but
    /// it must contain a palette.
    ///
    /// Note that not all pixmaps will conform, in which case the returned
    /// pixmap is a plain copy.
    ///
    /// **See also:** [`Icon`]
    ///
    /// Returns the given *logicalRectangle* converted to screen
    /// coordinates based on the specified *direction.* The *boundingRectangle* is used when performing the translation.
    ///
    /// This function is provided to support right-to-left desktops, and
    /// is typically used in implementations of the subControlRect()
    /// function.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    ///
    /// Returns the given *logicalPosition* converted to screen
    /// coordinates based on the specified *direction.* The *boundingRectangle* is used when performing the translation.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    ///
    /// Converts the given *logicalValue* to a pixel position. The *min*
    /// parameter maps to 0, *max* maps to *span* and other values are
    /// distributed evenly in-between.
    ///
    /// This function can handle the entire integer range without
    /// overflow, providing that *span* is less than 4096.
    ///
    /// By default, this function assumes that the maximum value is on the
    /// right for horizontal items and on the bottom for vertical items.
    /// Set the *upsideDown* parameter to true to reverse this behavior.
    ///
    /// **See also:** [`slider_value_from_position()`]
    ///
    /// Converts the given pixel *position* to a logical value. 0 maps to
    /// the *min* parameter, *span* maps to *max* and other values are
    /// distributed evenly in-between.
    ///
    /// This function can handle the entire integer range without
    /// overflow.
    ///
    /// By default, this function assumes that the maximum value is on the
    /// right for horizontal items and on the bottom for vertical
    /// items. Set the *upsideDown* parameter to true to reverse this
    /// behavior.
    ///
    /// **See also:** [`slider_position_from_value()`]
    ///
    /// Transforms an *alignment* of Qt::AlignLeft or Qt::AlignRight
    /// without Qt::AlignAbsolute into Qt::AlignLeft or Qt::AlignRight with
    /// Qt::AlignAbsolute according to the layout *direction.* The other
    /// alignment flags are left untouched.
    ///
    /// If no horizontal alignment was specified, the function returns the
    /// default alignment for the given layout *direction.*
    ///
    /// QWidget::layoutDirection
    ///
    /// Returns a new rectangle of the specified *size* that is aligned to the given *rectangle* according to the specified *alignment* and *direction.*
    ///
    /// QSizePolicy::ControlType control2, Qt::Orientation orientation,
    /// const QStyleOption *option = 0, const QWidget *widget = 0) const
    ///
    /// Returns the spacing that should be used between *control1* and
    /// *control2* in a layout. *orientation* specifies whether the
    /// controls are laid out side by side or stacked vertically. The *option* parameter can be used to pass extra information about the
    /// parent widget. The *widget* parameter is optional and can also
    /// be used if *option* is 0.
    ///
    /// This function is called by the layout system. It is used only if
    /// PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
    /// negative value.
    ///
    /// **See also:** [`combined_layout_spacing()`]
    ///
    /// Returns the spacing that should be used between *controls1* and
    /// *controls2* in a layout. *orientation* specifies whether the
    /// controls are laid out side by side or stacked vertically. The *option* parameter can be used to pass extra information about the
    /// parent widget. The *widget* parameter is optional and can also
    /// be used if *option* is 0.
    ///
    /// *controls1* and *controls2* are OR-combination of zero or more
    /// [control types](QSizePolicy::ControlTypes)
    ///
    ///
    /// This function is called by the layout system. It is used only if
    /// PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
    /// negative value.
    ///
    /// **See also:** [`layout_spacing()`]
    ///
    /// This function returns the current proxy for this style.
    /// By default most styles will return themselves. However
    /// when a proxy style is in use, it will allow the style to
    /// call back into its proxy.
    pub fn proxy(&self) -> Option<Style> {
        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).proxy)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Style::new_from_rc(t);
            } else {
                ret_val = Style::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}
pub trait StyleTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_style_obj_funcs(&self) -> (*const RUBase, *const RUStyleFuncs);
}

impl<'a> ObjectTrait<'a> for Style<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> StyleTrait<'a> for Style<'a> {
    #[doc(hidden)]
    fn get_style_obj_funcs(&self) -> (*const RUBase, *const RUStyleFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).style_funcs) }
    }
}
bitflags! {
    pub struct StateFlag: u32 {
        const StateNone = 0x0;
        const StateEnabled = 0x1;
        const StateRaised = 0x2;
        const StateSunken = 0x4;
        const StateOff = 0x8;
        const StateNoChange = 0x10;
        const StateOn = 0x20;
        const StateDownArrow = 0x40;
        const StateHorizontal = 0x80;
        const StateHasFocus = 0x100;
        const StateTop = 0x200;
        const StateBottom = 0x400;
        const StateFocusAtBorder = 0x800;
        const StateAutoRaise = 0x1000;
        const StateMouseOver = 0x2000;
        const StateUpArrow = 0x4000;
        const StateSelected = 0x8000;
        const StateActive = 0x10000;
        const StateWindow = 0x20000;
        const StateOpen = 0x40000;
        const StateChildren = 0x80000;
        const StateItem = 0x100000;
        const StateSibling = 0x200000;
        const StateEditing = 0x400000;
        const StateKeyboardFocusChange = 0x800000;
        const StateReadOnly = 0x2000000;
        const StateSmall = 0x4000000;
        const StateMini = 0x8000000;
    }
}

bitflags! {
    pub struct PrimitiveElement: u32 {
        const PeFrame = 0x0;
        const PeFrameDefaultButton = 0x1;
        const PeFrameDockWidget = 0x2;
        const PeFrameFocusRect = 0x3;
        const PeFrameGroupBox = 0x4;
        const PeFrameLineEdit = 0x5;
        const PeFrameMenu = 0x6;
        const PeFrameStatusBar = 0x7;
        const PeFrameStatusBarItem = 0x7;
        const PeFrameTabWidget = 0x8;
        const PeFrameWindow = 0x9;
        const PeFrameButtonBevel = 0xa;
        const PeFrameButtonTool = 0xb;
        const PeFrameTabBarBase = 0xc;
        const PePanelButtonCommand = 0xd;
        const PePanelButtonBevel = 0xe;
        const PePanelButtonTool = 0xf;
        const PePanelMenuBar = 0x10;
        const PePanelToolBar = 0x11;
        const PePanelLineEdit = 0x12;
        const PeIndicatorArrowDown = 0x13;
        const PeIndicatorArrowLeft = 0x14;
        const PeIndicatorArrowRight = 0x15;
        const PeIndicatorArrowUp = 0x16;
        const PeIndicatorBranch = 0x17;
        const PeIndicatorButtonDropDown = 0x18;
        const PeIndicatorViewItemCheck = 0x19;
        const PeIndicatorItemViewItemCheck = 0x19;
        const PeIndicatorCheckBox = 0x1a;
        const PeIndicatorDockWidgetResizeHandle = 0x1b;
        const PeIndicatorHeaderArrow = 0x1c;
        const PeIndicatorMenuCheckMark = 0x1d;
        const PeIndicatorProgressChunk = 0x1e;
        const PeIndicatorRadioButton = 0x1f;
        const PeIndicatorSpinDown = 0x20;
        const PeIndicatorSpinMinus = 0x21;
        const PeIndicatorSpinPlus = 0x22;
        const PeIndicatorSpinUp = 0x23;
        const PeIndicatorToolBarHandle = 0x24;
        const PeIndicatorToolBarSeparator = 0x25;
        const PePanelTipLabel = 0x26;
        const PeIndicatorTabTear = 0x27;
        const PeIndicatorTabTearLeft = 0x27;
        const PePanelScrollAreaCorner = 0x28;
        const PeWidget = 0x29;
        const PeIndicatorColumnViewArrow = 0x2a;
        const PeIndicatorItemViewItemDrop = 0x2b;
        const PePanelItemViewItem = 0x2c;
        const PePanelItemViewRow = 0x2d;
        const PePanelStatusBar = 0x2e;
        const PeIndicatorTabClose = 0x2f;
        const PePanelMenu = 0x30;
        const PeIndicatorTabTearRight = 0x31;
        const PeCustomBase = 0xf000000;
    }
}

#[repr(u32)]
pub enum ControlElement {
    CePushButton = 0,
    CePushButtonBevel = 1,
    CePushButtonLabel = 2,
    CeCheckBox = 3,
    CeCheckBoxLabel = 4,
    CeRadioButton = 5,
    CeRadioButtonLabel = 6,
    CeTabBarTab = 7,
    CeTabBarTabShape = 8,
    CeTabBarTabLabel = 9,
    CeProgressBar = 10,
    CeProgressBarGroove = 11,
    CeProgressBarContents = 12,
    CeProgressBarLabel = 13,
    CeMenuItem = 14,
    CeMenuScroller = 15,
    CeMenuVMargin = 16,
    CeMenuHMargin = 17,
    CeMenuTearoff = 18,
    CeMenuEmptyArea = 19,
    CeMenuBarItem = 20,
    CeMenuBarEmptyArea = 21,
    CeToolButtonLabel = 22,
    CeHeader = 23,
    CeHeaderSection = 24,
    CeHeaderLabel = 25,
    CeToolBoxTab = 26,
    CeSizeGrip = 27,
    CeSplitter = 28,
    CeRubberBand = 29,
    CeDockWidgetTitle = 30,
    CeScrollBarAddLine = 31,
    CeScrollBarSubLine = 32,
    CeScrollBarAddPage = 33,
    CeScrollBarSubPage = 34,
    CeScrollBarSlider = 35,
    CeScrollBarFirst = 36,
    CeScrollBarLast = 37,
    CeFocusFrame = 38,
    CeComboBoxLabel = 39,
    CeToolBar = 40,
    CeToolBoxTabShape = 41,
    CeToolBoxTabLabel = 42,
    CeHeaderEmptyArea = 43,
    CeColumnViewGrip = 44,
    CeItemViewItem = 45,
    CeShapedFrame = 46,
    CeCustomBase = 4026531840,
}

bitflags! {
    pub struct SubElement: u32 {
        const SePushButtonContents = 0x0;
        const SePushButtonFocusRect = 0x1;
        const SeCheckBoxIndicator = 0x2;
        const SeCheckBoxContents = 0x3;
        const SeCheckBoxFocusRect = 0x4;
        const SeCheckBoxClickRect = 0x5;
        const SeRadioButtonIndicator = 0x6;
        const SeRadioButtonContents = 0x7;
        const SeRadioButtonFocusRect = 0x8;
        const SeRadioButtonClickRect = 0x9;
        const SeComboBoxFocusRect = 0xa;
        const SeSliderFocusRect = 0xb;
        const SeProgressBarGroove = 0xc;
        const SeProgressBarContents = 0xd;
        const SeProgressBarLabel = 0xe;
        const SeToolBoxTabContents = 0xf;
        const SeHeaderLabel = 0x10;
        const SeHeaderArrow = 0x11;
        const SeTabWidgetTabBar = 0x12;
        const SeTabWidgetTabPane = 0x13;
        const SeTabWidgetTabContents = 0x14;
        const SeTabWidgetLeftCorner = 0x15;
        const SeTabWidgetRightCorner = 0x16;
        const SeViewItemCheckIndicator = 0x17;
        const SeItemViewItemCheckIndicator = 0x17;
        const SeTabBarTearIndicator = 0x18;
        const SeTabBarTearIndicatorLeft = 0x18;
        const SeTreeViewDisclosureItem = 0x19;
        const SeLineEditContents = 0x1a;
        const SeFrameContents = 0x1b;
        const SeDockWidgetCloseButton = 0x1c;
        const SeDockWidgetFloatButton = 0x1d;
        const SeDockWidgetTitleBarText = 0x1e;
        const SeDockWidgetIcon = 0x1f;
        const SeCheckBoxLayoutItem = 0x20;
        const SeComboBoxLayoutItem = 0x21;
        const SeDateTimeEditLayoutItem = 0x22;
        const SeDialogButtonBoxLayoutItem = 0x23;
        const SeLabelLayoutItem = 0x24;
        const SeProgressBarLayoutItem = 0x25;
        const SePushButtonLayoutItem = 0x26;
        const SeRadioButtonLayoutItem = 0x27;
        const SeSliderLayoutItem = 0x28;
        const SeSpinBoxLayoutItem = 0x29;
        const SeToolButtonLayoutItem = 0x2a;
        const SeFrameLayoutItem = 0x2b;
        const SeGroupBoxLayoutItem = 0x2c;
        const SeTabWidgetLayoutItem = 0x2d;
        const SeItemViewItemDecoration = 0x2e;
        const SeItemViewItemText = 0x2f;
        const SeItemViewItemFocusRect = 0x30;
        const SeTabBarTabLeftButton = 0x31;
        const SeTabBarTabRightButton = 0x32;
        const SeTabBarTabText = 0x33;
        const SeShapedFrameContents = 0x34;
        const SeToolBarHandle = 0x35;
        const SeTabBarScrollLeftButton = 0x36;
        const SeTabBarScrollRightButton = 0x37;
        const SeTabBarTearIndicatorRight = 0x38;
        const SeCustomBase = 0xf0000000;
    }
}

#[repr(u32)]
pub enum ComplexControl {
    CcSpinBox = 0,
    CcComboBox = 1,
    CcScrollBar = 2,
    CcSlider = 3,
    CcToolButton = 4,
    CcTitleBar = 5,
    CcDial = 6,
    CcGroupBox = 7,
    CcMdiControls = 8,
    CcCustomBase = 4026531840,
}

bitflags! {
    pub struct SubControl: u32 {
        const ScNone = 0x0;
        const ScScrollBarAddLine = 0x1;
        const ScScrollBarSubLine = 0x2;
        const ScScrollBarAddPage = 0x4;
        const ScScrollBarSubPage = 0x8;
        const ScScrollBarFirst = 0x10;
        const ScScrollBarLast = 0x20;
        const ScScrollBarSlider = 0x40;
        const ScScrollBarGroove = 0x80;
        const ScSpinBoxUp = 0x1;
        const ScSpinBoxDown = 0x2;
        const ScSpinBoxFrame = 0x4;
        const ScSpinBoxEditField = 0x8;
        const ScComboBoxFrame = 0x1;
        const ScComboBoxEditField = 0x2;
        const ScComboBoxArrow = 0x4;
        const ScComboBoxListBoxPopup = 0x8;
        const ScSliderGroove = 0x1;
        const ScSliderHandle = 0x2;
        const ScSliderTickmarks = 0x4;
        const ScToolButton = 0x1;
        const ScToolButtonMenu = 0x2;
        const ScTitleBarSysMenu = 0x1;
        const ScTitleBarMinButton = 0x2;
        const ScTitleBarMaxButton = 0x4;
        const ScTitleBarCloseButton = 0x8;
        const ScTitleBarNormalButton = 0x10;
        const ScTitleBarShadeButton = 0x20;
        const ScTitleBarUnshadeButton = 0x40;
        const ScTitleBarContextHelpButton = 0x80;
        const ScTitleBarLabel = 0x100;
        const ScDialGroove = 0x1;
        const ScDialHandle = 0x2;
        const ScDialTickmarks = 0x4;
        const ScGroupBoxCheckBox = 0x1;
        const ScGroupBoxLabel = 0x2;
        const ScGroupBoxContents = 0x4;
        const ScGroupBoxFrame = 0x8;
        const ScMdiMinButton = 0x1;
        const ScMdiNormalButton = 0x2;
        const ScMdiCloseButton = 0x4;
        const ScCustomBase = 0xf0000000;
        const ScAll = 0xffffffff;
    }
}

bitflags! {
    pub struct PixelMetric: u32 {
        const PmButtonMargin = 0x0;
        const PmButtonDefaultIndicator = 0x1;
        const PmMenuButtonIndicator = 0x2;
        const PmButtonShiftHorizontal = 0x3;
        const PmButtonShiftVertical = 0x4;
        const PmDefaultFrameWidth = 0x5;
        const PmSpinBoxFrameWidth = 0x6;
        const PmComboBoxFrameWidth = 0x7;
        const PmMaximumDragDistance = 0x8;
        const PmScrollBarExtent = 0x9;
        const PmScrollBarSliderMin = 0xa;
        const PmSliderThickness = 0xb;
        const PmSliderControlThickness = 0xc;
        const PmSliderLength = 0xd;
        const PmSliderTickmarkOffset = 0xe;
        const PmSliderSpaceAvailable = 0xf;
        const PmDockWidgetSeparatorExtent = 0x10;
        const PmDockWidgetHandleExtent = 0x11;
        const PmDockWidgetFrameWidth = 0x12;
        const PmTabBarTabOverlap = 0x13;
        const PmTabBarTabHSpace = 0x14;
        const PmTabBarTabVSpace = 0x15;
        const PmTabBarBaseHeight = 0x16;
        const PmTabBarBaseOverlap = 0x17;
        const PmProgressBarChunkWidth = 0x18;
        const PmSplitterWidth = 0x19;
        const PmTitleBarHeight = 0x1a;
        const PmMenuScrollerHeight = 0x1b;
        const PmMenuHMargin = 0x1c;
        const PmMenuVMargin = 0x1d;
        const PmMenuPanelWidth = 0x1e;
        const PmMenuTearoffHeight = 0x1f;
        const PmMenuDesktopFrameWidth = 0x20;
        const PmMenuBarPanelWidth = 0x21;
        const PmMenuBarItemSpacing = 0x22;
        const PmMenuBarVMargin = 0x23;
        const PmMenuBarHMargin = 0x24;
        const PmIndicatorWidth = 0x25;
        const PmIndicatorHeight = 0x26;
        const PmExclusiveIndicatorWidth = 0x27;
        const PmExclusiveIndicatorHeight = 0x28;
        const PmDialogButtonsSeparator = 0x29;
        const PmDialogButtonsButtonWidth = 0x2a;
        const PmDialogButtonsButtonHeight = 0x2b;
        const PmMdiSubWindowFrameWidth = 0x2c;
        const PmMdiFrameWidth = 0x2c;
        const PmMdiSubWindowMinimizedWidth = 0x2d;
        const PmMdiMinimizedWidth = 0x2d;
        const PmHeaderMargin = 0x2e;
        const PmHeaderMarkSize = 0x2f;
        const PmHeaderGripMargin = 0x30;
        const PmTabBarTabShiftHorizontal = 0x31;
        const PmTabBarTabShiftVertical = 0x32;
        const PmTabBarScrollButtonWidth = 0x33;
        const PmToolBarFrameWidth = 0x34;
        const PmToolBarHandleExtent = 0x35;
        const PmToolBarItemSpacing = 0x36;
        const PmToolBarItemMargin = 0x37;
        const PmToolBarSeparatorExtent = 0x38;
        const PmToolBarExtensionExtent = 0x39;
        const PmSpinBoxSliderHeight = 0x3a;
        const PmDefaultTopLevelMargin = 0x3b;
        const PmDefaultChildMargin = 0x3c;
        const PmDefaultLayoutSpacing = 0x3d;
        const PmToolBarIconSize = 0x3e;
        const PmListViewIconSize = 0x3f;
        const PmIconViewIconSize = 0x40;
        const PmSmallIconSize = 0x41;
        const PmLargeIconSize = 0x42;
        const PmFocusFrameVMargin = 0x43;
        const PmFocusFrameHMargin = 0x44;
        const PmToolTipLabelFrameWidth = 0x45;
        const PmCheckBoxLabelSpacing = 0x46;
        const PmTabBarIconSize = 0x47;
        const PmSizeGripSize = 0x48;
        const PmDockWidgetTitleMargin = 0x49;
        const PmMessageBoxIconSize = 0x4a;
        const PmButtonIconSize = 0x4b;
        const PmDockWidgetTitleBarButtonMargin = 0x4c;
        const PmRadioButtonLabelSpacing = 0x4d;
        const PmLayoutLeftMargin = 0x4e;
        const PmLayoutTopMargin = 0x4f;
        const PmLayoutRightMargin = 0x50;
        const PmLayoutBottomMargin = 0x51;
        const PmLayoutHorizontalSpacing = 0x52;
        const PmLayoutVerticalSpacing = 0x53;
        const PmTabBarScrollButtonOverlap = 0x54;
        const PmTextCursorWidth = 0x55;
        const PmTabCloseIndicatorWidth = 0x56;
        const PmTabCloseIndicatorHeight = 0x57;
        const PmScrollViewScrollBarSpacing = 0x58;
        const PmScrollViewScrollBarOverlap = 0x59;
        const PmSubMenuOverlap = 0x5a;
        const PmTreeViewIndentation = 0x5b;
        const PmHeaderDefaultSectionSizeHorizontal = 0x5c;
        const PmHeaderDefaultSectionSizeVertical = 0x5d;
        const PmTitleBarButtonIconSize = 0x5e;
        const PmTitleBarButtonSize = 0x5f;
        const PmCustomBase = 0xf0000000;
    }
}

#[repr(u32)]
pub enum ContentsType {
    CtPushButton = 0,
    CtCheckBox = 1,
    CtRadioButton = 2,
    CtToolButton = 3,
    CtComboBox = 4,
    CtSplitter = 5,
    CtProgressBar = 6,
    CtMenuItem = 7,
    CtMenuBarItem = 8,
    CtMenuBar = 9,
    CtMenu = 10,
    CtTabBarTab = 11,
    CtSlider = 12,
    CtScrollBar = 13,
    CtLineEdit = 14,
    CtSpinBox = 15,
    CtSizeGrip = 16,
    CtTabWidget = 17,
    CtDialogButtons = 18,
    CtHeaderSection = 19,
    CtGroupBox = 20,
    CtMdiControls = 21,
    CtItemViewItem = 22,
    CtCustomBase = 4026531840,
}

#[repr(u32)]
pub enum RequestSoftwareInputPanel {
    RsipOnMouseClickAndAlreadyFocused = 0,
    RsipOnMouseClick = 1,
}

bitflags! {
    pub struct StyleHint: u32 {
        const ShEtchDisabledText = 0x0;
        const ShDitherDisabledText = 0x1;
        const ShScrollBarMiddleClickAbsolutePosition = 0x2;
        const ShScrollBarScrollWhenPointerLeavesControl = 0x3;
        const ShTabBarSelectMouseType = 0x4;
        const ShTabBarAlignment = 0x5;
        const ShHeaderArrowAlignment = 0x6;
        const ShSliderSnapToValue = 0x7;
        const ShSliderSloppyKeyEvents = 0x8;
        const ShProgressDialogCenterCancelButton = 0x9;
        const ShProgressDialogTextLabelAlignment = 0xa;
        const ShPrintDialogRightAlignButtons = 0xb;
        const ShMainWindowSpaceBelowMenuBar = 0xc;
        const ShFontDialogSelectAssociatedText = 0xd;
        const ShMenuAllowActiveAndDisabled = 0xe;
        const ShMenuSpaceActivatesItem = 0xf;
        const ShMenuSubMenuPopupDelay = 0x10;
        const ShScrollViewFrameOnlyAroundContents = 0x11;
        const ShMenuBarAltKeyNavigation = 0x12;
        const ShComboBoxListMouseTracking = 0x13;
        const ShMenuMouseTracking = 0x14;
        const ShMenuBarMouseTracking = 0x15;
        const ShItemViewChangeHighlightOnFocus = 0x16;
        const ShWidgetShareActivation = 0x17;
        const ShWorkspaceFillSpaceOnMaximize = 0x18;
        const ShComboBoxPopup = 0x19;
        const ShTitleBarNoBorder = 0x1a;
        const ShSliderStopMouseOverSlider = 0x1b;
        const ShScrollBarStopMouseOverSlider = 0x1b;
        const ShBlinkCursorWhenTextSelected = 0x1c;
        const ShRichTextFullWidthSelection = 0x1d;
        const ShMenuScrollable = 0x1e;
        const ShGroupBoxTextLabelVerticalAlignment = 0x1f;
        const ShGroupBoxTextLabelColor = 0x20;
        const ShMenuSloppySubMenus = 0x21;
        const ShTableGridLineColor = 0x22;
        const ShLineEditPasswordCharacter = 0x23;
        const ShDialogButtonsDefaultButton = 0x24;
        const ShToolBoxSelectedPageTitleBold = 0x25;
        const ShTabBarPreferNoArrows = 0x26;
        const ShScrollBarLeftClickAbsolutePosition = 0x27;
        const ShListViewExpandSelectMouseType = 0x28;
        const ShUnderlineShortcut = 0x29;
        const ShSpinBoxAnimateButton = 0x2a;
        const ShSpinBoxKeyPressAutoRepeatRate = 0x2b;
        const ShSpinBoxClickAutoRepeatRate = 0x2c;
        const ShMenuFillScreenWithScroll = 0x2d;
        const ShToolTipLabelOpacity = 0x2e;
        const ShDrawMenuBarSeparator = 0x2f;
        const ShTitleBarModifyNotification = 0x30;
        const ShButtonFocusPolicy = 0x31;
        const ShMessageBoxUseBorderForButtonSpacing = 0x32;
        const ShTitleBarAutoRaise = 0x33;
        const ShToolButtonPopupDelay = 0x34;
        const ShFocusFrameMask = 0x35;
        const ShRubberBandMask = 0x36;
        const ShWindowFrameMask = 0x37;
        const ShSpinControlsDisableOnBounds = 0x38;
        const ShDialBackgroundRole = 0x39;
        const ShComboBoxLayoutDirection = 0x3a;
        const ShItemViewEllipsisLocation = 0x3b;
        const ShItemViewShowDecorationSelected = 0x3c;
        const ShItemViewActivateItemOnSingleClick = 0x3d;
        const ShScrollBarContextMenu = 0x3e;
        const ShScrollBarRollBetweenButtons = 0x3f;
        const ShSliderAbsoluteSetButtons = 0x40;
        const ShSliderPageSetButtons = 0x41;
        const ShMenuKeyboardSearch = 0x42;
        const ShTabBarElideMode = 0x43;
        const ShDialogButtonLayout = 0x44;
        const ShComboBoxPopupFrameStyle = 0x45;
        const ShMessageBoxTextInteractionFlags = 0x46;
        const ShDialogButtonBoxButtonsHaveIcons = 0x47;
        const ShSpellCheckUnderlineStyle = 0x48;
        const ShMessageBoxCenterButtons = 0x49;
        const ShMenuSelectionWrap = 0x4a;
        const ShItemViewMovementWithoutUpdatingSelection = 0x4b;
        const ShToolTipMask = 0x4c;
        const ShFocusFrameAboveWidget = 0x4d;
        const ShTextControlFocusIndicatorTextCharFormat = 0x4e;
        const ShWizardStyle = 0x4f;
        const ShItemViewArrowKeysNavigateIntoChildren = 0x50;
        const ShMenuMask = 0x51;
        const ShMenuFlashTriggeredItem = 0x52;
        const ShMenuFadeOutOnHide = 0x53;
        const ShSpinBoxClickAutoRepeatThreshold = 0x54;
        const ShItemViewPaintAlternatingRowColorsForEmptyArea = 0x55;
        const ShFormLayoutWrapPolicy = 0x56;
        const ShTabWidgetDefaultTabPosition = 0x57;
        const ShToolBarMovable = 0x58;
        const ShFormLayoutFieldGrowthPolicy = 0x59;
        const ShFormLayoutFormAlignment = 0x5a;
        const ShFormLayoutLabelAlignment = 0x5b;
        const ShItemViewDrawDelegateFrame = 0x5c;
        const ShTabBarCloseButtonPosition = 0x5d;
        const ShDockWidgetButtonsHaveFrame = 0x5e;
        const ShToolButtonStyle = 0x5f;
        const ShRequestSoftwareInputPanel = 0x60;
        const ShScrollBarTransient = 0x61;
        const ShMenuSupportsSections = 0x62;
        const ShToolTipWakeUpDelay = 0x63;
        const ShToolTipFallAsleepDelay = 0x64;
        const ShWidgetAnimate = 0x65;
        const ShSplitterOpaqueResize = 0x66;
        const ShComboBoxUseNativePopup = 0x67;
        const ShLineEditPasswordMaskDelay = 0x68;
        const ShTabBarChangeCurrentDelay = 0x69;
        const ShMenuSubMenuUniDirection = 0x6a;
        const ShMenuSubMenuUniDirectionFailCount = 0x6b;
        const ShMenuSubMenuSloppySelectOtherActions = 0x6c;
        const ShMenuSubMenuSloppyCloseTimeout = 0x6d;
        const ShMenuSubMenuResetWhenReenteringParent = 0x6e;
        const ShMenuSubMenuDontStartSloppyOnLeave = 0x6f;
        const ShItemViewScrollMode = 0x70;
        const ShTitleBarShowToolTipsOnButtons = 0x71;
        const ShWidgetAnimationDuration = 0x72;
        const ShComboBoxAllowWheelScrolling = 0x73;
        const ShSpinBoxButtonsInsideFrame = 0x74;
        const ShCustomBase = 0xf0000000;
    }
}

#[repr(u32)]
pub enum StandardPixmap {
    SpTitleBarMenuButton = 0,
    SpTitleBarMinButton = 1,
    SpTitleBarMaxButton = 2,
    SpTitleBarCloseButton = 3,
    SpTitleBarNormalButton = 4,
    SpTitleBarShadeButton = 5,
    SpTitleBarUnshadeButton = 6,
    SpTitleBarContextHelpButton = 7,
    SpDockWidgetCloseButton = 8,
    SpMessageBoxInformation = 9,
    SpMessageBoxWarning = 10,
    SpMessageBoxCritical = 11,
    SpMessageBoxQuestion = 12,
    SpDesktopIcon = 13,
    SpTrashIcon = 14,
    SpComputerIcon = 15,
    SpDriveFdIcon = 16,
    SpDriveHdIcon = 17,
    SpDriveCdIcon = 18,
    SpDriveDvdIcon = 19,
    SpDriveNetIcon = 20,
    SpDirOpenIcon = 21,
    SpDirClosedIcon = 22,
    SpDirLinkIcon = 23,
    SpDirLinkOpenIcon = 24,
    SpFileIcon = 25,
    SpFileLinkIcon = 26,
    SpToolBarHorizontalExtensionButton = 27,
    SpToolBarVerticalExtensionButton = 28,
    SpFileDialogStart = 29,
    SpFileDialogEnd = 30,
    SpFileDialogToParent = 31,
    SpFileDialogNewFolder = 32,
    SpFileDialogDetailedView = 33,
    SpFileDialogInfoView = 34,
    SpFileDialogContentsView = 35,
    SpFileDialogListView = 36,
    SpFileDialogBack = 37,
    SpDirIcon = 38,
    SpDialogOkButton = 39,
    SpDialogCancelButton = 40,
    SpDialogHelpButton = 41,
    SpDialogOpenButton = 42,
    SpDialogSaveButton = 43,
    SpDialogCloseButton = 44,
    SpDialogApplyButton = 45,
    SpDialogResetButton = 46,
    SpDialogDiscardButton = 47,
    SpDialogYesButton = 48,
    SpDialogNoButton = 49,
    SpArrowUp = 50,
    SpArrowDown = 51,
    SpArrowLeft = 52,
    SpArrowRight = 53,
    SpArrowBack = 54,
    SpArrowForward = 55,
    SpDirHomeIcon = 56,
    SpCommandLink = 57,
    SpVistaShield = 58,
    SpBrowserReload = 59,
    SpBrowserStop = 60,
    SpMediaPlay = 61,
    SpMediaStop = 62,
    SpMediaPause = 63,
    SpMediaSkipForward = 64,
    SpMediaSkipBackward = 65,
    SpMediaSeekForward = 66,
    SpMediaSeekBackward = 67,
    SpMediaVolume = 68,
    SpMediaVolumeMuted = 69,
    SpLineEditClearButton = 70,
    SpCustomBase = 4026531840,
}
