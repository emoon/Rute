// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports
use auto::*;

///
/// Qt contains a set of QStyle subclasses that emulate the styles of
/// the different platforms supported by Qt (QWindowsStyle,
/// QMacStyle etc.). By default, these styles are built
/// into the Qt GUI module. Styles can also be made available as
/// plugins.
///
/// Qt's built-in widgets use QStyle to perform nearly all of their
/// drawing, ensuring that they look exactly like the equivalent
/// native widgets. The diagram below shows a QComboBox in nine
/// different styles.
///
/// ![Nine combo boxes](qstyle-comboboxes.png)
///
/// Topics:
///
/// # Setting a Style
///
/// The style of the entire application can be set using the
/// QApplication::setStyle() function. It can also be specified by the
/// user of the application, using the `-style` command-line option:
///
/// If no style is specified, Qt will choose the most appropriate
/// style for the user's platform or desktop environment.
///
/// A style can also be set on an individual widget using the
/// QWidget::setStyle() function.
///
/// # Developing Style-Aware Custom Widgets
///
/// If you are developing custom widgets and want them to look good on
/// all platforms, you can use QStyle functions to perform parts of
/// the widget drawing, such as drawItemText(), drawItemPixmap(),
/// drawPrimitive(), drawControl(), and drawComplexControl().
///
/// Most QStyle draw functions take four arguments:
/// * an enum value specifying which graphical element to draw
/// * a QStyleOption specifying how and where to render that element
/// * a QPainter that should be used to draw the element
/// * a QWidget on which the drawing is performed (optional)
///
/// For example, if you want to draw a focus rectangle on your
/// widget, you can write:
///
/// QStyle gets all the information it needs to render the graphical
/// element from QStyleOption. The widget is passed as the last
/// argument in case the style needs it to perform special effects
/// (such as animated default buttons on MacOS ), but it isn't
/// mandatory. In fact, you can use QStyle to draw on any paint
/// device, not just widgets, by setting the QPainter properly.
///
/// QStyleOption has various subclasses for the various types of
/// graphical elements that can be drawn. For example,
/// PE_FrameFocusRect expects a QStyleOptionFocusRect argument.
///
/// To ensure that drawing operations are as fast as possible,
/// QStyleOption and its subclasses have public data members. See the
/// QStyleOption class documentation for details on how to use it.
///
/// For convenience, Qt provides the QStylePainter class, which
/// combines a QStyle, a QPainter, and a QWidget. This makes it
/// possible to write
///
/// ...
///
/// instead of
///
/// ...
///
/// # Creating a Custom Style
///
/// You can create a custom look and feel for your application by
/// creating a custom style. There are two approaches to creating a
/// custom style. In the static approach, you either choose an
/// existing QStyle class, subclass it, and reimplement virtual
/// functions to provide the custom behavior, or you create an entire
/// QStyle class from scratch. In the dynamic approach, you modify the
/// behavior of your system style at runtime. The static approach is
/// described below. The dynamic approach is described in QProxyStyle.
///
/// The first step in the static approach is to pick one of the styles
/// provided by Qt from which you will build your custom style. Your
/// choice of QStyle class will depend on which style resembles your
/// desired style the most. The most general class that you can use as
/// a base is QCommonStyle (not QStyle). This is because Qt requires
/// its styles to be [QCommonStyle](QCommonStyle)
/// s.
///
/// Depending on which parts of the base style you want to change,
/// you must reimplement the functions that are used to draw those
/// parts of the interface. To illustrate this, we will modify the
/// look of the spin box arrows drawn by QWindowsStyle. The arrows
/// are *primitive elements* that are drawn by the drawPrimitive()
/// function, so we need to reimplement that function. We need the
/// following class declaration:
///
/// To draw its up and down arrows, QSpinBox uses the
/// PE_IndicatorSpinUp and PE_IndicatorSpinDown primitive elements.
/// Here's how to reimplement the drawPrimitive() function to draw
/// them differently:
///
/// Notice that we don't use the `widget` argument, except to pass it
/// on to the QWindowStyle::drawPrimitive() function. As mentioned
/// earlier, the information about what is to be drawn and how it
/// should be drawn is specified by a QStyleOption object, so there is
/// no need to ask the widget.
///
/// If you need to use the `widget` argument to obtain additional
/// information, be careful to ensure that it isn't 0 and that it is
/// of the correct type before using it. For example:
///
/// ...
///
/// When implementing a custom style, you cannot assume that the
/// widget is a QSpinBox just because the enum value is called
/// PE_IndicatorSpinUp or PE_IndicatorSpinDown.
///
/// The documentation for the [Styles](widgets/styles)
/// example
/// covers this topic in more detail.
///
/// **Warning**: Qt style sheets are currently not supported for custom QStyle
/// subclasses. We plan to address this in some future release.
///
/// # Using a Custom Style
///
/// There are several ways of using a custom style in a Qt
/// application. The simplest way is to pass the custom style to the
/// QApplication::setStyle() static function before creating the
/// QApplication object:
///
/// You can call QApplication::setStyle() at any time, but by calling
/// it before the constructor, you ensure that the user's preference,
/// set using the `-style` command-line option, is respected.
///
/// You may want to make your custom style available for use in other
/// applications, which may not be yours and hence not available for
/// you to recompile. The Qt Plugin system makes it possible to create
/// styles as plugins. Styles created as plugins are loaded as shared
/// objects at runtime by Qt itself. Please refer to the [Qt Plugin](How%20to%20Create%20Qt%20Plugins)
///
/// documentation for more information on how to go about creating a style
/// plugin.
///
/// Compile your plugin and put it into Qt's `plugins/styles`
/// directory. We now have a pluggable style that Qt can load
/// automatically. To use your new style with existing applications,
/// simply start the application with the following argument:
///
/// The application will use the look and feel from the custom style you
/// implemented.
///
/// # Right-to-Left Desktops
///
/// Languages written from right to left (such as Arabic and Hebrew)
/// usually also mirror the whole layout of widgets, and require the
/// light to come from the screen's top-right corner instead of
/// top-left.
///
/// If you create a custom style, you should take special care when
/// drawing asymmetric elements to make sure that they also look
/// correct in a mirrored layout. An easy way to test your styles is
/// to run applications with the `-reverse` command-line option or
/// to call QApplication::setLayoutDirection() in your `main()`
/// function.
///
/// Here are some things to keep in mind when making a style work well in a
/// right-to-left environment:
///
/// * subControlRect() and subElementRect() return rectangles in screen coordinates
/// * QStyleOption::direction indicates in which direction the item should be drawn in
/// * If a style is not right-to-left aware it will display items as if it were left-to-right
/// * visualRect(), visualPos(), and visualAlignment() are helpful functions that will translate from logical to screen representations.
/// * alignedRect() will return a logical rect aligned for the current direction
///
/// # Styles in Item Views
///
/// The painting of items in views is performed by a delegate. Qt's
/// default delegate, QStyledItemDelegate, is also used for calculating bounding
/// rectangles of items, and their sub-elements for the various kind
/// of item [data roles](Qt::ItemDataRole)
///
/// QStyledItemDelegate supports. See the QStyledItemDelegate class
/// description to find out which datatypes and roles are supported. You
/// can read more about item data roles in [Model/View Programming](Model/View%20Programming)
///
///
/// When QStyledItemDelegate paints its items, it draws
/// CE_ItemViewItem, and calculates their size with CT_ItemViewItem.
/// Note also that it uses SE_ItemViewItemText to set the size of
/// editors. When implementing a style to customize drawing of item
/// views, you need to check the implementation of QCommonStyle (and
/// any other subclasses from which your style
/// inherits). This way, you find out which and how
/// other style elements are painted, and you can then reimplement the
/// painting of elements that should be drawn differently.
///
/// We include a small example where we customize the drawing of item
/// backgrounds.
///
/// The primitive element PE_PanelItemViewItem is responsible for
/// painting the background of items, and is called from
/// [QCommonStyle](QCommonStyle)
/// 's implementation of CE_ItemViewItem.
///
/// To add support for drawing of new datatypes and item data roles,
/// it is necessary to create a custom delegate. But if you only
/// need to support the datatypes implemented by the default
/// delegate, a custom style does not need an accompanying
/// delegate. The QStyledItemDelegate class description gives more
/// information on custom delegates.
///
/// The drawing of item view headers is also done by the style, giving
/// control over size of header items and row and column sizes.
///
/// **See also:** [`StyleOption`]
/// [`StylePainter`]
/// {Styles Example}
/// {Styles and Style Aware Widgets}
/// [`StyledItemDelegate`]
/// {Styling}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Style<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUStyleAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Style<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUStyle) -> Style<'a> {
        Style {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUStyle) -> Style<'a> {
        Style {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUStyle) -> Style<'a> {
        Style {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    pub fn polish<W: WidgetTrait<'a>>(&self, widget: &W) -> &Self {
        let (obj_widget_1, _funcs) = widget.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).polish)(obj_data, obj_widget_1);
        }
        self
    }
    ///
    /// Uninitialize the given *widget* 's appearance.
    ///
    /// This function is the counterpart to polish(). It is called for
    /// every polished widget whenever the style is dynamically changed;
    /// the former style has to unpolish its settings before the new style
    /// can polish them again.
    ///
    /// Note that unpolish() will only be called if the widget is
    /// destroyed. This can cause problems in some cases, e.g, if you
    /// remove a widget from the UI, cache it, and then reinsert it after
    /// the style has changed; some of Qt's classes cache their widgets.
    ///
    /// **See also:** [`polish()`]
    ///
    /// **Overloads**
    /// Uninitialize the given *application.*
    pub fn unpolish<W: WidgetTrait<'a>>(&self, widget: &W) -> &Self {
        let (obj_widget_1, _funcs) = widget.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).unpolish)(obj_data, obj_widget_1);
        }
        self
    }
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    pub fn polish_2<A: ApplicationTrait<'a>>(&self, application: &A) -> &Self {
        let (obj_application_1, _funcs) = application.get_application_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).polish_2)(obj_data, obj_application_1);
        }
        self
    }
    ///
    /// Uninitialize the given *widget* 's appearance.
    ///
    /// This function is the counterpart to polish(). It is called for
    /// every polished widget whenever the style is dynamically changed;
    /// the former style has to unpolish its settings before the new style
    /// can polish them again.
    ///
    /// Note that unpolish() will only be called if the widget is
    /// destroyed. This can cause problems in some cases, e.g, if you
    /// remove a widget from the UI, cache it, and then reinsert it after
    /// the style has changed; some of Qt's classes cache their widgets.
    ///
    /// **See also:** [`polish()`]
    ///
    /// **Overloads**
    /// Uninitialize the given *application.*
    pub fn unpolish_2<A: ApplicationTrait<'a>>(&self, application: &A) -> &Self {
        let (obj_application_1, _funcs) = application.get_application_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).unpolish_2)(obj_data, obj_application_1);
        }
        self
    }
    ///
    /// Initializes the appearance of the given *widget.*
    ///
    /// This function is called for every widget at some point after it
    /// has been fully created but just *before* it is shown for the very
    /// first time.
    ///
    /// Note that the default implementation does nothing. Reasonable
    /// actions in this function might be to call the
    /// QWidget::setBackgroundMode() function for the widget. Do not use
    /// the function to set, for example, the geometry. Reimplementing
    /// this function provides a back-door through which the appearance
    /// of a widget can be changed, but with Qt's style engine it is
    /// rarely necessary to implement this function; reimplement
    /// drawItemPixmap(), drawItemText(), drawPrimitive(), etc. instead.
    ///
    /// The QWidget::inherits() function may provide enough information to
    /// allow class-specific customizations. But because new QStyle
    /// subclasses are expected to work reasonably with all current and *future* widgets, limited use of hard-coded customization is
    /// recommended.
    ///
    /// **See also:** [`unpolish()`]
    ///
    /// **Overloads**
    /// Late initialization of the given *application* object.
    ///
    /// **Overloads**
    /// Changes the *palette* according to style specific requirements
    /// for color palettes (if any).
    ///
    /// **See also:** [`Palette`]
    /// [`Application::set_palette`]
    pub fn polish_3<P: PaletteTrait<'a>>(&self, palette: &P) -> &Self {
        let (obj_palette_1, _funcs) = palette.get_palette_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).polish_3)(obj_data, obj_palette_1);
        }
        self
    }
    ///
    /// Returns the area within the given *rectangle* in which to draw
    /// the provided *text* according to the specified font *metrics*
    /// and *alignment.* The *enabled* parameter indicates whether or
    /// not the associated item is enabled.
    ///
    /// If the given *rectangle* is larger than the area needed to render
    /// the *text,* the rectangle that is returned will be offset within
    /// *rectangle* according to the specified *alignment.* For
    /// example, if *alignment* is Qt::AlignCenter, the returned
    /// rectangle will be centered within *rectangle.* If the given *rectangle* is smaller than the area needed, the returned rectangle
    /// will be the smallest rectangle large enough to render the *text.*
    ///
    /// **See also:** [`t::alignment()`]
    ///
    /// Returns the area within the given *rectangle* in which to draw
    /// the specified *pixmap* according to the defined *alignment.*
    pub fn item_pixmap_rect<P: PixmapTrait<'a>, R: RectTrait<'a>>(
        &self,
        r: &R,
        flags: i32,
        pixmap: &P,
    ) -> Rect {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let (obj_pixmap_3, _funcs) = pixmap.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_pixmap_rect)(obj_data, obj_r_1, flags, obj_pixmap_3);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Draws the given *text* in the specified *rectangle* using the
    /// provided *painter* and *palette.*
    ///
    /// The text is drawn using the painter's pen, and aligned and wrapped
    /// according to the specified *alignment.* If an explicit *textRole* is specified, the text is drawn using the *palette's*
    /// color for the given role. The *enabled* parameter indicates
    /// whether or not the item is enabled; when reimplementing this
    /// function, the *enabled* parameter should influence how the item is
    /// drawn.
    ///
    /// **See also:** [`t::alignment()`]
    /// [`draw_item_pixmap()`]
    pub fn draw_item_text<P: PainterTrait<'a>, Q: PaletteTrait<'a>, R: RectTrait<'a>>(
        &self,
        painter: &P,
        rect: &R,
        flags: i32,
        pal: &Q,
        enabled: bool,
        text: &str,
        text_role: ColorRole,
    ) -> &Self {
        let (obj_painter_1, _funcs) = painter.get_painter_obj_funcs();
        let (obj_rect_2, _funcs) = rect.get_rect_obj_funcs();
        let (obj_pal_4, _funcs) = pal.get_palette_obj_funcs();
        let str_in_text_6 = CString::new(text).unwrap();
        let enum_text_role_7 = text_role as i32;

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).draw_item_text)(
                obj_data,
                obj_painter_1,
                obj_rect_2,
                flags,
                obj_pal_4,
                enabled,
                str_in_text_6.as_ptr(),
                enum_text_role_7,
            );
        }
        self
    }
    ///
    /// const QPixmap &pixmap) const
    ///
    /// Draws the given *pixmap* in the specified *rectangle,* according
    /// to the specified *alignment,* using the provided *painter.*
    ///
    /// **See also:** [`draw_item_text()`]
    pub fn draw_item_pixmap<P: PainterTrait<'a>, Q: PixmapTrait<'a>, R: RectTrait<'a>>(
        &self,
        painter: &P,
        rect: &R,
        alignment: i32,
        pixmap: &Q,
    ) -> &Self {
        let (obj_painter_1, _funcs) = painter.get_painter_obj_funcs();
        let (obj_rect_2, _funcs) = rect.get_rect_obj_funcs();
        let (obj_pixmap_4, _funcs) = pixmap.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            ((*funcs).draw_item_pixmap)(
                obj_data,
                obj_painter_1,
                obj_rect_2,
                alignment,
                obj_pixmap_4,
            );
        }
        self
    }
    ///
    /// Returns the style's standard palette.
    ///
    /// Note that on systems that support system colors, the style's
    /// standard palette is not used. In particular, the Windows
    /// Vista and Mac styles do not use the standard palette, but make
    /// use of native theme engines. With these styles, you should not set
    /// the palette with QApplication::setPalette().
    ///
    /// **See also:** [`Application::set_palette`]
    pub fn standard_palette(&self) -> Palette {
        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).standard_palette)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Palette::new_from_rc(t);
            } else {
                ret_val = Palette::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Draws the given primitive *element* with the provided *painter* using the style
    /// options specified by *option.*
    ///
    /// The *widget* argument is optional and may contain a widget that may
    /// aid in drawing the primitive element.
    ///
    /// The table below is listing the primitive elements and their
    /// associated style option subclasses. The style options contain all
    /// the parameters required to draw the elements, including
    /// QStyleOption::state which holds the style flags that are used when
    /// drawing. The table also describes which flags that are set when
    /// casting the given option to the appropriate subclass.
    ///
    /// Note that if a primitive element is not listed here, it is because
    /// it uses a plain QStyleOption object.
    ///
    /// * Primitive Element
    /// * QStyleOption Subclass
    /// * Style Flag
    /// * Remark
    /// * [PE_FrameFocusRect](PE_FrameFocusRect)
    ///
    /// * [QStyleOptionFocusRect](QStyleOptionFocusRect)
    ///
    /// * [State_FocusAtBorder](State_FocusAtBorder)
    ///
    /// * Whether the focus is is at the border or inside the widget.
    /// * {1,2} [PE_IndicatorCheckBox](PE_IndicatorCheckBox)
    ///
    /// * {1,2} [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_NoChange](State_NoChange)
    ///
    /// * Indicates a "tri-state" checkbox.
    /// * [State_On](State_On)
    ///
    /// * Indicates the indicator is checked.
    /// * [PE_IndicatorRadioButton](PE_IndicatorRadioButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_On](State_On)
    ///
    /// * Indicates that a radio button is selected.
    /// * [State_NoChange](State_NoChange)
    ///
    /// * Indicates a "tri-state" controller.
    /// * [State_Enabled](State_Enabled)
    ///
    /// * Indicates the controller is enabled.
    /// * {1,4} [PE_IndicatorBranch](PE_IndicatorBranch)
    ///
    /// * {1,4} [QStyleOption](QStyleOption)
    ///
    /// * [State_Children](State_Children)
    ///
    /// * Indicates that the control for expanding the tree to show child items, should be drawn.
    /// * [State_Item](State_Item)
    ///
    /// * Indicates that a horizontal branch (to show a child item), should be drawn.
    /// * [State_Open](State_Open)
    ///
    /// * Indicates that the tree branch is expanded.
    /// * [State_Sibling](State_Sibling)
    ///
    /// * Indicates that a vertical line (to show a sibling item), should be drawn.
    /// * [PE_IndicatorHeaderArrow](PE_IndicatorHeaderArrow)
    ///
    /// * [QStyleOptionHeader](QStyleOptionHeader)
    ///
    /// * [State_UpArrow](State_UpArrow)
    ///
    /// * Indicates that the arrow should be drawn up; otherwise it should be down.
    /// * [PE_FrameGroupBox,](PE_FrameGroupBox,)
    /// [PE_Frame,](PE_Frame,)
    /// [PE_FrameLineEdit,](PE_FrameLineEdit,)
    /// [PE_FrameMenu,](PE_FrameMenu,)
    /// [PE_FrameDockWidget,](PE_FrameDockWidget,)
    /// [PE_FrameWindow](PE_FrameWindow)
    ///
    /// * [QStyleOptionFrame](QStyleOptionFrame)
    ///
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Indicates that the Frame should be sunken.
    /// * [PE_IndicatorToolBarHandle](PE_IndicatorToolBarHandle)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [State_Horizontal](State_Horizontal)
    ///
    /// * Indicates that the window handle is horizontal instead of vertical.
    /// * [PE_IndicatorSpinPlus,](PE_IndicatorSpinPlus,)
    /// [PE_IndicatorSpinMinus,](PE_IndicatorSpinMinus,)
    /// [PE_IndicatorSpinUp,](PE_IndicatorSpinUp,)
    /// [PE_IndicatorSpinDown,](PE_IndicatorSpinDown,)
    ///
    /// * [QStyleOptionSpinBox](QStyleOptionSpinBox)
    ///
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Indicates that the button is pressed.
    /// * {1,5} [PE_PanelButtonCommand](PE_PanelButtonCommand)
    ///
    /// * {1,5} [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [State_Enabled](State_Enabled)
    ///
    /// * Set if the button is enabled.
    /// * [State_HasFocus](State_HasFocus)
    ///
    /// * Set if the button has input focus.
    /// * [State_Raised](State_Raised)
    ///
    /// * Set if the button is not down, not on and not flat.
    /// * [State_On](State_On)
    ///
    /// * Set if the button is a toggle button and is toggled on.
    /// * [State_Sunken](State_Sunken)
    ///
    /// * Set if the button is down (i.e., the mouse button or the space bar is pressed on the button).
    ///
    /// **See also:** [`draw_complex_control()`]
    /// [`draw_control()`]
    ///
    /// Returns the sub-area for the given *element* as described in the
    /// provided style *option.* The returned rectangle is defined in
    /// screen coordinates.
    ///
    /// The *widget* argument is optional and can be used to aid
    /// determining the area. The QStyleOption object can be cast to the
    /// appropriate type using the qstyleoption_cast() function. See the
    /// table below for the appropriate *option* casts:
    ///
    /// * Sub Element
    /// * QStyleOption Subclass
    /// * [SE_PushButtonContents](SE_PushButtonContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_PushButtonFocusRect](SE_PushButtonFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxIndicator](SE_CheckBoxIndicator)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxContents](SE_CheckBoxContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_CheckBoxFocusRect](SE_CheckBoxFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonIndicator](SE_RadioButtonIndicator)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonContents](SE_RadioButtonContents)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_RadioButtonFocusRect](SE_RadioButtonFocusRect)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [SE_ComboBoxFocusRect](SE_ComboBoxFocusRect)
    ///
    /// * [QStyleOptionComboBox](QStyleOptionComboBox)
    ///
    /// * [SE_ProgressBarGroove](SE_ProgressBarGroove)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [SE_ProgressBarContents](SE_ProgressBarContents)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [SE_ProgressBarLabel](SE_ProgressBarLabel)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    ///
    /// Returns the size of the element described by the specified
    /// *option* and *type,* based on the provided *contentsSize.*
    ///
    /// The *option* argument is a pointer to a QStyleOption or one of
    /// its subclasses. The *option* can be cast to the appropriate type
    /// using the qstyleoption_cast() function. The *widget* is an
    /// optional argument and can contain extra information used for
    /// calculating the size.
    ///
    /// See the table below for the appropriate *option* casts:
    ///
    /// * Contents Type
    /// * QStyleOption Subclass
    /// * [CT_CheckBox](CT_CheckBox)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_ComboBox](CT_ComboBox)
    ///
    /// * [QStyleOptionComboBox](QStyleOptionComboBox)
    ///
    /// * [CT_GroupBox](CT_GroupBox)
    ///
    /// * [QStyleOptionGroupBox](QStyleOptionGroupBox)
    ///
    /// * [CT_HeaderSection](CT_HeaderSection)
    ///
    /// * [QStyleOptionHeader](QStyleOptionHeader)
    ///
    /// * [CT_ItemViewItem](CT_ItemViewItem)
    ///
    /// * [QStyleOptionViewItem](QStyleOptionViewItem)
    ///
    /// * [CT_LineEdit](CT_LineEdit)
    ///
    /// * [QStyleOptionFrame](QStyleOptionFrame)
    ///
    /// * [CT_MdiControls](CT_MdiControls)
    ///
    /// * [QStyleOptionComplex](QStyleOptionComplex)
    ///
    /// * [CT_Menu](CT_Menu)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_MenuItem](CT_MenuItem)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_MenuBar](CT_MenuBar)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_MenuBarItem](CT_MenuBarItem)
    ///
    /// * [QStyleOptionMenuItem](QStyleOptionMenuItem)
    ///
    /// * [CT_ProgressBar](CT_ProgressBar)
    ///
    /// * [QStyleOptionProgressBar](QStyleOptionProgressBar)
    ///
    /// * [CT_PushButton](CT_PushButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_RadioButton](CT_RadioButton)
    ///
    /// * [QStyleOptionButton](QStyleOptionButton)
    ///
    /// * [CT_ScrollBar](CT_ScrollBar)
    ///
    /// * [QStyleOptionSlider](QStyleOptionSlider)
    ///
    /// * [CT_SizeGrip](CT_SizeGrip)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_Slider](CT_Slider)
    ///
    /// * [QStyleOptionSlider](QStyleOptionSlider)
    ///
    /// * [CT_SpinBox](CT_SpinBox)
    ///
    /// * [QStyleOptionSpinBox](QStyleOptionSpinBox)
    ///
    /// * [CT_Splitter](CT_Splitter)
    ///
    /// * [QStyleOption](QStyleOption)
    ///
    /// * [CT_TabBarTab](CT_TabBarTab)
    ///
    /// * [QStyleOptionTab](QStyleOptionTab)
    ///
    /// * [CT_TabWidget](CT_TabWidget)
    ///
    /// * [QStyleOptionTabWidgetFrame](QStyleOptionTabWidgetFrame)
    ///
    /// * [CT_ToolButton](CT_ToolButton)
    ///
    /// * [QStyleOptionToolButton](QStyleOptionToolButton)
    ///
    /// **See also:** ContentsType
    /// [`StyleOption`]
    ///
    /// Returns an integer representing the specified style *hint* for
    /// the given *widget* described by the provided style *option.*
    ///
    /// *returnData* is used when the querying widget needs more detailed data than
    /// the integer that styleHint() returns. See the QStyleHintReturn class
    /// description for details.
    ///
    /// Returns a pixmap for the given *standardPixmap.*
    ///
    /// A standard pixmap is a pixmap that can follow some existing GUI
    /// style or guideline. The *option* argument can be used to pass
    /// extra information required when defining the appropriate
    /// pixmap. The *widget* argument is optional and can also be used to
    /// aid the determination of the pixmap.
    ///
    /// Developers calling standardPixmap() should instead call standardIcon()
    /// Developers who re-implemented standardPixmap() should instead re-implement
    /// standardIcon().
    ///
    /// **See also:** [`standard_icon()`]
    ///
    /// const QWidget *widget = 0) const = 0;
    ///
    /// Returns an icon for the given *standardIcon.*
    ///
    /// The *standardIcon* is a standard pixmap which can follow some
    /// existing GUI style or guideline. The *option* argument can be
    /// used to pass extra information required when defining the
    /// appropriate icon. The *widget* argument is optional and can also
    /// be used to aid the determination of the icon.
    ///
    /// const QPixmap &pixmap, const QStyleOption *option) const
    ///
    /// Returns a copy of the given *pixmap,* styled to conform to the
    /// specified *iconMode* and taking into account the palette
    /// specified by *option.*
    ///
    /// The *option* parameter can pass extra information, but
    /// it must contain a palette.
    ///
    /// Note that not all pixmaps will conform, in which case the returned
    /// pixmap is a plain copy.
    ///
    /// **See also:** [`Icon`]
    ///
    /// Returns the given *logicalRectangle* converted to screen
    /// coordinates based on the specified *direction.* The *boundingRectangle* is used when performing the translation.
    ///
    /// This function is provided to support right-to-left desktops, and
    /// is typically used in implementations of the subControlRect()
    /// function.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    ///
    /// Returns the given *logicalPosition* converted to screen
    /// coordinates based on the specified *direction.* The *boundingRectangle* is used when performing the translation.
    ///
    /// **See also:** [`Widget::layout_direction()`]
    ///
    /// Converts the given *logicalValue* to a pixel position. The *min*
    /// parameter maps to 0, *max* maps to *span* and other values are
    /// distributed evenly in-between.
    ///
    /// This function can handle the entire integer range without
    /// overflow, providing that *span* is less than 4096.
    ///
    /// By default, this function assumes that the maximum value is on the
    /// right for horizontal items and on the bottom for vertical items.
    /// Set the *upsideDown* parameter to true to reverse this behavior.
    ///
    /// **See also:** [`slider_value_from_position()`]
    ///
    /// Converts the given pixel *position* to a logical value. 0 maps to
    /// the *min* parameter, *span* maps to *max* and other values are
    /// distributed evenly in-between.
    ///
    /// This function can handle the entire integer range without
    /// overflow.
    ///
    /// By default, this function assumes that the maximum value is on the
    /// right for horizontal items and on the bottom for vertical
    /// items. Set the *upsideDown* parameter to true to reverse this
    /// behavior.
    ///
    /// **See also:** [`slider_position_from_value()`]
    ///
    /// Transforms an *alignment* of Qt::AlignLeft or Qt::AlignRight
    /// without Qt::AlignAbsolute into Qt::AlignLeft or Qt::AlignRight with
    /// Qt::AlignAbsolute according to the layout *direction.* The other
    /// alignment flags are left untouched.
    ///
    /// If no horizontal alignment was specified, the function returns the
    /// default alignment for the given layout *direction.*
    ///
    /// QWidget::layoutDirection
    ///
    /// Returns a new rectangle of the specified *size* that is aligned to the given *rectangle* according to the specified *alignment* and *direction.*
    ///
    /// QSizePolicy::ControlType control2, Qt::Orientation orientation,
    /// const QStyleOption *option = 0, const QWidget *widget = 0) const
    ///
    /// Returns the spacing that should be used between *control1* and
    /// *control2* in a layout. *orientation* specifies whether the
    /// controls are laid out side by side or stacked vertically. The *option* parameter can be used to pass extra information about the
    /// parent widget. The *widget* parameter is optional and can also
    /// be used if *option* is 0.
    ///
    /// This function is called by the layout system. It is used only if
    /// PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
    /// negative value.
    ///
    /// **See also:** [`combined_layout_spacing()`]
    ///
    /// Returns the spacing that should be used between *controls1* and
    /// *controls2* in a layout. *orientation* specifies whether the
    /// controls are laid out side by side or stacked vertically. The *option* parameter can be used to pass extra information about the
    /// parent widget. The *widget* parameter is optional and can also
    /// be used if *option* is 0.
    ///
    /// *controls1* and *controls2* are OR-combination of zero or more
    /// [control types](QSizePolicy::ControlTypes)
    ///
    ///
    /// This function is called by the layout system. It is used only if
    /// PM_LayoutHorizontalSpacing or PM_LayoutVerticalSpacing returns a
    /// negative value.
    ///
    /// **See also:** [`layout_spacing()`]
    ///
    /// This function returns the current proxy for this style.
    /// By default most styles will return themselves. However
    /// when a proxy style is in use, it will allow the style to
    /// call back into its proxy.
    pub fn proxy(&self) -> Option<Style> {
        let (obj_data, funcs) = self.get_style_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).proxy)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Style::new_from_rc(t);
            } else {
                ret_val = Style::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as i32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as i32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &EventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &EventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&EventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&EventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }
}
pub trait StyleTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_style_obj_funcs(&self) -> (*const RUBase, *const RUStyleFuncs);
}

impl<'a> ObjectTrait<'a> for Style<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> StyleTrait<'a> for Style<'a> {
    #[doc(hidden)]
    fn get_style_obj_funcs(&self) -> (*const RUBase, *const RUStyleFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).style_funcs) }
    }
}
#[repr(u32)]
pub enum StateFlag {
    StateNone,
    StateEnabled,
    StateRaised,
    StateSunken,
    StateOff,
    StateNoChange,
    StateOn,
    StateDownArrow,
    StateHorizontal,
    StateHasFocus,
    StateTop,
    StateBottom,
    StateFocusAtBorder,
    StateAutoRaise,
    StateMouseOver,
    StateUpArrow,
    StateSelected,
    StateActive,
    StateWindow,
    StateOpen,
    StateChildren,
    StateItem,
    StateSibling,
    StateEditing,
    StateKeyboardFocusChange,
    StateReadOnly,
    StateSmall,
    StateMini,
}

#[repr(u32)]
pub enum PrimitiveElement {
    PeFrame,
    PeFrameDefaultButton,
    PeFrameDockWidget,
    PeFrameFocusRect,
    PeFrameGroupBox,
    PeFrameLineEdit,
    PeFrameMenu,
    PeFrameStatusBar,
    PeFrameStatusBarItem,
    PeFrameTabWidget,
    PeFrameWindow,
    PeFrameButtonBevel,
    PeFrameButtonTool,
    PeFrameTabBarBase,
    PePanelButtonCommand,
    PePanelButtonBevel,
    PePanelButtonTool,
    PePanelMenuBar,
    PePanelToolBar,
    PePanelLineEdit,
    PeIndicatorArrowDown,
    PeIndicatorArrowLeft,
    PeIndicatorArrowRight,
    PeIndicatorArrowUp,
    PeIndicatorBranch,
    PeIndicatorButtonDropDown,
    PeIndicatorViewItemCheck,
    PeIndicatorItemViewItemCheck,
    PeIndicatorCheckBox,
    PeIndicatorDockWidgetResizeHandle,
    PeIndicatorHeaderArrow,
    PeIndicatorMenuCheckMark,
    PeIndicatorProgressChunk,
    PeIndicatorRadioButton,
    PeIndicatorSpinDown,
    PeIndicatorSpinMinus,
    PeIndicatorSpinPlus,
    PeIndicatorSpinUp,
    PeIndicatorToolBarHandle,
    PeIndicatorToolBarSeparator,
    PePanelTipLabel,
    PeIndicatorTabTear,
    PeIndicatorTabTearLeft,
    PePanelScrollAreaCorner,
    PeWidget,
    PeIndicatorColumnViewArrow,
    PeIndicatorItemViewItemDrop,
    PePanelItemViewItem,
    PePanelItemViewRow,
    PePanelStatusBar,
    PeIndicatorTabClose,
    PePanelMenu,
    PeIndicatorTabTearRight,
    PeCustomBase,
}

#[repr(u32)]
pub enum ControlElement {
    CePushButton,
    CePushButtonBevel,
    CePushButtonLabel,
    CeCheckBox,
    CeCheckBoxLabel,
    CeRadioButton,
    CeRadioButtonLabel,
    CeTabBarTab,
    CeTabBarTabShape,
    CeTabBarTabLabel,
    CeProgressBar,
    CeProgressBarGroove,
    CeProgressBarContents,
    CeProgressBarLabel,
    CeMenuItem,
    CeMenuScroller,
    CeMenuVMargin,
    CeMenuHMargin,
    CeMenuTearoff,
    CeMenuEmptyArea,
    CeMenuBarItem,
    CeMenuBarEmptyArea,
    CeToolButtonLabel,
    CeHeader,
    CeHeaderSection,
    CeHeaderLabel,
    CeToolBoxTab,
    CeSizeGrip,
    CeSplitter,
    CeRubberBand,
    CeDockWidgetTitle,
    CeScrollBarAddLine,
    CeScrollBarSubLine,
    CeScrollBarAddPage,
    CeScrollBarSubPage,
    CeScrollBarSlider,
    CeScrollBarFirst,
    CeScrollBarLast,
    CeFocusFrame,
    CeComboBoxLabel,
    CeToolBar,
    CeToolBoxTabShape,
    CeToolBoxTabLabel,
    CeHeaderEmptyArea,
    CeColumnViewGrip,
    CeItemViewItem,
    CeShapedFrame,
    CeCustomBase,
}

#[repr(u32)]
pub enum SubElement {
    SePushButtonContents,
    SePushButtonFocusRect,
    SeCheckBoxIndicator,
    SeCheckBoxContents,
    SeCheckBoxFocusRect,
    SeCheckBoxClickRect,
    SeRadioButtonIndicator,
    SeRadioButtonContents,
    SeRadioButtonFocusRect,
    SeRadioButtonClickRect,
    SeComboBoxFocusRect,
    SeSliderFocusRect,
    SeProgressBarGroove,
    SeProgressBarContents,
    SeProgressBarLabel,
    SeToolBoxTabContents,
    SeHeaderLabel,
    SeHeaderArrow,
    SeTabWidgetTabBar,
    SeTabWidgetTabPane,
    SeTabWidgetTabContents,
    SeTabWidgetLeftCorner,
    SeTabWidgetRightCorner,
    SeViewItemCheckIndicator,
    SeItemViewItemCheckIndicator,
    SeTabBarTearIndicator,
    SeTabBarTearIndicatorLeft,
    SeTreeViewDisclosureItem,
    SeLineEditContents,
    SeFrameContents,
    SeDockWidgetCloseButton,
    SeDockWidgetFloatButton,
    SeDockWidgetTitleBarText,
    SeDockWidgetIcon,
    SeCheckBoxLayoutItem,
    SeComboBoxLayoutItem,
    SeDateTimeEditLayoutItem,
    SeDialogButtonBoxLayoutItem,
    SeLabelLayoutItem,
    SeProgressBarLayoutItem,
    SePushButtonLayoutItem,
    SeRadioButtonLayoutItem,
    SeSliderLayoutItem,
    SeSpinBoxLayoutItem,
    SeToolButtonLayoutItem,
    SeFrameLayoutItem,
    SeGroupBoxLayoutItem,
    SeTabWidgetLayoutItem,
    SeItemViewItemDecoration,
    SeItemViewItemText,
    SeItemViewItemFocusRect,
    SeTabBarTabLeftButton,
    SeTabBarTabRightButton,
    SeTabBarTabText,
    SeShapedFrameContents,
    SeToolBarHandle,
    SeTabBarScrollLeftButton,
    SeTabBarScrollRightButton,
    SeTabBarTearIndicatorRight,
    SeCustomBase,
}

#[repr(u32)]
pub enum ComplexControl {
    CcSpinBox,
    CcComboBox,
    CcScrollBar,
    CcSlider,
    CcToolButton,
    CcTitleBar,
    CcDial,
    CcGroupBox,
    CcMdiControls,
    CcCustomBase,
}

#[repr(u32)]
pub enum SubControl {
    ScNone,
    ScScrollBarAddLine,
    ScScrollBarSubLine,
    ScScrollBarAddPage,
    ScScrollBarSubPage,
    ScScrollBarFirst,
    ScScrollBarLast,
    ScScrollBarSlider,
    ScScrollBarGroove,
    ScSpinBoxUp,
    ScSpinBoxDown,
    ScSpinBoxFrame,
    ScSpinBoxEditField,
    ScComboBoxFrame,
    ScComboBoxEditField,
    ScComboBoxArrow,
    ScComboBoxListBoxPopup,
    ScSliderGroove,
    ScSliderHandle,
    ScSliderTickmarks,
    ScToolButton,
    ScToolButtonMenu,
    ScTitleBarSysMenu,
    ScTitleBarMinButton,
    ScTitleBarMaxButton,
    ScTitleBarCloseButton,
    ScTitleBarNormalButton,
    ScTitleBarShadeButton,
    ScTitleBarUnshadeButton,
    ScTitleBarContextHelpButton,
    ScTitleBarLabel,
    ScDialGroove,
    ScDialHandle,
    ScDialTickmarks,
    ScGroupBoxCheckBox,
    ScGroupBoxLabel,
    ScGroupBoxContents,
    ScGroupBoxFrame,
    ScMdiMinButton,
    ScMdiNormalButton,
    ScMdiCloseButton,
    ScCustomBase,
    ScAll,
}

#[repr(u32)]
pub enum PixelMetric {
    PmButtonMargin,
    PmButtonDefaultIndicator,
    PmMenuButtonIndicator,
    PmButtonShiftHorizontal,
    PmButtonShiftVertical,
    PmDefaultFrameWidth,
    PmSpinBoxFrameWidth,
    PmComboBoxFrameWidth,
    PmMaximumDragDistance,
    PmScrollBarExtent,
    PmScrollBarSliderMin,
    PmSliderThickness,
    PmSliderControlThickness,
    PmSliderLength,
    PmSliderTickmarkOffset,
    PmSliderSpaceAvailable,
    PmDockWidgetSeparatorExtent,
    PmDockWidgetHandleExtent,
    PmDockWidgetFrameWidth,
    PmTabBarTabOverlap,
    PmTabBarTabHSpace,
    PmTabBarTabVSpace,
    PmTabBarBaseHeight,
    PmTabBarBaseOverlap,
    PmProgressBarChunkWidth,
    PmSplitterWidth,
    PmTitleBarHeight,
    PmMenuScrollerHeight,
    PmMenuHMargin,
    PmMenuVMargin,
    PmMenuPanelWidth,
    PmMenuTearoffHeight,
    PmMenuDesktopFrameWidth,
    PmMenuBarPanelWidth,
    PmMenuBarItemSpacing,
    PmMenuBarVMargin,
    PmMenuBarHMargin,
    PmIndicatorWidth,
    PmIndicatorHeight,
    PmExclusiveIndicatorWidth,
    PmExclusiveIndicatorHeight,
    PmDialogButtonsSeparator,
    PmDialogButtonsButtonWidth,
    PmDialogButtonsButtonHeight,
    PmMdiSubWindowFrameWidth,
    PmMdiFrameWidth,
    PmMdiSubWindowMinimizedWidth,
    PmMdiMinimizedWidth,
    PmHeaderMargin,
    PmHeaderMarkSize,
    PmHeaderGripMargin,
    PmTabBarTabShiftHorizontal,
    PmTabBarTabShiftVertical,
    PmTabBarScrollButtonWidth,
    PmToolBarFrameWidth,
    PmToolBarHandleExtent,
    PmToolBarItemSpacing,
    PmToolBarItemMargin,
    PmToolBarSeparatorExtent,
    PmToolBarExtensionExtent,
    PmSpinBoxSliderHeight,
    PmDefaultTopLevelMargin,
    PmDefaultChildMargin,
    PmDefaultLayoutSpacing,
    PmToolBarIconSize,
    PmListViewIconSize,
    PmIconViewIconSize,
    PmSmallIconSize,
    PmLargeIconSize,
    PmFocusFrameVMargin,
    PmFocusFrameHMargin,
    PmToolTipLabelFrameWidth,
    PmCheckBoxLabelSpacing,
    PmTabBarIconSize,
    PmSizeGripSize,
    PmDockWidgetTitleMargin,
    PmMessageBoxIconSize,
    PmButtonIconSize,
    PmDockWidgetTitleBarButtonMargin,
    PmRadioButtonLabelSpacing,
    PmLayoutLeftMargin,
    PmLayoutTopMargin,
    PmLayoutRightMargin,
    PmLayoutBottomMargin,
    PmLayoutHorizontalSpacing,
    PmLayoutVerticalSpacing,
    PmTabBarScrollButtonOverlap,
    PmTextCursorWidth,
    PmTabCloseIndicatorWidth,
    PmTabCloseIndicatorHeight,
    PmScrollViewScrollBarSpacing,
    PmScrollViewScrollBarOverlap,
    PmSubMenuOverlap,
    PmTreeViewIndentation,
    PmHeaderDefaultSectionSizeHorizontal,
    PmHeaderDefaultSectionSizeVertical,
    PmTitleBarButtonIconSize,
    PmTitleBarButtonSize,
    PmCustomBase,
}

#[repr(u32)]
pub enum ContentsType {
    CtPushButton,
    CtCheckBox,
    CtRadioButton,
    CtToolButton,
    CtComboBox,
    CtSplitter,
    CtProgressBar,
    CtMenuItem,
    CtMenuBarItem,
    CtMenuBar,
    CtMenu,
    CtTabBarTab,
    CtSlider,
    CtScrollBar,
    CtLineEdit,
    CtSpinBox,
    CtSizeGrip,
    CtTabWidget,
    CtDialogButtons,
    CtHeaderSection,
    CtGroupBox,
    CtMdiControls,
    CtItemViewItem,
    CtCustomBase,
}

#[repr(u32)]
pub enum RequestSoftwareInputPanel {
    RsipOnMouseClickAndAlreadyFocused,
    RsipOnMouseClick,
}

#[repr(u32)]
pub enum StyleHint {
    ShEtchDisabledText,
    ShDitherDisabledText,
    ShScrollBarMiddleClickAbsolutePosition,
    ShScrollBarScrollWhenPointerLeavesControl,
    ShTabBarSelectMouseType,
    ShTabBarAlignment,
    ShHeaderArrowAlignment,
    ShSliderSnapToValue,
    ShSliderSloppyKeyEvents,
    ShProgressDialogCenterCancelButton,
    ShProgressDialogTextLabelAlignment,
    ShPrintDialogRightAlignButtons,
    ShMainWindowSpaceBelowMenuBar,
    ShFontDialogSelectAssociatedText,
    ShMenuAllowActiveAndDisabled,
    ShMenuSpaceActivatesItem,
    ShMenuSubMenuPopupDelay,
    ShScrollViewFrameOnlyAroundContents,
    ShMenuBarAltKeyNavigation,
    ShComboBoxListMouseTracking,
    ShMenuMouseTracking,
    ShMenuBarMouseTracking,
    ShItemViewChangeHighlightOnFocus,
    ShWidgetShareActivation,
    ShWorkspaceFillSpaceOnMaximize,
    ShComboBoxPopup,
    ShTitleBarNoBorder,
    ShSliderStopMouseOverSlider,
    ShScrollBarStopMouseOverSlider,
    ShBlinkCursorWhenTextSelected,
    ShRichTextFullWidthSelection,
    ShMenuScrollable,
    ShGroupBoxTextLabelVerticalAlignment,
    ShGroupBoxTextLabelColor,
    ShMenuSloppySubMenus,
    ShTableGridLineColor,
    ShLineEditPasswordCharacter,
    ShDialogButtonsDefaultButton,
    ShToolBoxSelectedPageTitleBold,
    ShTabBarPreferNoArrows,
    ShScrollBarLeftClickAbsolutePosition,
    ShListViewExpandSelectMouseType,
    ShUnderlineShortcut,
    ShSpinBoxAnimateButton,
    ShSpinBoxKeyPressAutoRepeatRate,
    ShSpinBoxClickAutoRepeatRate,
    ShMenuFillScreenWithScroll,
    ShToolTipLabelOpacity,
    ShDrawMenuBarSeparator,
    ShTitleBarModifyNotification,
    ShButtonFocusPolicy,
    ShMessageBoxUseBorderForButtonSpacing,
    ShTitleBarAutoRaise,
    ShToolButtonPopupDelay,
    ShFocusFrameMask,
    ShRubberBandMask,
    ShWindowFrameMask,
    ShSpinControlsDisableOnBounds,
    ShDialBackgroundRole,
    ShComboBoxLayoutDirection,
    ShItemViewEllipsisLocation,
    ShItemViewShowDecorationSelected,
    ShItemViewActivateItemOnSingleClick,
    ShScrollBarContextMenu,
    ShScrollBarRollBetweenButtons,
    ShSliderAbsoluteSetButtons,
    ShSliderPageSetButtons,
    ShMenuKeyboardSearch,
    ShTabBarElideMode,
    ShDialogButtonLayout,
    ShComboBoxPopupFrameStyle,
    ShMessageBoxTextInteractionFlags,
    ShDialogButtonBoxButtonsHaveIcons,
    ShSpellCheckUnderlineStyle,
    ShMessageBoxCenterButtons,
    ShMenuSelectionWrap,
    ShItemViewMovementWithoutUpdatingSelection,
    ShToolTipMask,
    ShFocusFrameAboveWidget,
    ShTextControlFocusIndicatorTextCharFormat,
    ShWizardStyle,
    ShItemViewArrowKeysNavigateIntoChildren,
    ShMenuMask,
    ShMenuFlashTriggeredItem,
    ShMenuFadeOutOnHide,
    ShSpinBoxClickAutoRepeatThreshold,
    ShItemViewPaintAlternatingRowColorsForEmptyArea,
    ShFormLayoutWrapPolicy,
    ShTabWidgetDefaultTabPosition,
    ShToolBarMovable,
    ShFormLayoutFieldGrowthPolicy,
    ShFormLayoutFormAlignment,
    ShFormLayoutLabelAlignment,
    ShItemViewDrawDelegateFrame,
    ShTabBarCloseButtonPosition,
    ShDockWidgetButtonsHaveFrame,
    ShToolButtonStyle,
    ShRequestSoftwareInputPanel,
    ShScrollBarTransient,
    ShMenuSupportsSections,
    ShToolTipWakeUpDelay,
    ShToolTipFallAsleepDelay,
    ShWidgetAnimate,
    ShSplitterOpaqueResize,
    ShComboBoxUseNativePopup,
    ShLineEditPasswordMaskDelay,
    ShTabBarChangeCurrentDelay,
    ShMenuSubMenuUniDirection,
    ShMenuSubMenuUniDirectionFailCount,
    ShMenuSubMenuSloppySelectOtherActions,
    ShMenuSubMenuSloppyCloseTimeout,
    ShMenuSubMenuResetWhenReenteringParent,
    ShMenuSubMenuDontStartSloppyOnLeave,
    ShItemViewScrollMode,
    ShTitleBarShowToolTipsOnButtons,
    ShWidgetAnimationDuration,
    ShComboBoxAllowWheelScrolling,
    ShSpinBoxButtonsInsideFrame,
    ShCustomBase,
}

#[repr(u32)]
pub enum StandardPixmap {
    SpTitleBarMenuButton,
    SpTitleBarMinButton,
    SpTitleBarMaxButton,
    SpTitleBarCloseButton,
    SpTitleBarNormalButton,
    SpTitleBarShadeButton,
    SpTitleBarUnshadeButton,
    SpTitleBarContextHelpButton,
    SpDockWidgetCloseButton,
    SpMessageBoxInformation,
    SpMessageBoxWarning,
    SpMessageBoxCritical,
    SpMessageBoxQuestion,
    SpDesktopIcon,
    SpTrashIcon,
    SpComputerIcon,
    SpDriveFdIcon,
    SpDriveHdIcon,
    SpDriveCdIcon,
    SpDriveDvdIcon,
    SpDriveNetIcon,
    SpDirOpenIcon,
    SpDirClosedIcon,
    SpDirLinkIcon,
    SpDirLinkOpenIcon,
    SpFileIcon,
    SpFileLinkIcon,
    SpToolBarHorizontalExtensionButton,
    SpToolBarVerticalExtensionButton,
    SpFileDialogStart,
    SpFileDialogEnd,
    SpFileDialogToParent,
    SpFileDialogNewFolder,
    SpFileDialogDetailedView,
    SpFileDialogInfoView,
    SpFileDialogContentsView,
    SpFileDialogListView,
    SpFileDialogBack,
    SpDirIcon,
    SpDialogOkButton,
    SpDialogCancelButton,
    SpDialogHelpButton,
    SpDialogOpenButton,
    SpDialogSaveButton,
    SpDialogCloseButton,
    SpDialogApplyButton,
    SpDialogResetButton,
    SpDialogDiscardButton,
    SpDialogYesButton,
    SpDialogNoButton,
    SpArrowUp,
    SpArrowDown,
    SpArrowLeft,
    SpArrowRight,
    SpArrowBack,
    SpArrowForward,
    SpDirHomeIcon,
    SpCommandLink,
    SpVistaShield,
    SpBrowserReload,
    SpBrowserStop,
    SpMediaPlay,
    SpMediaStop,
    SpMediaPause,
    SpMediaSkipForward,
    SpMediaSkipBackward,
    SpMediaSeekForward,
    SpMediaSeekBackward,
    SpMediaVolume,
    SpMediaVolumeMuted,
    SpLineEditClearButton,
    SpCustomBase,
}
