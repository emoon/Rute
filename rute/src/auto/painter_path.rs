
// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CString, CStr};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;


/// 
/// A painter path is an object composed of a number of graphical
/// building blocks, such as rectangles, ellipses, lines, and curves.
/// Building blocks can be joined in closed subpaths, for example as a
/// rectangle or an ellipse. A closed path has coinciding start and
/// end points. Or they can exist independently as unclosed subpaths,
/// such as lines and curves.
/// 
/// A QPainterPath object can be used for filling, outlining, and
/// clipping. To generate fillable outlines for a given painter path,
/// use the QPainterPathStroker class. The main advantage of painter
/// paths over normal drawing operations is that complex shapes only
/// need to be created once; then they can be drawn many times using
/// only calls to the QPainter::drawPath() function.
/// 
/// QPainterPath provides a collection of functions that can be used
/// to obtain information about the path and its elements. In addition
/// it is possible to reverse the order of the elements using the
/// toReversed() function. There are also several functions to convert
/// this painter path object into a polygon representation.
/// 
/// # Composing a QPainterPath
/// 
/// A QPainterPath object can be constructed as an empty path, with a
/// given start point, or as a copy of another QPainterPath object.
/// Once created, lines and curves can be added to the path using the
/// lineTo(), arcTo(), cubicTo() and quadTo() functions. The lines and
/// curves stretch from the currentPosition() to the position passed
/// as argument.
/// 
/// The currentPosition() of the QPainterPath object is always the end
/// position of the last subpath that was added (or the initial start
/// point). Use the moveTo() function to move the currentPosition()
/// without adding a component. The moveTo() function implicitly
/// starts a new subpath, and closes the previous one. Another way of
/// starting a new subpath is to call the closeSubpath() function
/// which closes the current path by adding a line from the
/// currentPosition() back to the path's start position. Note that the
/// new path will have (0, 0) as its initial currentPosition().
/// 
/// QPainterPath class also provides several convenience functions to
/// add closed subpaths to a painter path: addEllipse(), addPath(),
/// addRect(), addRegion() and addText(). The addPolygon() function
/// adds an *unclosed* subpath. In fact, these functions are all
/// collections of moveTo(), lineTo() and cubicTo() operations.
/// 
/// In addition, a path can be added to the current path using the
/// connectPath() function. But note that this function will connect
/// the last element of the current path to the first element of given
/// one by adding a line.
/// 
/// Below is a code snippet that shows how a QPainterPath object can
/// be used:
/// 
/// * ![qpainterpath-construction.png](qpainterpath-construction.png)
/// 
/// 
/// 
/// The painter path is initially empty when constructed. We first add
/// a rectangle, which is a closed subpath. Then we add two bezier
/// curves which together form a closed subpath even though they are
/// not closed individually. Finally we draw the entire path. The path
/// is filled using the default fill rule, Qt::OddEvenFill. Qt
/// provides two methods for filling paths:
/// 
/// * Qt::OddEvenFill
/// * Qt::WindingFill
/// 
/// * ![qt-fillrule-oddeven.png](qt-fillrule-oddeven.png)
/// 
/// * ![qt-fillrule-winding.png](qt-fillrule-winding.png)
/// 
/// See the Qt::FillRule documentation for the definition of the
/// rules. A painter path's currently set fill rule can be retrieved
/// using the fillRule() function, and altered using the setFillRule()
/// function.
/// 
/// # QPainterPath Information
/// 
/// The QPainterPath class provides a collection of functions that
/// returns information about the path and its elements.
/// 
/// The currentPosition() function returns the end point of the last
/// subpath that was added (or the initial start point). The
/// elementAt() function can be used to retrieve the various subpath
/// elements, the *number* of elements can be retrieved using the
/// elementCount() function, and the isEmpty() function tells whether
/// this QPainterPath object contains any elements at all.
/// 
/// The controlPointRect() function returns the rectangle containing
/// all the points and control points in this path. This function is
/// significantly faster to compute than the exact boundingRect()
/// which returns the bounding rectangle of this painter path with
/// floating point precision.
/// 
/// Finally, QPainterPath provides the contains() function which can
/// be used to determine whether a given point or rectangle is inside
/// the path, and the intersects() function which determines if any of
/// the points inside a given rectangle also are inside this path.
/// 
/// # QPainterPath Conversion
/// 
/// For compatibility reasons, it might be required to simplify the
/// representation of a painter path: QPainterPath provides the
/// toFillPolygon(), toFillPolygons() and toSubpathPolygons()
/// functions which convert the painter path into a polygon. The
/// toFillPolygon() returns the painter path as one single polygon,
/// while the two latter functions return a list of polygons.
/// 
/// The toFillPolygons() and toSubpathPolygons() functions are
/// provided because it is usually faster to draw several small
/// polygons than to draw one large polygon, even though the total
/// number of points drawn is the same. The difference between the two
/// is the *number* of polygons they return: The toSubpathPolygons()
/// creates one polygon for each subpath regardless of intersecting
/// subpaths (i.e. overlapping bounding rectangles), while the
/// toFillPolygons() functions creates only one polygon for
/// overlapping subpaths.
/// 
/// The toFillPolygon() and toFillPolygons() functions first convert
/// all the subpaths to polygons, then uses a rewinding technique to
/// make sure that overlapping subpaths can be filled using the
/// correct fill rule. Note that rewinding inserts additional lines in
/// the polygon so the outline of the fill polygon does not match the
/// outline of the path.
/// 
/// # Examples
/// 
/// Qt provides the [Painter Paths Example](painting/painterpaths)
/// 
/// and the [Vector Deformation example](painting/deform)
/// which are
/// located in Qt's example directory.
/// 
/// The [Painter Paths Example](painting/painterpaths)
/// shows how
/// painter paths can be used to build complex shapes for rendering
/// and lets the user experiment with the filling and stroking. The
/// [Vector Deformation Example](painting/deform)
/// shows how to use
/// QPainterPath to draw text.
/// 
/// * [Painter Paths Example](painting/painterpaths)
/// 
/// * [Vector Deformation Example](painting/deform)
/// 
/// * ![qpainterpath-example.png](qpainterpath-example.png)
/// 
/// * ![qpainterpath-demo.png](qpainterpath-demo.png)
/// 
/// **See also:** QPainterPathStroker
/// QPainter
/// QRegion
/// {Painter Paths Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct PainterPath<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUPainterPathAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl <'a>PainterPath<'a> {
    pub fn new() -> PainterPath<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_painter_path)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void)
        };

        data.set(Some(ffi_data.qt_data));

        PainterPath {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    pub fn new_from_rc(ffi_data: RUPainterPath) -> PainterPath<'a> {
        PainterPath {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUPainterPath) -> PainterPath<'a> {
        PainterPath {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUPainterPath) -> PainterPath<'a> {
        PainterPath {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait PainterPathType<'a> {
    /// 
    /// Swaps painter path *other* with this painter path. This operation is very
    /// fast and never fails.
    fn swap<P: PainterPathType<'a>>(&self, other: &P) -> &Self {
        let (obj_other_1, _funcs) = other.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).swap)(obj_data, obj_other_1);
        }
        self
    }
    /// 
    /// Closes the current subpath by drawing a line to the beginning of
    /// the subpath, automatically starting a new path. The current point
    /// of the new path is (0, 0).
    /// 
    /// If the subpath does not contain any elements, this function does
    /// nothing.
    /// 
    /// **See also:** moveTo()
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    fn close_subpath(&self) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).close_subpath)(obj_data);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Moves the current position to ( *x* , *y* ) and starts a new
    /// subpath, implicitly closing the previous path.
    /// 
    /// Moves the current point to the given *point,* implicitly starting
    /// a new subpath and closing the previous one.
    /// 
    /// **See also:** closeSubpath()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn move_to<P: PointFType<'a>>(&self, p: &P) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).move_to)(obj_data, obj_p_1);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Moves the current position to ( *x* , *y* ) and starts a new
    /// subpath, implicitly closing the previous path.
    /// 
    /// Moves the current point to the given *point,* implicitly starting
    /// a new subpath and closing the previous one.
    /// 
    /// **See also:** closeSubpath()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn move_to(&self, x: f32, y: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).move_to)(obj_data, x, y);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Draws a line from the current position to the point ( *x* ,
    /// *y* ).
    /// 
    /// Adds a straight line from the current position to the given *endPoint.* After the line is drawn, the current position is updated
    /// to be at the end point of the line.
    /// 
    /// **See also:** addPolygon()
    /// addRect()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn line_to<P: PointFType<'a>>(&self, p: &P) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).line_to)(obj_data, obj_p_1);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Draws a line from the current position to the point ( *x* ,
    /// *y* ).
    /// 
    /// Adds a straight line from the current position to the given *endPoint.* After the line is drawn, the current position is updated
    /// to be at the end point of the line.
    /// 
    /// **See also:** addPolygon()
    /// addRect()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn line_to(&self, x: f32, y: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).line_to)(obj_data, x, y);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Creates a move to that lies on the arc that occupies the
    /// QRectF( *x,* *y,* *width,* *height)* at *angle.*
    /// 
    /// Creates a move to that lies on the arc that occupies the given *rectangle* at *angle.*
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// **See also:** moveTo()
    /// arcTo()
    fn arc_move_to<R: RectFType<'a>>(&self, rect: &R, angle: f32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).arc_move_to)(obj_data, obj_rect_1, angle);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Creates a move to that lies on the arc that occupies the
    /// QRectF( *x,* *y,* *width,* *height)* at *angle.*
    /// 
    /// Creates a move to that lies on the arc that occupies the given *rectangle* at *angle.*
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// **See also:** moveTo()
    /// arcTo()
    fn arc_move_to(&self, x: f32, y: f32, w: f32, h: f32, angle: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).arc_move_to)(obj_data, x, y, w, h, angle);
        }
        self
    }
    /// 
    /// height, qreal startAngle, qreal sweepLength)
    /// 
    /// **Overloads**
    /// Creates an arc that occupies the rectangle QRectF( *x,* *y,* *width,* *height),* beginning at the specified *startAngle* and
    /// extending *sweepLength* degrees counter-clockwise.
    /// 
    /// 
    /// Creates an arc that occupies the given *rectangle,* beginning at
    /// the specified *startAngle* and extending *sweepLength* degrees
    /// counter-clockwise.
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// Note that this function connects the starting point of the arc to
    /// the current position if they are not already connected. After the
    /// arc has been added, the current position is the last point in
    /// arc. To draw a line back to the first point, use the
    /// closeSubpath() function.
    /// 
    /// * ![qpainterpath-arcto.png](qpainterpath-arcto.png)
    /// 
    /// 
    /// 
    /// **See also:** arcMoveTo()
    /// addEllipse()
    /// QPainter::drawArc()
    /// QPainter::drawPie()
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    fn arc_to<R: RectFType<'a>>(&self, rect: &R, start_angle: f32, arc_length: f32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).arc_to)(obj_data, obj_rect_1, start_angle, arc_length);
        }
        self
    }
    /// 
    /// height, qreal startAngle, qreal sweepLength)
    /// 
    /// **Overloads**
    /// Creates an arc that occupies the rectangle QRectF( *x,* *y,* *width,* *height),* beginning at the specified *startAngle* and
    /// extending *sweepLength* degrees counter-clockwise.
    /// 
    /// 
    /// Creates an arc that occupies the given *rectangle,* beginning at
    /// the specified *startAngle* and extending *sweepLength* degrees
    /// counter-clockwise.
    /// 
    /// Angles are specified in degrees. Clockwise arcs can be specified
    /// using negative angles.
    /// 
    /// Note that this function connects the starting point of the arc to
    /// the current position if they are not already connected. After the
    /// arc has been added, the current position is the last point in
    /// arc. To draw a line back to the first point, use the
    /// closeSubpath() function.
    /// 
    /// * ![qpainterpath-arcto.png](qpainterpath-arcto.png)
    /// 
    /// 
    /// 
    /// **See also:** arcMoveTo()
    /// addEllipse()
    /// QPainter::drawArc()
    /// QPainter::drawPie()
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    fn arc_to(&self, x: f32, y: f32, w: f32, h: f32, start_angle: f32, arc_length: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).arc_to)(obj_data, x, y, w, h, start_angle, arc_length);
        }
        self
    }
    /// 
    /// qreal c2Y, qreal endPointX, qreal endPointY);
    /// 
    /// **Overloads**
    /// Adds a cubic Bezier curve between the current position and the end
    /// point ( *endPointX* , *endPointY* ) with control points specified
    /// by ( *c1X* , *c1Y* ) and ( *c2X* , *c2Y* ).
    /// 
    /// Adds a cubic Bezier curve between the current position and the
    /// given *endPoint* using the control points specified by *c1,* and
    /// *c2.*
    /// 
    /// After the curve is added, the current position is updated to be at
    /// the end point of the curve.
    /// 
    /// * ![qpainterpath-cubicto.png](qpainterpath-cubicto.png)
    /// 
    /// 
    /// 
    /// **See also:** quadTo()
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    fn cubic_to<P: PointFType<'a>>(&self, ctrl_pt1: &P, ctrl_pt2: &P, end_pt: &P) -> &Self {
        let (obj_ctrl_pt1_1, _funcs) = ctrl_pt1.get_point_f_obj_funcs();
        let (obj_ctrl_pt2_2, _funcs) = ctrl_pt2.get_point_f_obj_funcs();
        let (obj_end_pt_3, _funcs) = end_pt.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).cubic_to)(obj_data, obj_ctrl_pt1_1, obj_ctrl_pt2_2, obj_end_pt_3);
        }
        self
    }
    /// 
    /// qreal c2Y, qreal endPointX, qreal endPointY);
    /// 
    /// **Overloads**
    /// Adds a cubic Bezier curve between the current position and the end
    /// point ( *endPointX* , *endPointY* ) with control points specified
    /// by ( *c1X* , *c1Y* ) and ( *c2X* , *c2Y* ).
    /// 
    /// Adds a cubic Bezier curve between the current position and the
    /// given *endPoint* using the control points specified by *c1,* and
    /// *c2.*
    /// 
    /// After the curve is added, the current position is updated to be at
    /// the end point of the curve.
    /// 
    /// * ![qpainterpath-cubicto.png](qpainterpath-cubicto.png)
    /// 
    /// 
    /// 
    /// **See also:** quadTo()
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    fn cubic_to(&self, ctrl_pt1x: f32, ctrl_pt1y: f32, ctrl_pt2x: f32, ctrl_pt2y: f32, end_ptx: f32, end_pty: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).cubic_to)(obj_data, ctrl_pt1x, ctrl_pt1y, ctrl_pt2x, ctrl_pt2y, end_ptx, end_pty);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Adds a quadratic Bezier curve between the current point and the endpoint
    /// ( *endPointX* , *endPointY* ) with the control point specified by
    /// ( *cx* , *cy* ).
    /// 
    /// Adds a quadratic Bezier curve between the current position and the
    /// given *endPoint* with the control point specified by *c.*
    /// 
    /// After the curve is added, the current point is updated to be at
    /// the end point of the curve.
    /// 
    /// **See also:** cubicTo()
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    fn quad_to<P: PointFType<'a>>(&self, ctrl_pt: &P, end_pt: &P) -> &Self {
        let (obj_ctrl_pt_1, _funcs) = ctrl_pt.get_point_f_obj_funcs();
        let (obj_end_pt_2, _funcs) = end_pt.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).quad_to)(obj_data, obj_ctrl_pt_1, obj_end_pt_2);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Adds a quadratic Bezier curve between the current point and the endpoint
    /// ( *endPointX* , *endPointY* ) with the control point specified by
    /// ( *cx* , *cy* ).
    /// 
    /// Adds a quadratic Bezier curve between the current position and the
    /// given *endPoint* with the control point specified by *c.*
    /// 
    /// After the curve is added, the current point is updated to be at
    /// the end point of the curve.
    /// 
    /// **See also:** cubicTo()
    /// {QPainterPath#Composing a QPainterPath}{Composing a
    /// QPainterPath}
    fn quad_to(&self, ctrl_ptx: f32, ctrl_pty: f32, end_ptx: f32, end_pty: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).quad_to)(obj_data, ctrl_ptx, ctrl_pty, end_ptx, end_pty);
        }
        self
    }
    /// 
    /// Returns the current position of the path.
    fn current_position(&self) -> PointF {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).current_position)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PointF::new_from_rc(t);
            } else {
                ret_val = PointF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// **Overloads**
    /// Adds a rectangle at position ( *x* , *y* ), with the given *width* and *height,* as a closed subpath.
    /// 
    /// Adds the given *rectangle* to this path as a closed subpath.
    /// 
    /// The *rectangle* is added as a clockwise set of lines. The painter
    /// path's current position after the *rectangle* has been added is
    /// at the top-left corner of the rectangle.
    /// 
    /// * ![qpainterpath-addrectangle.png](qpainterpath-addrectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** addRegion()
    /// lineTo()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_rect<R: RectFType<'a>>(&self, rect: &R) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_rect)(obj_data, obj_rect_1);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Adds a rectangle at position ( *x* , *y* ), with the given *width* and *height,* as a closed subpath.
    /// 
    /// Adds the given *rectangle* to this path as a closed subpath.
    /// 
    /// The *rectangle* is added as a clockwise set of lines. The painter
    /// path's current position after the *rectangle* has been added is
    /// at the top-left corner of the rectangle.
    /// 
    /// * ![qpainterpath-addrectangle.png](qpainterpath-addrectangle.png)
    /// 
    /// 
    /// 
    /// **See also:** addRegion()
    /// lineTo()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_rect(&self, x: f32, y: f32, w: f32, h: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_rect)(obj_data, x, y, w, h);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Creates an ellipse within the bounding rectangle defined by its top-left
    /// corner at ( *x,* *y),* *width* and *height,* and adds it to the
    /// painter path as a closed subpath.
    /// 
    /// **Overloads**
    /// Creates an ellipse positioned at *center* with radii *rx* and *ry* ,
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// Creates an ellipse within the specified *boundingRectangle*
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// The ellipse is composed of a clockwise curve, starting and
    /// finishing at zero degrees (the 3 o'clock position).
    /// 
    /// * ![qpainterpath-addellipse.png](qpainterpath-addellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** arcTo()
    /// QPainter::drawEllipse()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_ellipse<R: RectFType<'a>>(&self, rect: &R) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_ellipse)(obj_data, obj_rect_1);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Creates an ellipse within the bounding rectangle defined by its top-left
    /// corner at ( *x,* *y),* *width* and *height,* and adds it to the
    /// painter path as a closed subpath.
    /// 
    /// **Overloads**
    /// Creates an ellipse positioned at *center* with radii *rx* and *ry* ,
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// Creates an ellipse within the specified *boundingRectangle*
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// The ellipse is composed of a clockwise curve, starting and
    /// finishing at zero degrees (the 3 o'clock position).
    /// 
    /// * ![qpainterpath-addellipse.png](qpainterpath-addellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** arcTo()
    /// QPainter::drawEllipse()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_ellipse(&self, x: f32, y: f32, w: f32, h: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_ellipse)(obj_data, x, y, w, h);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Creates an ellipse within the bounding rectangle defined by its top-left
    /// corner at ( *x,* *y),* *width* and *height,* and adds it to the
    /// painter path as a closed subpath.
    /// 
    /// **Overloads**
    /// Creates an ellipse positioned at *center* with radii *rx* and *ry* ,
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// Creates an ellipse within the specified *boundingRectangle*
    /// and adds it to the painter path as a closed subpath.
    /// 
    /// The ellipse is composed of a clockwise curve, starting and
    /// finishing at zero degrees (the 3 o'clock position).
    /// 
    /// * ![qpainterpath-addellipse.png](qpainterpath-addellipse.png)
    /// 
    /// 
    /// 
    /// **See also:** arcTo()
    /// QPainter::drawEllipse()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_ellipse<P: PointFType<'a>>(&self, center: &P, rx: f32, ry: f32) -> &Self {
        let (obj_center_1, _funcs) = center.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_ellipse)(obj_data, obj_center_1, rx, ry);
        }
        self
    }
    /// 
    /// Adds the given *polygon* to the path as an (unclosed) subpath.
    /// 
    /// Note that the current position after the polygon has been added,
    /// is the last point in *polygon.* To draw a line back to the first
    /// point, use the closeSubpath() function.
    /// 
    /// * ![qpainterpath-addpolygon.png](qpainterpath-addpolygon.png)
    /// 
    /// 
    /// 
    /// **See also:** lineTo()
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    fn add_polygon<P: PolygonFType<'a>>(&self, polygon: &P) -> &Self {
        let (obj_polygon_1, _funcs) = polygon.get_polygon_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_polygon)(obj_data, obj_polygon_1);
        }
        self
    }
    /// 
    /// **Overloads**
    /// Adds the given *text* to this path as a set of closed subpaths created
    /// from the *font* supplied. The subpaths are positioned so that the left
    /// end of the text's baseline lies at the point specified by ( *x,* *y).*
    /// 
    /// Adds the given *text* to this path as a set of closed subpaths
    /// created from the *font* supplied. The subpaths are positioned so
    /// that the left end of the text's baseline lies at the specified *point.*
    /// 
    /// * ![qpainterpath-addtext.png](qpainterpath-addtext.png)
    /// 
    /// 
    /// 
    /// **See also:** QPainter::drawText()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_text<F: FontType<'a>, P: PointFType<'a>>(&self, point: &P, f: &F, text: &str) -> &Self {
        let (obj_point_1, _funcs) = point.get_point_f_obj_funcs();
        let (obj_f_2, _funcs) = f.get_font_obj_funcs();
        let str_in_text_3 = CString::new(text).unwrap();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_text)(obj_data, obj_point_1, obj_f_2, str_in_text_3.as_ptr());
        }
        self
    }
    /// 
    /// **Overloads**
    /// Adds the given *text* to this path as a set of closed subpaths created
    /// from the *font* supplied. The subpaths are positioned so that the left
    /// end of the text's baseline lies at the point specified by ( *x,* *y).*
    /// 
    /// Adds the given *text* to this path as a set of closed subpaths
    /// created from the *font* supplied. The subpaths are positioned so
    /// that the left end of the text's baseline lies at the specified *point.*
    /// 
    /// * ![qpainterpath-addtext.png](qpainterpath-addtext.png)
    /// 
    /// 
    /// 
    /// **See also:** QPainter::drawText()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_text<F: FontType<'a>>(&self, x: f32, y: f32, f: &F, text: &str) -> &Self {
        let (obj_f_3, _funcs) = f.get_font_obj_funcs();
        let str_in_text_4 = CString::new(text).unwrap();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_text)(obj_data, x, y, obj_f_3, str_in_text_4.as_ptr());
        }
        self
    }
    /// 
    /// Adds the given *path* to *this* path as a closed subpath.
    /// 
    /// **See also:** connectPath()
    /// {QPainterPath#Composing a
    /// QPainterPath}{Composing a QPainterPath}
    fn add_path<P: PainterPathType<'a>>(&self, path: &P) -> &Self {
        let (obj_path_1, _funcs) = path.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_path)(obj_data, obj_path_1);
        }
        self
    }
    /// 
    /// Adds the given *region* to the path by adding each rectangle in
    /// the region as a separate closed subpath.
    /// 
    /// **See also:** addRect()
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    fn add_region<R: RegionType<'a>>(&self, region: &R) -> &Self {
        let (obj_region_1, _funcs) = region.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_region)(obj_data, obj_region_1);
        }
        self
    }
    /// 
    /// Adds the given rectangle *rect* with rounded corners to the path.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii of
    /// the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range 0.0 to 100.0.
    /// 
    /// **See also:** addRect()
    /// 
    /// **Overloads**
    /// Adds the given rectangle *x,* *y,* *w,* *h* with rounded corners to the path.
    fn add_rounded_rect<R: RectFType<'a>>(&self, rect: &R, x_radius: f32, y_radius: f32, mode: SizeMode) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();
        let enum_mode_4 = mode as i32;

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_rounded_rect)(obj_data, obj_rect_1, x_radius, y_radius, enum_mode_4);
        }
        self
    }
    /// 
    /// Adds the given rectangle *rect* with rounded corners to the path.
    /// 
    /// The *xRadius* and *yRadius* arguments specify the radii of
    /// the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range 0.0 to 100.0.
    /// 
    /// **See also:** addRect()
    /// 
    /// **Overloads**
    /// Adds the given rectangle *x,* *y,* *w,* *h* with rounded corners to the path.
    fn add_rounded_rect(&self, x: f32, y: f32, w: f32, h: f32, x_radius: f32, y_radius: f32, mode: SizeMode) -> &Self {
        let enum_mode_7 = mode as i32;

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_rounded_rect)(obj_data, x, y, w, h, x_radius, y_radius, enum_mode_7);
        }
        self
    }
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    fn add_round_rect<R: RectFType<'a>>(&self, rect: &R, x_rnd: i32, y_rnd: i32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_round_rect)(obj_data, obj_rect_1, x_rnd, y_rnd);
        }
        self
    }
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    fn add_round_rect(&self, x: f32, y: f32, w: f32, h: f32, x_rnd: i32, y_rnd: i32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_round_rect)(obj_data, x, y, w, h, x_rnd, y_rnd);
        }
        self
    }
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    fn add_round_rect<R: RectFType<'a>>(&self, rect: &R, roundness: i32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_round_rect)(obj_data, obj_rect_1, roundness);
        }
        self
    }
    /// 
    /// Adds a rectangle *r* with rounded corners to the path.
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle, *rect,* to the path.
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rectangle with rounded corners to the path. The rectangle
    /// is constructed from *x,* *y,* and the width and height *w*
    /// and *h.*
    /// 
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    /// 
    /// **See also:** addRoundedRect()
    /// 
    /// **Overloads**
    /// Adds a rounded rectangle to the path, defined by the coordinates *x* and *y* with the specified *width* and *height.*
    /// 
    /// The *roundness* argument specifies uniform roundness for the
    /// rectangle. Vertical and horizontal roundness factors will be
    /// adjusted accordingly to act uniformly around both axes. Use this
    /// method if you want a rectangle equally rounded across both the X and
    /// Y axis.
    /// 
    /// **See also:** addRoundedRect()
    fn add_round_rect(&self, x: f32, y: f32, w: f32, h: f32, roundness: i32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).add_round_rect)(obj_data, x, y, w, h, roundness);
        }
        self
    }
    /// 
    /// Connects the given *path* to *this* path by adding a line from the
    /// last element of this path to the first element of the given path.
    /// 
    /// **See also:** addPath()
    /// {QPainterPath#Composing a QPainterPath}{Composing
    /// a QPainterPath}
    fn connect_path<P: PainterPathType<'a>>(&self, path: &P) -> &Self {
        let (obj_path_1, _funcs) = path.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).connect_path)(obj_data, obj_path_1);
        }
        self
    }
    /// 
    /// Returns `true` if the given *point* is inside the path, otherwise
    /// returns `false.`
    /// 
    /// **See also:** intersects()
    /// 
    /// Returns `true` if the given *rectangle* is inside the path,
    /// otherwise returns `false.`
    /// 
    /// Returns `true` if the given path *p* is contained within
    /// the current path. Returns `false` if any edges of the current path and
    /// *p* intersect.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** intersects()
    fn contains<P: PointFType<'a>>(&self, pt: &P) -> bool {
        let (obj_pt_1, _funcs) = pt.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contains)(obj_data, obj_pt_1);
            ret_val
        }
    }
    /// 
    /// Returns `true` if the given *point* is inside the path, otherwise
    /// returns `false.`
    /// 
    /// **See also:** intersects()
    /// 
    /// Returns `true` if the given *rectangle* is inside the path,
    /// otherwise returns `false.`
    /// 
    /// Returns `true` if the given path *p* is contained within
    /// the current path. Returns `false` if any edges of the current path and
    /// *p* intersect.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** intersects()
    fn contains<R: RectFType<'a>>(&self, rect: &R) -> bool {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contains)(obj_data, obj_rect_1);
            ret_val
        }
    }
    /// 
    /// Returns `true` if any point in the given *rectangle* intersects the
    /// path; otherwise returns `false.`
    /// 
    /// There is an intersection if any of the lines making up the
    /// rectangle crosses a part of the path or if any part of the
    /// rectangle overlaps with any area enclosed by the path. This
    /// function respects the current fillRule to determine what is
    /// considered inside the path.
    /// 
    /// **See also:** contains()
    /// 
    /// Returns `true` if the current path intersects at any point the given path *p.*
    /// Also returns `true` if the current path contains or is contained by any part of *p.*
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** contains()
    fn intersects<R: RectFType<'a>>(&self, rect: &R) -> bool {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).intersects)(obj_data, obj_rect_1);
            ret_val
        }
    }
    /// 
    /// Returns the bounding rectangle of this painter path as a rectangle with
    /// floating point precision.
    /// 
    /// **See also:** controlPointRect()
    fn bounding_rect(&self) -> RectF {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).bounding_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = RectF::new_from_rc(t);
            } else {
                ret_val = RectF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Returns the painter path's currently set fill rule.
    /// 
    /// **See also:** setFillRule()
    fn fill_rule(&self) -> FillRule {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).fill_rule)(obj_data);
           let ret_val = { transmute::<i32, FillRule>(ret_val) };
            ret_val
        }
    }
    /// 
    /// Sets the fill rule of the painter path to the given *fillRule.* Qt provides two methods for filling paths:
    /// 
    /// * Qt::OddEvenFill (default)
    /// * Qt::WindingFill
    /// 
    /// * ![qt-fillrule-oddeven.png](qt-fillrule-oddeven.png)
    /// 
    /// * ![qt-fillrule-winding.png](qt-fillrule-winding.png)
    /// 
    /// **See also:** fillRule()
    fn set_fill_rule(&self, fill_rule: FillRule) -> &Self {
        let enum_fill_rule_1 = fill_rule as i32;

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).set_fill_rule)(obj_data, enum_fill_rule_1);
        }
        self
    }
    /// 
    /// Returns `true` if either there are no elements in this path, or if the only
    /// element is a MoveToElement; otherwise returns `false.`
    /// 
    /// **See also:** elementCount()
    fn is_empty(&self) -> bool {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_empty)(obj_data);
            ret_val
        }
    }
    /// 
    /// Creates and returns a reversed copy of the path.
    /// 
    /// It is the order of the elements that is reversed: If a
    /// QPainterPath is composed by calling the moveTo(), lineTo() and
    /// cubicTo() functions in the specified order, the reversed copy is
    /// composed by calling cubicTo(), lineTo() and moveTo().
    fn to_reversed(&self) -> PainterPath {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_reversed)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PainterPath::new_from_rc(t);
            } else {
                ret_val = PainterPath::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Converts the path into a list of polygons using the QTransform
    /// *matrix,* and returns the list.
    /// 
    /// This function creates one polygon for each subpath regardless of
    /// intersecting subpaths (i.e. overlapping bounding rectangles). To
    /// make sure that such overlapping subpaths are filled correctly, use
    /// the toFillPolygons() function instead.
    /// 
    /// **See also:** toFillPolygons()
    /// toFillPolygon()
    /// {QPainterPath#QPainterPath
    /// Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    fn to_subpath_polygons<M: MatrixType<'a>>(&self, matrix: &M) -> RefArray<PolygonF, WrapperRcOwn> {
        let (obj_matrix_1, _funcs) = matrix.get_matrix_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_subpath_polygons)(obj_data, obj_matrix_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PolygonF::new_from_rc(t);
            } else {
                ret_val = PolygonF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** toSubpathPolygons()
    /// toFillPolygon()
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    fn to_fill_polygons<M: MatrixType<'a>>(&self, matrix: &M) -> RefArray<PolygonF, WrapperRcOwn> {
        let (obj_matrix_1, _funcs) = matrix.get_matrix_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_fill_polygons)(obj_data, obj_matrix_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PolygonF::new_from_rc(t);
            } else {
                ret_val = PolygonF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** toSubpathPolygons()
    /// toFillPolygon()
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    /// 
    /// Converts the path into a polygon using the QTransform
    /// *matrix,* and returns the polygon.
    /// 
    /// The polygon is created by first converting all subpaths to
    /// polygons, then using a rewinding technique to make sure that
    /// overlapping subpaths can be filled using the correct fill rule.
    /// 
    /// Note that rewinding inserts addition lines in the polygon so
    /// the outline of the fill polygon does not match the outline of
    /// the path.
    /// 
    /// **See also:** toSubpathPolygons()
    /// toFillPolygons()
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    fn to_fill_polygon<M: MatrixType<'a>>(&self, matrix: &M) -> PolygonF {
        let (obj_matrix_1, _funcs) = matrix.get_matrix_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_fill_polygon)(obj_data, obj_matrix_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PolygonF::new_from_rc(t);
            } else {
                ret_val = PolygonF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Converts the path into a list of polygons using the QTransform
    /// *matrix,* and returns the list.
    /// 
    /// This function creates one polygon for each subpath regardless of
    /// intersecting subpaths (i.e. overlapping bounding rectangles). To
    /// make sure that such overlapping subpaths are filled correctly, use
    /// the toFillPolygons() function instead.
    /// 
    /// **See also:** toFillPolygons()
    /// toFillPolygon()
    /// {QPainterPath#QPainterPath
    /// Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    fn to_subpath_polygons<T: TransformType<'a>>(&self, matrix: &T) -> RefArray<PolygonF, WrapperRcOwn> {
        let (obj_matrix_1, _funcs) = matrix.get_transform_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_subpath_polygons)(obj_data, obj_matrix_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PolygonF::new_from_rc(t);
            } else {
                ret_val = PolygonF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** toSubpathPolygons()
    /// toFillPolygon()
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    fn to_fill_polygons<T: TransformType<'a>>(&self, matrix: &T) -> RefArray<PolygonF, WrapperRcOwn> {
        let (obj_matrix_1, _funcs) = matrix.get_transform_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_fill_polygons)(obj_data, obj_matrix_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PolygonF::new_from_rc(t);
            } else {
                ret_val = PolygonF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Converts the path into a list of polygons using the
    /// QTransform *matrix,* and returns the list.
    /// 
    /// The function differs from the toFillPolygon() function in that it
    /// creates several polygons. It is provided because it is usually
    /// faster to draw several small polygons than to draw one large
    /// polygon, even though the total number of points drawn is the same.
    /// 
    /// The toFillPolygons() function differs from the toSubpathPolygons()
    /// function in that it create only polygon for subpaths that have
    /// overlapping bounding rectangles.
    /// 
    /// Like the toFillPolygon() function, this function uses a rewinding
    /// technique to make sure that overlapping subpaths can be filled
    /// using the correct fill rule. Note that rewinding inserts addition
    /// lines in the polygons so the outline of the fill polygon does not
    /// match the outline of the path.
    /// 
    /// **See also:** toSubpathPolygons()
    /// toFillPolygon()
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    /// 
    /// Converts the path into a polygon using the QTransform
    /// *matrix,* and returns the polygon.
    /// 
    /// The polygon is created by first converting all subpaths to
    /// polygons, then using a rewinding technique to make sure that
    /// overlapping subpaths can be filled using the correct fill rule.
    /// 
    /// Note that rewinding inserts addition lines in the polygon so
    /// the outline of the fill polygon does not match the outline of
    /// the path.
    /// 
    /// **See also:** toSubpathPolygons()
    /// toFillPolygons()
    /// {QPainterPath#QPainterPath Conversion}{QPainterPath Conversion}
    /// 
    /// **Overloads**
    fn to_fill_polygon<T: TransformType<'a>>(&self, matrix: &T) -> PolygonF {
        let (obj_matrix_1, _funcs) = matrix.get_transform_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).to_fill_polygon)(obj_data, obj_matrix_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PolygonF::new_from_rc(t);
            } else {
                ret_val = PolygonF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Returns the number of path elements in the painter path.
    /// 
    /// **See also:** ElementType
    /// elementAt()
    /// isEmpty()
    fn element_count(&self) -> i32 {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).element_count)(obj_data);
            ret_val
        }
    }
    /// 
    /// Returns the element at the given *index* in the painter path.
    /// 
    /// **See also:** ElementType
    /// elementCount()
    /// isEmpty()
    fn element_at(&self, i: i32) -> Element {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).element_at)(obj_data, i);
           let ret_val = { transmute::<i32, Element>(ret_val) };
            ret_val
        }
    }
    /// 
    /// Sets the x and y coordinate of the element at index *index* to *x* and *y.*
    fn set_element_position_at(&self, i: i32, x: f32, y: f32) -> &Self {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            ((*funcs).set_element_position_at)(obj_data, i, x, y);
        }
        self
    }
    /// 
    /// Returns the length of the current path.
    fn length(&self) -> f32 {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).length)(obj_data);
            ret_val
        }
    }
    /// 
    /// Returns percentage of the whole path at the specified length *len.*
    /// 
    /// Note that similarly to other percent methods, the percentage measurement
    /// is not linear with regards to the length, if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    fn percent_at_length(&self, t: f32) -> f32 {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).percent_at_length)(obj_data, t);
            ret_val
        }
    }
    /// 
    /// Returns the point at at the percentage *t* of the current path.
    /// The argument *t* has to be between 0 and 1.
    /// 
    /// Note that similarly to other percent methods, the percentage measurement
    /// is not linear with regards to the length, if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    fn point_at_percent(&self, t: f32) -> PointF {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).point_at_percent)(obj_data, t);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PointF::new_from_rc(t);
            } else {
                ret_val = PointF::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Returns the angle of the path tangent at the percentage *t.*
    /// The argument *t* has to be between 0 and 1.
    /// 
    /// Positive values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock position.
    /// 
    /// Note that similarly to the other percent methods, the percentage measurement
    /// is not linear with regards to the length if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    fn angle_at_percent(&self, t: f32) -> f32 {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).angle_at_percent)(obj_data, t);
            ret_val
        }
    }
    /// 
    /// Returns the slope of the path at the percentage *t.* The
    /// argument *t* has to be between 0 and 1.
    /// 
    /// Note that similarly to other percent methods, the percentage measurement
    /// is not linear with regards to the length, if curves are present
    /// in the path. When curves are present the percentage argument is mapped
    /// to the t parameter of the Bezier equations.
    fn slope_at_percent(&self, t: f32) -> f32 {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).slope_at_percent)(obj_data, t);
            ret_val
        }
    }
    /// 
    /// Returns `true` if any point in the given *rectangle* intersects the
    /// path; otherwise returns `false.`
    /// 
    /// There is an intersection if any of the lines making up the
    /// rectangle crosses a part of the path or if any part of the
    /// rectangle overlaps with any area enclosed by the path. This
    /// function respects the current fillRule to determine what is
    /// considered inside the path.
    /// 
    /// **See also:** contains()
    /// 
    /// Returns `true` if the current path intersects at any point the given path *p.*
    /// Also returns `true` if the current path contains or is contained by any part of *p.*
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** contains()
    fn intersects<P: PainterPathType<'a>>(&self, p: &P) -> bool {
        let (obj_p_1, _funcs) = p.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).intersects)(obj_data, obj_p_1);
            ret_val
        }
    }
    /// 
    /// Returns `true` if the given *point* is inside the path, otherwise
    /// returns `false.`
    /// 
    /// **See also:** intersects()
    /// 
    /// Returns `true` if the given *rectangle* is inside the path,
    /// otherwise returns `false.`
    /// 
    /// Returns `true` if the given path *p* is contained within
    /// the current path. Returns `false` if any edges of the current path and
    /// *p* intersect.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// 
    /// **See also:** intersects()
    fn contains<P: PainterPathType<'a>>(&self, p: &P) -> bool {
        let (obj_p_1, _funcs) = p.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contains)(obj_data, obj_p_1);
            ret_val
        }
    }
    /// 
    /// Returns a path which is the union of this path's fill area and *p's* fill area.
    /// 
    /// Set operations on paths will treat the paths as areas. Non-closed
    /// paths will be treated as implicitly closed.
    /// Bezier curves may be flattened to line segments due to numerical instability of
    /// doing bezier curve intersections.
    /// 
    /// **See also:** intersected()
    /// subtracted()
    fn united<P: PainterPathType<'a>>(&self, r: &P) -> PainterPath {
        let (obj_r_1, _funcs) = r.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).united)(obj_data, obj_r_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PainterPath::new_from_rc(t);
            } else {
                ret_val = PainterPath::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Returns a path which is the intersection of this path's fill area and *p's* fill area.
    /// Bezier curves may be flattened to line segments due to numerical instability of
    /// doing bezier curve intersections.
    fn intersected<P: PainterPathType<'a>>(&self, r: &P) -> PainterPath {
        let (obj_r_1, _funcs) = r.get_painter_path_obj_funcs();

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).intersected)(obj_data, obj_r_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PainterPath::new_from_rc(t);
            } else {
                ret_val = PainterPath::new_from_owned(t);
            }
            ret_val
        }
    }
    /// 
    /// Returns a simplified version of this path. This implies merging all subpaths that intersect,
    /// and returning a path containing no intersecting edges. Consecutive parallel lines will also
    /// be merged. The simplified path will always use the default fill rule, Qt::OddEvenFill.
    /// Bezier curves may be flattened to line segments due to numerical instability of
    /// doing bezier curve intersections.
    fn simplified(&self) -> PainterPath {

        let (obj_data, funcs) = self.get_painter_path_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).simplified)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PainterPath::new_from_rc(t);
            } else {
                ret_val = PainterPath::new_from_owned(t);
            }
            ret_val
        }
    }

    #[inline]
    fn get_painter_path_obj_funcs(&self) -> (*const RUBase, *const RUPainterPathFuncs);
}

impl<'a> PainterPathType<'a> for PainterPath<'a> {
    #[inline]
    fn get_painter_path_obj_funcs(&self) -> (*const RUBase, *const RUPainterPathFuncs) {
        let obj = self.data.get().unwrap();
        unsafe {
            (obj, (*self.all_funcs).painter_path_funcs)
        }
    }
}
