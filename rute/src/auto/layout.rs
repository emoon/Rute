// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports

#[allow(unused_imports)]
use auto::layout_ffi::*;
#[allow(unused_imports)]
use auto::layout_item::LayoutItem;
#[allow(unused_imports)]
use auto::layout_item::LayoutItemTrait;
#[allow(unused_imports)]
use auto::layout_item::*;
#[allow(unused_imports)]
use auto::layout_item_ffi::*;
#[allow(unused_imports)]
use auto::layout_item_ffi::*;
#[allow(unused_imports)]
use auto::margins::Margins;
#[allow(unused_imports)]
use auto::margins::MarginsTrait;
#[allow(unused_imports)]
use auto::margins_ffi::*;
#[allow(unused_imports)]
use auto::object::*;
#[allow(unused_imports)]
use auto::object_ffi::*;
#[allow(unused_imports)]
use auto::rect::Rect;
#[allow(unused_imports)]
use auto::rute::*;
#[allow(unused_imports)]
use auto::rute_enums::Alignment;
#[allow(unused_imports)]
use auto::rute_enums::FindChildOptions;
#[allow(unused_imports)]
use auto::rute_enums::Orientations;
#[allow(unused_imports)]
use auto::rute_ffi::*;
#[allow(unused_imports)]
use auto::size::Size;
#[allow(unused_imports)]
use auto::widget::Widget;
#[allow(unused_imports)]
use auto::widget::WidgetTrait;
#[allow(unused_imports)]
use auto::widget_ffi::*;
///
/// This is an abstract base class inherited by the concrete classes
/// QBoxLayout, QGridLayout, QFormLayout, and QStackedLayout.
///
/// For users of QLayout subclasses or of QMainWindow there is seldom
/// any need to use the basic functions provided by QLayout, such as
/// setSizeConstraint() or setMenuBar(). See [Layout Management](Layout%20Management)
/// for more information.
///
/// To make your own layout manager, implement the functions
/// addItem(), sizeHint(), setGeometry(), itemAt() and takeAt(). You
/// should also implement minimumSize() to ensure your layout isn't
/// resized to zero size if there is too little space. To support
/// children whose heights depend on their widths, implement
/// hasHeightForWidth() and heightForWidth(). See the
/// [Border Layout](layouts/borderlayout)
/// and
/// [Flow Layout](layouts/flowlayout)
/// examples for
/// more information about implementing custom layout managers.
///
/// Geometry management stops when the layout manager is deleted.
///
/// **See also:** [`LayoutItem`]
/// {Layout Management}
/// {Basic Layouts Example}
/// {Border Layout Example}
/// {Flow Layout Example}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Layout<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RULayoutAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Layout<'a> {
    pub fn new_from_rc(ffi_data: RULayout) -> Layout<'a> {
        Layout {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RULayout) -> Layout<'a> {
        Layout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RULayout) -> Layout<'a> {
        Layout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait LayoutTrait<'a> {
    ///
    /// Use setContentsMargins() and getContentsMargins() instead.
    ///
    /// **See also:** [`contents_rect()`]
    /// spacing
    ///
    fn margin(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).margin)(obj_data);
            ret_val
        }
    }
    ///
    /// If no value is explicitly set, the layout's spacing is inherited
    /// from the parent layout, or from the style settings for the parent
    /// widget.
    ///
    /// For QGridLayout and QFormLayout, it is possible to set different horizontal and
    /// vertical spacings using [setHorizontalSpacing()](QGridLayout::)
    ///
    /// and [setVerticalSpacing()](QGridLayout::)
    /// . In that case,
    /// spacing() returns -1.
    ///
    /// **See also:** [`contents_rect()`]
    /// [`get_contents_margins()`]
    /// [`Style::layout_spacing`]
    /// [`Style::pixel_metric`]
    fn spacing(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacing)(obj_data);
            ret_val
        }
    }
    ///
    fn set_margin(&self, arg0: i32) {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_margin)(obj_data, arg0);
        }
    }
    fn set_spacing(&self, arg0: i32) {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_spacing)(obj_data, arg0);
        }
    }
    ///
    /// Sets the *left,* *top,* *right,* and *bottom* margins to use
    /// around the layout.
    ///
    /// By default, QLayout uses the values provided by the style. On
    /// most platforms, the margin is 11 pixels in all directions.
    ///
    /// **See also:** [`get_contents_margins()`]
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutLeftMargin}
    /// {QStyle::}{PM_LayoutTopMargin}
    /// {QStyle::}{PM_LayoutRightMargin}
    /// {QStyle::}{PM_LayoutBottomMargin}
    ///
    /// Sets the *margins* to use around the layout.
    ///
    /// By default, QLayout uses the values provided by the style. On
    /// most platforms, the margin is 11 pixels in all directions.
    ///
    /// **See also:** [`contents_margins()`]
    fn set_contents_margins(&self, left: i32, top: i32, right: i32, bottom: i32) {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins)(obj_data, left, top, right, bottom);
        }
    }
    ///
    /// Sets the *left,* *top,* *right,* and *bottom* margins to use
    /// around the layout.
    ///
    /// By default, QLayout uses the values provided by the style. On
    /// most platforms, the margin is 11 pixels in all directions.
    ///
    /// **See also:** [`get_contents_margins()`]
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutLeftMargin}
    /// {QStyle::}{PM_LayoutTopMargin}
    /// {QStyle::}{PM_LayoutRightMargin}
    /// {QStyle::}{PM_LayoutBottomMargin}
    ///
    /// Sets the *margins* to use around the layout.
    ///
    /// By default, QLayout uses the values provided by the style. On
    /// most platforms, the margin is 11 pixels in all directions.
    ///
    /// **See also:** [`contents_margins()`]
    fn set_contents_margins_2(&self, margins: &MarginsTrait) {
        let (obj_margins_1, _funcs) = margins.get_margins_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins_2)(obj_data, obj_margins_1);
        }
    }
    ///
    /// Extracts the left, top, right, and bottom margins used around the
    /// layout, and assigns them to * *left,* * *top,* * *right,* and * *bottom* (unless they are null pointers).
    ///
    /// By default, QLayout uses the values provided by the style. On
    /// most platforms, the margin is 11 pixels in all directions.
    ///
    /// **See also:** [`set_contents_margins()`]
    /// [`Style::pixel_metric`]
    /// {QStyle::}{PM_LayoutLeftMargin}
    /// {QStyle::}{PM_LayoutTopMargin}
    /// {QStyle::}{PM_LayoutRightMargin}
    /// {QStyle::}{PM_LayoutBottomMargin}
    fn contents_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the layout's geometry() rectangle, but taking into account the
    /// contents margins.
    ///
    /// **See also:** [`set_contents_margins()`]
    /// [`get_contents_margins()`]
    fn contents_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the alignment for widget *w* to *alignment* and returns
    /// true if *w* is found in this layout (not including child
    /// layouts); otherwise returns `false.`
    ///
    /// **Overloads**
    /// Sets the alignment for the layout *l* to *alignment* and
    /// returns `true` if *l* is found in this layout (not including child
    /// layouts); otherwise returns `false.`
    fn set_alignment(&self, w: &WidgetTrait, alignment: Alignment) -> bool {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();
        let enum_alignment_2 = alignment as i32;

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment)(obj_data, obj_w_1, enum_alignment_2);
            ret_val
        }
    }
    ///
    /// Sets the alignment for widget *w* to *alignment* and returns
    /// true if *w* is found in this layout (not including child
    /// layouts); otherwise returns `false.`
    ///
    /// **Overloads**
    /// Sets the alignment for the layout *l* to *alignment* and
    /// returns `true` if *l* is found in this layout (not including child
    /// layouts); otherwise returns `false.`
    fn set_alignment_2(&self, l: &LayoutTrait, alignment: Alignment) -> bool {
        let (obj_l_1, _funcs) = l.get_layout_obj_funcs();
        let enum_alignment_2 = alignment as i32;

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment_2)(obj_data, obj_l_1, enum_alignment_2);
            ret_val
        }
    }
    ///
    /// Tells the geometry manager to place the menu bar *widget* at the
    /// top of parentWidget(), outside QWidget::contentsMargins(). All
    /// child widgets are placed below the bottom edge of the menu bar.
    fn set_menu_bar(&self, w: &WidgetTrait) {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_menu_bar)(obj_data, obj_w_1);
        }
    }
    ///
    /// Returns the menu bar set for this layout, or 0 if no menu bar is
    /// set.
    fn menu_bar(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).menu_bar)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the parent widget of this layout, or 0 if this layout is
    /// not installed on any widget.
    ///
    /// If the layout is a sub-layout, this function returns the parent
    /// widget of the parent layout.
    ///
    /// **See also:** [`parent()`]
    fn parent_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    fn invalidate(&self) {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).invalidate)(obj_data);
        }
    }
    ///
    /// Redoes the layout for parentWidget() if necessary.
    ///
    /// You should generally not need to call this because it is
    /// automatically called at the most appropriate times. It returns
    /// true if the layout was redone.
    ///
    /// **See also:** [`update()`]
    /// [`Widget::update_geometry`]
    fn activate(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).activate)(obj_data);
            ret_val
        }
    }
    ///
    /// Updates the layout for parentWidget().
    ///
    /// You should generally not need to call this because it is
    /// automatically called at the most appropriate times.
    ///
    /// **See also:** [`activate()`]
    /// [`invalidate()`]
    fn update(&self) {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).update)(obj_data);
        }
    }
    ///
    /// Adds widget *w* to this layout in a manner specific to the
    /// layout. This function uses addItem().
    fn add_widget(&self, w: &WidgetTrait) {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).add_widget)(obj_data, obj_w_1);
        }
    }
    ///
    /// Implemented in subclasses to add an *item.* How it is added is
    /// specific to each subclass.
    ///
    /// This function is not usually called in application code. To add a widget
    /// to a layout, use the addWidget() function; to add a child layout, use the
    /// addLayout() function provided by the relevant QLayout subclass.
    ///
    /// **Note:** The ownership of *item* is transferred to the layout, and it's
    /// the layout's responsibility to delete it.
    ///
    /// **See also:** [`add_widget()`]
    /// [`BoxLayout::add_layout`]
    /// [`GridLayout::add_layout`]
    fn add_item(&self, arg0: &LayoutItemTrait) {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).add_item)(obj_data, obj_arg0_1);
        }
    }
    ///
    /// Removes the widget *widget* from the layout. After this call, it
    /// is the caller's responsibility to give the widget a reasonable
    /// geometry or to put the widget back into a layout or to explicitly
    /// hide it if necessary.
    ///
    /// **Note:** The ownership of *widget* remains the same as
    /// when it was added.
    ///
    /// **See also:** [`remove_item()`]
    /// [`Widget::set_geometry`]
    /// [`add_widget()`]
    fn remove_widget(&self, w: &WidgetTrait) {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_widget)(obj_data, obj_w_1);
        }
    }
    ///
    /// Removes the layout item *item* from the layout. It is the
    /// caller's responsibility to delete the item.
    ///
    /// Notice that *item* can be a layout (since QLayout inherits
    /// QLayoutItem).
    ///
    /// **See also:** [`remove_widget()`]
    /// [`add_item()`]
    fn remove_item(&self, arg0: &LayoutItemTrait) {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_item)(obj_data, obj_arg0_1);
        }
    }
    ///
    /// Returns whether this layout can make use of more space than
    /// sizeHint(). A value of Qt::Vertical or Qt::Horizontal means that
    /// it wants to grow in only one dimension, whereas Qt::Vertical |
    /// Qt::Horizontal means that it wants to grow in both dimensions.
    ///
    /// The default implementation returns Qt::Horizontal | Qt::Vertical.
    /// Subclasses reimplement it to return a meaningful value based on
    /// their child widgets's [size policies](QSizePolicy)
    ///
    ///
    /// **See also:** [`size_hint()`]
    fn expanding_directions(&self) -> Orientations {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).expanding_directions)(obj_data);
            let ret_val = { transmute::<i32, Orientations>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the minimum size of this layout. This is the smallest
    /// size that the layout can have while still respecting the
    /// specifications.
    ///
    /// The returned value doesn't include the space required by
    /// QWidget::setContentsMargins() or menuBar().
    ///
    /// The default implementation allows unlimited resizing.
    fn minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the maximum size of this layout. This is the largest size
    /// that the layout can have while still respecting the
    /// specifications.
    ///
    /// The returned value doesn't include the space required by
    /// QWidget::setContentsMargins() or menuBar().
    ///
    /// The default implementation allows unlimited resizing.
    fn maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Must be implemented in subclasses to return the layout item at *index.* If there is no such item, the function must return 0.
    /// Items are numbered consecutively from 0. If an item is deleted, other items will be renumbered.
    ///
    /// This function can be used to iterate over a layout. The following
    /// code will draw a rectangle for each layout item in the layout structure of the widget.
    ///
    /// **See also:** [`count()`]
    /// [`take_at()`]
    fn item_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Must be implemented in subclasses to remove the layout item at *index* from the layout, and return the item. If there is no such
    /// item, the function must do nothing and return 0. Items are numbered
    /// consecutively from 0. If an item is removed, other items will be
    /// renumbered.
    ///
    /// The following code fragment shows a safe way to remove all items
    /// from a layout:
    ///
    /// **See also:** [`item_at()`]
    /// [`count()`]
    fn take_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).take_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Searches for widget *widget* in this layout (not including child
    /// layouts).
    ///
    /// Returns the index of *widget,* or -1 if *widget* is not found.
    ///
    /// The default implementation iterates over all items using itemAt()
    fn index_of(&self, arg0: &WidgetTrait) -> i32 {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).index_of)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    ///
    /// Must be implemented in subclasses to return the number of items
    /// in the layout.
    ///
    /// **See also:** [`item_at()`]
    fn count(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).count)(obj_data);
            ret_val
        }
    }
    ///
    fn is_empty(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_empty)(obj_data);
            ret_val
        }
    }
    ///
    /// Searches for widget *from* and replaces it with widget *to* if found.
    /// Returns the layout item that contains the widget *from* on success.
    /// Otherwise `0` is returned. If *options* contains `Qt::FindChildrenRecursively`
    /// (the default), sub-layouts are searched for doing the replacement.
    /// Any other flag in *options* is ignored.
    ///
    /// Notice that the returned item therefore might not belong to this layout,
    /// but to a sub-layout.
    ///
    /// The returned layout item is no longer owned by the layout and should be
    /// either deleted or inserted to another layout. The widget *from* is no
    /// longer managed by the layout and may need to be deleted or hidden. The
    /// parent of widget *from* is left unchanged.
    ///
    /// This function works for the built-in Qt layouts, but might not work for
    /// custom layouts.
    ///
    /// **See also:** [`index_of()`]
    fn replace_widget(
        &self,
        from: &WidgetTrait,
        to: &WidgetTrait,
        options: FindChildOptions,
    ) -> Option<LayoutItem> {
        let (obj_from_1, _funcs) = from.get_widget_obj_funcs();
        let (obj_to_2, _funcs) = to.get_widget_obj_funcs();
        let enum_options_3 = options as i32;

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).replace_widget)(obj_data, obj_from_1, obj_to_2, enum_options_3);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    fn total_height_for_width(&self, w: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_height_for_width)(obj_data, w);
            ret_val
        }
    }
    fn total_minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    fn total_maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    fn total_size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    fn layout(&self) -> Option<Layout> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Layout::new_from_rc(t);
            } else {
                ret_val = Layout::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Enables this layout if *enable* is true, otherwise disables it.
    ///
    /// An enabled layout adjusts dynamically to changes; a disabled
    /// layout acts as if it did not exist.
    ///
    /// By default all layouts are enabled.
    ///
    /// **See also:** [`is_enabled()`]
    fn set_enabled(&self, arg0: bool) {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_enabled)(obj_data, arg0);
        }
    }
    ///
    /// Returns `true` if the layout is enabled; otherwise returns `false.`
    ///
    /// **See also:** [`set_enabled()`]
    fn is_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_enabled)(obj_data);
            ret_val
        }
    }

    #[inline]
    fn get_layout_obj_funcs(&self) -> (*const RUBase, *const RULayoutFuncs);
}

impl<'a> ObjectTrait<'a> for Layout<'a> {
    #[inline]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> LayoutItemTrait<'a> for Layout<'a> {
    #[inline]
    fn get_layout_item_obj_funcs(&self) -> (*const RUBase, *const RULayoutItemFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_item_funcs) }
    }
}

impl<'a> LayoutTrait<'a> for Layout<'a> {
    #[inline]
    fn get_layout_obj_funcs(&self) -> (*const RUBase, *const RULayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_funcs) }
    }
}
#[repr(u32)]
pub enum SizeConstraint {
    SetDefaultConstraint,
    SetNoConstraint,
    SetMinimumSize,
    SetFixedSize,
    SetMaximumSize,
    SetMinAndMaxSize,
}
