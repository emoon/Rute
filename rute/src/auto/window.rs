// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports

#[allow(unused_imports)]
use auto::cursor::Cursor;
#[allow(unused_imports)]
use auto::cursor::CursorTrait;
#[allow(unused_imports)]
use auto::cursor_ffi::*;
#[allow(unused_imports)]
use auto::expose_event::ExposeEvent;
#[allow(unused_imports)]
use auto::expose_event::ExposeEventTrait;
#[allow(unused_imports)]
use auto::expose_event_ffi::*;
#[allow(unused_imports)]
use auto::focus_event::FocusEvent;
#[allow(unused_imports)]
use auto::focus_event::FocusEventTrait;
#[allow(unused_imports)]
use auto::focus_event_ffi::*;
#[allow(unused_imports)]
use auto::hide_event::HideEvent;
#[allow(unused_imports)]
use auto::hide_event::HideEventTrait;
#[allow(unused_imports)]
use auto::hide_event_ffi::*;
#[allow(unused_imports)]
use auto::icon::Icon;
#[allow(unused_imports)]
use auto::icon::IconTrait;
#[allow(unused_imports)]
use auto::icon_ffi::*;
#[allow(unused_imports)]
use auto::key_event::KeyEvent;
#[allow(unused_imports)]
use auto::key_event::KeyEventTrait;
#[allow(unused_imports)]
use auto::key_event_ffi::*;
#[allow(unused_imports)]
use auto::margins::Margins;
#[allow(unused_imports)]
use auto::mouse_event::MouseEvent;
#[allow(unused_imports)]
use auto::mouse_event::MouseEventTrait;
#[allow(unused_imports)]
use auto::mouse_event_ffi::*;
#[allow(unused_imports)]
use auto::move_event::MoveEvent;
#[allow(unused_imports)]
use auto::move_event::MoveEventTrait;
#[allow(unused_imports)]
use auto::move_event_ffi::*;
#[allow(unused_imports)]
use auto::object::Object;
#[allow(unused_imports)]
use auto::object::ObjectTrait;
#[allow(unused_imports)]
use auto::object::*;
#[allow(unused_imports)]
use auto::object_ffi::*;
#[allow(unused_imports)]
use auto::object_ffi::*;
#[allow(unused_imports)]
use auto::point::Point;
#[allow(unused_imports)]
use auto::point::PointTrait;
#[allow(unused_imports)]
use auto::point_ffi::*;
#[allow(unused_imports)]
use auto::region::Region;
#[allow(unused_imports)]
use auto::region::RegionTrait;
#[allow(unused_imports)]
use auto::region_ffi::*;
#[allow(unused_imports)]
use auto::resize_event::ResizeEvent;
#[allow(unused_imports)]
use auto::resize_event::ResizeEventTrait;
#[allow(unused_imports)]
use auto::resize_event_ffi::*;
#[allow(unused_imports)]
use auto::rute::*;
#[allow(unused_imports)]
use auto::rute_enums::ScreenOrientation;
#[allow(unused_imports)]
use auto::rute_enums::WindowFlags;
#[allow(unused_imports)]
use auto::rute_enums::WindowModality;
#[allow(unused_imports)]
use auto::rute_enums::WindowState;
#[allow(unused_imports)]
use auto::rute_enums::WindowStates;
#[allow(unused_imports)]
use auto::rute_ffi::*;
#[allow(unused_imports)]
use auto::screen::Screen;
#[allow(unused_imports)]
use auto::screen::ScreenTrait;
#[allow(unused_imports)]
use auto::screen_ffi::*;
#[allow(unused_imports)]
use auto::show_event::ShowEvent;
#[allow(unused_imports)]
use auto::show_event::ShowEventTrait;
#[allow(unused_imports)]
use auto::show_event_ffi::*;
#[allow(unused_imports)]
use auto::size::Size;
#[allow(unused_imports)]
use auto::size::SizeTrait;
#[allow(unused_imports)]
use auto::size_ffi::*;
#[allow(unused_imports)]
use auto::surface::SurfaceType;
#[allow(unused_imports)]
use auto::surface::*;
#[allow(unused_imports)]
use auto::surface_ffi::*;
#[allow(unused_imports)]
use auto::surface_format::SurfaceFormat;
#[allow(unused_imports)]
use auto::surface_format::SurfaceFormatTrait;
#[allow(unused_imports)]
use auto::surface_format_ffi::*;
#[allow(unused_imports)]
use auto::tablet_event::TabletEvent;
#[allow(unused_imports)]
use auto::tablet_event::TabletEventTrait;
#[allow(unused_imports)]
use auto::tablet_event_ffi::*;
#[allow(unused_imports)]
use auto::touch_event::TouchEvent;
#[allow(unused_imports)]
use auto::touch_event::TouchEventTrait;
#[allow(unused_imports)]
use auto::touch_event_ffi::*;
#[allow(unused_imports)]
use auto::wheel_event::WheelEvent;
#[allow(unused_imports)]
use auto::wheel_event::WheelEventTrait;
#[allow(unused_imports)]
use auto::wheel_event_ffi::*;
#[allow(unused_imports)]
use auto::window_ffi::*;
///
/// A window that is supplied a parent becomes a native child window of
/// their parent window.
///
/// An application will typically use QWidget or QQuickView for its UI, and not
/// QWindow directly. Still, it is possible to render directly to a QWindow
/// with QBackingStore or QOpenGLContext, when wanting to keep dependencies to
/// a minimum or when wanting to use OpenGL directly. The
/// [Raster Window Example](Raster%20Window%20Example)
/// and [OpenGL Window Example](OpenGL%20Window%20Example)
/// are useful reference examples for how to render to a QWindow using
/// either approach.
///
/// # Resource Management
///
/// Windows can potentially use a lot of memory. A usual measurement is
/// width times height times color depth. A window might also include multiple
/// buffers to support double and triple buffering, as well as depth and stencil
/// buffers. To release a window's memory resources, call the destroy() function.
///
/// # Content Orientation
///
/// QWindow has reportContentOrientationChange() that can be used to specify
/// the layout of the window contents in relation to the screen. The content
/// orientation is simply a hint to the windowing system about which
/// orientation the window contents are in. It's useful when you wish to keep
/// the same window size, but rotate the contents instead, especially when
/// doing rotation animations between different orientations. The windowing
/// system might use this value to determine the layout of system popups or
/// dialogs.
///
/// # Visibility and Windowing System Exposure
///
/// By default, the window is not visible, and you must call setVisible(true),
/// or show() or similar to make it visible. To make a window hidden again,
/// call setVisible(false) or hide(). The visible property describes the state
/// the application wants the window to be in. Depending on the underlying
/// system, a visible window might still not be shown on the screen. It could,
/// for instance, be covered by other opaque windows or moved outside the
/// physical area of the screen. On windowing systems that have exposure
/// notifications, the isExposed() accessor describes whether the window should
/// be treated as directly visible on screen. The exposeEvent() function is
/// called whenever the windows exposure in the windowing system changes. On
/// windowing systems that do not make this information visible to the
/// application, isExposed() will simply return the same value as isVisible().
///
/// QWindow::Visibility queried through visibility() is a convenience API
/// combining the functions of visible() and windowStates().
///
/// # Rendering
///
/// There are two Qt APIs that can be used to render content into a window,
/// QBackingStore for rendering with a QPainter and flushing the contents
/// to a window with type QSurface::RasterSurface, and QOpenGLContext for
/// rendering with OpenGL to a window with type QSurface::OpenGLSurface.
///
/// The application can start rendering as soon as isExposed() returns `true,`
/// and can keep rendering until it isExposed() returns `false.` To find out when
/// isExposed() changes, reimplement exposeEvent(). The window will always get
/// a resize event before the first expose event.
///
/// # Initial Geometry
///
/// If the window's width and height are left uninitialized, the window will
/// get a reasonable default geometry from the platform window. If the position
/// is left uninitialized, then the platform window will allow the windowing
/// system to position the window. For example on X11, the window manager
/// usually does some kind of smart positioning to try to avoid having new
/// windows completely obscure existing windows. However setGeometry()
/// initializes both the position and the size, so if you want a fixed size but
/// an automatic position, you should call resize() or setWidth() and
/// setHeight() instead.
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Window<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUWindowAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Window<'a> {
    pub fn new() -> Window<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_window)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Window {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    pub fn new_from_rc(ffi_data: RUWindow) -> Window<'a> {
        Window {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUWindow) -> Window<'a> {
        Window {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUWindow) -> Window<'a> {
        Window {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    pub fn set_screen_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &ScreenTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &ScreenTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_screen_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_screen_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_screen_changed_event<F>(&self, func: F)
    where
        F: Fn(&ScreenTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&ScreenTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_screen_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_screen_changed_trampoline as usize),
            );
        }
    }

    pub fn set_window_title_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &str) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &str) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_window_title_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_window_title_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_window_title_changed_event<F>(&self, func: F)
    where
        F: Fn(&str) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&str) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_window_title_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_window_title_changed_trampoline as usize),
            );
        }
    }

    pub fn set_x_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_x_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_x_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_x_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_x_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_x_changed_trampoline as usize),
            );
        }
    }

    pub fn set_y_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_y_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_y_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_y_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_y_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_y_changed_trampoline as usize),
            );
        }
    }

    pub fn set_width_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_width_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_width_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_width_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_width_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_width_changed_trampoline as usize),
            );
        }
    }

    pub fn set_height_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_height_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_height_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_height_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_height_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_height_changed_trampoline as usize),
            );
        }
    }

    pub fn set_minimum_width_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_minimum_width_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_minimum_width_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_minimum_width_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_minimum_width_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_minimum_width_changed_trampoline as usize),
            );
        }
    }

    pub fn set_minimum_height_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_minimum_height_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_minimum_height_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_minimum_height_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_minimum_height_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_minimum_height_changed_trampoline as usize),
            );
        }
    }

    pub fn set_maximum_width_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_maximum_width_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_maximum_width_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_maximum_width_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_maximum_width_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_maximum_width_changed_trampoline as usize),
            );
        }
    }

    pub fn set_maximum_height_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, i32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, i32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_maximum_height_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_maximum_height_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_maximum_height_changed_event<F>(&self, func: F)
    where
        F: Fn(i32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(i32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_maximum_height_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_maximum_height_changed_trampoline as usize),
            );
        }
    }

    pub fn set_visible_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, bool) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, bool) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_visible_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_visible_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_visible_changed_event<F>(&self, func: F)
    where
        F: Fn(bool) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(bool) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_visible_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_visible_changed_trampoline as usize),
            );
        }
    }

    pub fn set_active_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_active_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_active_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_active_changed_event<F>(&self, func: F)
    where
        F: Fn() + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn() + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_active_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_active_changed_trampoline as usize),
            );
        }
    }

    pub fn set_focus_object_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &ObjectTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &ObjectTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_focus_object_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_focus_object_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_focus_object_changed_event<F>(&self, func: F)
    where
        F: Fn(&ObjectTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&ObjectTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_focus_object_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_focus_object_changed_trampoline as usize),
            );
        }
    }

    pub fn set_opacity_changed_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, f32) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, f32) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_opacity_changed_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_opacity_changed_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_opacity_changed_event<F>(&self, func: F)
    where
        F: Fn(f32) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(f32) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_opacity_changed_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_opacity_changed_trampoline as usize),
            );
        }
    }

    pub fn set_expose_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &ExposeEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &ExposeEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_expose_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_expose_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_expose_event<F>(&self, func: F)
    where
        F: Fn(&ExposeEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&ExposeEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_expose_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_expose_trampoline as usize),
            );
        }
    }

    pub fn set_resize_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &ResizeEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &ResizeEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_resize_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_resize_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_resize_event<F>(&self, func: F)
    where
        F: Fn(&ResizeEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&ResizeEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_resize_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_resize_trampoline as usize),
            );
        }
    }

    pub fn set_move_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &MoveEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &MoveEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_move_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_move_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_move_event<F>(&self, func: F)
    where
        F: Fn(&MoveEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&MoveEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_move_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_move_trampoline as usize),
            );
        }
    }

    pub fn set_focus_in_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &FocusEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &FocusEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_focus_in_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_focus_in_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_focus_in_event<F>(&self, func: F)
    where
        F: Fn(&FocusEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&FocusEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_focus_in_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_focus_in_trampoline as usize),
            );
        }
    }

    pub fn set_focus_out_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &FocusEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &FocusEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_focus_out_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_focus_out_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_focus_out_event<F>(&self, func: F)
    where
        F: Fn(&FocusEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&FocusEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_focus_out_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_focus_out_trampoline as usize),
            );
        }
    }

    pub fn set_show_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &ShowEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &ShowEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_show_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_show_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_show_event<F>(&self, func: F)
    where
        F: Fn(&ShowEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&ShowEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_show_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_show_trampoline as usize),
            );
        }
    }

    pub fn set_hide_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &HideEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &HideEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_hide_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_hide_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_hide_event<F>(&self, func: F)
    where
        F: Fn(&HideEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&HideEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_hide_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_hide_trampoline as usize),
            );
        }
    }

    pub fn set_key_press_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &KeyEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &KeyEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_key_press_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_key_press_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_key_press_event<F>(&self, func: F)
    where
        F: Fn(&KeyEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&KeyEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_key_press_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_key_press_trampoline as usize),
            );
        }
    }

    pub fn set_key_release_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &KeyEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &KeyEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_key_release_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_key_release_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_key_release_event<F>(&self, func: F)
    where
        F: Fn(&KeyEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&KeyEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_key_release_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_key_release_trampoline as usize),
            );
        }
    }

    pub fn set_mouse_press_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &MouseEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_press_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_mouse_press_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_mouse_press_event<F>(&self, func: F)
    where
        F: Fn(&MouseEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&MouseEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_press_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_mouse_press_trampoline as usize),
            );
        }
    }

    pub fn set_mouse_release_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &MouseEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_release_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_mouse_release_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_mouse_release_event<F>(&self, func: F)
    where
        F: Fn(&MouseEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&MouseEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_release_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_mouse_release_trampoline as usize),
            );
        }
    }

    pub fn set_mouse_double_click_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &MouseEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_double_click_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_mouse_double_click_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_mouse_double_click_event<F>(&self, func: F)
    where
        F: Fn(&MouseEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&MouseEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_double_click_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_mouse_double_click_trampoline as usize),
            );
        }
    }

    pub fn set_mouse_move_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &MouseEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &MouseEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_mouse_move_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_mouse_move_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_mouse_move_event<F>(&self, func: F)
    where
        F: Fn(&MouseEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&MouseEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_mouse_move_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_mouse_move_trampoline as usize),
            );
        }
    }

    pub fn set_wheel_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &WheelEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &WheelEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_wheel_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_wheel_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_wheel_event<F>(&self, func: F)
    where
        F: Fn(&WheelEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&WheelEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_wheel_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_wheel_trampoline as usize),
            );
        }
    }

    pub fn set_touch_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &TouchEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &TouchEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_touch_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_touch_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_touch_event<F>(&self, func: F)
    where
        F: Fn(&TouchEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&TouchEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_touch_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_touch_trampoline as usize),
            );
        }
    }

    pub fn set_tablet_event_ud<F, T>(&self, data: &'a T, func: F)
    where
        F: Fn(&T, &TabletEventTrait) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();

        let f: Box<Box<Fn(&T, &TabletEventTrait) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_tablet_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(window_tablet_trampoline_ud::<T> as usize),
            );
        }
    }

    pub fn set_tablet_event<F>(&self, func: F)
    where
        F: Fn(&TabletEventTrait) + 'a,
    {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        let f: Box<Box<Fn(&TabletEventTrait) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_tablet_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(window_tablet_trampoline as usize),
            );
        }
    }
}

pub struct WindowStatic<'a> {
    pub all_funcs: *const RUWindowAllFuncs,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}
///
/// This signal is emitted when a window's *screen* changes, either
/// by being set explicitly with setScreen(), or automatically when
/// the window's screen is removed.

unsafe extern "C" fn window_screen_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    screen: *const RUBase,
) {
    let f: &&(Fn(&T, &ScreenTrait) + 'static) = transmute(func);
    let obj_screen_0 = Screen::new_from_temporary(*(screen as *const RUScreen));
    let data = self_c as *const T;
    f(&*data, &obj_screen_0);
}

unsafe extern "C" fn window_screen_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    screen: *const RUBase,
) {
    let f: &&(Fn(&ScreenTrait) + 'static) = transmute(func);
    let obj_screen_0 = Screen::new_from_temporary(*(screen as *const RUScreen));
    f(&obj_screen_0);
}

///
///
/// This signal is emitted when the *windowState* changes, either
/// by being set explicitly with setWindowStates(), or automatically when
/// the user clicks one of the titlebar buttons or by other means.

unsafe extern "C" fn window_window_title_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    title: *const ::std::os::raw::c_char,
) {
    let f: &&(Fn(&T, &str) + 'static) = transmute(func);
    let str_in_title_0 = CStr::from_ptr(title);

    let data = self_c as *const T;
    f(&*data, str_in_title_0.to_str().unwrap());
}

unsafe extern "C" fn window_window_title_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    title: *const ::std::os::raw::c_char,
) {
    let f: &&(Fn(&str) + 'static) = transmute(func);
    let str_in_title_0 = CStr::from_ptr(title);

    f(str_in_title_0.to_str().unwrap());
}

unsafe extern "C" fn window_x_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_x_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_y_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_y_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_width_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_width_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_height_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_height_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_minimum_width_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_minimum_width_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_minimum_height_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_minimum_height_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_maximum_width_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_maximum_width_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_maximum_height_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(&T, i32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_maximum_height_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: i32,
) {
    let f: &&(Fn(i32) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_visible_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg: bool,
) {
    let f: &&(Fn(&T, bool) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, arg);
}

unsafe extern "C" fn window_visible_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg: bool,
) {
    let f: &&(Fn(bool) + 'static) = transmute(func);

    f(arg);
}

unsafe extern "C" fn window_active_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
) {
    let f: &&(Fn(&T) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data);
}

unsafe extern "C" fn window_active_changed_trampoline(self_c: *const c_void, func: *const c_void) {
    let f: &&(Fn() + 'static) = transmute(func);

    f();
}

///
/// This signal is emitted when the final receiver of events tied to focus
/// is changed to *object.*
///
/// **See also:** [`focus_object()`]

unsafe extern "C" fn window_focus_object_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    object: *const RUBase,
) {
    let f: &&(Fn(&T, &ObjectTrait) + 'static) = transmute(func);
    let obj_object_0 = Object::new_from_temporary(*(object as *const RUObject));
    let data = self_c as *const T;
    f(&*data, &obj_object_0);
}

unsafe extern "C" fn window_focus_object_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    object: *const RUBase,
) {
    let f: &&(Fn(&ObjectTrait) + 'static) = transmute(func);
    let obj_object_0 = Object::new_from_temporary(*(object as *const RUObject));
    f(&obj_object_0);
}

unsafe extern "C" fn window_opacity_changed_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    opacity: f32,
) {
    let f: &&(Fn(&T, f32) + 'static) = transmute(func);

    let data = self_c as *const T;
    f(&*data, opacity);
}

unsafe extern "C" fn window_opacity_changed_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    opacity: f32,
) {
    let f: &&(Fn(f32) + 'static) = transmute(func);

    f(opacity);
}

///
/// The expose event ( *ev)* is sent by the window system whenever the window's
/// exposure on screen changes.
///
/// The application can start rendering into the window with QBackingStore
/// and QOpenGLContext as soon as it gets an exposeEvent() such that
/// isExposed() is true.
///
/// If the window is moved off screen, is made totally obscured by another
/// window, iconified or similar, this function might be called and the
/// value of isExposed() might change to false. When this happens,
/// an application should stop its rendering as it is no longer visible
/// to the user.
///
/// A resize event will always be sent before the expose event the first time
/// a window is shown.
///
/// **See also:** [`is_exposed()`]

unsafe extern "C" fn window_expose_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &ExposeEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = ExposeEvent::new_from_temporary(*(arg0 as *const RUExposeEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_expose_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&ExposeEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = ExposeEvent::new_from_temporary(*(arg0 as *const RUExposeEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle resize events ( *ev).*
///
/// The resize event is called whenever the window is resized in the windowing system,
/// either directly through the windowing system acknowledging a setGeometry() or resize() request,
/// or indirectly through the user resizing the window manually.

unsafe extern "C" fn window_resize_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &ResizeEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = ResizeEvent::new_from_temporary(*(arg0 as *const RUResizeEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_resize_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&ResizeEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = ResizeEvent::new_from_temporary(*(arg0 as *const RUResizeEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle window move events ( *ev).*

unsafe extern "C" fn window_move_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MoveEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MoveEvent::new_from_temporary(*(arg0 as *const RUMoveEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_move_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MoveEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MoveEvent::new_from_temporary(*(arg0 as *const RUMoveEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle focus in events ( *ev).*
///
/// Focus in events are sent when the window receives keyboard focus.
///
/// **See also:** [`focus_out_event()`]

unsafe extern "C" fn window_focus_in_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &FocusEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_focus_in_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&FocusEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle focus out events ( *ev).*
///
/// Focus out events are sent when the window loses keyboard focus.
///
/// **See also:** [`focus_in_event()`]

unsafe extern "C" fn window_focus_out_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &FocusEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_focus_out_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&FocusEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = FocusEvent::new_from_temporary(*(arg0 as *const RUFocusEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle show events ( *ev).*
///
/// The function is called when the window has requested becoming visible.
///
/// If the window is successfully shown by the windowing system, this will
/// be followed by a resize and an expose event.

unsafe extern "C" fn window_show_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &ShowEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = ShowEvent::new_from_temporary(*(arg0 as *const RUShowEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_show_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&ShowEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = ShowEvent::new_from_temporary(*(arg0 as *const RUShowEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle hide events ( *ev).*
///
/// The function is called when the window has requested being hidden in the
/// windowing system.

unsafe extern "C" fn window_hide_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &HideEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = HideEvent::new_from_temporary(*(arg0 as *const RUHideEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_hide_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&HideEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = HideEvent::new_from_temporary(*(arg0 as *const RUHideEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle key press events ( *ev).*
///
/// **See also:** [`key_release_event()`]

unsafe extern "C" fn window_key_press_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &KeyEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = KeyEvent::new_from_temporary(*(arg0 as *const RUKeyEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_key_press_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&KeyEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = KeyEvent::new_from_temporary(*(arg0 as *const RUKeyEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle key release events ( *ev).*
///
/// **See also:** [`key_press_event()`]

unsafe extern "C" fn window_key_release_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &KeyEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = KeyEvent::new_from_temporary(*(arg0 as *const RUKeyEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_key_release_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&KeyEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = KeyEvent::new_from_temporary(*(arg0 as *const RUKeyEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle mouse press events ( *ev).*
///
/// **See also:** [`mouse_release_event()`]

unsafe extern "C" fn window_mouse_press_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_mouse_press_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle mouse release events ( *ev).*
///
/// **See also:** [`mouse_press_event()`]

unsafe extern "C" fn window_mouse_release_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_mouse_release_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle mouse double click events ( *ev).*
///
/// **See also:** [`mouse_press_event()`]
/// [`StyleHints::mouse_double_click_interval`]

unsafe extern "C" fn window_mouse_double_click_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_mouse_double_click_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle mouse move events ( *ev).*

unsafe extern "C" fn window_mouse_move_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_mouse_move_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&MouseEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = MouseEvent::new_from_temporary(*(arg0 as *const RUMouseEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle mouse wheel or other wheel events ( *ev).*

unsafe extern "C" fn window_wheel_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &WheelEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = WheelEvent::new_from_temporary(*(arg0 as *const RUWheelEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_wheel_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&WheelEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = WheelEvent::new_from_temporary(*(arg0 as *const RUWheelEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle touch events ( *ev).*

unsafe extern "C" fn window_touch_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &TouchEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = TouchEvent::new_from_temporary(*(arg0 as *const RUTouchEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_touch_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&TouchEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = TouchEvent::new_from_temporary(*(arg0 as *const RUTouchEvent));
    f(&obj_arg0_0);
}

///
/// Override this to handle tablet press, move, and release events ( *ev).*
///
/// Proximity enter and leave events are not sent to windows, they are
/// delivered to the application instance.

unsafe extern "C" fn window_tablet_trampoline_ud<T>(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&T, &TabletEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = TabletEvent::new_from_temporary(*(arg0 as *const RUTabletEvent));
    let data = self_c as *const T;
    f(&*data, &obj_arg0_0);
}

unsafe extern "C" fn window_tablet_trampoline(
    self_c: *const c_void,
    func: *const c_void,
    arg0: *const RUBase,
) {
    let f: &&(Fn(&TabletEventTrait) + 'static) = transmute(func);
    let obj_arg0_0 = TabletEvent::new_from_temporary(*(arg0 as *const RUTabletEvent));
    f(&obj_arg0_0);
}

pub trait WindowTrait<'a> {
    ///
    /// Sets the *surfaceType* of the window.
    ///
    /// Specifies whether the window is meant for raster rendering with
    /// QBackingStore, or OpenGL rendering with QOpenGLContext.
    ///
    /// The surfaceType will be used when the native surface is created
    /// in the create() function. Calling this function after the native
    /// surface has been created requires calling destroy() and create()
    /// to release the old native surface and create a new one.
    ///
    /// **See also:** [`BackingStore`]
    /// [`OpenGLContext`]
    /// [`create()`]
    /// [`destroy()`]
    fn set_object_surface_type(&self, surface_type: SurfaceType) {
        let enum_surface_type_1 = surface_type as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_object_surface_type)(obj_data, enum_surface_type_1);
        }
    }
    ///
    /// Returns the surface type of the window.
    ///
    /// **See also:** [`set_surface_type()`]
    fn surface_type(&self) -> SurfaceType {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).surface_type)(obj_data);
            let ret_val = { transmute::<i32, SurfaceType>(ret_val) };
            ret_val
        }
    }
    fn is_visible(&self) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_visible)(obj_data);
            ret_val
        }
    }
    ///
    /// Visibility is whether the window should appear in the windowing system as
    /// normal, minimized, maximized, fullscreen or hidden.
    ///
    /// To set the visibility to AutomaticVisibility means to give the window
    /// a default visible state, which might be fullscreen or windowed depending on
    /// the platform.
    /// When reading the visibility property you will always get the actual state,
    /// never AutomaticVisibility.
    fn visibility(&self) -> Visibility {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).visibility)(obj_data);
            let ret_val = { transmute::<i32, Visibility>(ret_val) };
            ret_val
        }
    }
    fn set_visibility(&self, v: Visibility) {
        let enum_v_1 = v as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_visibility)(obj_data, enum_v_1);
        }
    }
    ///
    /// Allocates the platform resources associated with the window.
    ///
    /// It is at this point that the surface format set using setFormat() gets resolved
    /// into an actual native surface. However, the window remains hidden until setVisible() is called.
    ///
    /// Note that it is not usually necessary to call this function directly, as it will be implicitly
    /// called by show(), setVisible(), and other functions that require access to the platform
    /// resources.
    ///
    /// Call destroy() to free the platform resources if necessary.
    ///
    /// **See also:** [`destroy()`]
    fn create(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).create)(obj_data);
        }
    }
    ///
    /// Returns the window's platform id.
    ///
    /// For platforms where this id might be useful, the value returned
    /// will uniquely represent the window inside the corresponding screen.
    ///
    /// **See also:** [`screen()`]
    fn win_id(&self) -> u64 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).win_id)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the parent window, if any.
    ///
    /// If *mode* is IncludeTransients, then the transient parent is returned
    /// if there is no parent.
    ///
    /// A window without a parent is known as a top level window.
    ///
    ///
    /// Returns the parent window, if any.
    ///
    /// A window without a parent is known as a top level window.
    fn parent(&self, mode: AncestorMode) -> Option<Window> {
        let enum_mode_1 = mode as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data, enum_mode_1);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the parent window, if any.
    ///
    /// If *mode* is IncludeTransients, then the transient parent is returned
    /// if there is no parent.
    ///
    /// A window without a parent is known as a top level window.
    ///
    ///
    /// Returns the parent window, if any.
    ///
    /// A window without a parent is known as a top level window.
    fn parent_2(&self) -> Option<Window> {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent_2)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the *parent* Window. This will lead to the windowing system managing
    /// the clip of the window, so it will be clipped to the *parent* window.
    ///
    /// Setting *parent* to be 0 will make the window become a top level window.
    ///
    /// If *parent* is a window created by fromWinId(), then the current window
    /// will be embedded inside *parent,* if the platform supports it.
    fn set_parent(&self, parent: &WindowTrait) {
        let (obj_parent_1, _funcs) = parent.get_window_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
    }
    ///
    /// Returns whether the window is top level, i.e. has no parent window.
    fn is_top_level(&self) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_top_level)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns whether the window is modal.
    ///
    /// A modal window prevents other windows from getting any input.
    ///
    /// **See also:** [`Window::modality()`]
    fn is_modal(&self) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_modal)(obj_data);
            ret_val
        }
    }
    ///
    /// A modal window prevents other windows from receiving input events. Qt
    /// supports two types of modality: Qt::WindowModal and Qt::ApplicationModal.
    ///
    /// By default, this property is Qt::NonModal
    ///
    /// **See also:** [`t::window_modality()`]
    ///
    /// This signal is emitted when the Qwindow::modality property changes to *modality.*
    fn modality(&self) -> WindowModality {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).modality)(obj_data);
            let ret_val = { transmute::<i32, WindowModality>(ret_val) };
            ret_val
        }
    }
    fn set_modality(&self, modality: WindowModality) {
        let enum_modality_1 = modality as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_modality)(obj_data, enum_modality_1);
        }
    }
    ///
    /// Sets the window's surface *format.*
    ///
    /// The format determines properties such as color depth, alpha, depth and
    /// stencil buffer size, etc. For example, to give a window a transparent
    /// background (provided that the window system supports compositing, and
    /// provided that other content in the window does not make it opaque again):
    ///
    /// ```
    /// QSurfaceFormat format;
    /// format.setAlphaBufferSize(8);
    /// window.setFormat(format);
    /// ```
    ///
    /// The surface format will be resolved in the create() function. Calling
    /// this function after create() has been called will not re-resolve the
    /// surface format of the native surface.
    ///
    /// When the format is not explicitly set via this function, the format returned
    /// by QSurfaceFormat::defaultFormat() will be used. This means that when having
    /// multiple windows, individual calls to this function can be replaced by one
    /// single call to QSurfaceFormat::setDefaultFormat() before creating the first
    /// window.
    ///
    /// **See also:** [`create()`]
    /// [`destroy()`]
    /// [`SurfaceFormat::set_default_format`]
    fn set_object_format(&self, format: &SurfaceFormatTrait) {
        let (obj_format_1, _funcs) = format.get_surface_format_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_object_format)(obj_data, obj_format_1);
        }
    }
    ///
    /// Returns the actual format of this window.
    ///
    /// After the window has been created, this function will return the actual surface format
    /// of the window. It might differ from the requested format if the requested format could
    /// not be fulfilled by the platform. It might also be a superset, for example certain
    /// buffer sizes may be larger than requested.
    ///
    /// **Note**: Depending on the platform, certain values in this surface format may still
    /// contain the requested values, that is, the values that have been passed to
    /// setFormat(). Typical examples are the OpenGL version, profile and options. These may
    /// not get updated during create() since these are context specific and a single window
    /// may be used together with multiple contexts over its lifetime. Use the
    /// QOpenGLContext's format() instead to query such values.
    ///
    /// **See also:** [`create()`]
    /// [`requested_format()`]
    /// [`OpenGLContext::format`]
    fn format(&self) -> SurfaceFormat {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).format)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = SurfaceFormat::new_from_rc(t);
            } else {
                ret_val = SurfaceFormat::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the requested surface format of this window.
    ///
    /// If the requested format was not supported by the platform implementation,
    /// the requestedFormat will differ from the actual window format.
    ///
    /// This is the value set with setFormat().
    ///
    /// **See also:** [`set_format()`]
    /// [`format()`]
    fn requested_format(&self) -> SurfaceFormat {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).requested_format)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = SurfaceFormat::new_from_rc(t);
            } else {
                ret_val = SurfaceFormat::new_from_owned(t);
            }
            ret_val
        }
    }
    fn set_flags(&self, flags: WindowFlags) {
        let enum_flags_1 = flags as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_flags)(obj_data, enum_flags_1);
        }
    }
    ///
    /// The window flags control the window's appearance in the windowing system,
    /// whether it's a dialog, popup, or a regular window, and whether it should
    /// have a title bar, etc.
    ///
    /// The actual window flags might differ from the flags set with setFlags()
    /// if the requested flags could not be fulfilled.
    ///
    /// **See also:** [`set_flag()`]
    fn flags(&self) -> WindowFlags {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).flags)(obj_data);
            let ret_val = { transmute::<i32, WindowFlags>(ret_val) };
            ret_val
        }
    }
    ///
    /// Sets the window flag *flag* on this window if *on* is true;
    /// otherwise clears the flag.
    ///
    /// **See also:** [`set_flags()`]
    /// [`flags()`]
    /// [`type()`]
    ///
    /// Returns the type of the window.
    ///
    /// This returns the part of the window flags that represents
    /// whether the window is a dialog, tooltip, popup, regular window, etc.
    ///
    /// **See also:** [`flags()`]
    /// [`set_flags()`]
    ///
    /// The window title might appear in the title area of the window decorations,
    /// depending on the windowing system and the window flags. It might also
    /// be used by the windowing system to identify the window in other contexts,
    /// such as in the task switcher.
    ///
    /// **See also:** [`flags()`]
    fn title(&self) -> String {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).title)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    fn set_opacity(&self, level: f32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_opacity)(obj_data, level);
        }
    }
    ///
    /// If the windowing system supports window opacity, this can be used to fade the
    /// window in and out, or to make it semitransparent.
    ///
    /// A value of 1.0 or above is treated as fully opaque, whereas a value of 0.0 or below
    /// is treated as fully transparent. Values inbetween represent varying levels of
    /// translucency between the two extremes.
    ///
    /// The default value is 1.0.
    fn opacity(&self) -> f32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).opacity)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the mask of the window.
    ///
    /// The mask is a hint to the windowing system that the application does not
    /// want to receive mouse or touch input outside the given *region.*
    ///
    /// The window manager may or may not choose to display any areas of the window
    /// not included in the mask, thus it is the application's responsibility to
    /// clear to transparent the areas that are not part of the mask.
    fn set_mask(&self, region: &RegionTrait) {
        let (obj_region_1, _funcs) = region.get_region_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_mask)(obj_data, obj_region_1);
        }
    }
    ///
    /// Returns the mask set on the window.
    ///
    /// The mask is a hint to the windowing system that the application does not
    /// want to receive mouse or touch input outside the given region.
    fn mask(&self) -> Region {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).mask)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns `true` if the window should appear active from a style perspective.
    ///
    /// This is the case for the window that has input focus as well as windows
    /// that are in the same parent / transient parent chain as the focus window.
    ///
    /// To get the window that currently has focus, use QGuiApplication::focusWindow().
    fn is_active(&self) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_active)(obj_data);
            ret_val
        }
    }
    fn report_content_orientation_change(&self, orientation: ScreenOrientation) {
        let enum_orientation_1 = orientation as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).report_content_orientation_change)(obj_data, enum_orientation_1);
        }
    }
    ///
    /// This is a hint to the window manager in case it needs to display
    /// additional content like popups, dialogs, status bars, or similar
    /// in relation to the window.
    ///
    /// The recommended orientation is QScreen::orientation() but
    /// an application doesn't have to support all possible orientations,
    /// and thus can opt to ignore the current screen orientation.
    ///
    /// The difference between the window and the content orientation
    /// determines how much to rotate the content by. QScreen::angleBetween(),
    /// QScreen::transformBetween(), and QScreen::mapBetween() can be used
    /// to compute the necessary transform.
    ///
    /// The default value is Qt::PrimaryOrientation
    fn content_orientation(&self) -> ScreenOrientation {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).content_orientation)(obj_data);
            let ret_val = { transmute::<i32, ScreenOrientation>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the ratio between physical pixels and device-independent pixels
    /// for the window. This value is dependent on the screen the window is on,
    /// and may change when the window is moved.
    ///
    /// Common values are 1.0 on normal displays and 2.0 on Apple displays.
    ///
    /// **Note**: For windows not backed by a platform window, meaning that create() was not
    /// called, the function will fall back to the associated QScreen's device pixel ratio.
    ///
    /// **See also:** [`Screen::device_pixel_ratio`]
    fn device_pixel_ratio(&self) -> f32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_pixel_ratio)(obj_data);
            ret_val
        }
    }
    ///
    /// **See also:** [`set_window_state()`]
    /// [`window_states()`]
    ///
    /// The window can be in a combination of several states. For example, if
    /// the window is both minimized and maximized, the window will appear
    /// minimized, but clicking on the task bar entry will restore it to
    /// the maximized state.
    ///
    /// **See also:** [`set_window_states()`]
    ///
    /// This signal is emitted when the *windowState* changes, either
    /// by being set explicitly with setWindowStates(), or automatically when
    /// the user clicks one of the titlebar buttons or by other means.
    fn window_state(&self) -> WindowState {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_state)(obj_data);
            let ret_val = { transmute::<i32, WindowState>(ret_val) };
            ret_val
        }
    }
    ///
    /// The window can be in a combination of several states. For example, if
    /// the window is both minimized and maximized, the window will appear
    /// minimized, but clicking on the task bar entry will restore it to
    /// the maximized state.
    ///
    /// **See also:** [`set_window_states()`]
    fn window_states(&self) -> WindowStates {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window_states)(obj_data);
            let ret_val = { transmute::<i32, WindowStates>(ret_val) };
            ret_val
        }
    }
    ///
    /// The window *state* represents whether the window appears in the
    /// windowing system as maximized, minimized, fullscreen, or normal.
    ///
    /// The enum value Qt::WindowActive is not an accepted parameter.
    ///
    /// **See also:** [`show_normal()`]
    /// [`show_full_screen()`]
    /// [`show_minimized()`]
    /// [`show_maximized()`]
    /// [`set_window_states()`]
    ///
    /// The window *state* represents whether the window appears in the
    /// windowing system as maximized, minimized and/or fullscreen.
    ///
    /// The window can be in a combination of several states. For example, if
    /// the window is both minimized and maximized, the window will appear
    /// minimized, but clicking on the task bar entry will restore it to the
    /// maximized state.
    ///
    /// The enum value Qt::WindowActive should not be set.
    ///
    /// **See also:** [`show_normal()`]
    /// [`show_full_screen()`]
    /// [`show_minimized()`]
    /// [`show_maximized()`]
    fn set_window_state(&self, state: WindowState) {
        let enum_state_1 = state as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_window_state)(obj_data, enum_state_1);
        }
    }
    ///
    /// The window *state* represents whether the window appears in the
    /// windowing system as maximized, minimized and/or fullscreen.
    ///
    /// The window can be in a combination of several states. For example, if
    /// the window is both minimized and maximized, the window will appear
    /// minimized, but clicking on the task bar entry will restore it to the
    /// maximized state.
    ///
    /// The enum value Qt::WindowActive should not be set.
    ///
    /// **See also:** [`show_normal()`]
    /// [`show_full_screen()`]
    /// [`show_minimized()`]
    /// [`show_maximized()`]
    fn set_window_states(&self, states: WindowStates) {
        let enum_states_1 = states as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_window_states)(obj_data, enum_states_1);
        }
    }
    ///
    /// Sets the transient *parent*
    ///
    /// This is a hint to the window manager that this window is a dialog or pop-up
    /// on behalf of the given window.
    ///
    /// In order to cause the window to be centered above its transient parent by
    /// default, depending on the window manager, it may also be necessary to call
    /// setFlags() with a suitable [Qt::WindowType](Qt::WindowType)
    /// (such as `Qt::Dialog).`
    ///
    /// **See also:** [`transient_parent()`]
    /// [`parent()`]
    fn set_transient_parent(&self, parent: &WindowTrait) {
        let (obj_parent_1, _funcs) = parent.get_window_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_transient_parent)(obj_data, obj_parent_1);
        }
    }
    ///
    /// Returns `true` if the window is an ancestor of the given *child.* If *mode*
    /// is IncludeTransients, then transient parents are also considered ancestors.
    fn is_ancestor_of(&self, child: &WindowTrait, mode: AncestorMode) -> bool {
        let (obj_child_1, _funcs) = child.get_window_obj_funcs();
        let enum_mode_2 = mode as i32;

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_ancestor_of)(obj_data, obj_child_1, enum_mode_2);
            ret_val
        }
    }
    ///
    /// Returns if this window is exposed in the windowing system.
    ///
    /// When the window is not exposed, it is shown by the application
    /// but it is still not showing in the windowing system, so the application
    /// should minimize rendering and other graphical activities.
    ///
    /// An exposeEvent() is sent every time this value changes.
    ///
    /// **See also:** [`expose_event()`]
    fn is_exposed(&self) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_exposed)(obj_data);
            ret_val
        }
    }
    ///
    fn minimum_width(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_width)(obj_data);
            ret_val
        }
    }
    ///
    fn minimum_height(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_height)(obj_data);
            ret_val
        }
    }
    ///
    fn maximum_width(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_width)(obj_data);
            ret_val
        }
    }
    ///
    fn maximum_height(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_height)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the minimum size of the window.
    ///
    /// **See also:** [`set_minimum_size()`]
    fn minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the maximum size of the window.
    ///
    /// **See also:** [`set_maximum_size()`]
    fn maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the base size of the window.
    ///
    /// **See also:** [`set_base_size()`]
    fn base_size(&self) -> Size {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).base_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the size increment of the window.
    ///
    /// **See also:** [`set_size_increment()`]
    fn size_increment(&self) -> Size {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_increment)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the minimum size of the window.
    ///
    /// This is a hint to the window manager to prevent resizing below the specified *size.*
    ///
    /// **See also:** [`set_maximum_size()`]
    /// [`minimum_size()`]
    fn set_minimum_size(&self, size: &SizeTrait) {
        let (obj_size_1, _funcs) = size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_size)(obj_data, obj_size_1);
        }
    }
    ///
    /// Sets the maximum size of the window.
    ///
    /// This is a hint to the window manager to prevent resizing above the specified *size.*
    ///
    /// **See also:** [`set_minimum_size()`]
    /// [`maximum_size()`]
    fn set_maximum_size(&self, size: &SizeTrait) {
        let (obj_size_1, _funcs) = size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_size)(obj_data, obj_size_1);
        }
    }
    ///
    /// Sets the base *size* of the window.
    ///
    /// The base size is used to calculate a proper window size if the
    /// window defines sizeIncrement().
    ///
    /// **See also:** [`set_minimum_size()`]
    /// [`set_maximum_size()`]
    /// [`set_size_increment()`]
    /// [`base_size()`]
    fn set_base_size(&self, size: &SizeTrait) {
        let (obj_size_1, _funcs) = size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_base_size)(obj_data, obj_size_1);
        }
    }
    ///
    /// Sets the size increment ( *size)* of the window.
    ///
    /// When the user resizes the window, the size will move in steps of
    /// sizeIncrement().width() pixels horizontally and
    /// sizeIncrement().height() pixels vertically, with baseSize() as the
    /// basis.
    ///
    /// By default, this property contains a size with zero width and height.
    ///
    /// The windowing system might not support size increments.
    ///
    /// **See also:** [`set_base_size()`]
    /// [`set_minimum_size()`]
    /// [`set_maximum_size()`]
    fn set_size_increment(&self, size: &SizeTrait) {
        let (obj_size_1, _funcs) = size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_size_increment)(obj_data, obj_size_1);
        }
    }
    ///
    /// Returns the window frame margins surrounding the window.
    ///
    /// **See also:** [`geometry()`]
    /// [`frame_geometry()`]
    fn frame_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).frame_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the top left position of the window, including its window frame.
    ///
    /// This returns the same value as frameGeometry().topLeft().
    ///
    /// **See also:** [`geometry()`]
    /// [`frame_geometry()`]
    fn frame_position(&self) -> Point {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).frame_position)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the upper left position of the window ( *point)* including its window frame.
    ///
    /// The position is in relation to the virtualGeometry() of its screen.
    ///
    /// **See also:** [`set_geometry()`]
    /// [`frame_geometry()`]
    fn set_frame_position(&self, point: &PointTrait) {
        let (obj_point_1, _funcs) = point.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_frame_position)(obj_data, obj_point_1);
        }
    }
    ///
    fn width(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).width)(obj_data);
            ret_val
        }
    }
    ///
    fn height(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height)(obj_data);
            ret_val
        }
    }
    ///
    fn x(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).x)(obj_data);
            ret_val
        }
    }
    ///
    fn y(&self) -> i32 {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).y)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the size increment of the window.
    ///
    /// **See also:** [`set_size_increment()`]
    ///
    /// **See also:** [`resize()`]
    fn size(&self) -> Size {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **See also:** [`set_position()`]
    fn position(&self) -> Point {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).position)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// *pt*
    ///
    /// The position is in relation to the virtualGeometry() of its screen.
    ///
    /// **See also:** [`position()`]
    ///
    /// *posx,* *posy*
    ///
    /// The position is in relation to the virtualGeometry() of its screen.
    ///
    /// **See also:** [`position()`]
    fn set_position(&self, pt: &PointTrait) {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_position)(obj_data, obj_pt_1);
        }
    }
    ///
    /// *pt*
    ///
    /// The position is in relation to the virtualGeometry() of its screen.
    ///
    /// **See also:** [`position()`]
    ///
    /// *posx,* *posy*
    ///
    /// The position is in relation to the virtualGeometry() of its screen.
    ///
    /// **See also:** [`position()`]
    fn set_position_2(&self, posx: i32, posy: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_position_2)(obj_data, posx, posy);
        }
    }
    ///
    /// set the size of the window, excluding any window frame, to a QSize
    /// constructed from width *w* and height *h*
    ///
    /// **See also:** [`size()`]
    /// [`geometry()`]
    ///
    /// *newSize*
    ///
    /// **See also:** [`size()`]
    /// [`geometry()`]
    ///
    /// Override this to handle resize events ( *ev).*
    ///
    /// The resize event is called whenever the window is resized in the windowing system,
    /// either directly through the windowing system acknowledging a setGeometry() or resize() request,
    /// or indirectly through the user resizing the window manually.
    fn resize(&self, new_size: &SizeTrait) {
        let (obj_new_size_1, _funcs) = new_size.get_size_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).resize)(obj_data, obj_new_size_1);
        }
    }
    ///
    /// set the size of the window, excluding any window frame, to a QSize
    /// constructed from width *w* and height *h*
    ///
    /// **See also:** [`size()`]
    /// [`geometry()`]
    ///
    /// *newSize*
    ///
    /// **See also:** [`size()`]
    /// [`geometry()`]
    ///
    /// Override this to handle resize events ( *ev).*
    ///
    /// The resize event is called whenever the window is resized in the windowing system,
    /// either directly through the windowing system acknowledging a setGeometry() or resize() request,
    /// or indirectly through the user resizing the window manually.
    fn resize_2(&self, w: i32, h: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).resize_2)(obj_data, w, h);
        }
    }
    ///
    /// The windowing system might use *filePath* to display the
    /// path of the document this window is representing in the tile bar.
    ///
    fn set_file_path(&self, file_path: &str) {
        let str_in_file_path_1 = CString::new(file_path).unwrap();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_file_path)(obj_data, str_in_file_path_1.as_ptr());
        }
    }
    ///
    /// **See also:** [`set_file_path()`]
    fn file_path(&self) -> String {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).file_path)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    ///
    /// *icon* in the windowing system
    ///
    /// The window icon might be used by the windowing system for example to
    /// decorate the window, and/or in the task switcher.
    ///
    /// **Note**: On macOS, the window title bar icon is meant for windows representing
    /// documents, and will only show up if a file path is also set.
    ///
    /// **See also:** [`set_file_path()`]
    fn set_icon(&self, icon: &IconTrait) {
        let (obj_icon_1, _funcs) = icon.get_icon_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_icon)(obj_data, obj_icon_1);
        }
    }
    ///
    /// **See also:** [`set_icon()`]
    fn icon(&self) -> Icon {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).icon)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Icon::new_from_rc(t);
            } else {
                ret_val = Icon::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets whether keyboard grab should be enabled or not ( *grab).*
    ///
    /// If the return value is true, the window receives all key events until
    /// setKeyboardGrabEnabled(false) is called; other windows get no key events at
    /// all. Mouse events are not affected. Use setMouseGrabEnabled() if you want
    /// to grab that.
    ///
    /// **See also:** [`set_mouse_grab_enabled()`]
    fn set_keyboard_grab_enabled(&self, grab: bool) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_keyboard_grab_enabled)(obj_data, grab);
            ret_val
        }
    }
    ///
    /// Sets whether mouse grab should be enabled or not ( *grab).*
    ///
    /// If the return value is true, the window receives all mouse events until setMouseGrabEnabled(false) is
    /// called; other windows get no mouse events at all. Keyboard events are not affected.
    /// Use setKeyboardGrabEnabled() if you want to grab that.
    ///
    /// **See also:** [`set_keyboard_grab_enabled()`]
    fn set_mouse_grab_enabled(&self, grab: bool) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_mouse_grab_enabled)(obj_data, grab);
            ret_val
        }
    }
    ///
    /// Returns the screen on which the window is shown, or null if there is none.
    ///
    /// For child windows, this returns the screen of the corresponding top level window.
    ///
    /// **See also:** [`set_screen()`]
    /// [`Screen::virtual_siblings`]
    ///
    /// This signal is emitted when a window's *screen* changes, either
    /// by being set explicitly with setScreen(), or automatically when
    /// the window's screen is removed.
    fn screen(&self) -> Option<Screen> {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).screen)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Screen::new_from_rc(t);
            } else {
                ret_val = Screen::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the screen on which the window should be shown.
    ///
    /// If the window has been created, it will be recreated on the *newScreen.*
    ///
    /// **Note**: If the screen is part of a virtual desktop of multiple screens,
    /// the window will not move automatically to *newScreen.* To place the
    /// window relative to the screen, use the screen's topLeft() position.
    ///
    /// This function only works for top level windows.
    ///
    /// **See also:** [`screen()`]
    /// [`Screen::virtual_siblings`]
    fn set_screen(&self, screen: &ScreenTrait) {
        let (obj_screen_1, _funcs) = screen.get_screen_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_screen)(obj_data, obj_screen_1);
        }
    }
    ///
    /// This signal is emitted when the final receiver of events tied to focus
    /// is changed to *object.*
    ///
    /// **See also:** [`focus_object()`]
    ///
    /// Returns the QObject that will be the final receiver of events tied focus, such
    /// as key events.
    fn focus_object(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).focus_object)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Translates the window coordinate *pos* to global screen
    /// coordinates. For example, `mapToGlobal(QPoint(0,0))` would give
    /// the global coordinates of the top-left pixel of the window.
    ///
    /// **See also:** [`map_from_global()`]
    fn map_to_global(&self, pos: &PointTrait) -> Point {
        let (obj_pos_1, _funcs) = pos.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_to_global)(obj_data, obj_pos_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Translates the global screen coordinate *pos* to window
    /// coordinates.
    ///
    /// **See also:** [`map_to_global()`]
    fn map_from_global(&self, pos: &PointTrait) -> Point {
        let (obj_pos_1, _funcs) = pos.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).map_from_global)(obj_data, obj_pos_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **See also:** [`set_cursor()`]
    /// [`unset_cursor()`]
    fn cursor(&self) -> Cursor {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).cursor)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Cursor::new_from_rc(t);
            } else {
                ret_val = Cursor::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// The mouse *cursor* will assume this shape when it is over this
    /// window, unless an override cursor is set.
    /// See the [list of predefined cursor objects](Qt::CursorShape)
    /// for a
    /// range of useful shapes.
    ///
    /// If no cursor has been set, or after a call to unsetCursor(), the
    /// parent window's cursor is used.
    ///
    /// By default, the cursor has the Qt::ArrowCursor shape.
    ///
    /// Some underlying window implementations will reset the cursor if it
    /// leaves a window even if the mouse is grabbed. If you want to have
    /// a cursor set for all windows, even when outside the window, consider
    /// QGuiApplication::setOverrideCursor().
    ///
    /// **See also:** [`GuiApplication::set_override_cursor`]
    fn set_cursor(&self, arg0: &CursorTrait) {
        let (obj_arg0_1, _funcs) = arg0.get_cursor_obj_funcs();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_cursor)(obj_data, obj_arg0_1);
        }
    }
    ///
    fn unset_cursor(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).unset_cursor)(obj_data);
        }
    }
    ///
    /// Requests the window to be activated, i.e. receive keyboard focus.
    ///
    /// **See also:** [`is_active()`]
    /// [`GuiApplication::focus_window`]
    /// [`WindowsWindowFunctions::set_window_activation_behavior`]
    fn request_activate(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).request_activate)(obj_data);
        }
    }
    fn set_visible(&self, visible: bool) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_visible)(obj_data, visible);
        }
    }
    ///
    /// Shows the window.
    ///
    /// This is equivalent to calling showFullScreen(), showMaximized(), or showNormal(),
    /// depending on the platform's default behavior for the window type and flags.
    ///
    /// **See also:** [`show_full_screen()`]
    /// [`show_maximized()`]
    /// [`show_normal()`]
    /// [`hide()`]
    /// [`StyleHints::show_is_full_screen`]
    /// [`flags()`]
    ///
    /// Shows the window as minimized.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowMinimized) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    ///
    /// Shows the window as maximized.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowMaximized) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    ///
    /// Shows the window as fullscreen.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowFullScreen) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    ///
    /// Shows the window as normal, i.e. neither maximized, minimized, nor fullscreen.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowNoState) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    ///
    /// Override this to handle show events ( *ev).*
    ///
    /// The function is called when the window has requested becoming visible.
    ///
    /// If the window is successfully shown by the windowing system, this will
    /// be followed by a resize and an expose event.
    fn show(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).show)(obj_data);
        }
    }
    ///
    /// Hides the window.
    ///
    /// Equivalent to calling setVisible(false).
    ///
    /// **See also:** [`show()`]
    /// [`set_visible()`]
    ///
    /// Override this to handle hide events ( *ev).*
    ///
    /// The function is called when the window has requested being hidden in the
    /// windowing system.
    fn hide(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).hide)(obj_data);
        }
    }
    ///
    /// Shows the window as minimized.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowMinimized) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    fn show_minimized(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).show_minimized)(obj_data);
        }
    }
    ///
    /// Shows the window as maximized.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowMaximized) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    fn show_maximized(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).show_maximized)(obj_data);
        }
    }
    ///
    /// Shows the window as fullscreen.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowFullScreen) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    fn show_full_screen(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).show_full_screen)(obj_data);
        }
    }
    ///
    /// Shows the window as normal, i.e. neither maximized, minimized, nor fullscreen.
    ///
    /// Equivalent to calling setWindowStates(Qt::WindowNoState) and then
    /// setVisible(true).
    ///
    /// **See also:** [`set_window_states()`]
    /// [`set_visible()`]
    fn show_normal(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).show_normal)(obj_data);
        }
    }
    ///
    /// Close the window.
    ///
    /// This closes the window, effectively calling destroy(), and potentially
    /// quitting the application. Returns `true` on success, false if it has a parent
    /// window (in which case the top level window should be closed instead).
    ///
    /// **See also:** [`destroy()`]
    /// [`GuiApplication::quit_on_last_window_closed`]
    fn close(&self) -> bool {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).close)(obj_data);
            ret_val
        }
    }
    ///
    /// Raise the window in the windowing system.
    ///
    /// Requests that the window be raised to appear above other windows.
    fn raise(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).raise)(obj_data);
        }
    }
    ///
    /// Lower the window in the windowing system.
    ///
    /// Requests that the window be lowered to appear below other windows.
    fn lower(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).lower)(obj_data);
        }
    }
    fn set_title(&self, arg0: &str) {
        let str_in_arg0_1 = CString::new(arg0).unwrap();

        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_title)(obj_data, str_in_arg0_1.as_ptr());
        }
    }
    fn set_x(&self, arg: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_x)(obj_data, arg);
        }
    }
    fn set_y(&self, arg: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_y)(obj_data, arg);
        }
    }
    fn set_width(&self, arg: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_width)(obj_data, arg);
        }
    }
    fn set_height(&self, arg: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_height)(obj_data, arg);
        }
    }
    fn set_minimum_width(&self, w: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_width)(obj_data, w);
        }
    }
    fn set_minimum_height(&self, h: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_minimum_height)(obj_data, h);
        }
    }
    fn set_maximum_width(&self, w: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_width)(obj_data, w);
        }
    }
    fn set_maximum_height(&self, h: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).set_maximum_height)(obj_data, h);
        }
    }
    ///
    /// Causes an alert to be shown for *msec* miliseconds. If *msec* is `0` (the
    /// default), then the alert is shown indefinitely until the window becomes
    /// active again. This function has no effect on an active window.
    ///
    /// In alert state, the window indicates that it demands attention, for example by
    /// flashing or bouncing the taskbar entry.
    ///
    fn alert(&self, msec: i32) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).alert)(obj_data, msec);
        }
    }
    ///
    /// Schedules a QEvent::UpdateRequest event to be delivered to this window.
    ///
    /// The event is delivered in sync with the display vsync on platforms
    /// where this is possible. Otherwise, the event is delivered after a
    /// delay of 5 ms. The additional time is there to give the event loop
    /// a bit of idle time to gather system events, and can be overridden
    /// using the QT_QPA_UPDATE_IDLE_TIME environment variable.
    ///
    /// When driving animations, this function should be called once after drawing
    /// has completed. Calling this function multiple times will result in a single
    /// event being delivered to the window.
    ///
    /// Subclasses of QWindow should reimplement event(), intercept the event and
    /// call the application's rendering code, then call the base class
    /// implementation.
    ///
    /// **Note**: The subclass' reimplementation of event() must invoke the base class
    /// implementation, unless it is absolutely sure that the event does not need to
    /// be handled by the base class. For example, the default implementation of
    /// this function relies on QEvent::Timer events. Filtering them away would
    /// therefore break the delivery of the update events.
    ///
    fn request_update(&self) {
        let (obj_data, funcs) = self.get_window_obj_funcs();
        unsafe {
            ((*funcs).request_update)(obj_data);
        }
    }

    #[inline]
    fn get_window_obj_funcs(&self) -> (*const RUBase, *const RUWindowFuncs);
}

impl<'a> ObjectTrait<'a> for Window<'a> {
    #[inline]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> SurfaceTrait<'a> for Window<'a> {
    #[inline]
    fn get_surface_obj_funcs(&self) -> (*const RUBase, *const RUSurfaceFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).surface_funcs) }
    }
}

impl<'a> WindowTrait<'a> for Window<'a> {
    #[inline]
    fn get_window_obj_funcs(&self) -> (*const RUBase, *const RUWindowFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).window_funcs) }
    }
}
pub trait WindowStaticTrait {
    ///
    /// Creates a local representation of a window created by another process or by
    /// using native libraries below Qt.
    ///
    /// Given the handle *id* to a native window, this method creates a QWindow
    /// object which can be used to represent the window when invoking methods like
    /// setParent() and setTransientParent().
    ///
    /// This can be used, on platforms which support it, to embed a QWindow inside a
    /// native window, or to embed a native window inside a QWindow.
    ///
    /// If foreign windows are not supported or embedding the native window
    /// failed in the platform plugin, this function returns 0.
    ///
    /// **Note**: The resulting QWindow should not be used to manipulate the underlying
    /// native window (besides re-parenting), or to observe state changes of the
    /// native window. Any support for these kind of operations is incidental, highly
    /// platform dependent and untested.
    ///
    /// **See also:** [`set_parent()`]
    /// **See also:** [`set_transient_parent()`]
    fn from_win_id<'a>(id: u64) -> Option<Window<'a>> {
        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_window)(::std::ptr::null()).all_funcs).window_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).from_win_id)(obj_data, id);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Window::new_from_rc(t);
            } else {
                ret_val = Window::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
}

impl<'a> WindowStaticTrait for Window<'a> {}

impl<'a> WindowStaticTrait for WindowStatic<'a> {}
#[repr(u32)]
pub enum Visibility {
    Hidden,
    AutomaticVisibility,
    Windowed,
    Minimized,
    Maximized,
    FullScreen,
}

#[repr(u32)]
pub enum AncestorMode {
    ExcludeTransients,
    IncludeTransients,
}
