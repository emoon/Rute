// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// QBoxLayout takes the space it gets (from its parent layout or from
/// the parentWidget()), divides it up into a row of boxes, and makes
/// each managed widget fill one box.
///
/// ![Horizontal box layout with five child widgets](qhboxlayout-with-5-children.png)
///
/// If the QBoxLayout's orientation is Qt::Horizontal the boxes are
/// placed in a row, with suitable sizes. Each widget (or other box)
/// will get at least its minimum size and at most its maximum size.
/// Any excess space is shared according to the stretch factors (more
/// about that below).
///
/// ![Vertical box layout with five child widgets](qvboxlayout-with-5-children.png)
///
/// If the QBoxLayout's orientation is Qt::Vertical, the boxes are
/// placed in a column, again with suitable sizes.
///
/// The easiest way to create a QBoxLayout is to use one of the
/// convenience classes, e.g. QHBoxLayout (for Qt::Horizontal boxes)
/// or QVBoxLayout (for Qt::Vertical boxes). You can also use the
/// QBoxLayout constructor directly, specifying its direction as
/// LeftToRight, RightToLeft, TopToBottom, or BottomToTop.
///
/// If the QBoxLayout is not the top-level layout (i.e. it is not
/// managing all of the widget's area and children), you must add it
/// to its parent layout before you can do anything with it. The
/// normal way to add a layout is by calling
/// parentLayout-\>addLayout().
///
/// Once you have done this, you can add boxes to the QBoxLayout using
/// one of four functions:
///
/// * addWidget() to add a widget to the QBoxLayout and set the widget's stretch factor. (The stretch factor is along the row of boxes.)
/// * addSpacing() to create an empty box; this is one of the functions you use to create nice and spacious dialogs. See below for ways to set margins.
/// * addStretch() to create an empty, stretchable box.
/// * addLayout() to add a box containing another QLayout to the row and set that layout's stretch factor.
///
/// Use insertWidget(), insertSpacing(), insertStretch() or
/// insertLayout() to insert a box at a specified position in the
/// layout.
///
/// QBoxLayout also includes two margin widths:
///
/// * setContentsMargins() sets the width of the outer border on each side of the widget. This is the width of the reserved space along each of the QBoxLayout's four sides.
/// * setSpacing() sets the width between neighboring boxes. (You can use addSpacing() to get more space at a particular spot.)
///
/// The margin default is provided by the style. The default margin
/// most Qt styles specify is 9 for child widgets and 11 for windows.
/// The spacing defaults to the same as the margin width for a
/// top-level layout, or to the same as the parent layout.
///
/// To remove a widget from a layout, call removeWidget(). Calling
/// QWidget::hide() on a widget also effectively removes the widget
/// from the layout until QWidget::show() is called.
///
/// You will almost always want to use QVBoxLayout and QHBoxLayout
/// rather than QBoxLayout because of their convenient constructors.
///
/// **See also:** [`GridLayout`]
/// [`StackedLayout`]
/// {Layout Management}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct BoxLayout<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUBoxLayoutAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> BoxLayout<'a> {
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUBoxLayout) -> BoxLayout<'a> {
        BoxLayout {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUBoxLayout) -> BoxLayout<'a> {
        BoxLayout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUBoxLayout) -> BoxLayout<'a> {
        BoxLayout {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Returns the direction of the box. addWidget() and addSpacing()
    /// work in this direction; the stretch stretches in this direction.
    ///
    /// **See also:** [`BoxLayout::direction()`]
    /// [`add_widget()`]
    /// [`add_spacing()`]
    pub fn direction(&self) -> Direction {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).direction)(obj_data);
            let ret_val = Direction::from_bits_truncate(ret_val);
            ret_val
        }
    }
    ///
    /// Sets the direction of this layout to *direction.*
    pub fn set_direction(&self, arg0: Direction) -> &Self {
        let enum_arg0_1 = arg0.bits();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).set_direction)(obj_data, enum_arg0_1);
        }
        self
    }
    ///
    /// Adds a non-stretchable space (a QSpacerItem) with size *size*
    /// to the end of this box layout. QBoxLayout provides default margin
    /// and spacing. This function adds additional space.
    ///
    /// **See also:** [`insert_spacing()`]
    /// [`add_item()`]
    /// [`SpacerItem`]
    pub fn add_spacing(&self, size: i32) -> &Self {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_spacing)(obj_data, size);
        }
        self
    }
    ///
    /// Adds *spacerItem* to the end of this box layout.
    ///
    /// **See also:** [`add_spacing()`]
    /// [`add_stretch()`]
    pub fn add_spacer_item<S: SpacerItemTrait<'a>>(&self, spacer_item: &S) -> &Self {
        let (obj_spacer_item_1, _funcs) = spacer_item.get_spacer_item_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_spacer_item)(obj_data, obj_spacer_item_1);
        }
        self
    }
    ///
    /// Adds *widget* to the end of this box layout, with a stretch
    /// factor of *stretch* and alignment *alignment.*
    ///
    /// The stretch factor applies only in the [direction](direction())
    ///
    /// of the QBoxLayout, and is relative to the other boxes and widgets
    /// in this QBoxLayout. Widgets and boxes with higher stretch factors
    /// grow more.
    ///
    /// If the stretch factor is 0 and nothing else in the QBoxLayout has
    /// a stretch factor greater than zero, the space is distributed
    /// according to the QWidget:sizePolicy() of each widget that's
    /// involved.
    ///
    /// The alignment is specified by *alignment.* The default
    /// alignment is 0, which means that the widget fills the entire cell.
    ///
    /// **See also:** [`insert_widget()`]
    /// [`add_item()`]
    /// [`add_layout()`]
    /// [`add_stretch()`]
    /// [`add_spacing()`]
    /// [`add_strut()`]
    pub fn add_widget<W: WidgetTrait<'a>>(
        &self,
        arg0: &W,
        stretch: i32,
        alignment: Alignment,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();
        let enum_alignment_3 = alignment.bits();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_widget)(obj_data, obj_arg0_1, stretch, enum_alignment_3);
        }
        self
    }
    ///
    /// Adds *layout* to the end of the box, with serial stretch factor
    /// *stretch.*
    ///
    /// **See also:** [`insert_layout()`]
    /// [`add_item()`]
    /// [`add_widget()`]
    pub fn add_layout<L: LayoutTrait<'a>>(&self, layout: &L, stretch: i32) -> &Self {
        let (obj_layout_1, _funcs) = layout.get_layout_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).add_layout)(obj_data, obj_layout_1, stretch);
        }
        self
    }
    ///
    ///
    /// Inserts a non-stretchable space (a QSpacerItem) at position *index,* with
    /// size *size.* If *index* is negative the space is added at the end.
    ///
    /// The box layout has default margin and spacing. This function adds
    /// additional space.
    ///
    /// **See also:** [`add_spacing()`]
    /// [`insert_item()`]
    /// [`SpacerItem`]
    pub fn insert_spacing(&self, index: i32, size: i32) -> &Self {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_spacing)(obj_data, index, size);
        }
        self
    }
    ///
    /// Inserts *spacerItem* at position *index,* with zero minimum
    /// size and stretch factor. If *index* is negative the
    /// space is added at the end.
    ///
    /// **See also:** [`add_spacer_item()`]
    /// [`insert_stretch()`]
    /// [`insert_spacing()`]
    ///
    /// Inserts *widget* at position *index,* with stretch factor *stretch* and alignment *alignment.* If *index* is negative, the
    /// widget is added at the end.
    ///
    /// The stretch factor applies only in the [direction](direction())
    ///
    /// of the QBoxLayout, and is relative to the other boxes and widgets
    /// in this QBoxLayout. Widgets and boxes with higher stretch factors
    /// grow more.
    ///
    /// If the stretch factor is 0 and nothing else in the QBoxLayout has
    /// a stretch factor greater than zero, the space is distributed
    /// according to the QWidget:sizePolicy() of each widget that's
    /// involved.
    ///
    /// The alignment is specified by *alignment.* The default alignment
    /// is 0, which means that the widget fills the entire cell.
    ///
    /// **See also:** [`add_widget()`]
    /// [`insert_item()`]
    pub fn insert_widget<W: WidgetTrait<'a>>(
        &self,
        index: i32,
        widget: &W,
        stretch: i32,
        alignment: Alignment,
    ) -> &Self {
        let (obj_widget_2, _funcs) = widget.get_widget_obj_funcs();
        let enum_alignment_4 = alignment.bits();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_widget)(obj_data, index, obj_widget_2, stretch, enum_alignment_4);
        }
        self
    }
    ///
    /// Inserts *layout* at position *index,* with stretch factor *stretch.* If *index* is negative, the layout is added at the end.
    ///
    /// *layout* becomes a child of the box layout.
    ///
    /// **See also:** [`add_layout()`]
    /// [`insert_item()`]
    pub fn insert_layout<L: LayoutTrait<'a>>(&self, index: i32, layout: &L, stretch: i32) -> &Self {
        let (obj_layout_2, _funcs) = layout.get_layout_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_layout)(obj_data, index, obj_layout_2, stretch);
        }
        self
    }
    ///
    /// Inserts *item* into this box layout at position *index.* If *index* is negative, the item is added at the end.
    ///
    /// **See also:** [`add_item()`]
    /// [`insert_widget()`]
    /// [`insert_layout()`]
    /// [`insert_stretch()`]
    /// [`insert_spacing()`]
    pub fn insert_item<L: LayoutItemTrait<'a>>(&self, index: i32, arg0: &L) -> &Self {
        let (obj_arg0_2, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).insert_item)(obj_data, index, obj_arg0_2);
        }
        self
    }
    ///
    /// Reimplements QLayout::spacing(). If the spacing property is
    /// valid, that value is returned. Otherwise, a value for the spacing
    /// property is computed and returned. Since layout spacing in a widget
    /// is style dependent, if the parent is a widget, it queries the style
    /// for the (horizontal or vertical) spacing of the layout. Otherwise,
    /// the parent is a layout, and it queries the parent layout for the
    /// spacing().
    ///
    /// **See also:** [`Layout::spacing`]
    /// [`set_spacing()`]
    pub fn spacing(&self) -> i32 {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacing)(obj_data);
            ret_val
        }
    }
    ///
    /// Reimplements QLayout::setSpacing(). Sets the spacing
    /// property to *spacing.*
    ///
    /// **See also:** [`Layout::set_spacing`]
    /// [`spacing()`]
    pub fn set_spacing(&self, spacing: i32) -> &Self {
        let (obj_data, funcs) = self.get_box_layout_obj_funcs();
        unsafe {
            ((*funcs).set_spacing)(obj_data, spacing);
        }
        self
    }
    #[doc(hidden)]
    pub fn margin(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).margin)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_margin(&self, arg0: i32) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_margin)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins(&self, left: i32, top: i32, right: i32, bottom: i32) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins)(obj_data, left, top, right, bottom);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_contents_margins_2<M: MarginsTrait<'a>>(&self, margins: &M) -> &Self {
        let (obj_margins_1, _funcs) = margins.get_margins_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_contents_margins_2)(obj_data, obj_margins_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn contents_margins(&self) -> Margins {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_margins)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Margins::new_from_rc(t);
            } else {
                ret_val = Margins::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn contents_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contents_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_alignment<W: WidgetTrait<'a>>(&self, w: &W, alignment: Alignment) -> bool {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();
        let enum_alignment_2 = alignment.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment)(obj_data, obj_w_1, enum_alignment_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_alignment_2<L: LayoutTrait<'a>>(&self, l: &L, alignment: Alignment) -> bool {
        let (obj_l_1, _funcs) = l.get_layout_obj_funcs();
        let enum_alignment_2 = alignment.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).set_alignment_2)(obj_data, obj_l_1, enum_alignment_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_menu_bar<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_menu_bar)(obj_data, obj_w_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn menu_bar(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).menu_bar)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn parent_widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent_widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn invalidate(&self) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).invalidate)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn activate(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).activate)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn update(&self) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).update)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn add_item<L: LayoutItemTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).add_item)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn remove_widget<W: WidgetTrait<'a>>(&self, w: &W) -> &Self {
        let (obj_w_1, _funcs) = w.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_widget)(obj_data, obj_w_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn remove_item<L: LayoutItemTrait<'a>>(&self, arg0: &L) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_layout_item_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).remove_item)(obj_data, obj_arg0_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn expanding_directions(&self) -> Orientations {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).expanding_directions)(obj_data);
            let ret_val = Orientations::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn item_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).item_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn take_at(&self, index: i32) -> Option<LayoutItem> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).take_at)(obj_data, index);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn index_of<W: WidgetTrait<'a>>(&self, arg0: &W) -> i32 {
        let (obj_arg0_1, _funcs) = arg0.get_widget_obj_funcs();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).index_of)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn count(&self) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).count)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_empty(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_empty)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn replace_widget<W: WidgetTrait<'a>>(
        &self,
        from: &W,
        to: &W,
        options: FindChildOptions,
    ) -> Option<LayoutItem> {
        let (obj_from_1, _funcs) = from.get_widget_obj_funcs();
        let (obj_to_2, _funcs) = to.get_widget_obj_funcs();
        let enum_options_3 = options.bits();

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).replace_widget)(obj_data, obj_from_1, obj_to_2, enum_options_3);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = LayoutItem::new_from_rc(t);
            } else {
                ret_val = LayoutItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn total_height_for_width(&self, w: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_height_for_width)(obj_data, w);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_minimum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_minimum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_maximum_size(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_maximum_size)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn total_size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).total_size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn layout(&self) -> Option<Layout> {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Layout::new_from_rc(t);
            } else {
                ret_val = Layout::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn set_size_constraint(&self, constraint: SizeConstraint) -> &Self {
        let enum_constraint_1 = constraint as u32;

        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_size_constraint)(obj_data, enum_constraint_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn size_constraint(&self) -> SizeConstraint {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_constraint)(obj_data);
            let ret_val = { transmute::<u32, SizeConstraint>(ret_val) };
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_enabled(&self, arg0: bool) -> &Self {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            ((*funcs).set_enabled)(obj_data, arg0);
        }
        self
    }
    #[doc(hidden)]
    pub fn is_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_enabled)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn size_hint(&self) -> Size {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).size_hint)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Size::new_from_rc(t);
            } else {
                ret_val = Size::new_from_owned(t);
            }
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn has_height_for_width(&self) -> bool {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_height_for_width)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn minimum_height_for_width(&self, arg0: i32) -> i32 {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).minimum_height_for_width)(obj_data, arg0);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn widget(&self) -> Option<Widget> {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).widget)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Widget::new_from_rc(t);
            } else {
                ret_val = Widget::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn spacer_item(&self) -> Option<SpacerItem> {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).spacer_item)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = SpacerItem::new_from_rc(t);
            } else {
                ret_val = SpacerItem::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn alignment(&self) -> Alignment {
        let (obj_data, funcs) = self.get_layout_item_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).alignment)(obj_data);
            let ret_val = Alignment::from_bits_truncate(ret_val);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn object_name(&self) -> String {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).object_name)(obj_data);
            let ret_val = CStr::from_ptr(ret_val).to_string_lossy().into_owned();
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_object_name(&self, name: &str) -> &Self {
        let str_in_name_1 = CString::new(name).unwrap();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_object_name)(obj_data, str_in_name_1.as_ptr());
        }
        self
    }
    #[doc(hidden)]
    pub fn is_widget_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_widget_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_window_type(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_window_type)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn signals_blocked(&self) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).signals_blocked)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn block_signals(&self, b: bool) -> bool {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).block_signals)(obj_data, b);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer(&self, interval: i32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer)(obj_data, interval, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn start_timer_2(&self, time: u32, timer_type: TimerType) -> i32 {
        let enum_timer_type_2 = timer_type as u32;

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).start_timer_2)(obj_data, time, enum_timer_type_2);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn kill_timer(&self, id: i32) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).kill_timer)(obj_data, id);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_parent<O: ObjectTrait<'a>>(&self, parent: &O) -> &Self {
        let (obj_parent_1, _funcs) = parent.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).set_parent)(obj_data, obj_parent_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn install_event_filter<O: ObjectTrait<'a>>(&self, filter_obj: &O) -> &Self {
        let (obj_filter_obj_1, _funcs) = filter_obj.get_object_obj_funcs();

        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).install_event_filter)(obj_data, obj_filter_obj_1);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_tree_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_tree_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn dump_object_info_2(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).dump_object_info_2)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn parent(&self) -> Option<Object> {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).parent)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Object::new_from_rc(t);
            } else {
                ret_val = Object::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    #[doc(hidden)]
    pub fn delete_later(&self) -> &Self {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        unsafe {
            ((*funcs).delete_later)(obj_data);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_custom_event_ud<F, T>(&self, data: &'a T, func: F) -> &Self
    where
        F: Fn(&T, &Event) + 'a,
        T: 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();

        let f: Box<Box<Fn(&T, &Event) + 'a>> = Box::new(Box::new(func));
        let user_data = data as *const _ as *const c_void;

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                user_data,
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline_ud::<T> as usize),
            );
        }

        self
    }

    pub fn set_custom_event<F>(&self, func: F) -> &Self
    where
        F: Fn(&Event) + 'a,
    {
        let (obj_data, funcs) = self.get_object_obj_funcs();
        let f: Box<Box<Fn(&Event) + 'a>> = Box::new(Box::new(func));

        unsafe {
            ((*funcs).set_custom_event)(
                obj_data,
                ::std::ptr::null(),
                Box::into_raw(f) as *const _,
                transmute(object_custom_trampoline as usize),
            );
        }

        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<WrapperRcOwn> for BoxLayout<'a> {
    fn from(t: WrapperRcOwn) -> Self {
        let mut data = RUBoxLayout {
            qt_data: ::std::ptr::null(),
            host_data: ::std::ptr::null(),
            all_funcs: t.all_funcs as *const RUBoxLayoutAllFuncs,
        };

        if t.owned {
            data.host_data = t.data as *const RUBase;
            BoxLayout::new_from_rc(data)
        } else {
            data.qt_data = t.data as *const RUBase;
            BoxLayout::new_from_temporary(data)
        }
    }
}

pub trait BoxLayoutTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_box_layout_obj_funcs(&self) -> (*const RUBase, *const RUBoxLayoutFuncs);
}

impl<'a> ObjectTrait<'a> for BoxLayout<'a> {
    #[doc(hidden)]
    fn get_object_obj_funcs(&self) -> (*const RUBase, *const RUObjectFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).object_funcs) }
    }
}

impl<'a> LayoutItemTrait<'a> for BoxLayout<'a> {
    #[doc(hidden)]
    fn get_layout_item_obj_funcs(&self) -> (*const RUBase, *const RULayoutItemFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_item_funcs) }
    }
}

impl<'a> LayoutTrait<'a> for BoxLayout<'a> {
    #[doc(hidden)]
    fn get_layout_obj_funcs(&self) -> (*const RUBase, *const RULayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).layout_funcs) }
    }
}

impl<'a> BoxLayoutTrait<'a> for BoxLayout<'a> {
    #[doc(hidden)]
    fn get_box_layout_obj_funcs(&self) -> (*const RUBase, *const RUBoxLayoutFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).box_layout_funcs) }
    }
}
bitflags! {
    pub struct Direction: u32 {
        const LeftToRight = 0x0;
        const RightToLeft = 0x1;
        const TopToBottom = 0x2;
        const BottomToTop = 0x3;
        const Down = 0x2;
        const Up = 0x3;
    }
}
