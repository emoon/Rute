// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// A QPolygon object is a QVector<QPoint>. The easiest way to add
/// points to a QPolygon is to use QVector's streaming operator, as
/// illustrated below:
///
/// In addition to the functions provided by QVector, QPolygon
/// provides some point-specific functions.
///
/// Each point in a polygon can be retrieved by passing its index to
/// the point() function. To populate the polygon, QPolygon provides
/// the setPoint() function to set the point at a given index, the
/// setPoints() function to set all the points in the polygon
/// (resizing it to the given number of points), and the putPoints()
/// function which copies a number of given points into the polygon
/// from a specified index (resizing the polygon if necessary).
///
/// QPolygon provides the boundingRect() and translate() functions for
/// geometry functions. Use the QMatrix::map() function for more
/// general transformations of QPolygons.
///
/// The QPolygon class is [implicitly
/// shared](Implicit%20Data%20Sharing)
///
///
/// **See also:** [`Vector`]
/// [`PolygonF`]
/// [`Line`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Polygon<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUPolygonAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Polygon<'a> {
    pub fn new() -> Polygon<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_polygon)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Polygon {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUPolygon) -> Polygon<'a> {
        Polygon {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUPolygon) -> Polygon<'a> {
        Polygon {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUPolygon) -> Polygon<'a> {
        Polygon {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Swaps polygon *other* with this polygon. This operation is very
    /// fast and never fails.
    pub fn swap<P: PolygonTrait<'a>>(&self, other: &P) -> &Self {
        let (obj_other_1, _funcs) = other.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            ((*funcs).swap)(obj_data, obj_other_1);
        }
        self
    }
    ///
    /// Returns the bounding rectangle of the polygon, or QRect(0, 0, 0,
    /// 0) if the polygon is empty.
    ///
    /// **See also:** [`Vector::is_empty`]
    pub fn bounding_rect(&self) -> Rect {
        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).bounding_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Extracts the coordinates of the point at the given *index* to
    /// * *x* and * *y* (if they are valid pointers).
    ///
    /// **See also:** [`set_point()`]
    ///
    /// **Overloads**
    /// Returns the point at the given *index.*
    pub fn point_2(&self, i: i32) -> Point {
        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).point_2)(obj_data, i);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// **Overloads**
    /// Sets the point at the given *index* to the given *point.*
    ///
    /// Sets the point at the given *index* to the point specified by
    /// ( *x* , *y* ).
    ///
    /// **See also:** [`point()`]
    /// [`put_points()`]
    /// [`set_points()`]
    /// */
    ///
    /// /*!
    /// Resizes the polygon to *nPoints* and populates it with the given
    /// *points.*
    ///
    /// The example code creates a polygon with two points (10, 20) and
    /// (30, 40):
    ///
    /// **See also:** [`set_point()`]
    /// [`put_points()`]
    ///
    /// **Overloads**
    /// Resizes the polygon to *nPoints* and populates it with the points
    /// specified by the variable argument list. The points are given as a
    /// sequence of integers, starting with *firstx* then *firsty,* and
    /// so on.
    ///
    /// The example code creates a polygon with two points (10, 20) and
    /// (30, 40):
    ///
    pub fn set_point(&self, index: i32, x: i32, y: i32) -> &Self {
        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            ((*funcs).set_point)(obj_data, index, x, y);
        }
        self
    }
    ///
    /// **Overloads**
    /// Sets the point at the given *index* to the given *point.*
    ///
    /// Sets the point at the given *index* to the point specified by
    /// ( *x* , *y* ).
    ///
    /// **See also:** [`point()`]
    /// [`put_points()`]
    /// [`set_points()`]
    /// */
    ///
    /// /*!
    /// Resizes the polygon to *nPoints* and populates it with the given
    /// *points.*
    ///
    /// The example code creates a polygon with two points (10, 20) and
    /// (30, 40):
    ///
    /// **See also:** [`set_point()`]
    /// [`put_points()`]
    ///
    /// **Overloads**
    /// Resizes the polygon to *nPoints* and populates it with the points
    /// specified by the variable argument list. The points are given as a
    /// sequence of integers, starting with *firstx* then *firsty,* and
    /// so on.
    ///
    /// The example code creates a polygon with two points (10, 20) and
    /// (30, 40):
    ///
    pub fn set_point_2<P: PointTrait<'a>>(&self, index: i32, p: &P) -> &Self {
        let (obj_p_2, _funcs) = p.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            ((*funcs).set_point_2)(obj_data, index, obj_p_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Resizes the polygon to *nPoints* and populates it with the points
    /// specified by the variable argument list. The points are given as a
    /// sequence of integers, starting with *firstx* then *firsty,* and
    /// so on.
    ///
    /// The example code creates a polygon with two points (10, 20) and
    /// (30, 40):
    ///
    pub fn set_points_2(&self, n_points: i32, firstx: i32, firsty: i32) -> &Self {
        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            ((*funcs).set_points_2)(obj_data, n_points, firstx, firsty);
        }
        self
    }
    ///
    /// Copies *nPoints* points from the variable argument list into this
    /// polygon from the given *index.*
    ///
    /// The points are given as a sequence of integers, starting with *firstx* then *firsty,* and so on. The polygon is resized if
    /// `index+nPoints` exceeds its current size.
    ///
    /// The example code creates a polygon with three points (4,5), (6,7)
    /// and (8,9), by expanding the polygon from 1 to 3 points:
    ///
    /// The following code has the same result, but here the putPoints()
    /// function overwrites rather than extends:
    ///
    /// **See also:** [`set_points()`]
    ///
    /// **Overloads**
    /// Copies *nPoints* points from the given *fromIndex* ( 0 by
    /// default) in *fromPolygon* into this polygon, starting at the
    /// specified *index.* For example:
    ///
    pub fn put_points_2(&self, index: i32, n_points: i32, firstx: i32, firsty: i32) -> &Self {
        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            ((*funcs).put_points_2)(obj_data, index, n_points, firstx, firsty);
        }
        self
    }
    ///
    /// Copies *nPoints* points from the variable argument list into this
    /// polygon from the given *index.*
    ///
    /// The points are given as a sequence of integers, starting with *firstx* then *firsty,* and so on. The polygon is resized if
    /// `index+nPoints` exceeds its current size.
    ///
    /// The example code creates a polygon with three points (4,5), (6,7)
    /// and (8,9), by expanding the polygon from 1 to 3 points:
    ///
    /// The following code has the same result, but here the putPoints()
    /// function overwrites rather than extends:
    ///
    /// **See also:** [`set_points()`]
    ///
    /// **Overloads**
    /// Copies *nPoints* points from the given *fromIndex* ( 0 by
    /// default) in *fromPolygon* into this polygon, starting at the
    /// specified *index.* For example:
    ///
    pub fn put_points_3<P: PolygonTrait<'a>>(
        &self,
        index: i32,
        n_points: i32,
        from: &P,
        from_index: i32,
    ) -> &Self {
        let (obj_from_3, _funcs) = from.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            ((*funcs).put_points_3)(obj_data, index, n_points, obj_from_3, from_index);
        }
        self
    }
    ///
    /// Returns `true` if the given *point* is inside the polygon according to
    /// the specified *fillRule;* otherwise returns `false.`
    pub fn contains_point<P: PointTrait<'a>>(&self, pt: &P, fill_rule: FillRule) -> bool {
        let (obj_pt_1, _funcs) = pt.get_point_obj_funcs();
        let enum_fill_rule_2 = fill_rule as i32;

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).contains_point)(obj_data, obj_pt_1, enum_fill_rule_2);
            ret_val
        }
    }
    ///
    /// Returns a polygon which is the union of this polygon and *r.*
    ///
    /// Set operations on polygons, will treat the polygons as areas, and
    /// implicitly close the polygon.
    ///
    /// **See also:** [`intersected()`]
    /// [`subtracted()`]
    pub fn united<P: PolygonTrait<'a>>(&self, r: &P) -> Polygon {
        let (obj_r_1, _funcs) = r.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).united)(obj_data, obj_r_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Polygon::new_from_rc(t);
            } else {
                ret_val = Polygon::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns a polygon which is the intersection of this polygon and *r.*
    ///
    /// Set operations on polygons will treat the polygons as
    /// areas. Non-closed polygons will be treated as implicitly closed.
    ///
    /// **See also:** [`intersects()`]
    pub fn intersected<P: PolygonTrait<'a>>(&self, r: &P) -> Polygon {
        let (obj_r_1, _funcs) = r.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).intersected)(obj_data, obj_r_1);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Polygon::new_from_rc(t);
            } else {
                ret_val = Polygon::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns `true` if the current polygon intersects at any point the given polygon *p.*
    /// Also returns `true` if the current polygon contains or is contained by any part of *p.*
    ///
    /// Set operations on polygons will treat the polygons as
    /// areas. Non-closed polygons will be treated as implicitly closed.
    ///
    /// **See also:** [`intersected()`]
    pub fn intersects<P: PolygonTrait<'a>>(&self, r: &P) -> bool {
        let (obj_r_1, _funcs) = r.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_polygon_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).intersects)(obj_data, obj_r_1);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn is_null(&self) -> bool {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_null)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn x(&self) -> i32 {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).x)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn y(&self) -> i32 {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).y)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn set_x(&self, x: i32) -> &Self {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            ((*funcs).set_x)(obj_data, x);
        }
        self
    }
    #[doc(hidden)]
    pub fn set_y(&self, y: i32) -> &Self {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            ((*funcs).set_y)(obj_data, y);
        }
        self
    }
    #[doc(hidden)]
    pub fn manhattan_length(&self) -> i32 {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).manhattan_length)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn rx(&self) -> i32 {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).rx)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn ry(&self) -> i32 {
        let (obj_data, funcs) = self.get_point_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).ry)(obj_data);
            ret_val
        }
    }
    #[doc(hidden)]
    pub fn dot_product<P: PointTrait<'a>>(p1: &P, p2: &P) -> i32 {
        let (obj_p1_1, _funcs) = p1.get_point_obj_funcs();
        let (obj_p2_2, _funcs) = p2.get_point_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_point)(::std::ptr::null()).all_funcs).point_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).dot_product)(obj_data, obj_p1_1, obj_p2_2);
            ret_val
        }
    }
}
pub trait PolygonTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_polygon_obj_funcs(&self) -> (*const RUBase, *const RUPolygonFuncs);
}

impl<'a> PointTrait<'a> for Polygon<'a> {
    #[doc(hidden)]
    fn get_point_obj_funcs(&self) -> (*const RUBase, *const RUPointFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).point_funcs) }
    }
}

impl<'a> PolygonTrait<'a> for Polygon<'a> {
    #[doc(hidden)]
    fn get_polygon_obj_funcs(&self) -> (*const RUBase, *const RUPolygonFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).polygon_funcs) }
    }
}
