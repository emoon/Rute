// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

// Auto-generated imports

#[allow(unused_imports)]
use auto::event::*;
#[allow(unused_imports)]
use auto::event_ffi::*;
#[allow(unused_imports)]
use auto::input_event::*;
#[allow(unused_imports)]
use auto::input_event_ffi::*;
#[allow(unused_imports)]
use auto::point::Point;
#[allow(unused_imports)]
use auto::point_f::PointF;
#[allow(unused_imports)]
use auto::rute::*;
#[allow(unused_imports)]
use auto::rute_enums::MouseButtons;
#[allow(unused_imports)]
use auto::rute_enums::MouseEventSource;
#[allow(unused_imports)]
use auto::rute_enums::Orientation;
#[allow(unused_imports)]
use auto::rute_enums::ScrollPhase;
#[allow(unused_imports)]
use auto::rute_ffi::*;
#[allow(unused_imports)]
use auto::wheel_event_ffi::*;
///
/// Wheel events are sent to the widget under the mouse cursor, but
/// if that widget does not handle the event they are sent to the
/// focus widget. Wheel events are generated for both mouse wheels
/// and trackpad scroll gestures. There are two ways to read the
/// wheel event delta: angleDelta() returns the delta in wheel
/// degrees. This value is always provided. pixelDelta() returns
/// the delta in screen pixels and is available on platforms that
/// have high-resolution trackpads, such as MacOS . If that is the
/// case, source() will return Qt::MouseEventSynthesizedBySystem.
///
/// The functions pos() and globalPos() return the mouse cursor's
/// location at the time of the event.
///
/// A wheel event contains a special accept flag that indicates
/// whether the receiver wants the event. You should call ignore() if
/// you do not handle the wheel event; this ensures that it will be
/// sent to the parent widget.
///
/// The QWidget::setEnabled() function can be used to enable or
/// disable mouse and keyboard events for a widget.
///
/// The event handler QWidget::wheelEvent() receives wheel events.
///
/// **See also:** [`MouseEvent`]
/// [`Widget::grab_mouse`]
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct WheelEvent<'a> {
    pub data: Rc<Cell<Option<*const RUBase>>>,
    pub all_funcs: *const RUWheelEventAllFuncs,
    pub owned: bool,
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> WheelEvent<'a> {
    pub fn new_from_rc(ffi_data: RUWheelEvent) -> WheelEvent<'a> {
        WheelEvent {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    pub fn new_from_owned(ffi_data: RUWheelEvent) -> WheelEvent<'a> {
        WheelEvent {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    pub fn new_from_temporary(ffi_data: RUWheelEvent) -> WheelEvent<'a> {
        WheelEvent {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
}
pub trait WheelEventTrait<'a> {
    ///
    /// Returns the scrolling distance in pixels on screen. This value is
    /// provided on platforms that support high-resolution pixel-based
    /// delta values, such as MacOS . The value should be used directly
    /// to scroll content on screen.
    ///
    /// Example:
    ///
    /// **Note**: On platforms that support scrolling [phases](phase())
    /// , the delta may be null when:
    /// * scrolling is about to begin, but the distance did not yet change (Qt::ScrollBegin),
    /// * or scrolling has ended and the distance did not change anymore (Qt::ScrollEnd).
    /// **Note**: On X11 this value is driver specific and unreliable, use angleDelta() instead
    fn pixel_delta(&self) -> Point {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pixel_delta)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the distance that the wheel is rotated, in eighths of a
    /// degree. A positive value indicates that the wheel was rotated
    /// forwards away from the user; a negative value indicates that the
    /// wheel was rotated backwards toward the user.
    ///
    /// Most mouse types work in steps of 15 degrees, in which case the
    /// delta value is a multiple of 120; i.e., 120 units * 1/8 = 15 degrees.
    ///
    /// However, some mice have finer-resolution wheels and send delta values
    /// that are less than 120 units (less than 15 degrees). To support this
    /// possibility, you can either cumulatively add the delta values from events
    /// until the value of 120 is reached, then scroll the widget, or you can
    /// partially scroll the widget in response to each wheel event.
    ///
    /// Example:
    ///
    /// **Note**: On platforms that support scrolling [phases](phase())
    /// , the delta may be null when:
    /// * scrolling is about to begin, but the distance did not yet change (Qt::ScrollBegin),
    /// * or scrolling has ended and the distance did not change anymore (Qt::ScrollEnd).
    fn angle_delta(&self) -> Point {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).angle_delta)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// This function has been deprecated, use pixelDelta() or angleDelta() instead.
    fn delta(&self) -> i32 {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).delta)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the wheel's orientation.
    ///
    /// Use angleDelta() instead.
    fn orientation(&self) -> Orientation {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).orientation)(obj_data);
            let ret_val = { transmute::<i32, Orientation>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the position of the mouse cursor relative to the widget
    /// that received the event.
    ///
    /// If you move your widgets around in response to mouse events,
    /// use globalPos() instead of this function.
    ///
    /// **See also:** [`x()`]
    /// [`y()`]
    /// [`global_pos()`]
    ///
    /// Returns the position of the mouse cursor relative to the widget
    /// that received the event.
    ///
    /// If you move your widgets around in response to mouse events,
    /// use globalPosF() instead of this function.
    ///
    /// **See also:** [`global_pos_f()`]
    fn pos(&self) -> Point {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pos)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the global position of the mouse pointer *at the time
    /// of the event* . This is important on asynchronous window systems
    /// such as X11; whenever you move your widgets around in response to
    /// mouse events, globalPos() can differ a lot from the current
    /// cursor position returned by QCursor::pos().
    ///
    /// **See also:** [`global_x()`]
    /// [`global_y()`]
    ///
    /// Returns the global position of the mouse pointer *at the time
    /// of the event* . This is important on asynchronous window systems
    /// such as X11; whenever you move your widgets around in response to
    /// mouse events, globalPosF() can differ a lot from the current
    /// cursor position returned by QCursor::pos().
    ///
    /// **See also:** [`pos_f()`]
    fn global_pos(&self) -> Point {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).global_pos)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the x position of the mouse cursor, relative to the
    /// widget that received the event.
    ///
    /// **See also:** [`y()`]
    /// [`pos()`]
    fn x(&self) -> i32 {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).x)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the y position of the mouse cursor, relative to the
    /// widget that received the event.
    ///
    /// **See also:** [`x()`]
    /// [`pos()`]
    fn y(&self) -> i32 {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).y)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the global x position of the mouse cursor at the time of
    /// the event.
    ///
    /// **See also:** [`global_y()`]
    /// [`global_pos()`]
    fn global_x(&self) -> i32 {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).global_x)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the global y position of the mouse cursor at the time of
    /// the event.
    ///
    /// **See also:** [`global_x()`]
    /// [`global_pos()`]
    fn global_y(&self) -> i32 {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).global_y)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the position of the mouse cursor relative to the widget
    /// that received the event.
    ///
    /// If you move your widgets around in response to mouse events,
    /// use globalPosF() instead of this function.
    ///
    /// **See also:** [`global_pos_f()`]
    fn pos_f(&self) -> Option<PointF> {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pos_f)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PointF::new_from_rc(t);
            } else {
                ret_val = PointF::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the global position of the mouse pointer *at the time
    /// of the event* . This is important on asynchronous window systems
    /// such as X11; whenever you move your widgets around in response to
    /// mouse events, globalPosF() can differ a lot from the current
    /// cursor position returned by QCursor::pos().
    ///
    /// **See also:** [`pos_f()`]
    fn global_pos_f(&self) -> Option<PointF> {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).global_pos_f)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PointF::new_from_rc(t);
            } else {
                ret_val = PointF::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the mouse state when the event occurred.
    fn buttons(&self) -> MouseButtons {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).buttons)(obj_data);
            let ret_val = { transmute::<i32, MouseButtons>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the scrolling phase of this wheel event.
    ///
    /// **Note**: The Qt::ScrollBegin and Qt::ScrollEnd phases are currently
    /// supported only on MacOS .
    fn phase(&self) -> ScrollPhase {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).phase)(obj_data);
            let ret_val = { transmute::<i32, ScrollPhase>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns whether the delta values delivered with the event are inverted.
    ///
    /// Normally, a vertical wheel will produce a QWheelEvent with positive delta
    /// values if the top of the wheel is rotating away from the hand operating it.
    /// Similarly, a horizontal wheel movement will produce a QWheelEvent with
    /// positive delta values if the top of the wheel is moved to the left.
    ///
    /// However, on some platforms this is configurable, so that the same
    /// operations described above will produce negative delta values (but with the
    /// same magnitude). With the inverted property a wheel event consumer can
    /// choose to always follow the direction of the wheel, regardless of the
    /// system settings, but only for specific widgets. (One such use case could be
    /// that the user is rotating the wheel in the same direction as a visual
    /// Tumbler rotates. Another usecase is to make a slider handle follow the
    /// direction of movement of fingers on a touchpad regardless of system
    /// configuration.)
    ///
    /// **Note**: Many platforms provide no such information. On such platforms
    /// [inverted](inverted)
    /// always returns false.
    fn inverted(&self) -> bool {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).inverted)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns information about the wheel event source.
    ///
    /// The source can be used to distinguish between events that come from a mouse
    /// with a physical wheel and events that are generated by some other means,
    /// such as a flick gesture on a touchpad.
    ///
    /// **Note**: Many platforms provide no such information. On such platforms
    /// [Qt::MouseEventNotSynthesized](Qt::MouseEventNotSynthesized)
    /// is returned always.
    ///
    /// **See also:** [`t::mouse_event_source()`]
    fn source(&self) -> MouseEventSource {
        let (obj_data, funcs) = self.get_wheel_event_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).source)(obj_data);
            let ret_val = { transmute::<i32, MouseEventSource>(ret_val) };
            ret_val
        }
    }

    #[inline]
    fn get_wheel_event_obj_funcs(&self) -> (*const RUBase, *const RUWheelEventFuncs);
}

impl<'a> EventTrait<'a> for WheelEvent<'a> {
    #[inline]
    fn get_event_obj_funcs(&self) -> (*const RUBase, *const RUEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).event_funcs) }
    }
}

impl<'a> InputEventTrait<'a> for WheelEvent<'a> {
    #[inline]
    fn get_input_event_obj_funcs(&self) -> (*const RUBase, *const RUInputEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).input_event_funcs) }
    }
}

impl<'a> WheelEventTrait<'a> for WheelEvent<'a> {
    #[inline]
    fn get_wheel_event_obj_funcs(&self) -> (*const RUBase, *const RUWheelEventFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).wheel_event_funcs) }
    }
}
#[repr(u32)]
pub enum WheelEventFixMeEnums {
    DefaultDeltasPerStep,
}
