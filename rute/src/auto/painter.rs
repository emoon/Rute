// This file is auto-generated by rute_gen. DO NOT EDIT.
use std::cell::Cell;
use std::rc::Rc;

#[allow(unused_imports)]
use std::marker::PhantomData;

#[allow(unused_imports)]
use std::os::raw::c_void;

#[allow(unused_imports)]
use std::mem::transmute;

#[allow(unused_imports)]
use std::ffi::{CStr, CString};

use rute_ffi_base::*;

#[allow(unused_imports)]
use auto::*;

/// **Notice these docs are heavy WIP and not very relevent yet**
///
/// QPainter provides highly optimized functions to do most of the
/// drawing GUI programs require. It can draw everything from simple
/// lines to complex shapes like pies and chords. It can also draw
/// aligned text and pixmaps. Normally, it draws in a
/// coordinate system, but it can also do view and world
/// transformation. QPainter can operate on any object that inherits
/// the QPaintDevice class.
///
/// The common use of QPainter is inside a widget's paint event:
/// Construct and customize (e.g. set the pen or the brush) the
/// painter. Then draw. Remember to destroy the QPainter object after
/// drawing. For example:
///
/// The core functionality of QPainter is drawing, but the class also
/// provide several functions that allows you to customize QPainter's
/// settings and its rendering quality, and others that enable
/// clipping. In addition you can control how different shapes are
/// merged together by specifying the painter's composition mode.
///
/// The isActive() function indicates whether the painter is active. A
/// painter is activated by the begin() function and the constructor
/// that takes a QPaintDevice argument. The end() function, and the
/// destructor, deactivates it.
///
/// Together with the QPaintDevice and QPaintEngine classes, QPainter
/// form the basis for Qt's paint system. QPainter is the class used
/// to perform drawing operations. QPaintDevice represents a device
/// that can be painted on using a QPainter. QPaintEngine provides the
/// interface that the painter uses to draw onto different types of
/// devices. If the painter is active, device() returns the paint
/// device on which the painter paints, and paintEngine() returns the
/// paint engine that the painter is currently operating on. For more
/// information, see the [Paint System](Paint%20System)
///
///
/// Sometimes it is desirable to make someone else paint on an unusual
/// QPaintDevice. QPainter supports a static function to do this,
/// setRedirected().
///
/// **Warning**: When the paintdevice is a widget, QPainter can only be
/// used inside a paintEvent() function or in a function called by
/// paintEvent().
///
/// # Settings
///
/// There are several settings that you can customize to make QPainter
/// draw according to your preferences:
///
/// * font() is the font used for drawing text. If the painter isActive(), you can retrieve information about the currently set font, and its metrics, using the fontInfo() and fontMetrics() functions respectively.
/// * brush() defines the color or pattern that is used for filling shapes.
/// * pen() defines the color or stipple that is used for drawing lines or boundaries.
/// * backgroundMode() defines whether there is a background() or not, i.e it is either Qt::OpaqueMode or Qt::TransparentMode.
/// * background() only applies when backgroundMode() is [Qt::OpaqueMode](Qt::OpaqueMode)
/// and pen() is a stipple. In that case, it describes the color of the background pixels in the stipple.
/// * brushOrigin() defines the origin of the tiled brushes, normally the origin of widget's background.
/// * viewport(), window(), worldTransform() make up the painter's coordinate transformation system. For more information, see the [Coordinate Transformations](Coordinate%20Transformations)
/// section and the [Coordinate
/// System](Coordinate%0A%20%20%20%20%20%20%20%20System)
/// documentation.
/// * hasClipping() tells whether the painter clips at all. (The paint device clips, too.) If the painter clips, it clips to clipRegion().
/// * layoutDirection() defines the layout direction used by the painter when drawing text.
/// * worldMatrixEnabled() tells whether world transformation is enabled.
/// * viewTransformEnabled() tells whether view transformation is enabled.
///
/// Note that some of these settings mirror settings in some paint
/// devices, e.g. QWidget::font(). The QPainter::begin() function (or
/// equivalently the QPainter constructor) copies these attributes
/// from the paint device.
///
/// You can at any time save the QPainter's state by calling the
/// save() function which saves all the available settings on an
/// internal stack. The restore() function pops them back.
///
/// # Drawing
///
/// QPainter provides functions to draw most primitives: drawPoint(),
/// drawPoints(), drawLine(), drawRect(), drawRoundedRect(),
/// drawEllipse(), drawArc(), drawPie(), drawChord(), drawPolyline(),
/// drawPolygon(), drawConvexPolygon() and drawCubicBezier(). The two
/// convenience functions, drawRects() and drawLines(), draw the given
/// number of rectangles or lines in the given array of [QRects](QRect)
/// or [QLines](QLine)
/// using the current pen and
/// brush.
///
/// The QPainter class also provides the fillRect() function which
/// fills the given QRect, with the given QBrush, and the eraseRect()
/// function that erases the area inside the given rectangle.
///
/// All of these functions have both integer and floating point
/// versions.
///
/// * ![qpainter-basicdrawing.png](qpainter-basicdrawing.png)
///
/// * **Basic Drawing Example** The [Basic Drawing](painting/basicdrawing)
/// example shows how to display basic graphics primitives in a variety of styles using the QPainter class.
///
/// If you need to draw a complex shape, especially if you need to do
/// so repeatedly, consider creating a QPainterPath and drawing it
/// using drawPath().
///
/// * **Painter Paths example** The QPainterPath class provides a container for painting operations, enabling graphical shapes to be constructed and reused. The [Painter Paths](painting/painterpaths)
/// example shows how painter paths can be used to build complex shapes for rendering.
/// * ![qpainter-painterpaths.png](qpainter-painterpaths.png)
///
/// QPainter also provides the fillPath() function which fills the
/// given QPainterPath with the given QBrush, and the strokePath()
/// function that draws the outline of the given path (i.e. strokes
/// the path).
///
/// See also the [Vector Deformation](painting/deform)
/// example which
/// shows how to use advanced vector techniques to draw text using a
/// QPainterPath, the [Gradients](painting/gradients)
/// example which shows
/// the different types of gradients that are available in Qt, and the [Path Stroking](painting/pathstroke)
/// example which shows Qt's built-in
/// dash patterns and shows how custom patterns can be used to extend
/// the range of available patterns.
///
/// * [Vector Deformation](painting/deform)
///
/// * [Gradients](painting/gradients)
///
/// * [Path Stroking](painting/pathstroke)
///
/// * ![qpainter-vectordeformation.png](qpainter-vectordeformation.png)
///
/// * ![qpainter-gradients.png](qpainter-gradients.png)
///
/// * ![qpainter-pathstroking.png](qpainter-pathstroking.png)
///
/// Text drawing is done using drawText(). When you need
/// fine-grained positioning, boundingRect() tells you where a given
/// drawText() command will draw.
///
/// # Drawing Pixmaps and Images
///
/// There are functions to draw pixmaps/images, namely drawPixmap(),
/// drawImage() and drawTiledPixmap(). Both drawPixmap() and drawImage()
/// produce the same result, except that drawPixmap() is faster
/// on-screen while drawImage() may be faster on a QPrinter or other
/// devices.
///
/// There is a drawPicture() function that draws the contents of an
/// entire QPicture. The drawPicture() function is the only function
/// that disregards all the painter's settings as QPicture has its own
/// settings.
///
/// ## Drawing High Resolution Versions of Pixmaps and Images
///
/// High resolution versions of pixmaps have a *device pixel ratio* value larger
/// than 1 (see QImageReader, QPixmap::devicePixelRatio()). Should it match the value
/// of the underlying QPaintDevice, it is drawn directly onto the device with no
/// additional transformation applied.
///
/// This is for example the case when drawing a QPixmap of 64x64 pixels size with
/// a device pixel ratio of 2 onto a high DPI screen which also has
/// a device pixel ratio of 2. Note that the pixmap is then effectively 32x32
/// pixels in *user space* . Code paths in Qt that calculate layout geometry
/// based on the pixmap size will use this size. The net effect of this is that
/// the pixmap is displayed as high DPI pixmap rather than a large pixmap.
///
/// # Rendering Quality
///
/// To get the optimal rendering result using QPainter, you should use
/// the platform independent QImage as paint device; i.e. using QImage
/// will ensure that the result has an identical pixel representation
/// on any platform.
///
/// The QPainter class also provides a means of controlling the
/// rendering quality through its RenderHint enum and the support for
/// floating point precision: All the functions for drawing primitives
/// has a floating point version. These are often used in combination
/// with the [QPainter::Antialiasing](RenderHint)
/// render hint.
///
/// * ![qpainter-concentriccircles.png](qpainter-concentriccircles.png)
///
/// * **Concentric Circles Example** The [Concentric Circles](painting/concentriccircles)
/// example shows the improved rendering quality that can be obtained using floating point precision and anti-aliasing when drawing custom widgets. The application's main window displays several widgets which are drawn using the various combinations of precision and anti-aliasing.
///
/// The RenderHint enum specifies flags to QPainter that may or may
/// not be respected by any given engine. [QPainter::Antialiasing](RenderHint)
/// indicates that the engine
/// should antialias edges of primitives if possible, [QPainter::TextAntialiasing](RenderHint)
/// indicates that the engine
/// should antialias text if possible, and the [QPainter::SmoothPixmapTransform](RenderHint)
/// indicates that the
/// engine should use a smooth pixmap transformation algorithm.
///
/// The renderHints() function returns a flag that specifies the
/// rendering hints that are set for this painter. Use the
/// setRenderHint() function to set or clear the currently set
/// RenderHints.
///
/// # Coordinate Transformations
///
/// Normally, the QPainter operates on the device's own coordinate
/// system (usually pixels), but QPainter has good support for
/// coordinate transformations.
///
/// * nop
/// * rotate()
/// * scale()
/// * translate()
///
/// * ![qpainter-clock.png](qpainter-clock.png)
///
/// * ![qpainter-rotation.png](qpainter-rotation.png)
///
/// * ![qpainter-scale.png](qpainter-scale.png)
///
/// * ![qpainter-translation.png](qpainter-translation.png)
///
/// The most commonly used transformations are scaling, rotation,
/// translation and shearing. Use the scale() function to scale the
/// coordinate system by a given offset, the rotate() function to
/// rotate it clockwise and translate() to translate it (i.e. adding a
/// given offset to the points). You can also twist the coordinate
/// system around the origin using the shear() function. See the [Affine Transformations](painting/affine)
/// example for a visualization of
/// a sheared coordinate system.
///
/// See also the [Transformations](painting/transformations)
///
/// example which shows how transformations influence the way that
/// QPainter renders graphics primitives. In particular it shows how
/// the order of transformations affects the result.
///
/// * **Affine Transformations Example** The [Affine Transformations](painting/affine)
/// example shows Qt's ability to perform affine transformations on painting operations. The demo also allows the user to experiment with the transformation operations and see the results immediately.
/// * ![qpainter-affinetransformations.png](qpainter-affinetransformations.png)
///
/// All the tranformation operations operate on the transformation
/// worldTransform(). A matrix transforms a point in the plane to another
/// point. For more information about the transformation matrix, see
/// the [Coordinate System](Coordinate%20System)
/// and QTransform documentation.
///
/// The setWorldTransform() function can replace or add to the currently
/// set worldTransform(). The resetTransform() function resets any
/// transformations that were made using translate(), scale(),
/// shear(), rotate(), setWorldTransform(), setViewport() and setWindow()
/// functions. The deviceTransform() returns the matrix that transforms
/// from logical coordinates to device coordinates of the platform
/// dependent paint device. The latter function is only needed when
/// using platform painting commands on the platform dependent handle,
/// and the platform does not do transformations nativly.
///
/// When drawing with QPainter, we specify points using logical
/// coordinates which then are converted into the physical coordinates
/// of the paint device. The mapping of the logical coordinates to the
/// physical coordinates are handled by QPainter's combinedTransform(), a
/// combination of viewport() and window() and worldTransform(). The
/// viewport() represents the physical coordinates specifying an
/// arbitrary rectangle, the window() describes the same rectangle in
/// logical coordinates, and the worldTransform() is identical with the
/// transformation matrix.
///
/// See also [Coordinate System](Coordinate%20System)
/// # Clipping
///
/// QPainter can clip any drawing operation to a rectangle, a region,
/// or a vector path. The current clip is available using the
/// functions clipRegion() and clipPath(). Whether paths or regions are
/// preferred (faster) depends on the underlying paintEngine(). For
/// example, the QImage paint engine prefers paths while the X11 paint
/// engine prefers regions. Setting a clip is done in the painters
/// logical coordinates.
///
/// After QPainter's clipping, the paint device may also clip. For
/// example, most widgets clip away the pixels used by child widgets,
/// and most printers clip away an area near the edges of the paper.
/// This additional clipping is not reflected by the return value of
/// clipRegion() or hasClipping().
///
/// # Composition Modes
///
/// QPainter provides the CompositionMode enum which defines the
/// Porter-Duff rules for digital image compositing; it describes a
/// model for combining the pixels in one image, the source, with the
/// pixels in another image, the destination.
///
/// The two most common forms of composition are [Source](QPainter::CompositionMode)
/// and [SourceOver](QPainter::CompositionMode)
/// . [Source](QPainter::CompositionMode)
/// is used to draw opaque objects
/// onto a paint device. In this mode, each pixel in the source
/// replaces the corresponding pixel in the destination. In [SourceOver](QPainter::CompositionMode)
/// composition mode, the
/// source object is transparent and is drawn on top of the
/// destination.
///
/// Note that composition transformation operates pixelwise. For that
/// reason, there is a difference between using the graphic primitive
/// itself and its bounding rectangle: The bounding rect contains
/// pixels with alpha == 0 (i.e the pixels surrounding the
/// primitive). These pixels will overwrite the other image's pixels,
/// affectively clearing those, while the primitive only overwrites
/// its own area.
///
/// * ![qpainter-compositiondemo.png](qpainter-compositiondemo.png)
///
/// * **Composition Modes Example** The [Composition Modes](painting/composition)
/// example, available in Qt's examples directory, allows you to experiment with the various composition modes and see the results immediately.
///
/// # Limitations
///
/// If you are using coordinates with Qt's raster-based paint engine, it is
/// important to note that, while coordinates greater than +/- 2 ^15 can
/// be used, any painting performed with coordinates outside this range is not
/// guaranteed to be shown; the drawing may be clipped. This is due to the
/// use of `short int` in the implementation.
///
/// The outlines generated by Qt's stroker are only an approximation when dealing
/// with curved shapes. It is in most cases impossible to represent the outline of
/// a bezier curve segment using another bezier curve segment, and so Qt approximates
/// the curve outlines by using several smaller curves. For performance reasons there
/// is a limit to how many curves Qt uses for these outlines, and thus when using
/// large pen widths or scales the outline error increases. To generate outlines with
/// smaller errors it is possible to use the QPainterPathStroker class, which has the
/// setCurveThreshold member function which let's the user specify the error tolerance.
/// Another workaround is to convert the paths to polygons first and then draw the
/// polygons instead.
///
/// # Performance
///
/// QPainter is a rich framework that allows developers to do a great
/// variety of graphical operations, such as gradients, composition
/// modes and vector graphics. And QPainter can do this across a
/// variety of different hardware and software stacks. Naturally the
/// underlying combination of hardware and software has some
/// implications for performance, and ensuring that every single
/// operation is fast in combination with all the various combinations
/// of composition modes, brushes, clipping, transformation, etc, is
/// close to an impossible task because of the number of
/// permutations. As a compromise we have selected a subset of the
/// QPainter API and backends, where performance is guaranteed to be as
/// good as we can sensibly get it for the given combination of
/// hardware and software.
///
/// The backends we focus on as high-performance engines are:
///
/// * Raster - This backend implements all rendering in pure software and is always used to render into QImages. For optimal performance only use the format types QImage::Format_ARGB32_Premultiplied, QImage::Format_RGB32 or QImage::Format_RGB16. Any other format, including QImage::Format_ARGB32, has significantly worse performance. This engine is used by default for QWidget and QPixmap.
/// * OpenGL 2.0 (ES) - This backend is the primary backend for hardware accelerated graphics. It can be run on desktop machines and embedded devices supporting the OpenGL 2.0 or OpenGL/ES 2.0 specification. This includes most graphics chips produced in the last couple of years. The engine can be enabled by using QPainter onto a QOpenGLWidget.
///
/// These operations are:
///
/// * Simple transformations, meaning translation and scaling, pluss 0, 90, 180, 270 degree rotations.
/// * `drawPixmap()` in combination with simple transformations and opacity with non-smooth transformation mode ( `QPainter::SmoothPixmapTransform` not enabled as a render hint).
/// * Rectangle fills with solid color, two-color linear gradients and simple transforms.
/// * Rectangular clipping with simple transformations and intersect clip.
/// * Composition Modes `QPainter::CompositionMode_Source` and QPainter::CompositionMode_SourceOver
/// * Rounded rectangle filling using solid color and two-color linear gradients fills.
/// * 3x3 patched pixmaps, via qDrawBorderPixmap.
///
/// This list gives an indication of which features to safely use in
/// an application where performance is critical. For certain setups,
/// other operations may be fast too, but before making extensive use
/// of them, it is recommended to benchmark and verify them on the
/// system where the software will run in the end. There are also
/// cases where expensive operations are ok to use, for instance when
/// the result is cached in a QPixmap.
///
/// **See also:** [`PaintDevice`]
/// [`PaintEngine`]
/// {Qt SVG}
/// {Basic Drawing Example}
/// {Drawing Utility Functions}
/// # Licence
///
/// The documentation is an adoption of the original [Qt Documentation](http://doc.qt.io/) and provided herein is licensed under the terms of the [GNU Free Documentation License version 1.3](http://www.gnu.org/licenses/fdl.html) as published by the Free Software Foundation.
#[derive(Clone)]
pub struct Painter<'a> {
    #[doc(hidden)]
    pub data: Rc<Cell<Option<*const RUBase>>>,
    #[doc(hidden)]
    pub all_funcs: *const RUPainterAllFuncs,
    #[doc(hidden)]
    pub owned: bool,
    #[doc(hidden)]
    pub _marker: PhantomData<::std::cell::Cell<&'a ()>>,
}

impl<'a> Painter<'a> {
    pub fn new() -> Painter<'a> {
        let data = Rc::new(Cell::new(None));

        let ffi_data = unsafe {
            ((*rute_ffi_get()).create_painter)(
                ::std::ptr::null(),
                transmute(rute_object_delete_callback as usize),
                Rc::into_raw(data.clone()) as *const c_void,
            )
        };

        data.set(Some(ffi_data.qt_data));

        Painter {
            data,
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }
    #[allow(dead_code)]
    pub(crate) fn new_from_rc(ffi_data: RUPainter) -> Painter<'a> {
        Painter {
            data: unsafe { Rc::from_raw(ffi_data.host_data as *const Cell<Option<*const RUBase>>) },
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_owned(ffi_data: RUPainter) -> Painter<'a> {
        Painter {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: true,
            _marker: PhantomData,
        }
    }

    #[allow(dead_code)]
    pub(crate) fn new_from_temporary(ffi_data: RUPainter) -> Painter<'a> {
        Painter {
            data: Rc::new(Cell::new(Some(ffi_data.qt_data as *const RUBase))),
            all_funcs: ffi_data.all_funcs,
            owned: false,
            _marker: PhantomData,
        }
    }
    ///
    /// Returns the paint device on which this painter is currently
    /// painting, or 0 if the painter is not active.
    ///
    /// **See also:** [`is_active()`]
    pub fn device(&self) -> Option<PaintDevice> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintDevice::new_from_rc(t);
            } else {
                ret_val = PaintDevice::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Begins painting the paint *device* and returns `true` if
    /// successful; otherwise returns `false.`
    ///
    /// Notice that all painter settings (setPen(), setBrush() etc.) are reset
    /// to default values when begin() is called.
    ///
    /// The errors that can occur are serious problems, such as these:
    ///
    /// Note that most of the time, you can use one of the constructors
    /// instead of begin(), and that end() is automatically done at
    /// destruction.
    ///
    /// **Warning**: A paint device can only be painted by one painter at a
    /// time.
    ///
    /// **Warning**: Painting on a QImage with the format
    /// QImage::Format_Indexed8 is not supported.
    ///
    /// **See also:** [`end()`]
    /// [`q_painter()`]
    ///
    /// Flushes the painting pipeline and prepares for the user issuing commands
    /// directly to the underlying graphics context. Must be followed by a call to
    /// endNativePainting().
    ///
    /// Note that only the states the underlying paint engine changes will be reset
    /// to their respective default states. The states we reset may change from
    /// release to release. The following states are currently reset in the OpenGL
    /// 2 engine:
    ///
    /// * blending is disabled
    /// * the depth, stencil and scissor tests are disabled
    /// * the active texture unit is reset to 0
    /// * the depth mask, depth function and the clear depth are reset to their default values
    /// * the stencil mask, stencil operation and stencil function are reset to their default values
    /// * the current color is reset to solid white
    ///
    /// If, for example, the OpenGL polygon mode is changed by the user inside a
    /// beginNativePaint()/endNativePainting() block, it will not be reset to the
    /// default state by endNativePainting(). Here is an example that shows
    /// intermixing of painter commands and raw OpenGL commands:
    ///
    /// **See also:** [`end_native_painting()`]
    pub fn begin<P: PaintDeviceTrait<'a>>(&self, arg0: &P) -> bool {
        let (obj_arg0_1, _funcs) = arg0.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).begin)(obj_data, obj_arg0_1);
            ret_val
        }
    }
    ///
    /// Ends painting. Any resources used while painting are released. You
    /// don't normally need to call this since it is called by the
    /// destructor.
    ///
    /// Returns `true` if the painter is no longer active; otherwise returns `false.`
    ///
    /// **See also:** [`begin()`]
    /// [`is_active()`]
    ///
    /// Restores the painter after manually issuing native painting commands. Lets
    /// the painter restore any native state that it relies on before calling any
    /// other painter commands.
    ///
    /// **See also:** [`begin_native_painting()`]
    pub fn end(&self) -> bool {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).end)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns `true` if begin() has been called and end() has not yet been
    /// called; otherwise returns `false.`
    ///
    /// **See also:** [`begin()`]
    /// [`PaintDevice::painting_active`]
    pub fn is_active(&self) -> bool {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).is_active)(obj_data);
            ret_val
        }
    }
    ///
    /// Initializes the painters pen, background and font to the same as
    /// the given *device.*
    ///
    /// **See also:** [`begin()`]
    /// {QPainter#Settings}{Settings}
    pub fn init_from<P: PaintDeviceTrait<'a>>(&self, device: &P) -> &Self {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).init_from)(obj_data, obj_device_1);
        }
        self
    }
    ///
    /// Sets the composition mode to the given *mode.*
    ///
    /// **Warning**: Only a QPainter operating on a QImage fully supports all
    /// composition modes. The RasterOp modes are supported for X11 as
    /// described in compositionMode().
    ///
    /// **See also:** [`composition_mode()`]
    pub fn set_composition_mode(&self, mode: CompositionMode) -> &Self {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_composition_mode)(obj_data, enum_mode_1);
        }
        self
    }
    ///
    /// Returns the current composition mode.
    ///
    /// **See also:** CompositionMode
    /// [`set_composition_mode()`]
    pub fn composition_mode(&self) -> CompositionMode {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).composition_mode)(obj_data);
            let ret_val = { transmute::<u32, CompositionMode>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the font metrics for the painter if the painter is
    /// active. Otherwise, the return value is undefined.
    ///
    /// **See also:** [`font()`]
    /// [`is_active()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// Returns the font info for the painter if the painter is
    /// active. Otherwise, the return value is undefined.
    ///
    /// **See also:** [`font()`]
    /// [`is_active()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// Returns the currently set font used for drawing text.
    ///
    /// **See also:** [`set_font()`]
    /// [`draw_text()`]
    /// {QPainter#Settings}{Settings}
    pub fn font(&self) -> Option<Font> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).font)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Font::new_from_rc(t);
            } else {
                ret_val = Font::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the painter's font to the given *font.*
    ///
    /// This font is used by subsequent drawText() functions. The text
    /// color is the same as the pen color.
    ///
    /// If you set a font that isn't available, Qt finds a close match.
    /// font() will return what you set using setFont() and fontInfo() returns the
    /// font actually being used (which may be the same).
    ///
    /// **See also:** [`font()`]
    /// [`draw_text()`]
    /// {QPainter#Settings}{Settings}
    pub fn set_font<F: FontTrait<'a>>(&self, f: &F) -> &Self {
        let (obj_f_1, _funcs) = f.get_font_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_font)(obj_data, obj_f_1);
        }
        self
    }
    ///
    /// Returns the font info for the painter if the painter is
    /// active. Otherwise, the return value is undefined.
    ///
    /// **See also:** [`font()`]
    /// [`is_active()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the painter's pen to have style Qt::SolidLine, width 1 and the
    /// specified *color.*
    ///
    /// Sets the painter's pen to be the given *pen.*
    ///
    /// The *pen* defines how to draw lines and outlines, and it also
    /// defines the text color.
    ///
    /// **See also:** [`pen()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the painter's pen to have the given *style,* width 1 and
    /// black color.
    pub fn set_pen<C: ColorTrait<'a>>(&self, color: &C) -> &Self {
        let (obj_color_1, _funcs) = color.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_pen)(obj_data, obj_color_1);
        }
        self
    }
    ///
    /// **Overloads**
    /// Sets the painter's pen to have style Qt::SolidLine, width 1 and the
    /// specified *color.*
    ///
    /// Sets the painter's pen to be the given *pen.*
    ///
    /// The *pen* defines how to draw lines and outlines, and it also
    /// defines the text color.
    ///
    /// **See also:** [`pen()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the painter's pen to have the given *style,* width 1 and
    /// black color.
    pub fn set_pen_2<P: PenTrait<'a>>(&self, pen: &P) -> &Self {
        let (obj_pen_1, _funcs) = pen.get_pen_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_pen_2)(obj_data, obj_pen_1);
        }
        self
    }
    ///
    /// **Overloads**
    /// Sets the painter's pen to have style Qt::SolidLine, width 1 and the
    /// specified *color.*
    ///
    /// Sets the painter's pen to be the given *pen.*
    ///
    /// The *pen* defines how to draw lines and outlines, and it also
    /// defines the text color.
    ///
    /// **See also:** [`pen()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the painter's pen to have the given *style,* width 1 and
    /// black color.
    pub fn set_pen_3(&self, style: PenStyle) -> &Self {
        let enum_style_1 = style as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_pen_3)(obj_data, enum_style_1);
        }
        self
    }
    ///
    /// Returns the painter's current pen.
    ///
    /// **See also:** [`set_pen()`]
    /// {QPainter#Settings}{Settings}
    pub fn pen(&self) -> Option<Pen> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).pen)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Pen::new_from_rc(t);
            } else {
                ret_val = Pen::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the brush origin to *position.*
    ///
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    ///
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    ///
    /// **See also:** [`brush_origin()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    ///
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    ///
    /// Sets the painter's brush to the given *brush.*
    ///
    /// The painter's brush defines how shapes are filled.
    ///
    /// **See also:** [`brush()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the painter's brush to black color and the specified *style.*
    pub fn set_brush<B: BrushTrait<'a>>(&self, brush: &B) -> &Self {
        let (obj_brush_1, _funcs) = brush.get_brush_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_brush)(obj_data, obj_brush_1);
        }
        self
    }
    ///
    /// Sets the brush origin to *position.*
    ///
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    ///
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    ///
    /// **See also:** [`brush_origin()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    ///
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    ///
    /// Sets the painter's brush to the given *brush.*
    ///
    /// The painter's brush defines how shapes are filled.
    ///
    /// **See also:** [`brush()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the painter's brush to black color and the specified *style.*
    pub fn set_brush_2(&self, style: BrushStyle) -> &Self {
        let enum_style_1 = style as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_brush_2)(obj_data, enum_style_1);
        }
        self
    }
    ///
    /// Returns the currently set brush origin.
    ///
    /// **See also:** [`set_brush_origin()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// Returns the painter's current brush.
    ///
    /// **See also:** [`Painter::set_brush`]
    /// {QPainter#Settings}{Settings}
    pub fn brush(&self) -> Option<Brush> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).brush)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Brush::new_from_rc(t);
            } else {
                ret_val = Brush::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Sets the background mode of the painter to the given *mode*
    ///
    /// Qt::TransparentMode (the default) draws stippled lines and text
    /// without setting the background pixels. Qt::OpaqueMode fills these
    /// space with the current background color.
    ///
    /// Note that in order to draw a bitmap or pixmap transparently, you
    /// must use QPixmap::setMask().
    ///
    /// **See also:** [`background_mode()`]
    /// [`set_background()`]
    /// {QPainter#Settings}{Settings}
    pub fn set_background_mode(&self, mode: BGMode) -> &Self {
        let enum_mode_1 = mode as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_background_mode)(obj_data, enum_mode_1);
        }
        self
    }
    ///
    /// Returns the current background mode.
    ///
    /// **See also:** [`set_background_mode()`]
    /// {QPainter#Settings}{Settings}
    pub fn background_mode(&self) -> BGMode {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).background_mode)(obj_data);
            let ret_val = { transmute::<u32, BGMode>(ret_val) };
            ret_val
        }
    }
    ///
    /// Returns the currently set brush origin.
    ///
    /// **See also:** [`set_brush_origin()`]
    /// {QPainter#Settings}{Settings}
    pub fn brush_origin(&self) -> Point {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).brush_origin)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Point::new_from_rc(t);
            } else {
                ret_val = Point::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the brush origin to *position.*
    ///
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    ///
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    ///
    /// **See also:** [`brush_origin()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    ///
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    pub fn set_brush_origin(&self, x: i32, y: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_brush_origin)(obj_data, x, y);
        }
        self
    }
    ///
    /// Sets the brush origin to *position.*
    ///
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    ///
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    ///
    /// **See also:** [`brush_origin()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    ///
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    pub fn set_brush_origin_2<P: PointTrait<'a>>(&self, arg0: &P) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_brush_origin_2)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Sets the brush origin to *position.*
    ///
    /// The brush origin specifies the (0, 0) coordinate of the painter's
    /// brush.
    ///
    /// Note that while the brushOrigin() was necessary to adopt the
    /// parent's background for a widget in Qt 3, this is no longer the
    /// case since the Qt 4 painter doesn't paint the background unless
    /// you explicitly tell it to do so by setting the widget's [autoFillBackground](QWidget::autoFillBackground)
    /// property to
    /// true.
    ///
    /// **See also:** [`brush_origin()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// **Overloads**
    /// Sets the brush's origin to the given *position.*
    ///
    /// **Overloads**
    /// Sets the brush's origin to point ( *x,* *y).*
    pub fn set_brush_origin_3<P: PointFTrait<'a>>(&self, arg0: &P) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_brush_origin_3)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Sets the background mode of the painter to the given *mode*
    ///
    /// Qt::TransparentMode (the default) draws stippled lines and text
    /// without setting the background pixels. Qt::OpaqueMode fills these
    /// space with the current background color.
    ///
    /// Note that in order to draw a bitmap or pixmap transparently, you
    /// must use QPixmap::setMask().
    ///
    /// **See also:** [`background_mode()`]
    /// [`set_background()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// Sets the background brush of the painter to the given *brush.*
    ///
    /// The background brush is the brush that is filled in when drawing
    /// opaque text, stippled lines and bitmaps. The background brush has
    /// no effect in transparent background mode (which is the default).
    ///
    /// **See also:** [`background()`]
    /// [`set_background_mode()`]
    /// {QPainter#Settings}{Settings}
    pub fn set_background<B: BrushTrait<'a>>(&self, bg: &B) -> &Self {
        let (obj_bg_1, _funcs) = bg.get_brush_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_background)(obj_data, obj_bg_1);
        }
        self
    }
    ///
    /// Returns the current background brush.
    ///
    /// **See also:** [`set_background()`]
    /// {QPainter#Settings}{Settings}
    ///
    /// Returns the current background mode.
    ///
    /// **See also:** [`set_background_mode()`]
    /// {QPainter#Settings}{Settings}
    pub fn background(&self) -> Option<Brush> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).background)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Brush::new_from_rc(t);
            } else {
                ret_val = Brush::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the opacity of the painter. The default value is
    /// 1.
    pub fn opacity(&self) -> f32 {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).opacity)(obj_data);
            ret_val
        }
    }
    ///
    /// Sets the opacity of the painter to *opacity.* The value should
    /// be in the range 0.0 to 1.0, where 0.0 is fully transparent and
    /// 1.0 is fully opaque.
    ///
    /// Opacity set on the painter will apply to all drawing operations
    /// individually.
    pub fn set_opacity(&self, opacity: f32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_opacity)(obj_data, opacity);
        }
        self
    }
    ///
    /// Returns the currently set clip region. Note that the clip region
    /// is given in logical coordinates.
    ///
    /// **Warning**: QPainter does not store the combined clip explicitly as
    /// this is handled by the underlying QPaintEngine, so the path is
    /// recreated on demand and transformed to the current logical
    /// coordinate system. This is potentially an expensive operation.
    ///
    /// **See also:** [`set_clip_region()`]
    /// [`clip_path()`]
    /// [`set_clipping()`]
    pub fn clip_region(&self) -> Region {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).clip_region)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Region::new_from_rc(t);
            } else {
                ret_val = Region::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given clip *operation.* The default operation
    /// is to replace the current clip rectangle.
    ///
    /// Note that the clip rectangle is specified in logical (painter)
    /// coordinates.
    ///
    /// **See also:** [`clip_region()`]
    /// [`set_clipping()`]
    /// {QPainter#Clipping}{Clipping}
    ///
    /// **Overloads**
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given
    /// clip *operation.*
    ///
    /// Enables clipping, and sets the clip region to the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    pub fn set_clip_rect<R: RectFTrait<'a>>(&self, arg0: &R, op: ClipOperation) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_f_obj_funcs();
        let enum_op_2 = op as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_clip_rect)(obj_data, obj_arg0_1, enum_op_2);
        }
        self
    }
    ///
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given clip *operation.* The default operation
    /// is to replace the current clip rectangle.
    ///
    /// Note that the clip rectangle is specified in logical (painter)
    /// coordinates.
    ///
    /// **See also:** [`clip_region()`]
    /// [`set_clipping()`]
    /// {QPainter#Clipping}{Clipping}
    ///
    /// **Overloads**
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given
    /// clip *operation.*
    ///
    /// Enables clipping, and sets the clip region to the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    pub fn set_clip_rect_2<R: RectTrait<'a>>(&self, arg0: &R, op: ClipOperation) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();
        let enum_op_2 = op as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_clip_rect_2)(obj_data, obj_arg0_1, enum_op_2);
        }
        self
    }
    ///
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given clip *operation.* The default operation
    /// is to replace the current clip rectangle.
    ///
    /// Note that the clip rectangle is specified in logical (painter)
    /// coordinates.
    ///
    /// **See also:** [`clip_region()`]
    /// [`set_clipping()`]
    /// {QPainter#Clipping}{Clipping}
    ///
    /// **Overloads**
    /// Enables clipping, and sets the clip region to the given *rectangle* using the given
    /// clip *operation.*
    ///
    /// Enables clipping, and sets the clip region to the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    pub fn set_clip_rect_3(&self, x: i32, y: i32, w: i32, h: i32, op: ClipOperation) -> &Self {
        let enum_op_5 = op as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_clip_rect_3)(obj_data, x, y, w, h, enum_op_5);
        }
        self
    }
    ///
    /// Sets the clip region to the given *region* using the specified clip
    /// *operation.* The default clip operation is to replace the current
    /// clip region.
    ///
    /// Note that the clip region is given in logical coordinates.
    ///
    /// **See also:** [`clip_region()`]
    /// [`set_clip_rect()`]
    /// {QPainter#Clipping}{Clipping}
    pub fn set_clip_region<R: RegionTrait<'a>>(&self, arg0: &R, op: ClipOperation) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_region_obj_funcs();
        let enum_op_2 = op as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_clip_region)(obj_data, obj_arg0_1, enum_op_2);
        }
        self
    }
    ///
    /// Enables clipping if *enable* is true, or disables clipping if *enable* is false.
    ///
    /// **See also:** [`has_clipping()`]
    /// {QPainter#Clipping}{Clipping}
    pub fn set_clipping(&self, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_clipping)(obj_data, enable);
        }
        self
    }
    ///
    /// Returns `true` if clipping has been set; otherwise returns `false.`
    ///
    /// **See also:** [`set_clipping()`]
    /// {QPainter#Clipping}{Clipping}
    pub fn has_clipping(&self) -> bool {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).has_clipping)(obj_data);
            ret_val
        }
    }
    ///
    /// Returns the bounding rectangle of the current clip if there is a clip;
    /// otherwise returns an empty rectangle. Note that the clip region is
    /// given in logical coordinates.
    ///
    /// The bounding rectangle is not guaranteed to be tight.
    ///
    /// **See also:** [`set_clip_rect()`]
    /// [`set_clip_path()`]
    /// [`set_clip_region()`]
    ///
    pub fn clip_bounding_rect(&self) -> RectF {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).clip_bounding_rect)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = RectF::new_from_rc(t);
            } else {
                ret_val = RectF::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Saves the current painter state (pushes the state onto a stack). A
    /// save() must be followed by a corresponding restore(); the end()
    /// function unwinds the stack.
    ///
    /// **See also:** [`restore()`]
    pub fn save(&self) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).save)(obj_data);
        }
        self
    }
    ///
    /// Restores the current painter state (pops a saved state off the
    /// stack).
    ///
    /// **See also:** [`save()`]
    ///
    /// Using QWidget::render() obsoletes the use of this function.
    ///
    /// Restores the previous redirection for the given *device* after a
    /// call to setRedirected().
    ///
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    ///
    /// **See also:** [`redirected()`]
    pub fn restore(&self) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).restore)(obj_data);
        }
        self
    }
    ///
    /// Sets the world transformation matrix.
    /// If *combine* is true, the specified *transform* is combined with
    /// the current matrix; otherwise it replaces the current matrix.
    ///
    /// **See also:** [`transform()`]
    /// [`set_world_transform()`]
    pub fn set_transform<T: TransformTrait<'a>>(&self, transform: &T, combine: bool) -> &Self {
        let (obj_transform_1, _funcs) = transform.get_transform_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_transform)(obj_data, obj_transform_1, combine);
        }
        self
    }
    pub fn device_transform(&self) -> Option<Transform> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).device_transform)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Transform::new_from_rc(t);
            } else {
                ret_val = Transform::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the matrix that transforms from logical coordinates to
    /// device coordinates of the platform dependent paint device.
    ///
    /// This function is *only* needed when using platform painting
    /// commands on the platform dependent handle (Qt::HANDLE), and the
    /// platform does not do transformations nativly.
    ///
    /// The QPaintEngine::PaintEngineFeature enum can be queried to
    /// determine whether the platform performs the transformations or
    /// not.
    ///
    /// **See also:** [`world_transform()`]
    /// [`PaintEngine::has_feature`]
    /// */
    ///
    /// const QTransform & QPainter::deviceTransform() const
    ///
    /// Q_D(const QPainter);
    /// if (!d->engine) {
    /// qWarning("QPainter::deviceTransform: Painter not active");
    /// return d->fakeState()->transform;
    ///
    /// return d->state->matrix;
    ///
    ///
    /// /*!
    /// Resets any transformations that were made using translate(),
    /// scale(), shear(), rotate(), setWorldTransform(), setViewport()
    /// and setWindow().
    ///
    /// **See also:** {Coordinate Transformations}
    pub fn reset_transform(&self) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).reset_transform)(obj_data);
        }
        self
    }
    ///
    /// Sets the world transformation matrix.
    /// If *combine* is true, the specified *matrix* is combined with the current matrix;
    /// otherwise it replaces the current matrix.
    ///
    /// **See also:** [`transform()`]
    /// [`set_transform()`]
    pub fn set_world_transform<T: TransformTrait<'a>>(&self, matrix: &T, combine: bool) -> &Self {
        let (obj_matrix_1, _funcs) = matrix.get_transform_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_world_transform)(obj_data, obj_matrix_1, combine);
        }
        self
    }
    ///
    /// Returns the world transformation matrix.
    pub fn world_transform(&self) -> Option<Transform> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).world_transform)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Transform::new_from_rc(t);
            } else {
                ret_val = Transform::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Returns the transformation matrix combining the current
    /// window/viewport and world transformation.
    ///
    /// **See also:** [`set_world_transform()`]
    /// [`set_window()`]
    /// [`set_viewport()`]
    pub fn combined_transform(&self) -> Transform {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).combined_transform)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Transform::new_from_rc(t);
            } else {
                ret_val = Transform::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Scales the coordinate system by ( *sx* , *sy* ).
    ///
    /// **See also:** [`set_world_transform()`]
    /// {QPainter#Coordinate Transformations}{Coordinate Transformations}
    pub fn scale(&self, sx: f32, sy: f32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).scale)(obj_data, sx, sy);
        }
        self
    }
    ///
    /// Shears the coordinate system by ( *sh* , *sv* ).
    ///
    /// **See also:** [`set_world_transform()`]
    /// {QPainter#Coordinate Transformations}{Coordinate Transformations}
    pub fn shear(&self, sh: f32, sv: f32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).shear)(obj_data, sh, sv);
        }
        self
    }
    ///
    /// Rotates the coordinate system clockwise. The given *angle* parameter is in degrees.
    ///
    /// **See also:** [`set_world_transform()`]
    /// {QPainter#Coordinate Transformations}{Coordinate Transformations}
    pub fn rotate(&self, a: f32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).rotate)(obj_data, a);
        }
        self
    }
    ///
    /// Returns the window rectangle.
    ///
    /// **See also:** [`set_window()`]
    /// [`set_view_transform_enabled()`]
    pub fn window(&self) -> Rect {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).window)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the painter's window to the given *rectangle,* and enables
    /// view transformations.
    ///
    /// The window rectangle is part of the view transformation. The
    /// window specifies the logical coordinate system. Its sister, the
    /// viewport(), specifies the device coordinate system.
    ///
    /// The default window rectangle is the same as the device's
    /// rectangle.
    ///
    /// **See also:** [`window()`]
    /// [`view_transform_enabled()`]
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    ///
    /// **Overloads**
    /// Sets the painter's window to the rectangle beginning at ( *x,* *y)* and the given *width* and *height.*
    pub fn set_window<R: RectTrait<'a>>(&self, window: &R) -> &Self {
        let (obj_window_1, _funcs) = window.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_window)(obj_data, obj_window_1);
        }
        self
    }
    ///
    /// Sets the painter's window to the given *rectangle,* and enables
    /// view transformations.
    ///
    /// The window rectangle is part of the view transformation. The
    /// window specifies the logical coordinate system. Its sister, the
    /// viewport(), specifies the device coordinate system.
    ///
    /// The default window rectangle is the same as the device's
    /// rectangle.
    ///
    /// **See also:** [`window()`]
    /// [`view_transform_enabled()`]
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    ///
    /// **Overloads**
    /// Sets the painter's window to the rectangle beginning at ( *x,* *y)* and the given *width* and *height.*
    pub fn set_window_2(&self, x: i32, y: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_window_2)(obj_data, x, y, w, h);
        }
        self
    }
    ///
    /// Returns the viewport rectangle.
    ///
    /// **See also:** [`set_viewport()`]
    /// [`set_view_transform_enabled()`]
    pub fn viewport(&self) -> Rect {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).viewport)(obj_data);
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Sets the painter's viewport rectangle to the given *rectangle,*
    /// and enables view transformations.
    ///
    /// The viewport rectangle is part of the view transformation. The
    /// viewport specifies the device coordinate system. Its sister, the
    /// window(), specifies the logical coordinate system.
    ///
    /// The default viewport rectangle is the same as the device's
    /// rectangle.
    ///
    /// **See also:** [`viewport()`]
    /// [`view_transform_enabled()`]
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    ///
    /// **Overloads**
    /// Sets the painter's viewport rectangle to be the rectangle
    /// beginning at ( *x,* *y)* with the given *width* and *height.*
    pub fn set_viewport<R: RectTrait<'a>>(&self, viewport: &R) -> &Self {
        let (obj_viewport_1, _funcs) = viewport.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_viewport)(obj_data, obj_viewport_1);
        }
        self
    }
    ///
    /// Sets the painter's viewport rectangle to the given *rectangle,*
    /// and enables view transformations.
    ///
    /// The viewport rectangle is part of the view transformation. The
    /// viewport specifies the device coordinate system. Its sister, the
    /// window(), specifies the logical coordinate system.
    ///
    /// The default viewport rectangle is the same as the device's
    /// rectangle.
    ///
    /// **See also:** [`viewport()`]
    /// [`view_transform_enabled()`]
    /// {Coordinate
    /// System#Window-Viewport Conversion}{Window-Viewport Conversion}
    ///
    /// **Overloads**
    /// Sets the painter's viewport rectangle to be the rectangle
    /// beginning at ( *x,* *y)* with the given *width* and *height.*
    pub fn set_viewport_2(&self, x: i32, y: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_viewport_2)(obj_data, x, y, w, h);
        }
        self
    }
    ///
    /// Enables view transformations if *enable* is true, or disables
    /// view transformations if *enable* is false.
    ///
    /// **See also:** [`view_transform_enabled()`]
    /// {Coordinate System#Window-Viewport
    /// Conversion}{Window-Viewport Conversion}
    pub fn set_view_transform_enabled(&self, enable: bool) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_view_transform_enabled)(obj_data, enable);
        }
        self
    }
    ///
    /// Returns `true` if view transformation is enabled; otherwise returns
    /// false.
    ///
    /// **See also:** [`set_view_transform_enabled()`]
    /// [`world_transform()`]
    pub fn view_transform_enabled(&self) -> bool {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).view_transform_enabled)(obj_data);
            ret_val
        }
    }
    ///
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    ///
    /// **Overloads**
    /// Draws a single point at position ( *x,* *y).*
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_point<P: PointFTrait<'a>>(&self, pt: &P) -> &Self {
        let (obj_pt_1, _funcs) = pt.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_point)(obj_data, obj_pt_1);
        }
        self
    }
    ///
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    ///
    /// **Overloads**
    /// Draws a single point at position ( *x,* *y).*
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_point_2<P: PointTrait<'a>>(&self, p: &P) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_point_2)(obj_data, obj_p_1);
        }
        self
    }
    ///
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a single point at the given *position* using the current
    /// pen's color.
    ///
    /// **Overloads**
    /// Draws a single point at position ( *x,* *y).*
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_point_3(&self, x: i32, y: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_point_3)(obj_data, x, y);
        }
        self
    }
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_points<P: PointFTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_points)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_points_2<P: PolygonFTrait<'a>>(&self, points: &P) -> &Self {
        let (obj_points_1, _funcs) = points.get_polygon_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_points_2)(obj_data, obj_points_1);
        }
        self
    }
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_points_3<P: PointTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_points_3)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **See also:** {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the first *pointCount* points in the array *points* using
    /// the current pen's color.
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    ///
    /// **Overloads**
    /// Draws the points in the vector *points.*
    pub fn draw_points_4<P: PolygonTrait<'a>>(&self, points: &P) -> &Self {
        let (obj_points_1, _funcs) = points.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_points_4)(obj_data, obj_points_1);
        }
        self
    }
    ///
    /// Draws a line defined by *line.*
    ///
    /// * ![qpainter-line.png](qpainter-line.png)
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a line defined by *line.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_line<L: LineFTrait<'a>>(&self, line: &L) -> &Self {
        let (obj_line_1, _funcs) = line.get_line_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_line)(obj_data, obj_line_1);
        }
        self
    }
    ///
    /// Draws a line defined by *line.*
    ///
    /// * ![qpainter-line.png](qpainter-line.png)
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a line defined by *line.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_line_2<L: LineTrait<'a>>(&self, line: &L) -> &Self {
        let (obj_line_1, _funcs) = line.get_line_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_line_2)(obj_data, obj_line_1);
        }
        self
    }
    ///
    /// Draws a line defined by *line.*
    ///
    /// * ![qpainter-line.png](qpainter-line.png)
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a line defined by *line.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_line_3(&self, x1: i32, y1: i32, x2: i32, y2: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_line_3)(obj_data, x1, y1, x2, y2);
        }
        self
    }
    ///
    /// Draws a line defined by *line.*
    ///
    /// * ![qpainter-line.png](qpainter-line.png)
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a line defined by *line.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_line_4<P: PointTrait<'a>>(&self, p1: &P, p2: &P) -> &Self {
        let (obj_p1_1, _funcs) = p1.get_point_obj_funcs();
        let (obj_p2_2, _funcs) = p2.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_line_4)(obj_data, obj_p1_1, obj_p2_2);
        }
        self
    }
    ///
    /// Draws a line defined by *line.*
    ///
    /// * ![qpainter-line.png](qpainter-line.png)
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a line defined by *line.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from *p1* to *p2.*
    ///
    /// **Overloads**
    /// Draws a line from ( *x1,* *y1)* to ( *x2,* *y2).*
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_line_5<P: PointFTrait<'a>>(&self, p1: &P, p2: &P) -> &Self {
        let (obj_p1_1, _funcs) = p1.get_point_f_obj_funcs();
        let (obj_p2_2, _funcs) = p2.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_line_5)(obj_data, obj_p1_1, obj_p2_2);
        }
        self
    }
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_lines<L: LineFTrait<'a>>(&self, lines: &L, line_count: i32) -> &Self {
        let (obj_lines_1, _funcs) = lines.get_line_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_lines)(obj_data, obj_lines_1, line_count);
        }
        self
    }
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_lines_3<P: PointFTrait<'a>>(&self, point_pairs: &P, line_count: i32) -> &Self {
        let (obj_point_pairs_1, _funcs) = point_pairs.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_lines_3)(obj_data, obj_point_pairs_1, line_count);
        }
        self
    }
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    pub fn draw_lines_7<P: PointTrait<'a>>(&self, point_pairs: &P, line_count: i32) -> &Self {
        let (obj_point_pairs_1, _funcs) = point_pairs.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_lines_7)(obj_data, obj_point_pairs_1, line_count);
        }
        self
    }
    ///
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **See also:** [`draw_line()`]
    /// [`draw_polyline()`]
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *lines*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen. The lines are specified as pairs of points
    /// so the number of entries in *pointPairs* must be at least *lineCount* * 2.
    ///
    /// **Overloads**
    /// Draws the first *lineCount* lines in the array *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen. If there is an odd number of points in the
    /// array, the last point will be ignored.
    ///
    /// **Overloads**
    /// Draws a line for each pair of points in the vector *pointPairs*
    /// using the current pen.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the set of lines defined by the list *lines* using the
    /// current pen and brush.
    ///
    /// Draws the current *rectangle* with the current pen and brush.
    ///
    /// A filled rectangle has a size of *rectangle* .size(). A stroked
    /// rectangle has a size of *rectangle* .size() plus the pen width.
    ///
    /// * ![qpainter-rectangle.png](qpainter-rectangle.png)
    ///
    ///
    ///
    /// **See also:** [`draw_rects()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the current *rectangle* with the current pen and brush.
    ///
    /// **Overloads**
    /// Draws a rectangle with upper left corner at ( *x* , *y* ) and
    /// with the given *width* and *height.*
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    pub fn draw_rect<R: RectFTrait<'a>>(&self, rect: &R) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rect)(obj_data, obj_rect_1);
        }
        self
    }
    ///
    /// Draws the current *rectangle* with the current pen and brush.
    ///
    /// A filled rectangle has a size of *rectangle* .size(). A stroked
    /// rectangle has a size of *rectangle* .size() plus the pen width.
    ///
    /// * ![qpainter-rectangle.png](qpainter-rectangle.png)
    ///
    ///
    ///
    /// **See also:** [`draw_rects()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the current *rectangle* with the current pen and brush.
    ///
    /// **Overloads**
    /// Draws a rectangle with upper left corner at ( *x* , *y* ) and
    /// with the given *width* and *height.*
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    pub fn draw_rect_2(&self, x1: i32, y1: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rect_2)(obj_data, x1, y1, w, h);
        }
        self
    }
    ///
    /// Draws the current *rectangle* with the current pen and brush.
    ///
    /// A filled rectangle has a size of *rectangle* .size(). A stroked
    /// rectangle has a size of *rectangle* .size() plus the pen width.
    ///
    /// * ![qpainter-rectangle.png](qpainter-rectangle.png)
    ///
    ///
    ///
    /// **See also:** [`draw_rects()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the current *rectangle* with the current pen and brush.
    ///
    /// **Overloads**
    /// Draws a rectangle with upper left corner at ( *x* , *y* ) and
    /// with the given *width* and *height.*
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    pub fn draw_rect_3<R: RectTrait<'a>>(&self, rect: &R) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rect_3)(obj_data, obj_rect_1);
        }
        self
    }
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    pub fn draw_rects<R: RectFTrait<'a>>(&self, rects: &R, rect_count: i32) -> &Self {
        let (obj_rects_1, _funcs) = rects.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rects)(obj_data, obj_rects_1, rect_count);
        }
        self
    }
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    pub fn draw_rects_3<R: RectTrait<'a>>(&self, rects: &R, rect_count: i32) -> &Self {
        let (obj_rects_1, _funcs) = rects.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rects_3)(obj_data, obj_rects_1, rect_count);
        }
        self
    }
    ///
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Draws the first *rectCount* of the given *rectangles* using the
    /// current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// **Overloads**
    /// Draws the given *rectangles* using the current pen and brush.
    ///
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    ///
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    pub fn draw_ellipse<R: RectFTrait<'a>>(&self, r: &R) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse)(obj_data, obj_r_1);
        }
        self
    }
    ///
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    ///
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    pub fn draw_ellipse_2<R: RectTrait<'a>>(&self, r: &R) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse_2)(obj_data, obj_r_1);
        }
        self
    }
    ///
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    ///
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    pub fn draw_ellipse_3(&self, x: i32, y: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse_3)(obj_data, x, y, w, h);
        }
        self
    }
    ///
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    ///
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    pub fn draw_ellipse_4<P: PointFTrait<'a>>(&self, center: &P, rx: f32, ry: f32) -> &Self {
        let (obj_center_1, _funcs) = center.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse_4)(obj_data, obj_center_1, rx, ry);
        }
        self
    }
    ///
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// A filled ellipse has a size of *rectangle* . [size()](QRect::size())
    /// . A stroked ellipse has a size of
    /// *rectangle* . [size()](QRect::size())
    /// plus the pen width.
    ///
    /// * ![qpainter-ellipse.png](qpainter-ellipse.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the given *rectangle.*
    ///
    /// **Overloads**
    /// Draws the ellipse defined by the rectangle beginning at ( *x* ,
    /// *y* ) with the given *width* and *height.*
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    ///
    /// **Overloads**
    /// Draws the ellipse positioned at *center* with radii *rx* and *ry* .
    pub fn draw_ellipse_5<P: PointTrait<'a>>(&self, center: &P, rx: i32, ry: i32) -> &Self {
        let (obj_center_1, _funcs) = center.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_ellipse_5)(obj_data, obj_center_1, rx, ry);
        }
        self
    }
    ///
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    pub fn draw_polyline<P: PointFTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polyline)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    pub fn draw_polyline_2<P: PolygonFTrait<'a>>(&self, polyline: &P) -> &Self {
        let (obj_polyline_1, _funcs) = polyline.get_polygon_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polyline_2)(obj_data, obj_polyline_1);
        }
        self
    }
    ///
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    pub fn draw_polyline_3<P: PointTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polyline_3)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// Note that unlike the drawPolygon() function the last point is *not* connected to the first, neither is the polyline filled.
    ///
    ///
    ///
    /// **See also:** [`draw_lines()`]
    /// [`draw_polygon()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the polyline defined by the first *pointCount* points in *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    ///
    /// **Overloads**
    /// Draws the polyline defined by the given *points* using the
    /// current pen.
    pub fn draw_polyline_4<P: PolygonTrait<'a>>(&self, polygon: &P) -> &Self {
        let (obj_polygon_1, _funcs) = polygon.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polyline_4)(obj_data, obj_polygon_1);
        }
        self
    }
    ///
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    ///
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    ///
    /// **See also:** [`draw_convex_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    pub fn draw_polygon<P: PointFTrait<'a>>(
        &self,
        points: &P,
        point_count: i32,
        fill_rule: FillRule,
    ) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();
        let enum_fill_rule_3 = fill_rule as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon)(obj_data, obj_points_1, point_count, enum_fill_rule_3);
        }
        self
    }
    ///
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    ///
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    ///
    /// **See also:** [`draw_convex_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    pub fn draw_polygon_2<P: PolygonFTrait<'a>>(&self, polygon: &P, fill_rule: FillRule) -> &Self {
        let (obj_polygon_1, _funcs) = polygon.get_polygon_f_obj_funcs();
        let enum_fill_rule_2 = fill_rule as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon_2)(obj_data, obj_polygon_1, enum_fill_rule_2);
        }
        self
    }
    ///
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    ///
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    ///
    /// **See also:** [`draw_convex_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    pub fn draw_polygon_3<P: PointTrait<'a>>(
        &self,
        points: &P,
        point_count: i32,
        fill_rule: FillRule,
    ) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();
        let enum_fill_rule_3 = fill_rule as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon_3)(obj_data, obj_points_1, point_count, enum_fill_rule_3);
        }
        self
    }
    ///
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points* using the current pen and brush.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush().
    ///
    /// If *fillRule* is Qt::WindingFill, the polygon is filled using the
    /// winding fill algorithm. If *fillRule* is Qt::OddEvenFill, the
    /// polygon is filled using the odd-even fill algorithm. See
    /// [Qt::FillRule](Qt::FillRule)
    /// for a more detailed description of these fill
    /// rules.
    ///
    /// **See also:** [`draw_convex_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    /// **Overloads**
    /// Draws the polygon defined by the first *pointCount* points in the
    /// array *points.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    ///
    /// **Overloads**
    /// Draws the polygon defined by the given *points* using the fill
    /// rule *fillRule.*
    pub fn draw_polygon_4<P: PolygonTrait<'a>>(&self, polygon: &P, fill_rule: FillRule) -> &Self {
        let (obj_polygon_1, _funcs) = polygon.get_polygon_obj_funcs();
        let enum_fill_rule_2 = fill_rule as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_polygon_4)(obj_data, obj_polygon_1, enum_fill_rule_2);
        }
        self
    }
    ///
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    ///
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    ///
    /// **See also:** [`draw_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    pub fn draw_convex_polygon<P: PointFTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_convex_polygon)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    ///
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    ///
    /// **See also:** [`draw_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    pub fn draw_convex_polygon_2<P: PolygonFTrait<'a>>(&self, polygon: &P) -> &Self {
        let (obj_polygon_1, _funcs) = polygon.get_polygon_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_convex_polygon_2)(obj_data, obj_polygon_1);
        }
        self
    }
    ///
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    ///
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    ///
    /// **See also:** [`draw_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    pub fn draw_convex_polygon_3<P: PointTrait<'a>>(&self, points: &P, point_count: i32) -> &Self {
        let (obj_points_1, _funcs) = points.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_convex_polygon_3)(obj_data, obj_points_1, point_count);
        }
        self
    }
    ///
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// * ![qpainter-polygon.png](qpainter-polygon.png)
    ///
    ///
    ///
    /// The first point is implicitly connected to the last point, and the
    /// polygon is filled with the current brush(). If the supplied
    /// polygon is not convex, i.e. it contains at least one angle larger
    /// than 180 degrees, the results are undefined.
    ///
    /// On some platforms (e.g. X11), the drawConvexPolygon() function can
    /// be faster than the drawPolygon() function.
    ///
    /// **See also:** [`draw_polygon()`]
    /// [`draw_polyline()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by the first *pointCount* points
    /// in the array *points* using the current pen.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    ///
    /// **Overloads**
    /// Draws the convex polygon defined by *polygon* using the current
    /// pen and brush.
    pub fn draw_convex_polygon_4<P: PolygonTrait<'a>>(&self, polygon: &P) -> &Self {
        let (obj_polygon_1, _funcs) = polygon.get_polygon_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_convex_polygon_4)(obj_data, obj_polygon_1);
        }
        self
    }
    ///
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// The *startAngle* and *spanAngle* must be specified in 1/16th of
    /// a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    /// values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-arc.png](qpainter-arc.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// [`draw_chord()`]
    /// {Coordinate System}
    /// int spanAngle)
    ///
    /// **Overloads**
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// int startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the arc defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    pub fn draw_arc<R: RectFTrait<'a>>(&self, rect: &R, a: i32, alen: i32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_arc)(obj_data, obj_rect_1, a, alen);
        }
        self
    }
    ///
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// The *startAngle* and *spanAngle* must be specified in 1/16th of
    /// a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    /// values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-arc.png](qpainter-arc.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// [`draw_chord()`]
    /// {Coordinate System}
    /// int spanAngle)
    ///
    /// **Overloads**
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// int startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the arc defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    pub fn draw_arc_2<R: RectTrait<'a>>(&self, arg0: &R, a: i32, alen: i32) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_arc_2)(obj_data, obj_arg0_1, a, alen);
        }
        self
    }
    ///
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// The *startAngle* and *spanAngle* must be specified in 1/16th of
    /// a degree, i.e. a full circle equals 5760 (16 * 360). Positive
    /// values for the angles mean counter-clockwise while negative values
    /// mean the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-arc.png](qpainter-arc.png)
    ///
    ///
    ///
    /// **See also:** [`draw_pie()`]
    /// [`draw_chord()`]
    /// {Coordinate System}
    /// int spanAngle)
    ///
    /// **Overloads**
    /// Draws the arc defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// int startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the arc defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    pub fn draw_arc_3(&self, x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_arc_3)(obj_data, x, y, w, h, a, alen);
        }
        self
    }
    ///
    /// Draws a pie defined by the given *rectangle,* *startAngle* and *spanAngle.*
    ///
    /// The pie is filled with the current brush().
    ///
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-pie.png](qpainter-pie.png)
    ///
    ///
    ///
    /// **See also:** [`draw_ellipse()`]
    /// [`draw_chord()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a pie defined by the given *rectangle,* *startAngle* and
    /// and *spanAngle.*
    ///
    /// startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the pie defined by the rectangle beginning at ( *x,* *y)* with
    /// the specified *width* and *height,* and the given *startAngle* and
    /// *spanAngle.*
    pub fn draw_pie<R: RectFTrait<'a>>(&self, rect: &R, a: i32, alen: i32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pie)(obj_data, obj_rect_1, a, alen);
        }
        self
    }
    ///
    /// Draws a pie defined by the given *rectangle,* *startAngle* and *spanAngle.*
    ///
    /// The pie is filled with the current brush().
    ///
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-pie.png](qpainter-pie.png)
    ///
    ///
    ///
    /// **See also:** [`draw_ellipse()`]
    /// [`draw_chord()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a pie defined by the given *rectangle,* *startAngle* and
    /// and *spanAngle.*
    ///
    /// startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the pie defined by the rectangle beginning at ( *x,* *y)* with
    /// the specified *width* and *height,* and the given *startAngle* and
    /// *spanAngle.*
    pub fn draw_pie_2(&self, x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pie_2)(obj_data, x, y, w, h, a, alen);
        }
        self
    }
    ///
    /// Draws a pie defined by the given *rectangle,* *startAngle* and *spanAngle.*
    ///
    /// The pie is filled with the current brush().
    ///
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-pie.png](qpainter-pie.png)
    ///
    ///
    ///
    /// **See also:** [`draw_ellipse()`]
    /// [`draw_chord()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws a pie defined by the given *rectangle,* *startAngle* and
    /// and *spanAngle.*
    ///
    /// startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the pie defined by the rectangle beginning at ( *x,* *y)* with
    /// the specified *width* and *height,* and the given *startAngle* and
    /// *spanAngle.*
    pub fn draw_pie_3<R: RectTrait<'a>>(&self, arg0: &R, a: i32, alen: i32) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pie_3)(obj_data, obj_arg0_1, a, alen);
        }
        self
    }
    ///
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.* The chord is filled with the current brush().
    ///
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-chord.png](qpainter-chord.png)
    ///
    ///
    ///
    /// **See also:** [`draw_arc()`]
    /// [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the chord defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    pub fn draw_chord<R: RectFTrait<'a>>(&self, rect: &R, a: i32, alen: i32) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_chord)(obj_data, obj_rect_1, a, alen);
        }
        self
    }
    ///
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.* The chord is filled with the current brush().
    ///
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-chord.png](qpainter-chord.png)
    ///
    ///
    ///
    /// **See also:** [`draw_arc()`]
    /// [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the chord defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    pub fn draw_chord_2(&self, x: i32, y: i32, w: i32, h: i32, a: i32, alen: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_chord_2)(obj_data, x, y, w, h, a, alen);
        }
        self
    }
    ///
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.* The chord is filled with the current brush().
    ///
    /// The startAngle and spanAngle must be specified in 1/16th of a
    /// degree, i.e. a full circle equals 5760 (16 * 360). Positive values
    /// for the angles mean counter-clockwise while negative values mean
    /// the clockwise direction. Zero degrees is at the 3 o'clock
    /// position.
    ///
    /// * ![qpainter-chord.png](qpainter-chord.png)
    ///
    ///
    ///
    /// **See also:** [`draw_arc()`]
    /// [`draw_pie()`]
    /// {Coordinate System}
    ///
    /// **Overloads**
    /// Draws the chord defined by the given *rectangle,* *startAngle* and
    /// *spanAngle.*
    ///
    /// startAngle, int spanAngle)
    ///
    /// **Overloads**
    /// Draws the chord defined by the rectangle beginning at ( *x,* *y)*
    /// with the specified *width* and *height,* and the given *startAngle* and *spanAngle.*
    pub fn draw_chord_3<R: RectTrait<'a>>(&self, arg0: &R, a: i32, alen: i32) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_chord_3)(obj_data, obj_arg0_1, a, alen);
        }
        self
    }
    ///
    /// Draws the given rectangle *rect* with rounded corners.
    ///
    /// The *xRadius* and *yRadius* arguments specify the radii
    /// of the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range
    /// 0.0 to 100.0.
    ///
    /// A filled rectangle has a size of rect.size(). A stroked rectangle
    /// has a size of rect.size() plus the pen width.
    ///
    /// * ![qpainter-roundrect.png](qpainter-roundrect.png)
    ///
    ///
    ///
    /// **See also:** [`draw_rect()`]
    /// [`Pen`]
    ///
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *rect* with rounded corners.
    ///
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *x,* *y,* *w,* *h* with rounded corners.
    pub fn draw_rounded_rect<R: RectFTrait<'a>>(
        &self,
        rect: &R,
        x_radius: f32,
        y_radius: f32,
        mode: SizeMode,
    ) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();
        let enum_mode_4 = mode as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rounded_rect)(obj_data, obj_rect_1, x_radius, y_radius, enum_mode_4);
        }
        self
    }
    ///
    /// Draws the given rectangle *rect* with rounded corners.
    ///
    /// The *xRadius* and *yRadius* arguments specify the radii
    /// of the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range
    /// 0.0 to 100.0.
    ///
    /// A filled rectangle has a size of rect.size(). A stroked rectangle
    /// has a size of rect.size() plus the pen width.
    ///
    /// * ![qpainter-roundrect.png](qpainter-roundrect.png)
    ///
    ///
    ///
    /// **See also:** [`draw_rect()`]
    /// [`Pen`]
    ///
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *rect* with rounded corners.
    ///
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *x,* *y,* *w,* *h* with rounded corners.
    pub fn draw_rounded_rect_2(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        x_radius: f32,
        y_radius: f32,
        mode: SizeMode,
    ) -> &Self {
        let enum_mode_7 = mode as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rounded_rect_2)(obj_data, x, y, w, h, x_radius, y_radius, enum_mode_7);
        }
        self
    }
    ///
    /// Draws the given rectangle *rect* with rounded corners.
    ///
    /// The *xRadius* and *yRadius* arguments specify the radii
    /// of the ellipses defining the corners of the rounded rectangle.
    /// When *mode* is Qt::RelativeSize, *xRadius* and
    /// *yRadius* are specified in percentage of half the rectangle's
    /// width and height respectively, and should be in the range
    /// 0.0 to 100.0.
    ///
    /// A filled rectangle has a size of rect.size(). A stroked rectangle
    /// has a size of rect.size() plus the pen width.
    ///
    /// * ![qpainter-roundrect.png](qpainter-roundrect.png)
    ///
    ///
    ///
    /// **See also:** [`draw_rect()`]
    /// [`Pen`]
    ///
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *rect* with rounded corners.
    ///
    /// Qt::SizeMode mode = Qt::AbsoluteSize);
    /// **Overloads**
    /// Draws the given rectangle *x,* *y,* *w,* *h* with rounded corners.
    pub fn draw_rounded_rect_3<R: RectTrait<'a>>(
        &self,
        rect: &R,
        x_radius: f32,
        y_radius: f32,
        mode: SizeMode,
    ) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();
        let enum_mode_4 = mode as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_rounded_rect_3)(obj_data, obj_rect_1, x_radius, y_radius, enum_mode_4);
        }
        self
    }
    ///
    /// Draws a rectangle *r* with rounded corners.
    ///
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    ///
    /// A filled rectangle has a size of r.size(). A stroked rectangle
    /// has a size of r.size() plus the pen width.
    ///
    /// **See also:** [`draw_rounded_rect()`]
    ///
    /// **Overloads**
    /// Draws the rectangle *r* with rounded corners.
    ///
    /// **Overloads**
    /// Draws the rectangle *x,* *y,* *w,* *h* with rounded corners.
    pub fn draw_round_rect<R: RectFTrait<'a>>(&self, r: &R, xround: i32, yround: i32) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_round_rect)(obj_data, obj_r_1, xround, yround);
        }
        self
    }
    ///
    /// Draws a rectangle *r* with rounded corners.
    ///
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    ///
    /// A filled rectangle has a size of r.size(). A stroked rectangle
    /// has a size of r.size() plus the pen width.
    ///
    /// **See also:** [`draw_rounded_rect()`]
    ///
    /// **Overloads**
    /// Draws the rectangle *r* with rounded corners.
    ///
    /// **Overloads**
    /// Draws the rectangle *x,* *y,* *w,* *h* with rounded corners.
    pub fn draw_round_rect_2(&self, x: i32, y: i32, w: i32, h: i32, arg0: i32, arg1: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_round_rect_2)(obj_data, x, y, w, h, arg0, arg1);
        }
        self
    }
    ///
    /// Draws a rectangle *r* with rounded corners.
    ///
    /// The *xRnd* and *yRnd* arguments specify how rounded the corners
    /// should be. 0 is angled corners, 99 is maximum roundedness.
    ///
    /// A filled rectangle has a size of r.size(). A stroked rectangle
    /// has a size of r.size() plus the pen width.
    ///
    /// **See also:** [`draw_rounded_rect()`]
    ///
    /// **Overloads**
    /// Draws the rectangle *r* with rounded corners.
    ///
    /// **Overloads**
    /// Draws the rectangle *x,* *y,* *w,* *h* with rounded corners.
    pub fn draw_round_rect_3<R: RectTrait<'a>>(&self, r: &R, xround: i32, yround: i32) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_round_rect_3)(obj_data, obj_r_1, xround, yround);
        }
        self
    }
    ///
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    ///
    /// Calling drawTiledPixmap() is similar to calling drawPixmap()
    /// several times to fill (tile) an area with a pixmap, but is
    /// potentially much more efficient depending on the underlying window
    /// system.
    ///
    /// **See also:** [`draw_pixmap()`]
    ///
    /// const QPoint &position = QPoint())
    /// **Overloads**
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    ///
    /// QPixmap &pixmap, int sx, int sy);
    /// **Overloads**
    /// Draws a tiled *pixmap* in the specified rectangle.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device
    /// that is to be drawn onto; with the given *width* and *height.* ( *sx* , *sy* ) specifies the top-left point in the *pixmap* that is to be drawn; this defaults to (0, 0).
    pub fn draw_tiled_pixmap<P: PixmapTrait<'a>, Q: PointFTrait<'a>, R: RectFTrait<'a>>(
        &self,
        rect: &R,
        pm: &P,
        offset: &Q,
    ) -> &Self {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();
        let (obj_offset_3, _funcs) = offset.get_point_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_tiled_pixmap)(obj_data, obj_rect_1, obj_pm_2, obj_offset_3);
        }
        self
    }
    ///
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    ///
    /// Calling drawTiledPixmap() is similar to calling drawPixmap()
    /// several times to fill (tile) an area with a pixmap, but is
    /// potentially much more efficient depending on the underlying window
    /// system.
    ///
    /// **See also:** [`draw_pixmap()`]
    ///
    /// const QPoint &position = QPoint())
    /// **Overloads**
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    ///
    /// QPixmap &pixmap, int sx, int sy);
    /// **Overloads**
    /// Draws a tiled *pixmap* in the specified rectangle.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device
    /// that is to be drawn onto; with the given *width* and *height.* ( *sx* , *sy* ) specifies the top-left point in the *pixmap* that is to be drawn; this defaults to (0, 0).
    pub fn draw_tiled_pixmap_2<P: PixmapTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        arg0: &P,
        sx: i32,
        sy: i32,
    ) -> &Self {
        let (obj_arg0_5, _funcs) = arg0.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_tiled_pixmap_2)(obj_data, x, y, w, h, obj_arg0_5, sx, sy);
        }
        self
    }
    ///
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    ///
    /// Calling drawTiledPixmap() is similar to calling drawPixmap()
    /// several times to fill (tile) an area with a pixmap, but is
    /// potentially much more efficient depending on the underlying window
    /// system.
    ///
    /// **See also:** [`draw_pixmap()`]
    ///
    /// const QPoint &position = QPoint())
    /// **Overloads**
    /// Draws a tiled *pixmap,* inside the given *rectangle* with its
    /// origin at the given *position.*
    ///
    /// QPixmap &pixmap, int sx, int sy);
    /// **Overloads**
    /// Draws a tiled *pixmap* in the specified rectangle.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device
    /// that is to be drawn onto; with the given *width* and *height.* ( *sx* , *sy* ) specifies the top-left point in the *pixmap* that is to be drawn; this defaults to (0, 0).
    pub fn draw_tiled_pixmap_3<P: PixmapTrait<'a>, Q: PointTrait<'a>, R: RectTrait<'a>>(
        &self,
        arg0: &R,
        arg1: &P,
        arg2: &Q,
    ) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();
        let (obj_arg1_2, _funcs) = arg1.get_pixmap_obj_funcs();
        let (obj_arg2_3, _funcs) = arg2.get_point_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_tiled_pixmap_3)(obj_data, obj_arg0_1, obj_arg1_2, obj_arg2_3);
        }
        self
    }
    ///
    /// Replays the given *picture* at the given *point.*
    ///
    /// The QPicture class is a paint device that records and replays
    /// QPainter commands. A picture serializes the painter commands to an
    /// IO device in a platform-independent format. Everything that can be
    /// painted on a widget or pixmap can also be stored in a picture.
    ///
    /// This function does exactly the same as QPicture::play() when
    /// called with *point* = QPoint(0, 0).
    ///
    ///
    ///
    /// **See also:** [`Picture::play`]
    ///
    /// **Overloads**
    /// Replays the given *picture* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *picture* at point ( *x,* *y).*
    ///
    /// Replays the given *picture* at the given *point.*
    ///
    /// The QPicture class is a paint device that records and replays
    /// QPainter commands. A picture serializes the painter commands to an
    /// IO device in a platform-independent format. Everything that can be
    /// painted on a widget or pixmap can also be stored in a picture.
    ///
    /// This function does exactly the same as QPicture::play() when
    /// called with *point* = QPoint(0, 0).
    ///
    ///
    ///
    /// **See also:** [`Picture::play`]
    ///
    /// **Overloads**
    /// Replays the given *picture* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *picture* at point ( *x,* *y).*
    ///
    /// Replays the given *picture* at the given *point.*
    ///
    /// The QPicture class is a paint device that records and replays
    /// QPainter commands. A picture serializes the painter commands to an
    /// IO device in a platform-independent format. Everything that can be
    /// painted on a widget or pixmap can also be stored in a picture.
    ///
    /// This function does exactly the same as QPicture::play() when
    /// called with *point* = QPoint(0, 0).
    ///
    ///
    ///
    /// **See also:** [`Picture::play`]
    ///
    /// **Overloads**
    /// Replays the given *picture* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *picture* at point ( *x,* *y).*
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap<P: PixmapTrait<'a>, R: RectFTrait<'a>>(
        &self,
        target_rect: &R,
        pixmap: &P,
        source_rect: &R,
    ) -> &Self {
        let (obj_target_rect_1, _funcs) = target_rect.get_rect_f_obj_funcs();
        let (obj_pixmap_2, _funcs) = pixmap.get_pixmap_obj_funcs();
        let (obj_source_rect_3, _funcs) = source_rect.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap)(obj_data, obj_target_rect_1, obj_pixmap_2, obj_source_rect_3);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_2<P: PixmapTrait<'a>, R: RectTrait<'a>>(
        &self,
        target_rect: &R,
        pixmap: &P,
        source_rect: &R,
    ) -> &Self {
        let (obj_target_rect_1, _funcs) = target_rect.get_rect_obj_funcs();
        let (obj_pixmap_2, _funcs) = pixmap.get_pixmap_obj_funcs();
        let (obj_source_rect_3, _funcs) = source_rect.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_2)(obj_data, obj_target_rect_1, obj_pixmap_2, obj_source_rect_3);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_3<P: PixmapTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        pm: &P,
        sx: i32,
        sy: i32,
        sw: i32,
        sh: i32,
    ) -> &Self {
        let (obj_pm_5, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_3)(obj_data, x, y, w, h, obj_pm_5, sx, sy, sw, sh);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_4<P: PixmapTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        pm: &P,
        sx: i32,
        sy: i32,
        sw: i32,
        sh: i32,
    ) -> &Self {
        let (obj_pm_3, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_4)(obj_data, x, y, obj_pm_3, sx, sy, sw, sh);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_5<Q: PixmapTrait<'a>, P: PointFTrait<'a>, R: RectFTrait<'a>>(
        &self,
        p: &P,
        pm: &Q,
        sr: &R,
    ) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_5)(obj_data, obj_p_1, obj_pm_2, obj_sr_3);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_6<Q: PixmapTrait<'a>, P: PointTrait<'a>, R: RectTrait<'a>>(
        &self,
        p: &P,
        pm: &Q,
        sr: &R,
    ) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_6)(obj_data, obj_p_1, obj_pm_2, obj_sr_3);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_7<Q: PixmapTrait<'a>, P: PointFTrait<'a>>(&self, p: &P, pm: &Q) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_7)(obj_data, obj_p_1, obj_pm_2);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_8<Q: PixmapTrait<'a>, P: PointTrait<'a>>(&self, p: &P, pm: &Q) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_8)(obj_data, obj_p_1, obj_pm_2);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_9<P: PixmapTrait<'a>>(&self, x: i32, y: i32, pm: &P) -> &Self {
        let (obj_pm_3, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_9)(obj_data, x, y, obj_pm_3);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_10<P: PixmapTrait<'a>, R: RectTrait<'a>>(&self, r: &R, pm: &P) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let (obj_pm_2, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_10)(obj_data, obj_r_1, obj_pm_2);
        }
        self
    }
    ///
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QPixmap::devicePixelRatio().
    ///
    ///
    ///
    /// If *pixmap* is a QBitmap it is drawn with the bits that are
    /// using the pens color. If backgroundMode is Qt::OpaqueMode, the
    /// bits are drawn using the color of the background brush; if
    /// backgroundMode is Qt::TransparentMode, the bits are
    /// transparent. Drawing bitmaps with gradient or texture colors is
    /// not supported.
    ///
    /// **See also:** [`draw_image()`]
    /// [`Pixmap::device_pixel_ratio`]
    ///
    /// const QRect &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// into the given *target* in the paint device.
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QRectF &source)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// const QRect &source)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *pixmap*
    /// with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* with its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *pixmap* at position ( *x* , *y* ).
    ///
    /// **Overloads**
    /// Draws the given *pixmap* into the given *rectangle.*
    ///
    /// **Note**: The pixmap is scaled to fit the rectangle, if both the pixmap and rectangle size disagree.
    ///
    /// const QPixmap &pixmap)
    ///
    /// **Overloads**
    /// Draws the *pixmap* into the rectangle at position ( *x* , *y* )
    /// with the given *width* and *height.*
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws the rectangular portion with the origin ( *sx* , *sy* ),
    /// width *sw* and height *sh,* of the given *pixmap* , at the
    /// point ( *x* , *y* ), with a width of *w* and a height of *h.*
    /// If sw or sh are equal to zero the width/height of the pixmap
    /// is used and adjusted by the offset sx/sy;
    ///
    /// int sx, int sy, int sw, int sh)
    ///
    /// **Overloads**
    /// Draws a pixmap at ( *x* , *y* ) by copying a part of the given *pixmap* into the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *pixmap* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the pixmap that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the pixmap.
    ///
    /// This function is used to draw *pixmap,* or a sub-rectangle of *pixmap,*
    /// at multiple positions with different scale, rotation and opacity. *fragments* is an array of *fragmentCount* elements specifying the
    /// parameters used to draw each pixmap fragment. The *hints*
    /// parameter can be used to pass in drawing hints.
    ///
    /// This function is potentially faster than multiple calls to drawPixmap(),
    /// since the backend can optimize state changes.
    ///
    /// **See also:** [`Painter::pixmap_fragment()`]
    /// [`Painter::pixmap_fragment_hint()`]
    pub fn draw_pixmap_11<P: PixmapTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        pm: &P,
    ) -> &Self {
        let (obj_pm_5, _funcs) = pm.get_pixmap_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_pixmap_11)(obj_data, x, y, w, h, obj_pm_5);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image<I: ImageTrait<'a>, R: RectFTrait<'a>>(
        &self,
        target_rect: &R,
        image: &I,
        source_rect: &R,
        flags: ImageConversionFlags,
    ) -> &Self {
        let (obj_target_rect_1, _funcs) = target_rect.get_rect_f_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();
        let (obj_source_rect_3, _funcs) = source_rect.get_rect_f_obj_funcs();
        let enum_flags_4 = flags.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image)(
                obj_data,
                obj_target_rect_1,
                obj_image_2,
                obj_source_rect_3,
                enum_flags_4,
            );
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_2<I: ImageTrait<'a>, R: RectTrait<'a>>(
        &self,
        target_rect: &R,
        image: &I,
        source_rect: &R,
        flags: ImageConversionFlags,
    ) -> &Self {
        let (obj_target_rect_1, _funcs) = target_rect.get_rect_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();
        let (obj_source_rect_3, _funcs) = source_rect.get_rect_obj_funcs();
        let enum_flags_4 = flags.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_2)(
                obj_data,
                obj_target_rect_1,
                obj_image_2,
                obj_source_rect_3,
                enum_flags_4,
            );
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_3<I: ImageTrait<'a>, P: PointFTrait<'a>, R: RectFTrait<'a>>(
        &self,
        p: &P,
        image: &I,
        sr: &R,
        flags: ImageConversionFlags,
    ) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_f_obj_funcs();
        let enum_flags_4 = flags.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_3)(obj_data, obj_p_1, obj_image_2, obj_sr_3, enum_flags_4);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_4<I: ImageTrait<'a>, P: PointTrait<'a>, R: RectTrait<'a>>(
        &self,
        p: &P,
        image: &I,
        sr: &R,
        flags: ImageConversionFlags,
    ) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();
        let (obj_sr_3, _funcs) = sr.get_rect_obj_funcs();
        let enum_flags_4 = flags.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_4)(obj_data, obj_p_1, obj_image_2, obj_sr_3, enum_flags_4);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_5<I: ImageTrait<'a>, R: RectFTrait<'a>>(&self, r: &R, image: &I) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_5)(obj_data, obj_r_1, obj_image_2);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_6<I: ImageTrait<'a>, R: RectTrait<'a>>(&self, r: &R, image: &I) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_6)(obj_data, obj_r_1, obj_image_2);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_7<I: ImageTrait<'a>, P: PointFTrait<'a>>(&self, p: &P, image: &I) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_7)(obj_data, obj_p_1, obj_image_2);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_8<I: ImageTrait<'a>, P: PointTrait<'a>>(&self, p: &P, image: &I) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();
        let (obj_image_2, _funcs) = image.get_image_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_8)(obj_data, obj_p_1, obj_image_2);
        }
        self
    }
    ///
    /// Qt::ImageConversionFlags flags)
    ///
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    /// **Note**: See [Drawing High Resolution Versions of Pixmaps and Images](Drawing%20High%20Resolution%20Versions%20of%20Pixmaps%20and%20Images)
    /// on how this is affected
    /// by QImage::devicePixelRatio().
    ///
    /// If the image needs to be modified to fit in a lower-resolution
    /// result (e.g. converting from 32-bit to 8-bit), use the *flags* to
    /// specify how you would prefer this to happen.
    ///
    ///
    ///
    /// **See also:** [`draw_pixmap()`]
    /// [`Image::device_pixel_ratio`]
    ///
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image*
    /// into the *target* rectangle in the paint device.
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    ///
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// Qt::ImageConversionFlags flags = 0)
    /// **Overloads**
    /// Draws the rectangular portion *source* of the given *image* with
    /// its origin at the given *point.*
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// **Overloads**
    /// Draws the given *image* into the given *rectangle.*
    ///
    /// **Note**: The image is scaled to fit the rectangle, if both the image and rectangle size disagree.
    ///
    /// int sx, int sy, int sw, int sh,
    /// Qt::ImageConversionFlags flags)
    /// **Overloads**
    /// Draws an image at ( *x* , *y* ) by copying a part of *image* into
    /// the paint device.
    ///
    /// ( *x* , *y* ) specifies the top-left point in the paint device that is
    /// to be drawn onto. ( *sx* , *sy* ) specifies the top-left point in *image* that is to be drawn. The default is (0, 0).
    ///
    /// ( *sw* , *sh* ) specifies the size of the image that is to be drawn.
    /// The default, (0, 0) (and negative) means all the way to the
    /// bottom-right of the image.
    pub fn draw_image_9<I: ImageTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        image: &I,
        sx: i32,
        sy: i32,
        sw: i32,
        sh: i32,
        flags: ImageConversionFlags,
    ) -> &Self {
        let (obj_image_3, _funcs) = image.get_image_obj_funcs();
        let enum_flags_8 = flags.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_image_9)(obj_data, x, y, obj_image_3, sx, sy, sw, sh, enum_flags_8);
        }
        self
    }
    ///
    /// Sets the layout direction used by the painter when drawing text,
    /// to the specified *direction.*
    ///
    /// The default is Qt::LayoutDirectionAuto, which will implicitly determine the
    /// direction from the text drawn.
    ///
    /// **See also:** [`TextOption::set_text_direction`]
    /// [`layout_direction()`]
    /// [`draw_text()`]
    /// {QPainter#Settings}{Settings}
    pub fn set_layout_direction(&self, direction: LayoutDirection) -> &Self {
        let enum_direction_1 = direction as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_layout_direction)(obj_data, enum_direction_1);
        }
        self
    }
    ///
    /// Returns the layout direction used by the painter when drawing text.
    ///
    /// **See also:** [`TextOption::text_direction`]
    /// [`set_layout_direction()`]
    /// [`draw_text()`]
    /// {QPainter#Settings}{Settings}
    pub fn layout_direction(&self) -> LayoutDirection {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).layout_direction)(obj_data);
            let ret_val = { transmute::<u32, LayoutDirection>(ret_val) };
            ret_val
        }
    }
    ///
    /// Draws the glyphs represented by *glyphs* at *position.* The *position* gives the
    /// edge of the baseline for the string of glyphs. The glyphs will be retrieved from the font
    /// selected on *glyphs* and at offsets given by the positions in *glyphs.*
    ///
    /// **See also:** [`GlyphRun::set_raw_font`]
    /// [`GlyphRun::set_positions`]
    /// [`GlyphRun::set_glyph_indexes`]
    ///
    /// **Overloads**
    /// Draws the *staticText* at the *topLeftPosition.*
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    ///
    /// **Overloads**
    /// Draws the *staticText* at coordinates *left* and *top.*
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// Draws the given *staticText* at the given *topLeftPosition.*
    ///
    /// The text will be drawn using the font and the transformation set on the painter. If the
    /// font and/or transformation set on the painter are different from the ones used to initialize
    /// the layout of the QStaticText, then the layout will have to be recalculated. Use
    /// QStaticText::prepare() to initialize *staticText* with the font and transformation with which
    /// it will later be drawn.
    ///
    /// If *topLeftPosition* is not the same as when *staticText* was initialized, or when it was
    /// last drawn, then there will be a slight overhead when translating the text to its new position.
    ///
    /// **Note**: If the painter's transformation is not affine, then *staticText* will be drawn using
    /// regular calls to drawText(), losing any potential for performance improvement.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`StaticText`]
    ///
    /// **Overloads**
    /// Draws the *staticText* at the *topLeftPosition.*
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    ///
    /// **Overloads**
    /// Draws the *staticText* at coordinates *left* and *top.*
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// Draws the given *staticText* at the given *topLeftPosition.*
    ///
    /// The text will be drawn using the font and the transformation set on the painter. If the
    /// font and/or transformation set on the painter are different from the ones used to initialize
    /// the layout of the QStaticText, then the layout will have to be recalculated. Use
    /// QStaticText::prepare() to initialize *staticText* with the font and transformation with which
    /// it will later be drawn.
    ///
    /// If *topLeftPosition* is not the same as when *staticText* was initialized, or when it was
    /// last drawn, then there will be a slight overhead when translating the text to its new position.
    ///
    /// **Note**: If the painter's transformation is not affine, then *staticText* will be drawn using
    /// regular calls to drawText(), losing any potential for performance improvement.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`StaticText`]
    ///
    /// **Overloads**
    /// Draws the *staticText* at the *topLeftPosition.*
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    ///
    /// **Overloads**
    /// Draws the *staticText* at coordinates *left* and *top.*
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// Draws the given *staticText* at the given *topLeftPosition.*
    ///
    /// The text will be drawn using the font and the transformation set on the painter. If the
    /// font and/or transformation set on the painter are different from the ones used to initialize
    /// the layout of the QStaticText, then the layout will have to be recalculated. Use
    /// QStaticText::prepare() to initialize *staticText* with the font and transformation with which
    /// it will later be drawn.
    ///
    /// If *topLeftPosition* is not the same as when *staticText* was initialized, or when it was
    /// last drawn, then there will be a slight overhead when translating the text to its new position.
    ///
    /// **Note**: If the painter's transformation is not affine, then *staticText* will be drawn using
    /// regular calls to drawText(), losing any potential for performance improvement.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`StaticText`]
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text<P: PointFTrait<'a>>(&self, p: &P, s: &str) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();
        let str_in_s_2 = CString::new(s).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text)(obj_data, obj_p_1, str_in_s_2.as_ptr());
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text_2<P: PointTrait<'a>>(&self, p: &P, s: &str) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_obj_funcs();
        let str_in_s_2 = CString::new(s).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text_2)(obj_data, obj_p_1, str_in_s_2.as_ptr());
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text_3(&self, x: i32, y: i32, s: &str) -> &Self {
        let str_in_s_3 = CString::new(s).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text_3)(obj_data, x, y, str_in_s_3.as_ptr());
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text_4<P: PointFTrait<'a>>(
        &self,
        p: &P,
        str: &str,
        tf: i32,
        justification_padding: i32,
    ) -> &Self {
        let (obj_p_1, _funcs) = p.get_point_f_obj_funcs();
        let str_in_str_2 = CString::new(str).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text_4)(
                obj_data,
                obj_p_1,
                str_in_str_2.as_ptr(),
                tf,
                justification_padding,
            );
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text_5<R: RectFTrait<'a>>(&self, r: &R, flags: i32, text: &str, br: &R) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let str_in_text_3 = CString::new(text).unwrap();
        let (obj_br_4, _funcs) = br.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text_5)(obj_data, obj_r_1, flags, str_in_text_3.as_ptr(), obj_br_4);
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text_6<R: RectTrait<'a>>(&self, r: &R, flags: i32, text: &str, br: &R) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let str_in_text_3 = CString::new(text).unwrap();
        let (obj_br_4, _funcs) = br.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text_6)(obj_data, obj_r_1, flags, str_in_text_3.as_ptr(), obj_br_4);
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    pub fn draw_text_7<R: RectTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        flags: i32,
        text: &str,
        br: &R,
    ) -> &Self {
        let str_in_text_6 = CString::new(text).unwrap();
        let (obj_br_7, _funcs) = br.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).draw_text_7)(
                obj_data,
                x,
                y,
                w,
                h,
                flags,
                str_in_text_6.as_ptr(),
                obj_br_7,
            );
        }
        self
    }
    ///
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// This function does not handle the newline character (\\n), as it cannot
    /// break text into multiple lines, and it cannot display the newline character.
    /// Use the QPainter::drawText() overload that takes a rectangle instead
    /// if you want to draw multiple lines of text with the newline character, or
    /// if you want the text to be wrapped.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* with the currently defined text direction,
    /// beginning at the given *position.*
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle.*
    /// The *rectangle* along with alignment *flags* defines the anchors for the *text.*
    ///
    /// * ![qpainter-text.png](qpainter-text.png)
    ///
    ///
    ///
    /// The *boundingRect* (if not null) is set to what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextDontClip
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`bounding_rect()`]
    /// [`layout_direction()`]
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **Overloads**
    /// Draws the given *text* within the provided *rectangle* according
    /// to the specified *flags.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents *rectangle:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// **Overloads**
    /// Draws the given *text* at position ( *x* , *y* ), using the painter's
    /// currently defined text direction.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the baseline of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QString &text, QRect *boundingRect)
    ///
    /// **Overloads**
    /// Draws the given *text* within the rectangle with origin ( *x* ,
    /// *y* ), *width* and *height.*
    ///
    /// The *boundingRect* (if not null) is set to the what the bounding rectangle
    /// should be in order to enclose the whole text. For example, in the following
    /// image, the dotted line represents *boundingRect* as calculated by the
    /// function, and the dashed line represents the rectangle defined by
    /// *x,* *y,* *width* and *height:*
    ///
    /// * ![qpainter-text-bounds.png](qpainter-text-bounds.png)
    ///
    ///
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    ///
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignJustify
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-position is used as the top of the font.
    ///
    /// **See also:** [`t::alignment_flag()`]
    /// [`t::text_flag()`]
    /// [`set_font()`]
    /// [`set_pen()`]
    ///
    /// const QTextOption &option)
    /// **Overloads**
    /// Draws the given *text* in the *rectangle* specified using the *option*
    /// to control its positioning and orientation.
    ///
    /// By default, QPainter draws text anti-aliased.
    ///
    /// **Note**: The y-coordinate of *rectangle* is used as the top of the font.
    ///
    /// **See also:** [`set_font()`]
    /// [`set_pen()`]
    ///
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    ///
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    ///
    /// **See also:** [`draw_text()`]
    /// [`t::alignment()`]
    /// [`t::text_flag()`]
    ///
    /// const QString &text)
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    ///
    /// const QString &text);
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    ///
    /// const QString &text, const QTextOption &option)
    ///
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    ///
    /// **See also:** [`TextOption`]
    pub fn bounding_rect<R: RectFTrait<'a>>(&self, rect: &R, flags: i32, text: &str) -> RectF {
        let (obj_rect_1, _funcs) = rect.get_rect_f_obj_funcs();
        let str_in_text_3 = CString::new(text).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val =
                ((*funcs).bounding_rect)(obj_data, obj_rect_1, flags, str_in_text_3.as_ptr());
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = RectF::new_from_rc(t);
            } else {
                ret_val = RectF::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    ///
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    ///
    /// **See also:** [`draw_text()`]
    /// [`t::alignment()`]
    /// [`t::text_flag()`]
    ///
    /// const QString &text)
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    ///
    /// const QString &text);
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    ///
    /// const QString &text, const QTextOption &option)
    ///
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    ///
    /// **See also:** [`TextOption`]
    pub fn bounding_rect_2<R: RectTrait<'a>>(&self, rect: &R, flags: i32, text: &str) -> Rect {
        let (obj_rect_1, _funcs) = rect.get_rect_obj_funcs();
        let str_in_text_3 = CString::new(text).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val =
                ((*funcs).bounding_rect_2)(obj_data, obj_rect_1, flags, str_in_text_3.as_ptr());
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    ///
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    ///
    /// **See also:** [`draw_text()`]
    /// [`t::alignment()`]
    /// [`t::text_flag()`]
    ///
    /// const QString &text)
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    ///
    /// const QString &text);
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    ///
    /// const QString &text, const QTextOption &option)
    ///
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    ///
    /// **See also:** [`TextOption`]
    pub fn bounding_rect_3(&self, x: i32, y: i32, w: i32, h: i32, flags: i32, text: &str) -> Rect {
        let str_in_text_6 = CString::new(text).unwrap();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val =
                ((*funcs).bounding_rect_3)(obj_data, x, y, w, h, flags, str_in_text_6.as_ptr());
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = Rect::new_from_rc(t);
            } else {
                ret_val = Rect::new_from_owned(t);
            }
            ret_val
        }
    }
    ///
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font(); i.e the function tells you
    /// where the drawText() function will draw when given the same
    /// arguments.
    ///
    /// If the *text* does not fit within the given *rectangle* using
    /// the specified *flags,* the function returns the required
    /// rectangle.
    ///
    /// The *flags* argument is a bitwise OR of the following flags:
    /// * Qt::AlignLeft
    /// * Qt::AlignRight
    /// * Qt::AlignHCenter
    /// * Qt::AlignTop
    /// * Qt::AlignBottom
    /// * Qt::AlignVCenter
    /// * Qt::AlignCenter
    /// * Qt::TextSingleLine
    /// * Qt::TextExpandTabs
    /// * Qt::TextShowMnemonic
    /// * Qt::TextWordWrap
    /// * Qt::TextIncludeTrailingSpaces
    /// If several of the horizontal or several of the vertical alignment
    /// flags are set, the resulting alignment is undefined.
    ///
    /// **See also:** [`draw_text()`]
    /// [`t::alignment()`]
    /// [`t::text_flag()`]
    ///
    /// const QString &text)
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the *text* as it will appear
    /// when drawn inside the given *rectangle* with the specified *flags* using the currently set font().
    ///
    /// const QString &text);
    ///
    /// **Overloads**
    /// Returns the bounding rectangle of the given *text* as it will
    /// appear when drawn inside the rectangle beginning at the point
    /// ( *x* , *y* ) with width *w* and height *h.*
    ///
    /// const QString &text, const QTextOption &option)
    ///
    /// **Overloads**
    /// Instead of specifying flags as a bitwise OR of the
    /// Qt::AlignmentFlag and Qt::TextFlag, this overloaded function takes
    /// an *option* argument. The QTextOption class provides a
    /// description of general rich text properties.
    ///
    /// **See also:** [`TextOption`]
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect<B: BrushTrait<'a>, R: RectFTrait<'a>>(&self, arg0: &R, arg1: &B) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_f_obj_funcs();
        let (obj_arg1_2, _funcs) = arg1.get_brush_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect)(obj_data, obj_arg0_1, obj_arg1_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_2<B: BrushTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        arg0: &B,
    ) -> &Self {
        let (obj_arg0_5, _funcs) = arg0.get_brush_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_2)(obj_data, x, y, w, h, obj_arg0_5);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_3<B: BrushTrait<'a>, R: RectTrait<'a>>(&self, arg0: &R, arg1: &B) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();
        let (obj_arg1_2, _funcs) = arg1.get_brush_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_3)(obj_data, obj_arg0_1, obj_arg1_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_4<C: ColorTrait<'a>, R: RectFTrait<'a>>(&self, arg0: &R, color: &C) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_f_obj_funcs();
        let (obj_color_2, _funcs) = color.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_4)(obj_data, obj_arg0_1, obj_color_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_5<C: ColorTrait<'a>>(
        &self,
        x: i32,
        y: i32,
        w: i32,
        h: i32,
        color: &C,
    ) -> &Self {
        let (obj_color_5, _funcs) = color.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_5)(obj_data, x, y, w, h, obj_color_5);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_6<C: ColorTrait<'a>, R: RectTrait<'a>>(&self, arg0: &R, color: &C) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();
        let (obj_color_2, _funcs) = color.get_color_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_6)(obj_data, obj_arg0_1, obj_color_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_7(&self, x: i32, y: i32, w: i32, h: i32, c: GlobalColor) -> &Self {
        let enum_c_5 = c as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_7)(obj_data, x, y, w, h, enum_c_5);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_8<R: RectTrait<'a>>(&self, r: &R, c: GlobalColor) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let enum_c_2 = c as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_8)(obj_data, obj_r_1, enum_c_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_9<R: RectFTrait<'a>>(&self, r: &R, c: GlobalColor) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let enum_c_2 = c as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_9)(obj_data, obj_r_1, enum_c_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_10(&self, x: i32, y: i32, w: i32, h: i32, style: BrushStyle) -> &Self {
        let enum_style_5 = style as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_10)(obj_data, x, y, w, h, enum_style_5);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_11<R: RectTrait<'a>>(&self, r: &R, style: BrushStyle) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_obj_funcs();
        let enum_style_2 = style as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_11)(obj_data, obj_r_1, enum_style_2);
        }
        self
    }
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the brush *style* specified.
    ///
    ///
    /// Fills the given *rectangle* with the *brush* specified.
    ///
    /// Alternatively, you can specify a QColor instead of a QBrush; the
    /// QBrush constructor (taking a QColor argument) will automatically
    /// create a solid pattern brush.
    ///
    /// **See also:** [`draw_rect()`]
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *brush.*
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the *color* specified.
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *brush.*
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the rectangle beginning at ( *x* , *y* ) with the given *width* and *height,* using the given *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    ///
    /// **Overloads**
    /// Fills the given *rectangle* with the specified *color.*
    ///
    pub fn fill_rect_12<R: RectFTrait<'a>>(&self, r: &R, style: BrushStyle) -> &Self {
        let (obj_r_1, _funcs) = r.get_rect_f_obj_funcs();
        let enum_style_2 = style as u32;

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).fill_rect_12)(obj_data, obj_r_1, enum_style_2);
        }
        self
    }
    ///
    /// Erases the area inside the given *rectangle.* Equivalent to
    /// calling
    ///
    /// **See also:** [`fill_rect()`]
    ///
    /// **Overloads**
    /// Erases the area inside the given *rectangle.*
    ///
    /// **Overloads**
    /// Erases the area inside the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    pub fn erase_rect<R: RectFTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_f_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).erase_rect)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Erases the area inside the given *rectangle.* Equivalent to
    /// calling
    ///
    /// **See also:** [`fill_rect()`]
    ///
    /// **Overloads**
    /// Erases the area inside the given *rectangle.*
    ///
    /// **Overloads**
    /// Erases the area inside the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    pub fn erase_rect_2(&self, x: i32, y: i32, w: i32, h: i32) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).erase_rect_2)(obj_data, x, y, w, h);
        }
        self
    }
    ///
    /// Erases the area inside the given *rectangle.* Equivalent to
    /// calling
    ///
    /// **See also:** [`fill_rect()`]
    ///
    /// **Overloads**
    /// Erases the area inside the given *rectangle.*
    ///
    /// **Overloads**
    /// Erases the area inside the rectangle beginning at ( *x,* *y)*
    /// with the given *width* and *height.*
    pub fn erase_rect_3<R: RectTrait<'a>>(&self, arg0: &R) -> &Self {
        let (obj_arg0_1, _funcs) = arg0.get_rect_obj_funcs();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).erase_rect_3)(obj_data, obj_arg0_1);
        }
        self
    }
    ///
    /// Sets the given render *hint* on the painter if *on* is true;
    /// otherwise clears the render hint.
    ///
    /// **See also:** [`set_render_hints()`]
    /// [`render_hints()`]
    /// {QPainter#Rendering
    /// Quality}{Rendering Quality}
    ///
    /// Sets the given render *hints* on the painter if *on* is true;
    /// otherwise clears the render hints.
    ///
    /// **See also:** [`set_render_hint()`]
    /// [`render_hints()`]
    /// {QPainter#Rendering
    /// Quality}{Rendering Quality}
    pub fn set_render_hint(&self, hint: RenderHint, on: bool) -> &Self {
        let enum_hint_1 = hint.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_render_hint)(obj_data, enum_hint_1, on);
        }
        self
    }
    ///
    /// Sets the given render *hints* on the painter if *on* is true;
    /// otherwise clears the render hints.
    ///
    /// **See also:** [`set_render_hint()`]
    /// [`render_hints()`]
    /// {QPainter#Rendering
    /// Quality}{Rendering Quality}
    pub fn set_render_hints(&self, hints: RenderHints, on: bool) -> &Self {
        let enum_hints_1 = hints.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).set_render_hints)(obj_data, enum_hints_1, on);
        }
        self
    }
    ///
    /// Returns a flag that specifies the rendering hints that are set for
    /// this painter.
    ///
    /// **See also:** [`test_render_hint()`]
    /// {QPainter#Rendering Quality}{Rendering Quality}
    pub fn render_hints(&self) -> RenderHints {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).render_hints)(obj_data);
            let ret_val = RenderHints::from_bits_truncate(ret_val);
            ret_val
        }
    }
    ///
    /// Returns `true` if *hint* is set; otherwise returns `false.`
    ///
    /// **See also:** [`render_hints()`]
    /// [`set_render_hint()`]
    pub fn test_render_hint(&self, hint: RenderHint) -> bool {
        let enum_hint_1 = hint.bits();

        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).test_render_hint)(obj_data, enum_hint_1);
            ret_val
        }
    }
    ///
    /// Returns the paint engine that the painter is currently operating
    /// on if the painter is active; otherwise 0.
    ///
    /// **See also:** [`is_active()`]
    pub fn paint_engine(&self) -> Option<PaintEngine> {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            let ret_val = ((*funcs).paint_engine)(obj_data);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintEngine::new_from_rc(t);
            } else {
                ret_val = PaintEngine::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Please use QWidget::render() instead.
    ///
    /// Redirects all paint commands for the given paint *device,* to the
    /// *replacement* device. The optional point *offset* defines an
    /// offset within the source device.
    ///
    /// The redirection will not be effective until the begin() function
    /// has been called; make sure to call end() for the given *device's* painter (if any) before redirecting. Call
    /// restoreRedirected() to restore the previous redirection.
    ///
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    ///
    /// **See also:** [`redirected()`]
    /// [`restore_redirected()`]
    pub fn set_redirected<P: PaintDeviceTrait<'a>, Q: PointTrait<'a>>(
        device: &P,
        replacement: &P,
        offset: &Q,
    ) {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();
        let (obj_replacement_2, _funcs) = replacement.get_paint_device_obj_funcs();
        let (obj_offset_3, _funcs) = offset.get_point_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_painter)(::std::ptr::null()).all_funcs).painter_funcs,
            )
        };
        unsafe {
            ((*funcs).set_redirected)(obj_data, obj_device_1, obj_replacement_2, obj_offset_3);
        }
    }
    ///
    /// Using QWidget::render() obsoletes the use of this function.
    ///
    /// Returns the replacement for given *device.* The optional out
    /// parameter *offset* returns the offset within the replaced device.
    ///
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    ///
    /// **See also:** [`set_redirected()`]
    /// [`restore_redirected()`]
    pub fn redirected<P: PaintDeviceTrait<'a>, Q: PointTrait<'a>>(
        device: &P,
        offset: &Q,
    ) -> Option<PaintDevice<'a>> {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();
        let (obj_offset_2, _funcs) = offset.get_point_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_painter)(::std::ptr::null()).all_funcs).painter_funcs,
            )
        };
        unsafe {
            let ret_val = ((*funcs).redirected)(obj_data, obj_device_1, obj_offset_2);
            if ret_val.qt_data == ::std::ptr::null() {
                return None;
            }
            let t = ret_val;
            let ret_val;
            if t.host_data != ::std::ptr::null() {
                ret_val = PaintDevice::new_from_rc(t);
            } else {
                ret_val = PaintDevice::new_from_owned(t);
            }
            Some(ret_val)
        }
    }
    ///
    /// Using QWidget::render() obsoletes the use of this function.
    ///
    /// Restores the previous redirection for the given *device* after a
    /// call to setRedirected().
    ///
    /// **Warning**: Making use of redirections in the QPainter API implies
    /// that QPainter::begin() and QPaintDevice destructors need to hold
    /// a mutex for a short period. This can impact performance. Use of
    /// QWidget::render is strongly encouraged.
    ///
    /// **See also:** [`redirected()`]
    pub fn restore_redirected<P: PaintDeviceTrait<'a>>(device: &P) {
        let (obj_device_1, _funcs) = device.get_paint_device_obj_funcs();

        let (obj_data, funcs) = unsafe {
            (
                ::std::ptr::null(),
                (*((*rute_ffi_get()).get_painter)(::std::ptr::null()).all_funcs).painter_funcs,
            )
        };
        unsafe {
            ((*funcs).restore_redirected)(obj_data, obj_device_1);
        }
    }
    ///
    /// Flushes the painting pipeline and prepares for the user issuing commands
    /// directly to the underlying graphics context. Must be followed by a call to
    /// endNativePainting().
    ///
    /// Note that only the states the underlying paint engine changes will be reset
    /// to their respective default states. The states we reset may change from
    /// release to release. The following states are currently reset in the OpenGL
    /// 2 engine:
    ///
    /// * blending is disabled
    /// * the depth, stencil and scissor tests are disabled
    /// * the active texture unit is reset to 0
    /// * the depth mask, depth function and the clear depth are reset to their default values
    /// * the stencil mask, stencil operation and stencil function are reset to their default values
    /// * the current color is reset to solid white
    ///
    /// If, for example, the OpenGL polygon mode is changed by the user inside a
    /// beginNativePaint()/endNativePainting() block, it will not be reset to the
    /// default state by endNativePainting(). Here is an example that shows
    /// intermixing of painter commands and raw OpenGL commands:
    ///
    /// **See also:** [`end_native_painting()`]
    pub fn begin_native_painting(&self) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).begin_native_painting)(obj_data);
        }
        self
    }
    ///
    /// Restores the painter after manually issuing native painting commands. Lets
    /// the painter restore any native state that it relies on before calling any
    /// other painter commands.
    ///
    /// **See also:** [`begin_native_painting()`]
    pub fn end_native_painting(&self) -> &Self {
        let (obj_data, funcs) = self.get_painter_obj_funcs();
        unsafe {
            ((*funcs).end_native_painting)(obj_data);
        }
        self
    }

    pub fn build(&self) -> Self {
        self.clone()
    }
}

impl<'a> From<(WrapperRcOwn, bool)> for Painter<'a> {
    fn from(t: (WrapperRcOwn, bool)) -> Self {
        if t.1 {
            Painter::new_from_rc(t.0 as *const RUPainter)
        } else {
            Painter::new_from_temporary(t.0 as *const RUPainter)
        }
    }
}

pub trait PainterTrait<'a> {
    #[inline]
    #[doc(hidden)]
    fn get_painter_obj_funcs(&self) -> (*const RUBase, *const RUPainterFuncs);
}

impl<'a> PainterTrait<'a> for Painter<'a> {
    #[doc(hidden)]
    fn get_painter_obj_funcs(&self) -> (*const RUBase, *const RUPainterFuncs) {
        let obj = self.data.get().unwrap();
        unsafe { (obj, (*self.all_funcs).painter_funcs) }
    }
}
bitflags! {
    pub struct RenderHint: u32 {
        const Antialiasing = 0x1;
        const TextAntialiasing = 0x2;
        const SmoothPixmapTransform = 0x4;
        const HighQualityAntialiasing = 0x8;
        const NonCosmeticDefaultPen = 0x10;
        const Qt4CompatiblePainting = 0x20;
    }
}

pub type RenderHints = RenderHint;

#[repr(u32)]
pub enum PixmapFragmentHint {
    OpaqueHint = 1,
}

#[repr(u32)]
pub enum CompositionMode {
    CompositionModeSourceOver = 0,
    CompositionModeDestinationOver = 1,
    CompositionModeClear = 2,
    CompositionModeSource = 3,
    CompositionModeDestination = 4,
    CompositionModeSourceIn = 5,
    CompositionModeDestinationIn = 6,
    CompositionModeSourceOut = 7,
    CompositionModeDestinationOut = 8,
    CompositionModeSourceAtop = 9,
    CompositionModeDestinationAtop = 10,
    CompositionModeXor = 11,
    CompositionModePlus = 12,
    CompositionModeMultiply = 13,
    CompositionModeScreen = 14,
    CompositionModeOverlay = 15,
    CompositionModeDarken = 16,
    CompositionModeLighten = 17,
    CompositionModeColorDodge = 18,
    CompositionModeColorBurn = 19,
    CompositionModeHardLight = 20,
    CompositionModeSoftLight = 21,
    CompositionModeDifference = 22,
    CompositionModeExclusion = 23,
    RasterOpSourceOrDestination = 24,
    RasterOpSourceAndDestination = 25,
    RasterOpSourceXorDestination = 26,
    RasterOpNotSourceAndNotDestination = 27,
    RasterOpNotSourceOrNotDestination = 28,
    RasterOpNotSourceXorDestination = 29,
    RasterOpNotSource = 30,
    RasterOpNotSourceAndDestination = 31,
    RasterOpSourceAndNotDestination = 32,
    RasterOpNotSourceOrDestination = 33,
    RasterOpSourceOrNotDestination = 34,
    RasterOpClearDestination = 35,
    RasterOpSetDestination = 36,
    RasterOpNotDestination = 37,
}
